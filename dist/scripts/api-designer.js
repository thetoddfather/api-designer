(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == 'function' && require;
        if (!u && a)
          return a(o, !0);
        if (i)
          return i(o, !0);
        var f = new Error('Cannot find module \'' + o + '\'');
        throw f.code = 'MODULE_NOT_FOUND', f;
      }
      var l = n[o] = { exports: {} };
      t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == 'function' && require;
  for (var o = 0; o < r.length; o++)
    s(r[o]);
  return s;
}({
  1: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, legacy_scorer, pluckCandidates, scorer, sortCandidates;
        scorer = require('./scorer');
        legacy_scorer = require('./legacy');
        pluckCandidates = function (a) {
          return a.candidate;
        };
        sortCandidates = function (a, b) {
          return b.score - a.score;
        };
        PathSeparator = require('path').sep;
        module.exports = function (candidates, query, _arg) {
          var allowErrors, bAllowErrors, bKey, candidate, coreQuery, key, legacy, maxInners, maxResults, prepQuery, queryHasSlashes, score, scoredCandidates, spotLeft, string, _i, _j, _len, _len1, _ref;
          _ref = _arg != null ? _arg : {}, key = _ref.key, maxResults = _ref.maxResults, maxInners = _ref.maxInners, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
          scoredCandidates = [];
          spotLeft = maxInners != null && maxInners > 0 ? maxInners : candidates.length;
          bAllowErrors = !!allowErrors;
          bKey = key != null;
          prepQuery = scorer.prepQuery(query);
          if (!legacy) {
            for (_i = 0, _len = candidates.length; _i < _len; _i++) {
              candidate = candidates[_i];
              string = bKey ? candidate[key] : candidate;
              if (!string) {
                continue;
              }
              score = scorer.score(string, query, prepQuery, bAllowErrors);
              if (score > 0) {
                scoredCandidates.push({
                  candidate: candidate,
                  score: score
                });
                if (!--spotLeft) {
                  break;
                }
              }
            }
          } else {
            queryHasSlashes = prepQuery.depth > 0;
            coreQuery = prepQuery.core;
            for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
              candidate = candidates[_j];
              string = key != null ? candidate[key] : candidate;
              if (!string) {
                continue;
              }
              score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
              if (!queryHasSlashes) {
                score = legacy_scorer.basenameScore(string, coreQuery, score);
              }
              if (score > 0) {
                scoredCandidates.push({
                  candidate: candidate,
                  score: score
                });
              }
            }
          }
          scoredCandidates.sort(sortCandidates);
          candidates = scoredCandidates.map(pluckCandidates);
          if (maxResults != null) {
            candidates = candidates.slice(0, maxResults);
          }
          return candidates;
        };
      }.call(this));
    },
    {
      './legacy': 3,
      './scorer': 5,
      'path': 6
    }
  ],
  2: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, filter, legacy_scorer, matcher, prepQueryCache, scorer;
        scorer = require('./scorer');
        legacy_scorer = require('./legacy');
        filter = require('./filter');
        matcher = require('./matcher');
        PathSeparator = require('path').sep;
        prepQueryCache = null;
        module.exports = {
          filter: function (candidates, query, options) {
            if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
              return [];
            }
            return filter(candidates, query, options);
          },
          prepQuery: function (query) {
            return scorer.prepQuery(query);
          },
          score: function (string, query, prepQuery, _arg) {
            var allowErrors, coreQuery, legacy, queryHasSlashes, score, _ref;
            _ref = _arg != null ? _arg : {}, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
            if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
              return 0;
            }
            if (prepQuery == null) {
              prepQuery = prepQueryCache && prepQueryCache.query === query ? prepQueryCache : prepQueryCache = scorer.prepQuery(query);
            }
            if (!legacy) {
              score = scorer.score(string, query, prepQuery, !!allowErrors);
            } else {
              queryHasSlashes = prepQuery.depth > 0;
              coreQuery = prepQuery.core;
              score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
              if (!queryHasSlashes) {
                score = legacy_scorer.basenameScore(string, coreQuery, score);
              }
            }
            return score;
          },
          match: function (string, query, prepQuery, _arg) {
            var allowErrors, baseMatches, matches, query_lw, string_lw, _i, _ref, _results;
            allowErrors = (_arg != null ? _arg : {}).allowErrors;
            if (!string) {
              return [];
            }
            if (!query) {
              return [];
            }
            if (string === query) {
              return function () {
                _results = [];
                for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
                  _results.push(_i);
                }
                return _results;
              }.apply(this);
            }
            if (prepQuery == null) {
              prepQuery = prepQueryCache && prepQueryCache.query === query ? prepQueryCache : prepQueryCache = scorer.prepQuery(query);
            }
            if (!(allowErrors || scorer.isMatch(string, prepQuery.core_lw, prepQuery.core_up))) {
              return [];
            }
            string_lw = string.toLowerCase();
            query_lw = prepQuery.query_lw;
            matches = matcher.match(string, string_lw, prepQuery);
            if (matches.length === 0) {
              return matches;
            }
            if (string.indexOf(PathSeparator) > -1) {
              baseMatches = matcher.basenameMatch(string, string_lw, prepQuery);
              matches = matcher.mergeMatches(matches, baseMatches);
            }
            return matches;
          }
        };
      }.call(this));
    },
    {
      './filter': 1,
      './legacy': 3,
      './matcher': 4,
      './scorer': 5,
      'path': 6
    }
  ],
  3: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, queryIsLastPathSegment;
        PathSeparator = require('path').sep;
        exports.basenameScore = function (string, query, score) {
          var base, depth, index, lastCharacter, segmentCount, slashCount;
          index = string.length - 1;
          while (string[index] === PathSeparator) {
            index--;
          }
          slashCount = 0;
          lastCharacter = index;
          base = null;
          while (index >= 0) {
            if (string[index] === PathSeparator) {
              slashCount++;
              if (base == null) {
                base = string.substring(index + 1, lastCharacter + 1);
              }
            } else if (index === 0) {
              if (lastCharacter < string.length - 1) {
                if (base == null) {
                  base = string.substring(0, lastCharacter + 1);
                }
              } else {
                if (base == null) {
                  base = string;
                }
              }
            }
            index--;
          }
          if (base === string) {
            score *= 2;
          } else if (base) {
            score += exports.score(base, query);
          }
          segmentCount = slashCount + 1;
          depth = Math.max(1, 10 - segmentCount);
          score *= depth * 0.01;
          return score;
        };
        exports.score = function (string, query) {
          var character, characterScore, indexInQuery, indexInString, lowerCaseIndex, minIndex, queryLength, queryScore, stringLength, totalCharacterScore, upperCaseIndex, _ref;
          if (string === query) {
            return 1;
          }
          if (queryIsLastPathSegment(string, query)) {
            return 1;
          }
          totalCharacterScore = 0;
          queryLength = query.length;
          stringLength = string.length;
          indexInQuery = 0;
          indexInString = 0;
          while (indexInQuery < queryLength) {
            character = query[indexInQuery++];
            lowerCaseIndex = string.indexOf(character.toLowerCase());
            upperCaseIndex = string.indexOf(character.toUpperCase());
            minIndex = Math.min(lowerCaseIndex, upperCaseIndex);
            if (minIndex === -1) {
              minIndex = Math.max(lowerCaseIndex, upperCaseIndex);
            }
            indexInString = minIndex;
            if (indexInString === -1) {
              return 0;
            }
            characterScore = 0.1;
            if (string[indexInString] === character) {
              characterScore += 0.1;
            }
            if (indexInString === 0 || string[indexInString - 1] === PathSeparator) {
              characterScore += 0.8;
            } else if ((_ref = string[indexInString - 1]) === '-' || _ref === '_' || _ref === ' ') {
              characterScore += 0.7;
            }
            string = string.substring(indexInString + 1, stringLength);
            totalCharacterScore += characterScore;
          }
          queryScore = totalCharacterScore / queryLength;
          return (queryScore * (queryLength / stringLength) + queryScore) / 2;
        };
        queryIsLastPathSegment = function (string, query) {
          if (string[string.length - query.length - 1] === PathSeparator) {
            return string.lastIndexOf(query) === string.length - query.length;
          }
        };
        exports.match = function (string, query, stringOffset) {
          var character, indexInQuery, indexInString, lowerCaseIndex, matches, minIndex, queryLength, stringLength, upperCaseIndex, _i, _ref, _results;
          if (stringOffset == null) {
            stringOffset = 0;
          }
          if (string === query) {
            return function () {
              _results = [];
              for (var _i = stringOffset, _ref = stringOffset + string.length; stringOffset <= _ref ? _i < _ref : _i > _ref; stringOffset <= _ref ? _i++ : _i--) {
                _results.push(_i);
              }
              return _results;
            }.apply(this);
          }
          queryLength = query.length;
          stringLength = string.length;
          indexInQuery = 0;
          indexInString = 0;
          matches = [];
          while (indexInQuery < queryLength) {
            character = query[indexInQuery++];
            lowerCaseIndex = string.indexOf(character.toLowerCase());
            upperCaseIndex = string.indexOf(character.toUpperCase());
            minIndex = Math.min(lowerCaseIndex, upperCaseIndex);
            if (minIndex === -1) {
              minIndex = Math.max(lowerCaseIndex, upperCaseIndex);
            }
            indexInString = minIndex;
            if (indexInString === -1) {
              return [];
            }
            matches.push(stringOffset + indexInString);
            stringOffset += indexInString + 1;
            string = string.substring(indexInString + 1, stringLength);
          }
          return matches;
        };
      }.call(this));
    },
    { 'path': 6 }
  ],
  4: [
    function (require, module, exports) {
      (function () {
        var PathSeparator, scorer;
        PathSeparator = require('path').sep;
        scorer = require('./scorer');
        exports.basenameMatch = function (subject, subject_lw, prepQuery) {
          var basePos, depth, end;
          end = subject.length - 1;
          while (subject[end] === PathSeparator) {
            end--;
          }
          basePos = subject.lastIndexOf(PathSeparator, end);
          if (basePos === -1) {
            return [];
          }
          depth = prepQuery.depth;
          while (depth-- > 0) {
            basePos = subject.lastIndexOf(PathSeparator, basePos - 1);
            if (basePos === -1) {
              return [];
            }
          }
          basePos++;
          end++;
          return exports.match(subject.slice(basePos, end), subject_lw.slice(basePos, end), prepQuery, basePos);
        };
        exports.mergeMatches = function (a, b) {
          var ai, bj, i, j, m, n, out;
          m = a.length;
          n = b.length;
          if (n === 0) {
            return a.slice();
          }
          if (m === 0) {
            return b.slice();
          }
          i = -1;
          j = 0;
          bj = b[j];
          out = [];
          while (++i < m) {
            ai = a[i];
            while (bj <= ai && ++j < n) {
              if (bj < ai) {
                out.push(bj);
              }
              bj = b[j];
            }
            out.push(ai);
          }
          while (j < n) {
            out.push(b[j++]);
          }
          return out;
        };
        exports.match = function (subject, subject_lw, prepQuery, offset) {
          var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
          if (offset == null) {
            offset = 0;
          }
          query = prepQuery.query;
          query_lw = prepQuery.query_lw;
          m = subject.length;
          n = query.length;
          acro_score = scorer.scoreAcronyms(subject, subject_lw, query, query_lw).score;
          score_row = new Array(n);
          csc_row = new Array(n);
          STOP = 0;
          UP = 1;
          LEFT = 2;
          DIAGONAL = 3;
          trace = new Array(m * n);
          pos = -1;
          j = -1;
          while (++j < n) {
            score_row[j] = 0;
            csc_row[j] = 0;
          }
          i = -1;
          while (++i < m) {
            score = 0;
            score_up = 0;
            csc_diag = 0;
            si_lw = subject_lw[i];
            j = -1;
            while (++j < n) {
              csc_score = 0;
              align = 0;
              score_diag = score_up;
              if (query_lw[j] === si_lw) {
                start = scorer.isWordStart(i, subject, subject_lw);
                csc_score = csc_diag > 0 ? csc_diag : scorer.scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
                align = score_diag + scorer.scoreCharacter(i, j, start, acro_score, csc_score);
              }
              score_up = score_row[j];
              csc_diag = csc_row[j];
              if (score > score_up) {
                move = LEFT;
              } else {
                score = score_up;
                move = UP;
              }
              if (align > score) {
                score = align;
                move = DIAGONAL;
              } else {
                csc_score = 0;
              }
              score_row[j] = score;
              csc_row[j] = csc_score;
              trace[++pos] = score > 0 ? move : STOP;
            }
          }
          i = m - 1;
          j = n - 1;
          pos = i * n + j;
          backtrack = true;
          matches = [];
          while (backtrack && i >= 0 && j >= 0) {
            switch (trace[pos]) {
            case UP:
              i--;
              pos -= n;
              break;
            case LEFT:
              j--;
              pos--;
              break;
            case DIAGONAL:
              matches.push(i + offset);
              j--;
              i--;
              pos -= n + 1;
              break;
            default:
              backtrack = false;
            }
          }
          matches.reverse();
          return matches;
        };
      }.call(this));
    },
    {
      './scorer': 5,
      'path': 6
    }
  ],
  5: [
    function (require, module, exports) {
      (function () {
        var AcronymResult, PathSeparator, Query, basenameScore, coreChars, countDir, doScore, emptyAcronymResult, file_coeff, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, opt_char_re, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_depth, tau_size, truncatedUpperCase, wm;
        PathSeparator = require('path').sep;
        wm = 150;
        pos_bonus = 20;
        tau_depth = 13;
        tau_size = 85;
        file_coeff = 1.2;
        miss_coeff = 0.75;
        opt_char_re = /[ _\-:\/\\]/g;
        exports.coreChars = coreChars = function (query) {
          return query.replace(opt_char_re, '');
        };
        exports.score = function (string, query, prepQuery, allowErrors) {
          var score, string_lw;
          if (prepQuery == null) {
            prepQuery = new Query(query);
          }
          if (allowErrors == null) {
            allowErrors = false;
          }
          if (!(allowErrors || isMatch(string, prepQuery.core_lw, prepQuery.core_up))) {
            return 0;
          }
          string_lw = string.toLowerCase();
          score = doScore(string, string_lw, prepQuery);
          return Math.ceil(basenameScore(string, string_lw, prepQuery, score));
        };
        Query = function () {
          function Query(query) {
            if (!(query != null ? query.length : void 0)) {
              return null;
            }
            this.query = query;
            this.query_lw = query.toLowerCase();
            this.core = coreChars(query);
            this.core_lw = this.core.toLowerCase();
            this.core_up = truncatedUpperCase(this.core);
            this.depth = countDir(query, query.length);
          }
          return Query;
        }();
        exports.prepQuery = function (query) {
          return new Query(query);
        };
        exports.isMatch = isMatch = function (subject, query_lw, query_up) {
          var i, j, m, n, qj_lw, qj_up, si;
          m = subject.length;
          n = query_lw.length;
          if (!m || n > m) {
            return false;
          }
          i = -1;
          j = -1;
          while (++j < n) {
            qj_lw = query_lw[j];
            qj_up = query_up[j];
            while (++i < m) {
              si = subject[i];
              if (si === qj_lw || si === qj_up) {
                break;
              }
            }
            if (i === m) {
              return false;
            }
          }
          return true;
        };
        doScore = function (subject, subject_lw, prepQuery) {
          var acro, acro_score, align, csc_diag, csc_row, csc_score, i, j, m, miss_budget, miss_left, mm, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
          query = prepQuery.query;
          query_lw = prepQuery.query_lw;
          m = subject.length;
          n = query.length;
          acro = scoreAcronyms(subject, subject_lw, query, query_lw);
          acro_score = acro.score;
          if (acro.count === n) {
            return scoreExact(n, m, acro_score, acro.pos);
          }
          pos = subject_lw.indexOf(query_lw);
          if (pos > -1) {
            return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
          }
          score_row = new Array(n);
          csc_row = new Array(n);
          sz = scoreSize(n, m);
          miss_budget = Math.ceil(miss_coeff * n) + 5;
          miss_left = miss_budget;
          j = -1;
          while (++j < n) {
            score_row[j] = 0;
            csc_row[j] = 0;
          }
          i = subject_lw.indexOf(query_lw[0]);
          if (i > -1) {
            i--;
          }
          mm = subject_lw.lastIndexOf(query_lw[n - 1], m);
          if (mm > i) {
            m = mm + 1;
          }
          while (++i < m) {
            score = 0;
            score_diag = 0;
            csc_diag = 0;
            si_lw = subject_lw[i];
            record_miss = true;
            j = -1;
            while (++j < n) {
              score_up = score_row[j];
              if (score_up > score) {
                score = score_up;
              }
              csc_score = 0;
              if (query_lw[j] === si_lw) {
                start = isWordStart(i, subject, subject_lw);
                csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
                align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
                if (align > score) {
                  score = align;
                  miss_left = miss_budget;
                } else {
                  if (record_miss && --miss_left <= 0) {
                    return score_row[n - 1] * sz;
                  }
                  record_miss = false;
                }
              }
              score_diag = score_up;
              csc_diag = csc_row[j];
              csc_row[j] = csc_score;
              score_row[j] = score;
            }
          }
          return score * sz;
        };
        exports.isWordStart = isWordStart = function (pos, subject, subject_lw) {
          var curr_s, prev_s;
          if (pos === 0) {
            return true;
          }
          curr_s = subject[pos];
          prev_s = subject[pos - 1];
          return isSeparator(curr_s) || isSeparator(prev_s) || curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1];
        };
        exports.isWordEnd = isWordEnd = function (pos, subject, subject_lw, len) {
          var curr_s, next_s;
          if (pos === len - 1) {
            return true;
          }
          curr_s = subject[pos];
          next_s = subject[pos + 1];
          return isSeparator(curr_s) || isSeparator(next_s) || curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1];
        };
        isSeparator = function (c) {
          return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
        };
        scorePosition = function (pos) {
          var sc;
          if (pos < pos_bonus) {
            sc = pos_bonus - pos;
            return 100 + sc * sc;
          } else {
            return Math.max(100 + pos_bonus - pos, 0);
          }
        };
        scoreSize = function (n, m) {
          return tau_size / (tau_size + Math.abs(m - n));
        };
        scoreExact = function (n, m, quality, pos) {
          return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
        };
        exports.scorePattern = scorePattern = function (count, len, sameCase, start, end) {
          var bonus, sz;
          sz = count;
          bonus = 6;
          if (sameCase === count) {
            bonus += 2;
          }
          if (start) {
            bonus += 3;
          }
          if (end) {
            bonus += 1;
          }
          if (count === len) {
            if (start) {
              if (sameCase === len) {
                sz += 2;
              } else {
                sz += 1;
              }
            }
            if (end) {
              bonus += 1;
            }
          }
          return sameCase + sz * (sz + bonus);
        };
        exports.scoreCharacter = scoreCharacter = function (i, j, start, acro_score, csc_score) {
          var posBonus;
          posBonus = scorePosition(i);
          if (start) {
            return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
          }
          return posBonus + wm * csc_score;
        };
        exports.scoreConsecutives = scoreConsecutives = function (subject, subject_lw, query, query_lw, i, j, start) {
          var k, m, mi, n, nj, sameCase, startPos, sz;
          m = subject.length;
          n = query.length;
          mi = m - i;
          nj = n - j;
          k = mi < nj ? mi : nj;
          startPos = i;
          sameCase = 0;
          sz = 0;
          if (query[j] === subject[i]) {
            sameCase++;
          }
          while (++sz < k && query_lw[++j] === subject_lw[++i]) {
            if (query[j] === subject[i]) {
              sameCase++;
            }
          }
          if (sz === 1) {
            return 1 + 2 * sameCase;
          }
          return scorePattern(sz, n, sameCase, start, isWordEnd(i, subject, subject_lw, m));
        };
        exports.scoreExactMatch = scoreExactMatch = function (subject, subject_lw, query, query_lw, pos, n, m) {
          var end, i, pos2, sameCase, start;
          start = isWordStart(pos, subject, subject_lw);
          if (!start) {
            pos2 = subject_lw.indexOf(query_lw, pos + 1);
            if (pos2 > -1) {
              start = isWordStart(pos2, subject, subject_lw);
              if (start) {
                pos = pos2;
              }
            }
          }
          i = -1;
          sameCase = 0;
          while (++i < n) {
            if (query[pos + i] === subject[i]) {
              sameCase++;
            }
          }
          end = isWordEnd(pos + n - 1, subject, subject_lw, m);
          return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
        };
        AcronymResult = function () {
          function AcronymResult(score, pos, count) {
            this.score = score;
            this.pos = pos;
            this.count = count;
          }
          return AcronymResult;
        }();
        emptyAcronymResult = new AcronymResult(0, 0.1, 0);
        exports.scoreAcronyms = scoreAcronyms = function (subject, subject_lw, query, query_lw) {
          var count, i, j, m, n, pos, qj_lw, sameCase, score;
          m = subject.length;
          n = query.length;
          if (!(m > 1 && n > 1)) {
            return emptyAcronymResult;
          }
          count = 0;
          pos = 0;
          sameCase = 0;
          i = -1;
          j = -1;
          while (++j < n) {
            qj_lw = query_lw[j];
            while (++i < m) {
              if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
                if (query[j] === subject[i]) {
                  sameCase++;
                }
                pos += i;
                count++;
                break;
              }
            }
            if (i === m) {
              break;
            }
          }
          if (count < 2) {
            return emptyAcronymResult;
          }
          score = scorePattern(count, n, sameCase, true, false);
          return new AcronymResult(score, pos / count, count);
        };
        basenameScore = function (subject, subject_lw, prepQuery, fullPathScore) {
          var alpha, basePathScore, basePos, depth, end;
          if (fullPathScore === 0) {
            return 0;
          }
          end = subject.length - 1;
          while (subject[end] === PathSeparator) {
            end--;
          }
          basePos = subject.lastIndexOf(PathSeparator, end);
          if (basePos === -1) {
            return fullPathScore;
          }
          depth = prepQuery.depth;
          while (depth-- > 0) {
            basePos = subject.lastIndexOf(PathSeparator, basePos - 1);
            if (basePos === -1) {
              return fullPathScore;
            }
          }
          basePos++;
          end++;
          basePathScore = doScore(subject.slice(basePos, end), subject_lw.slice(basePos, end), prepQuery);
          alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1));
          return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * (end - basePos));
        };
        exports.countDir = countDir = function (path, end) {
          var count, i;
          if (end < 1) {
            return 0;
          }
          count = 0;
          i = -1;
          while (++i < end && path[i] === PathSeparator) {
            continue;
          }
          while (++i < end) {
            if (path[i] === PathSeparator) {
              count++;
              while (++i < end && path[i] === PathSeparator) {
                continue;
              }
            }
          }
          return count;
        };
        truncatedUpperCase = function (str) {
          var char, upper, _i, _len;
          upper = '';
          for (_i = 0, _len = str.length; _i < _len; _i++) {
            char = str[_i];
            upper += char.toUpperCase()[0];
          }
          return upper;
        };
      }.call(this));
    },
    { 'path': 6 }
  ],
  6: [
    function (require, module, exports) {
      (function (process) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // resolves . and .. elements in a path array with directory names there
        // must be no slashes, empty elements, or device names (c:\) in the array
        // (so also no leading and trailing slashes - it does not distinguish
        // relative and absolute paths)
        function normalizeArray(parts, allowAboveRoot) {
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === '.') {
              parts.splice(i, 1);
            } else if (last === '..') {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          // if the path is allowed to go above the root, restore leading ..s
          if (allowAboveRoot) {
            for (; up--; up) {
              parts.unshift('..');
            }
          }
          return parts;
        }
        // Split a filename into [root, dir, basename, ext], unix version
        // 'root' is just a slash, or nothing.
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        var splitPath = function (filename) {
          return splitPathRe.exec(filename).slice(1);
        };
        // path.resolve([from ...], to)
        // posix version
        exports.resolve = function () {
          var resolvedPath = '', resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : process.cwd();
            // Skip empty and invalid entries
            if (typeof path !== 'string') {
              throw new TypeError('Arguments to path.resolve must be strings');
            } else if (!path) {
              continue;
            }
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charAt(0) === '/';
          }
          // At this point the path should be resolved to a full absolute path, but
          // handle relative paths to be safe (might happen when process.cwd() fails)
          // Normalize the path
          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
            return !!p;
          }), !resolvedAbsolute).join('/');
          return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
        };
        // path.normalize(path)
        // posix version
        exports.normalize = function (path) {
          var isAbsolute = exports.isAbsolute(path), trailingSlash = substr(path, -1) === '/';
          // Normalize the path
          path = normalizeArray(filter(path.split('/'), function (p) {
            return !!p;
          }), !isAbsolute).join('/');
          if (!path && !isAbsolute) {
            path = '.';
          }
          if (path && trailingSlash) {
            path += '/';
          }
          return (isAbsolute ? '/' : '') + path;
        };
        // posix version
        exports.isAbsolute = function (path) {
          return path.charAt(0) === '/';
        };
        // posix version
        exports.join = function () {
          var paths = Array.prototype.slice.call(arguments, 0);
          return exports.normalize(filter(paths, function (p, index) {
            if (typeof p !== 'string') {
              throw new TypeError('Arguments to path.join must be strings');
            }
            return p;
          }).join('/'));
        };
        // path.relative(from, to)
        // posix version
        exports.relative = function (from, to) {
          from = exports.resolve(from).substr(1);
          to = exports.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== '')
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== '')
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split('/'));
          var toParts = trim(to.split('/'));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push('..');
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join('/');
        };
        exports.sep = '/';
        exports.delimiter = ':';
        exports.dirname = function (path) {
          var result = splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            // No dirname whatsoever
            return '.';
          }
          if (dir) {
            // It has a dirname, strip trailing slash
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        };
        exports.basename = function (path, ext) {
          var f = splitPath(path)[2];
          // TODO: make this comparison case-insensitive on windows?
          if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
          }
          return f;
        };
        exports.extname = function (path) {
          return splitPath(path)[3];
        };
        function filter(xs, f) {
          if (xs.filter)
            return xs.filter(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs))
              res.push(xs[i]);
          }
          return res;
        }
        // String.prototype.substr - negative index don't work in IE8
        var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
            return str.substr(start, len);
          } : function (str, start, len) {
            if (start < 0)
              start = str.length + start;
            return str.substr(start, len);
          };
        ;
      }.call(this, require('_process')));
    },
    { '_process': 7 }
  ],
  7: [
    function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};
      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      }());
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = '';
      // empty string to avoid regexp issues
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function (name) {
        return [];
      };
      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };
      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };
    },
    {}
  ],
  8: [
    function (require, module, exports) {
      window['RAML'] = window['RAML'] || {};
      window['RAML'].Suggestions = require('./index');
    },
    { './index': 10 }
  ],
  9: [
    function (require, module, exports) {
      'use strict';
      /// <reference path="../typings/main.d.ts" />
      var parserApi = window.RAML.Parser;
      var def = parserApi.ds;
      var search = parserApi.search;
      var universeModule = parserApi.universes;
      var universeHelpers = parserApi.universeHelpers;
      var services = def;
      var _ = require('underscore');
      var categories = require('../resources/categories.json');
      var CompletionRequest = function () {
          function CompletionRequest(content) {
            this.async = false;
            this.content = content;
          }
          CompletionRequest.prototype.prefix = function () {
            if (typeof this.prefixValue !== 'undefined') {
              return this.prefixValue;
            }
            return getPrefix(this);
          };
          CompletionRequest.prototype.setPrefix = function (value) {
            this.prefixValue = value;
          };
          CompletionRequest.prototype.valuePrefix = function () {
            var offset = this.content.getOffset();
            var text = this.content.getText();
            for (var i = offset - 1; i >= 0; i--) {
              var c = text.charAt(i);
              if (c === '\r' || c === '\n' || c === ' ' || c === '\t' || c === '"' || c === '\'' || c === ':' || c === '(') {
                return text.substring(i + 1, offset);
              }
            }
            return '';
          };
          return CompletionRequest;
        }();
      exports.CompletionRequest = CompletionRequest;
      var CompletionProvider = function () {
          function CompletionProvider(contentProvider, astProvider) {
            if (astProvider === void 0) {
              astProvider = null;
            }
            this.currentRequest = null;
            this.astProvider = null;
            this.level = 0;
            this.contentProvider = contentProvider;
          }
          CompletionProvider.prototype.suggest = function (request, doPostProcess) {
            if (doPostProcess === void 0) {
              doPostProcess = false;
            }
            var suggestions = doSuggest(request, this);
            return doPostProcess ? postProcess(suggestions, request) : suggestions;
          };
          CompletionProvider.prototype.suggestAsync = function (request, doPostProcess) {
            if (doPostProcess === void 0) {
              doPostProcess = false;
            }
            return doSuggestAsync(request, this).then(function (suggestions) {
              return doPostProcess ? postProcess(suggestions, request) : suggestions;
            }, function (error) {
              return error;
            });
          };
          return CompletionProvider;
        }();
      exports.CompletionProvider = CompletionProvider;
      function suggest(editorState, fsProvider, astProvider) {
        if (astProvider === void 0) {
          astProvider = null;
        }
        var completionRequest = new CompletionRequest(editorState);
        var completionProvider = new CompletionProvider(fsProvider, astProvider);
        return completionProvider.suggest(completionRequest, true);
      }
      exports.suggest = suggest;
      function suggestAsync(editorState, fsProvider) {
        var completionRequest = new CompletionRequest(editorState);
        var completionProvider = new CompletionProvider(fsProvider);
        return completionProvider.suggestAsync(completionRequest, true);
      }
      exports.suggestAsync = suggestAsync;
      function categoryByRanges(suggestion, parentRange, propertyRange) {
        var categoryNames = Object.keys(categories);
        for (var i = 0; i < categoryNames.length; i++) {
          var categoryName = categoryNames[i];
          var issues = Object.keys(categories[categoryName]);
          for (var j = 0; j < issues.length; j++) {
            var issueName = issues[j];
            if (issueName !== suggestion) {
              continue;
            }
            var issue = categories[categoryName][issueName];
            var propertyIs = issue.is || [];
            var parentIs = issue.parentIs || [];
            if (propertyRange && _.find(propertyIs, function (name) {
                return isRangeAssignable(propertyRange, name);
              })) {
              return categoryName;
            }
            if (parentRange && _.find(parentIs, function (name) {
                return isRangeAssignable(parentRange, name);
              })) {
              return categoryName;
            }
          }
        }
        return 'unknown';
      }
      function isRangeAssignable(type, defCode) {
        var keys = defCode.split('.');
        var defObject = parserApi.universes;
        for (var i = 0; i < keys.length; i++) {
          defObject = defObject[keys[i]];
        }
        return type.isAssignableFrom(defObject.name);
      }
      function doSuggest(request, provider) {
        var preParsedAST = null;
        if (provider.astProvider) {
          preParsedAST = provider.astProvider.getASTRoot();
        }
        var result = getSuggestions(request, provider, preParsedAST);
        if (result)
          return result;
        return [];
      }
      function doSuggestAsync(request, provider) {
        request.async = true;
        request.promises = [];
        var apiPromise = parserApi.parseRAML(modifiedContent(request), {
            fsResolver: provider.contentProvider.fsResolver,
            filePath: request.content.getPath()
          });
        var suggestionsPromise = apiPromise.then(function (api) {
            return getSuggestions(request, provider, findAtOffsetInNode(request.content.getOffset(), api.highLevel()));
          });
        var requestSuggestionsPromise = suggestionsPromise.then(function (suggestions) {
            return Promise.all([suggestions].concat(request.promises));
          });
        var finalPromise = requestSuggestionsPromise.then(function (arrays) {
            var result = [];
            arrays.forEach(function (suggestions) {
              result = result.concat(suggestions);
            });
            return result;
          });
        return finalPromise;
      }
      function getSuggestions(request, provider, preParsedAst, project) {
        if (preParsedAst === void 0) {
          preParsedAst = undefined;
        }
        provider.currentRequest = request;
        try {
          if (provider.level > 100) {
            return;
          }
          provider.level++;
          var offset = request.content.getOffset();
          var text = request.content.getText();
          var kind = completionKind(request);
          var node = preParsedAst ? preParsedAst : getAstNode(request, provider.contentProvider, true, true, project);
          var hlnode = node;
          if (kind === parserApi.search.LocationKind.DIRECTIVE_COMPLETION) {
            return [{ text: 'include' }];
          }
          if (kind === parserApi.search.LocationKind.ANNOTATION_COMPLETION) {
            var declarations = parserApi.search.globalDeclarations(hlnode).filter(function (x) {
                return parserApi.universeHelpers.isAnnotationTypesProperty(x.property());
              });
            return declarations.map(function (x) {
              return {
                text: parserApi.search.qName(x, hlnode),
                annotation: true
              };
            });
          }
          if (kind === parserApi.search.LocationKind.VERSION_COMPLETION) {
            return ramlVersionCompletion(request);
          }
          if (kind === parserApi.search.LocationKind.INCOMMENT) {
            return [];
          }
          if (node === null) {
            return [];
          }
          var hasNewLine = false;
          for (var position = offset - 1; position >= hlnode.lowLevel().start(); position--) {
            var ch = text[position];
            if (ch == '\r' || ch == '\n') {
              hasNewLine = true;
              break;
            }
          }
          var cmi = offset;
          for (var pm = offset - 1; pm >= 0; pm--) {
            var c = text[pm];
            if (c === ' ' || c === '\t') {
              cmi = pm;
              continue;
            }
            break;
          }
          var attr = _.find(hlnode.attrs(), function (x) {
              return x.lowLevel().start() < cmi && x.lowLevel().end() >= cmi && !x.property().getAdapter(parserApi.ds.RAMLPropertyService).isKey();
            });
          if (!attr) {
            var p = _.find(hlnode.definition().allProperties(), function (p) {
                return p.canBeValue();
              });
            if (!hasNewLine) {
              if (p && kind == parserApi.search.LocationKind.VALUE_COMPLETION && parserApi.universeHelpers.isTypeProperty(p)) {
                if (hlnode.children().length == 1) {
                  attr = parserApi.stubs.createASTPropImpl(hlnode.lowLevel(), hlnode, p.range(), p);
                }
              }
            } else {
              var cm = _.find(hlnode.lowLevel().children(), function (x) {
                  return x.start() < offset && x.end() >= offset;
                });
              if (cm) {
                var p = _.find(hlnode.definition().allProperties(), function (p) {
                    return p.nameId() == cm.key();
                  });
                if (p) {
                  var il = getIndent(cm.keyStart(), cm.unit().contents());
                  var il2 = getIndent(offset, cm.unit().contents());
                  if (il2.length > il.length + 1) {
                    var isValue = p.range().hasValueTypeInHierarchy();
                    if (isValue) {
                      attr = parserApi.stubs.createVirtualASTPropImpl(cm, hlnode, p.range(), p);
                    } else {
                      if (cm.children().length > 0) {
                        hlnode = parserApi.stubs.createVirtualNodeImpl(cm.children()[0], hlnode, p.range(), p);
                      }
                    }
                  }
                }
              }
            }
          }
          if (kind == parserApi.search.LocationKind.PATH_COMPLETION) {
            return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
          }
          if (attr && (kind === parserApi.search.LocationKind.KEY_COMPLETION || kind === parserApi.search.LocationKind.SEQUENCE_KEY_COPLETION)) {
            var txt = '';
            for (var position = offset - 1; position >= 0; position--) {
              var ch = text[position];
              if (ch == '\r' || ch == '\n') {
                break;
              }
              txt = ch + txt;
            }
            txt = txt.trim();
            if (txt != attr.name()) {
              kind = parserApi.search.LocationKind.VALUE_COMPLETION;
            }
          }
          if (kind == parserApi.search.LocationKind.VALUE_COMPLETION) {
            var attrParent = attr && attr.parent && attr.parent();
            var parentPropertyOfAttr = attrParent && attrParent.property && attrParent.property();
            var attrParentType = attrParent && attrParent.definition && attrParent.definition();
            var isExtendableParent = attrParentType && (universeHelpers.isExtensionType(attrParentType) || universeHelpers.isOverlayType(attrParentType));
            var attrPropertyName = attr && attr.property && attr.property() && attr.property().nameId();
            var isExtendsProperty = attrPropertyName === universeModule.Universe10.Overlay.properties.extends.name || attrPropertyName === universeModule.Universe10.Extension.properties.extends.name;
            if (attrParentType && attrParentType.isAssignableFrom(parserApi.universes.Universe10.TypeDeclaration.name)) {
              if (attrPropertyName === universeModule.Universe10.ObjectTypeDeclaration.properties.discriminator.name) {
                var actualType = attrParent.localType && attrParent.localType();
                var typeProps = actualType && actualType.allProperties() || [];
                typeProps = typeProps.filter(function (typeProp) {
                  return typeProp.isPrimitive && typeProp.isPrimitive();
                });
                return typeProps.map(function (typeProp) {
                  var propertyName = typeProp.nameId();
                  return {
                    text: propertyName,
                    displayText: propertyName,
                    description: typeProp.description(),
                    category: categoryByRanges(propertyName, attrParentType, typeProp.range())
                  };
                });
              }
            }
            if (isExtendableParent && isExtendsProperty) {
              return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
            }
            if (parentPropertyOfAttr && universeHelpers.isUsesProperty(parentPropertyOfAttr)) {
              return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
            }
            var proposals = valueCompletion(node, attr, request, provider);
            if (!attr) {
              if (!proposals || proposals.length == 0) {
                if (!hasNewLine) {
                  if (hlnode.definition().getAdapter(parserApi.ds.RAMLService).isUserDefined()) {
                    return propertyCompletion(hlnode, request, mv, defNode, hasNewLine);
                  }
                }
              }
            }
            if (attr && attr.property() && (attr.property().getAdapter(parserApi.ds.RAMLPropertyService).isTypeExpr() || attr.property().isAnnotation())) {
              if (!proposals) {
                proposals = [];
              }
              proposals = proposals.filter(function (x) {
                var proposalText = getProposalText(x);
                if (proposalText === hlnode.name()) {
                  return false;
                }
                return true;
              });
              var pref = request.valuePrefix();
              var nmi = pref.lastIndexOf('.');
              if (nmi) {
                pref = pref.substr(0, nmi + 1);
              } else {
                pref = null;
              }
              if (pref) {
                proposals = proposals.filter(function (x) {
                  return getProposalText(x).indexOf(pref) == 0;
                });
                proposals.forEach(function (x) {
                  return updateProposalText(x, getProposalText(x).substring(pref.length));
                });
              }
            }
            if (proposals) {
              if (text[offset - 1] == ':') {
                proposals.forEach(function (x) {
                  if (x.extra) {
                    x.extra = ' ' + x.extra;
                  } else {
                    x.extra = ' ';
                  }
                });
              }
              if (request.prefix().indexOf('[') != -1) {
                request.setPrefix('');
                proposals.forEach(function (x) {
                  x.text = ': [ ' + x.displayText;
                });
              } else if (isSquareBracketExpected(attr)) {
                proposals = proposals.filter(function (proposed) {
                  return !isSiblingExists(attr, proposed.displayText);
                });
                var ending = '';
                var initialPosition = offset;
                for (var i = initialPosition; i < text.length && !/[\t\n\r]/.test(text[i]); i++) {
                  ending += text[i];
                  if (ending.replace(/\s/g, '') === ':') {
                    proposals.forEach(function (x) {
                      x.text = x.displayText;
                      x.snippet = null;
                      x.extra = null;
                    });
                    break;
                  }
                }
                var isOpenSquarePresent = false;
                initialPosition = offset - 1;
                for (var i = initialPosition; i >= 0 && !/[\t\n\r]/.test(text[i]); i--) {
                  if (text[i] === '[') {
                    isOpenSquarePresent = true;
                    break;
                  }
                }
                if (!isOpenSquarePresent) {
                  proposals.forEach(function (x) {
                    if (!request.valuePrefix() && x.snippet) {
                      x.text = x.displayText;
                      x.snippet = '[' + x.snippet + ']';
                      return;
                    }
                    x.extra = ' [';
                    x.text = (x.snippet || x.displayText) + ']';
                    x.snippet = null;
                  });
                }
              } else {
                var ending = '';
                var initialPosition = offset;
                for (var i = initialPosition; i < text.length && !/[\t\n\r]/.test(text[i]); i++) {
                  ending += text[i];
                  if (ending.replace(/\s/g, '') === ':') {
                    proposals.forEach(function (x) {
                      x.text = x.displayText;
                      x.snippet = null;
                      x.extra = null;
                    });
                    break;
                  }
                }
                proposals.forEach(function (x) {
                  if (x.isResourceType && !request.valuePrefix() && x.snippet) {
                    x.snippet = x.extra + x.snippet;
                    x.extra = null;
                    x.text = x.displayText;
                  }
                });
              }
            }
            if (!hasNewLine && proposals && proposals.length > 0) {
              proposals = addDefineInlineProposal2(proposals, hlnode.lowLevel().start(), text);
            }
            if (proposals && isInResourceDescription(attr) && request.prefix() && request.prefix().length > 0) {
              var canBeTemplate = false;
              var canBeTransform1 = 0;
              var canBeTransform2 = 0;
              var txt = '';
              for (var position = offset - 1; position >= 0; position--) {
                var ch = text[position];
                if (ch === '\r' || ch === '\n') {
                  break;
                }
                if (ch === '<' && text[position - 1] === '<') {
                  canBeTemplate = true;
                  break;
                }
                if (ch === '!') {
                  canBeTransform1++;
                }
                if (ch === '|' && canBeTransform1 === 1) {
                  canBeTransform2++;
                }
                txt = ch + txt;
              }
              if (canBeTemplate && canBeTransform1 === 1 && canBeTransform2 === 1) {
                var leftPart = new RegExp(/\|\s*!\s*/.source + request.prefix());
                if (leftPart.test(txt)) {
                  proposals = addTransformers(proposals, request.prefix());
                }
              }
            }
            return proposals;
          }
          if (kind == search.LocationKind.KEY_COMPLETION || kind == search.LocationKind.SEQUENCE_KEY_COPLETION && offset > 0 && text.charAt(offset - 1) != '-' && text.charAt(offset - 1) != ' ') {
            if (node.isAttr() || node.isImplicit()) {
              throw new Error('Should be highlevel node at this place');
            }
            if (search.isExampleNode(hlnode)) {
              return examplePropertyCompletion(hlnode, request, provider);
            }
            if (hlnode.property() && universeHelpers.isUriParametersProperty(hlnode.property()) && hlnode.definition() instanceof def.NodeClass) {
              var nm = hlnode.parent().attr('relativeUri');
              if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                var runtime = parserApi.utils.parseUrl(nm.value());
                if (runtime instanceof Array) {
                  if (runtime) {
                    if (isColonNeeded(offset, text)) {
                      var rs = runtime.map(function (x) {
                          return { text: x + ': \n' + getIndent2(offset, text) + '  ' };
                        });
                    } else {
                      var rs = runtime.map(function (x) {
                          return { text: x };
                        });
                    }
                    return rs;
                  }
                }
              }
            }
            if (hlnode.property() && universeHelpers.isBaseUriParametersProperty(hlnode.property()) && hlnode.definition() instanceof def.NodeClass) {
              var nm = hlnode.root().attr(universeModule.Universe10.Api.properties.baseUri.name);
              if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                var runtime = parserApi.utils.parseUrl(nm.value());
                if (runtime instanceof Array) {
                  if (runtime) {
                    if (isColonNeeded(offset, text)) {
                      var rs = runtime.map(function (x) {
                          return { text: x + ': \n' + getIndent2(offset, text) + '  ' };
                        });
                    } else {
                      var rs = runtime.map(function (x) {
                          return { text: x };
                        });
                    }
                    return rs;
                  }
                }
              }
            }
            //FIXME It still should be improved
            if (hlnode.property() && universeHelpers.isResourcesProperty(hlnode.property())) {
              var nm = hlnode.attr('relativeUri');
              if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                if (nm && nm.value().indexOf('{') != -1) {
                  return [{ text: 'mediaTypeExtension}' }];
                }
                return [];
              }
            }
            var mv = hlnode.property() && hlnode.property().isMultiValue();
            if (hlnode.lowLevel().keyEnd() < offset) {
              mv = false;
            }
            //extra test /*FIXME*/
            var defNode = true;
            if (mv) {
              var ce = hlnode.definition().getAdapter(services.RAMLService).getCanInherit();
              if (ce) {
                var context = hlnode.computedValue(ce[0]);
                if (context) {
                  defNode = true;
                  mv = false;
                }
              }
            }
            return propertyCompletion(hlnode, request, mv, defNode);
          }
          return [];
        } finally {
          provider.level--;
        }  //return [];
      }
      function ramlVersionCompletion(request) {
        var prop = [
            'RAML 0.8',
            'RAML 1.0'
          ];
        var rs = [];
        var text = request.content.getText();
        var offset = request.content.getOffset();
        var start = text.substr(0, offset);
        if (start.indexOf('#%RAML 1.0 ') == 0) {
          var list = [
              'DocumentationItem',
              'DataType',
              'NamedExample',
              'ResourceType',
              'Trait',
              'SecurityScheme',
              'AnnotationTypeDeclaration',
              'Library',
              'Overlay',
              'Extension'
            ];
          return list.map(function (x) {
            return { text: x };
          });
        }
        prop.forEach(function (x) {
          if (('#%' + x).indexOf(start) != 0) {
            return;
          }
          if (text.trim().indexOf('#%') == 0) {
            if (request.prefix().indexOf('R') != -1) {
              rs.push({
                displayText: x,
                text: x
              });
            } else {
              var pref = text.substring(2, offset);
              if (x.indexOf(pref) == 0) {
                if (request.prefix() == '1' || request.prefix() == '0') {
                  rs.push({
                    displayText: x,
                    text: request.prefix() + x.substr(offset - 2)
                  });
                } else {
                  rs.push({
                    displayText: x,
                    text: x.substr(offset - 2)
                  });
                }
              }
            }
          } else {
            rs.push({
              displayText: x,
              text: x,
              extra: '%'
            });
          }
        });
        return rs;
      }
      ;
      function completionKind(request) {
        return parserApi.search.determineCompletionKind(request.content.getText(), request.content.getOffset());
      }
      function getAstNode(request, contentProvider, clearLastChar, allowNull, oldProject) {
        if (clearLastChar === void 0) {
          clearLastChar = true;
        }
        if (allowNull === void 0) {
          allowNull = true;
        }
        var newProjectId = contentProvider.contentDirName(request.content);
        var project = oldProject || parserApi.project.createProject(newProjectId, contentProvider.fsResolver);
        var offset = request.content.getOffset();
        var text = request.content.getText();
        var kind = completionKind(request);
        if (kind === parserApi.search.LocationKind.KEY_COMPLETION && clearLastChar) {
          text = text.substring(0, offset) + 'k:' + text.substring(offset);
        }
        var unit = project.setCachedUnitContent(request.content.getBaseName(), text);
        var ast = unit.highLevel();
        var actualOffset = offset;
        for (var currentOffset = offset - 1; currentOffset >= 0; currentOffset--) {
          var symbol = text[currentOffset];
          if (symbol === ' ' || symbol === '\t') {
            actualOffset = currentOffset - 1;
            continue;
          }
          break;
        }
        var astNode = ast.findElementAtOffset(actualOffset);
        if (!allowNull && !astNode) {
          return ast;
        }
        if (astNode && search.isExampleNode(astNode)) {
          var exampleEnd = astNode.lowLevel().end();
          if (exampleEnd === actualOffset && text[exampleEnd] === '\n') {
            astNode = astNode.parent();
          }
        }
        return astNode;
      }
      function modifiedContent(request) {
        var offset = request.content.getOffset();
        var text = request.content.getText();
        var kind = completionKind(request);
        if (kind === parserApi.search.LocationKind.KEY_COMPLETION) {
          text = text.substring(0, offset) + 'k:' + text.substring(offset);
        }
        return text;
      }
      function findAtOffsetInNode(offset, node) {
        var actualOffset = offset;
        var text = node.lowLevel().unit().contents();
        for (var currentOffset = offset - 1; currentOffset >= 0; currentOffset--) {
          var symbol = text[currentOffset];
          if (symbol === ' ' || symbol === '\t') {
            actualOffset = currentOffset - 1;
            continue;
          }
          break;
        }
        return node.findElementAtOffset(actualOffset);
      }
      function getIndent(offset, text) {
        var spaces = '';
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c == ' ' || c == '\t') {
            if (spaces) {
              spaces += c;
            } else {
              spaces = c;
            }
          } else if (c == '\r' || c == '\n') {
            return spaces;
          } else if (spaces) {
            return '';
          }
        }
        return '';
      }
      function getIndentWithSequenc(offset, text) {
        var spaces = '';
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c == ' ' || c == '\t' || c == '-') {
            if (spaces) {
              spaces += c;
            } else {
              spaces = c;
            }
          } else if (c == '\r' || c == '\n') {
            return spaces;
          } else if (spaces) {
            return '';
          }
        }
        return '';
      }
      function getIndent2(offset, text) {
        var spaces = '';
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c == ' ' || c == '\t') {
            if (spaces) {
              spaces += c;
            } else {
              spaces = c;
            }
          } else if (c == '\r' || c == '\n') {
            return spaces;
          }
        }
      }
      function pathCompletion(request, contentProvider, attr, hlNode, custom) {
        var prefix = request.valuePrefix();
        if (prefix.indexOf('#') === -1) {
          return pathPartCompletion(request, contentProvider, attr, hlNode, custom);
        } else {
          return pathReferencePartCompletion(request, contentProvider, attr, hlNode, custom);
        }
      }
      function pathPartCompletion(request, contentProvider, attr, hlNode, custom) {
        var prefix = request.valuePrefix();
        var dn = contentProvider.contentDirName(request.content);
        var ll = contentProvider.resolve(dn, prefix.indexOf('/') === 0 ? '.' + prefix : prefix);
        var indexOfDot = ll.lastIndexOf('.');
        var indexOfSlash = ll.lastIndexOf('/');
        if (!(indexOfDot > 0 && (indexOfDot > indexOfSlash || indexOfSlash < 0))) {
          indexOfDot = -1;
        }
        var typedPath = ll;
        if (ll) {
          dn = contentProvider.dirName(ll);
          if (request.async) {
            dn = contentProvider.existsAsync(ll).then(function (isExists) {
              if (!isExists) {
                return contentProvider.dirName(ll);
              }
              return contentProvider.isDirectoryAsync(ll).then(function (isDirectory) {
                if (!isDirectory) {
                  return contentProvider.dirName(ll);
                }
                return ll;
              });
            });
          } else if (contentProvider.exists(ll) && contentProvider.isDirectory(ll)) {
            dn = ll;
          }
        }
        var res = [];
        var known = !custom;
        if (attr) {
          if (custom) {
            if (attr.name() === 'example') {
              res = res.concat(fromDir(prefix, dn, 'examples', contentProvider, request.promises));
              known = true;
            }
            if (attr.name() === 'value' && parserApi.universeHelpers.isGlobalSchemaType(attr.parent().definition())) {
              res = res.concat(fromDir(prefix, dn, 'schemas', contentProvider, request.promises));
              known = true;
            }
          }
        }
        if (!attr) {
          if (custom) {
            if (parserApi.universeHelpers.isTraitType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'traits', contentProvider, request.promises));
              known = true;
            }
            if (parserApi.universeHelpers.isResourceTypeType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'resourceTypes', contentProvider, request.promises));
              known = true;
            }
            if (parserApi.universeHelpers.isSecuritySchemaType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'securitySchemes', contentProvider, request.promises));
              known = true;
            }
            if (parserApi.universeHelpers.isGlobalSchemaType(hlNode.definition())) {
              res = res.concat(fromDir(prefix, dn, 'schemas', contentProvider, request.promises));
              known = true;
            }
          }
        }
        if (!known || !custom) {
          if (request.async) {
            filtredDirContentAsync(dn, typedPath, indexOfDot, contentProvider, request.promises);
          } else if (contentProvider.exists(dn) && contentProvider.isDirectory(dn)) {
            var dirContent = contentProvider.readDir(dn);
            res = res.concat(dirContent.filter(function (x) {
              try {
                var fullPath = contentProvider.resolve(dn, x);
                if (fullPath.indexOf(typedPath) === 0) {
                  return true;
                }
              } catch (exception) {
                return false;
              }
            }).map(function (x) {
              var fullPath = contentProvider.resolve(dn, x);
              var needSlash = contentProvider.exists(fullPath) && contentProvider.isDirectory(fullPath);
              return { text: indexOfDot > 0 ? fullPath.substr(indexOfDot + 1) : x + (needSlash ? '/' : '') };
            }));
          }
        }
        return res;
      }
      function filtredDirContentAsync(dirName, typedPath, indexOfDot, contentProvider, promises) {
        if (promises) {
          var asString;
          var exists = dirName.then(function (dirNameStr) {
              asString = dirNameStr;
              return contentProvider.existsAsync(dirNameStr);
            });
          var dirContent = exists.then(function (isExists) {
              if (!isExists) {
                return [];
              }
              return contentProvider.isDirectoryAsync(asString).then(function (isDir) {
                if (!isDir) {
                  return [];
                }
                return contentProvider.readDirAsync(asString).then(function (dirContent) {
                  var res = dirContent.filter(function (x) {
                      try {
                        var fullPath = contentProvider.resolve(asString, x);
                        if (fullPath.indexOf(typedPath) === 0) {
                          return true;
                        }
                      } catch (exception) {
                        return false;
                      }
                    }).map(function (x) {
                      var fullPath = contentProvider.resolve(asString, x);
                      return contentProvider.existsAsync(fullPath).then(function (exist) {
                        return contentProvider.isDirectoryAsync(fullPath).then(function (isDir) {
                          var needSlash = exist && isDir;
                          return { text: indexOfDot > 0 ? fullPath.substr(indexOfDot + 1) : x + (needSlash ? '/' : '') };
                        });
                      });
                    });
                  return Promise.all(res);
                });
              });
            });
          promises.push(dirContent);
        }
      }
      function fromDir(prefix, dn, dirToLook, contentProvider, promises) {
        if (promises) {
          var existsPromise = dn.then(function (dirName) {
              var pss = contentProvider.resolve(dirName, dirToLook);
              return contentProvider.existsAsync(pss);
            });
          var proposalsPromise = existsPromise.then(function (result) {
              if (result) {
                return contentProvider.readDirAsync(pss).then(function (dirNames) {
                  var proposals = dirNames.map(function (x) {
                      return {
                        text: x,
                        replacementPrefix: prefix,
                        extra: './' + dirToLook + '/'
                      };
                    });
                  return proposals;
                });
              }
              return [];
            });
          promises.push(proposalsPromise);
          return [];
        }
        var pss = contentProvider.resolve(dn, dirToLook);
        if (contentProvider.exists(pss)) {
          var dirContent = contentProvider.readDir(pss);
          var proposals = dirContent.map(function (x) {
              return {
                text: x,
                replacementPrefix: prefix,
                extra: './' + dirToLook + '/'
              };
            });
          return proposals;
        }
        return [];
      }
      function pathReferencePartCompletion(request, contentProvider, attr, hlNode, custom) {
        var prefix = request.valuePrefix();
        var includePath = parserApi.schema.getIncludePath(prefix);
        var includeReference = parserApi.schema.getIncludeReference(prefix);
        if (!includePath || !includeReference) {
          return [];
        }
        var includeUnit = attr.lowLevel().unit().resolve(includePath);
        if (!includeUnit) {
          return [];
        }
        var content = includeUnit.contents();
        if (!content) {
          return [];
        }
        try {
          var proposals = parserApi.schema.completeReference(includePath, includeReference, content);
          return proposals.map(function (proposal) {
            return { text: proposal };
          });
        } catch (Error) {
          console.log(Error);
        }
        return [];
      }
      function isColonNeeded(offset, text) {
        var needColon = true;
        for (var i = offset > 0 ? offset - 1 : 0; i < text.length; i++) {
          var chr = text.charAt(i);
          if (chr == ' ' || chr == '\r' || chr == '\n') {
            break;
          }
          if (chr == ':') {
            needColon = false;
          }
        }
        return needColon;
      }
      function isAllowed(node, x) {
        var ok = true;
        x.getContextRequirements().forEach(function (y) {
          if (y.name.indexOf('(') !== -1) {
            return;
          }
          var vl = node.computedValue(y.name);
          if (vl) {
            ok = ok && vl == y.value;
          } else {
            if (y.value) {
              ok = false;
            }
          }
        });
        return ok;
      }
      /**
 * Returns true if property should be left in the completion proposals, false if the property should be removed
 * @param node
 * @param property
 * @param existing
 */
      function filterPropertyCompletion(node, property, existing) {
        //basic filtering
        if (!(!property.getAdapter(parserApi.ds.RAMLPropertyService).isKey() && !property.getAdapter(parserApi.ds.RAMLPropertyService).isMerged() && !property.getAdapter(services.RAMLPropertyService).isSystem())) {
          return false;
        }
        //contextual filtering
        if (!isAllowed(node, property)) {
          return false;
        }
        //duplicate filtering
        if (!!existing[property.nameId()]) {
          return false;
        }
        //annotation filtering
        if (!!property.isAnnotation()) {
          return false;
        }
        if (property.nameId() == parserApi.universes.Universe10.TypeDeclaration.properties.allowedTargets.name && property.domain().key() && property.domain().key() == parserApi.universes.Universe10.TypeDeclaration && node.localType() && !node.localType().isAnnotationType()) {
          return false;
        }
        return true;
      }
      function propertyCompletion(node, request, mv, c, hasNewLine) {
        if (hasNewLine === void 0) {
          hasNewLine = true;
        }
        var hlnode = node;
        var notAKey = false;
        var onlyKey = false;
        var text = request.content.getText();
        var offset = request.content.getOffset();
        var rootWrapper = hlnode.root() && hlnode.root().wrapperNode();
        var isDefaultMedia = rootWrapper && rootWrapper.mediaType && rootWrapper.mediaType() && rootWrapper.mediaType().length > 0;
        var isDefaultBodyProperty = isDefaultMedia && hlnode.property && hlnode.property() && parserApi.universeHelpers.isBodyProperty(hlnode.property());
        if (hasNewLine) {
          var is = getIndentWithSequenc(node.lowLevel().keyStart(), text);
          if (is == undefined) {
            is = '';
          }
          var i2s = getIndentWithSequenc(offset, text);
          var i1 = is.length;
          var i2 = i2s.length;
          if (i1 == i2 && node.parent() && !isDefaultBodyProperty) {
            if (node.property().getAdapter(parserApi.ds.RAMLPropertyService).isMerged()) {
              hlnode = hlnode.parent();
            } else {
              notAKey = false;
              onlyKey = true;
            }
          }
          if (i2 > i1) {
            notAKey = true;
            if (i2 >= i1 + 4) {
              onlyKey = true;
              notAKey = false;
            }
          }
          while (i2 < i1 && hlnode.parent()) {
            hlnode = hlnode.parent();
            i1 = i1 - 2;
          }
        }
        var needColon = isColonNeeded(offset, text);
        var ks = needColon ? ': ' : '';
        var props = hlnode.definition().allProperties();
        var existing = {};
        hlnode.attrs().forEach(function (x) {
          existing[x.name()] = true;
        });
        props = props.filter(function (x) {
          return filterPropertyCompletion(hlnode, x, existing);
        });
        if (node.definition().isAssignableFrom(parserApi.universes.Universe10.TypeDeclaration.name)) {
          if (!node.definition().isAssignableFrom('ObjectTypeDeclaration')) {
            if (!node.attr('type')) {
              var q = node.definition().universe().type('ObjectTypeDeclaration');
              if (q) {
                props.push(q.property('properties'));
              }
            }
          }
        }
        //TODO MAKE IT BETTER (actually we need to filter out and guess availabe keys)
        var rs = [];
        if ((!mv || isDefaultBodyProperty) && !onlyKey) {
          rs = props.map(function (x) {
            var complextionText = x.nameId() + ks;
            if (x.range().isAssignableFrom(universeModule.Universe10.ExampleSpec.name)) {
              complextionText = complextionText.trim();
            } else if (!x.range().hasValueTypeInHierarchy() && needColon) {
              complextionText += '\n' + getIndent(offset, text) + '  ';
            }
            return {
              text: complextionText,
              displayText: x.nameId(),
              description: x.description(),
              category: categoryByRanges(x.nameId(), node.definition(), x.range())
            };
          });
        }
        if (c) {
          hlnode.definition().allProperties().filter(function (x) {
            return x.getAdapter(parserApi.ds.RAMLPropertyService).isMerged() || x.isFromParentKey();
          }).forEach(function (p) {
            if (onlyKey) {
              if (!p.isFromParentKey()) {
                return;
              }
            }
            if (notAKey) {
              if (p.isFromParentKey()) {
                return;
              }
            }
            var prop = p;
            var oftenKeys = p.getOftenKeys();
            if (!oftenKeys) {
              var sug = p.suggester();
              if (sug) {
                oftenKeys = sug(hlnode);
              }
            }
            if (!oftenKeys) {
              oftenKeys = p.enumOptions();
            }
            if (hlnode.property() && parserApi.universeHelpers.isBodyProperty(hlnode.property())) {
              if (!oftenKeys) {
                if (parserApi.universeHelpers.isResponseType(hlnode.property().domain())) {
                  oftenKeys = [
                    'application/json',
                    'application/xml'
                  ];
                }
                if (parserApi.universeHelpers.isMethodBaseType(hlnode.property().domain()) || parserApi.universeHelpers.isMethodType(hlnode.property().domain())) {
                  oftenKeys = [
                    'application/json',
                    'application/xml',
                    'multipart/form-data',
                    'application/x-www-form-urlencoded'
                  ];
                }
              }
            }
            if (oftenKeys) {
              oftenKeys.forEach(function (oftenKey) {
                var original = oftenKey;
                var cs = prop.valueDocProvider();
                var description = '';
                if (cs) {
                  description = cs(oftenKey);
                }
                var proposedContainsSlash = oftenKey.indexOf('/') >= 0;
                var requestContainsSlash = request.valuePrefix() && request.valuePrefix().indexOf('/') >= 0;
                var actualValue = requestContainsSlash ? oftenKey.replace(request.valuePrefix(), '') : oftenKey;
                var textValue = actualValue + (needColon ? ':' + '\n' + getIndent(offset, text) + '  ' : '');
                var prefixValue = proposedContainsSlash ? request.valuePrefix() : null;
                rs.push({
                  text: textValue,
                  description: description,
                  displayText: oftenKey,
                  prefix: requestContainsSlash ? prefixValue : null,
                  category: categoryByRanges(original, hlnode.definition(), prop.range())
                });
              });
            }
          });
        }
        return rs;
      }
      function isUnexspected(symbol) {
        if (symbol === '\'') {
          return true;
        }
        if (symbol === '"') {
          return true;
        }
        return false;
      }
      function isValueBroken(request) {
        var text = request.content.getText();
        var offset = request.content.getOffset();
        var prefix = request.prefix();
        var beginning = text.substring(0, offset);
        var value = beginning.substring(beginning.lastIndexOf(':') + 1).trim();
        if (!value.length) {
          return false;
        }
        if (value[value.length - 1] === ',') {
          if (value.indexOf('[') < 0) {
            return true;
          }
        }
        if (beginning[beginning.length - 1] === ' ') {
          if (/^\w$/.test(value[value.length - 1])) {
            return true;
          } else if (value[value.length - 1] === ',') {
            if (value.indexOf('[') < 0) {
              return true;
            }
          }
        }
        if (/^\w+$/.test(prefix)) {
          value = value.substring(0, value.lastIndexOf(prefix)).trim();
          if (/^\w$/.test(value[value.length - 1])) {
            return true;
          } else if (value[value.length - 1] === ',') {
            if (value.indexOf('[') < 0) {
              return true;
            }
          }
        }
        if (isUnexspected(value[value.length - 1])) {
          return true;
        }
        return false;
      }
      function valueCompletion(node, attr, request, provider) {
        var hlnode = node;
        var text = request.content.getText();
        var offset = request.content.getOffset();
        if (isValueBroken(request)) {
          return [];
        }
        if (attr) {
          var p = attr.property();
          var vl = attr.value();
          if (typeof vl === 'object' && vl) {
            var innerNode = vl.toHighLevel();
            if (innerNode) {
              return getSuggestions(provider.currentRequest, provider, findASTNodeByOffset(innerNode, request));
            } else if (parserApi.search.isExampleNodeContent(attr)) {
              var contentType = parserApi.search.findExampleContentType(attr);
              if (contentType) {
                var documentationRoot = parserApi.search.parseDocumentationContent(attr, contentType);
                if (documentationRoot) {
                  return getSuggestions(provider.currentRequest, provider, findASTNodeByOffset(documentationRoot, request));
                }
              }
            }
          }
          if (p) {
            var vls = enumValues(p, hlnode);
            if (p.isAllowNull()) {
              vls.push({
                text: 'null',
                description: 'null means - that no value is allowed'
              });
            }
            if (!vls || vls.length == 0) {
              var oftenKeys = p.getOftenKeys();
              if (oftenKeys) {
                return oftenKeys.map(function (x) {
                  return {
                    text: x,
                    displayText: x
                  };
                });
              }
            }
            if (universeHelpers.isExampleProperty(p) && universeHelpers.isBodyLikeType(hlnode.definition())) {
              if (!testVal(attr.value(), offset, text)) {
                return;
              }
              var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                  x.extra = '!include ./examples/';
                  x.displayText = '!include ./examples/' + x.text;
                  return x;
                });
              rs = addDefineInlineProposal(rs, attr.lowLevel().start(), text);
              return rs;
            }
            if (universeHelpers.isValueProperty(p) && universeHelpers.isGlobalSchemaType(hlnode.definition())) {
              if (!testVal(attr.value(), offset, text)) {
                return;
              }
              rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                x.extra = '!include ./schemas/';
                x.displayText = '!include ./schemas/' + x.text;
                return x;
              });
              rs = addDefineInlineProposal(rs, attr.lowLevel().start(), text);
            }
            if (vls) {
              return vls;
            }
          }
          return [];
        } else {
          //FIXME (To DEF)
          if (universeHelpers.isGlobalSchemaType(hlnode.definition())) {
            rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
              x.extra = '!include ./schemas/';
              x.displayText = '!include ./schemas/' + x.text;
              return x;
            });
            rs = addDefineInlineProposal(rs, hlnode.lowLevel().start(), text);
          }
          if (universeHelpers.isTraitType(hlnode.definition())) {
            rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
              x.extra = '!include ./traits/';
              x.displayText = '!include ./traits/' + x.text;
              return x;
            });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
          }
          if (universeHelpers.isResourceTypeType(hlnode.definition())) {
            var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                x.extra = '!include ./resourceTypes/';
                x.displayText = '!include ./resourceTypes/' + x.text;
                return x;
              });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
          }
          if (universeHelpers.isSecuritySchemaType(hlnode.definition())) {
            var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) {
                x.extra = '!include ./securitySchemes/';
                x.displayText = '!include ./securitySchemes/' + x.text;
                return x;
              });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
          }
          if (universeHelpers.isExampleSpecType(hlnode.definition())) {
            return examplePropertyCompletion(hlnode, request, provider);
          }
        }
      }
      exports.valueCompletion = valueCompletion;
      function findASTNodeByOffset(ast, request) {
        var text = request.content.getText();
        var cm = request.content.getOffset();
        for (var pm = cm - 1; pm >= 0; pm--) {
          var c = text[pm];
          if (c == ' ' || c == '\t') {
            cm = pm;
            continue;
          }
          break;
        }
        var astNode = ast.findElementAtOffset(cm);
        return astNode;
      }
      function enumValues(property, parentNode) {
        if (parentNode) {
          if (property.getAdapter(parserApi.ds.RAMLPropertyService).isTypeExpr()) {
            var associatedType = parentNode.associatedType();
            var parentDefinition = parentNode.definition();
            var noArraysOrPrimitives;
            var typeProperty = parentNode.attr(parserApi.universes.Universe10.TypeDeclaration.properties.type.name);
            var typePropertyValue = typeProperty && typeProperty.value();
            var typeProperties = parentNode.children() && parentNode.children().filter(function (child) {
                return child.isAttr() && parserApi.universeHelpers.isTypeProperty(child.property());
              });
            var visibleScopes = [];
            var api = parentNode && parentNode.root && parentNode.root();
            api && api.lowLevel() && api.lowLevel().unit() && visibleScopes.push(api.lowLevel().unit().absolutePath());
            api && api.wrapperNode && api.wrapperNode() && api.wrapperNode().uses && api.wrapperNode().uses().forEach(function (usesDeclaration) {
              if (usesDeclaration && usesDeclaration.value && usesDeclaration.value()) {
                var resolvedUnit = api.lowLevel().unit().resolve(usesDeclaration.value());
                if (resolvedUnit) {
                  visibleScopes.push(resolvedUnit.absolutePath());
                }
              }
            });
            var definitionNodes = parserApi.search.globalDeclarations(parentNode).filter(function (node) {
                var nodeLocation = node.lowLevel().unit().absolutePath();
                if (visibleScopes.indexOf(nodeLocation) < 0) {
                  return false;
                }
                if (parserApi.universeHelpers.isGlobalSchemaType(node.definition())) {
                  return true;
                }
                var superTypesOfProposed = node.definition().allSuperTypes();
                if (_.find(superTypesOfProposed, function (supertype) {
                    return parserApi.universeHelpers.isTypeDeclarationType(supertype);
                  })) {
                  var isMultiValue = typePropertyValue && property && property.isMultiValue() && typeProperties && typeProperties.length > 1;
                  if (isMultiValue) {
                    if (!associatedType) {
                      try {
                        associatedType = parentNode.localType();
                      } catch (exception) {
                        console.log(exception);
                      }
                    }
                    if (associatedType && !parentDefinition.hasUnionInHierarchy()) {
                      var supertypes = associatedType.superTypes().filter(function (supertype) {
                          return !supertype.isAssignableFrom('unknown');
                        });
                      if (supertypes) {
                        var isExtendsObject = _.find(supertypes, function (supertype) {
                            return isObject(supertype);
                          });
                        var isExtendsPrimitive = _.find(supertypes, function (supertype) {
                            return isPrimitive(supertype);
                          });
                        var isExtendsArray = _.find(supertypes, function (supertype) {
                            return isArray(supertype);
                          }) || parentDefinition && isArray(parentDefinition);
                        var noObjects = isExtendsArray || isExtendsPrimitive;
                        noArraysOrPrimitives = isExtendsObject || noObjects;
                        if (_.find(supertypes, function (supertype) {
                            return parserApi.search.qName(node, parentNode) === supertype.nameId();
                          })) {
                          return false;
                        }
                        if (noArraysOrPrimitives && (isPrimitive(node.definition()) || isArray(node.definition()))) {
                          return false;
                        }
                        if (noObjects && isObject(node.definition())) {
                          return false;
                        }
                      }
                    }
                    if (parentDefinition.hasUnionInHierarchy()) {
                      var unionClasses = allClassesForUnion(parentDefinition);
                      if (_.find(unionClasses, function (unionPart) {
                          return parserApi.search.qName(node, parentNode) === unionPart.nameId();
                        })) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
                return universeHelpers.isTypeDeclarationType(node.definition()) && node.property().nameId() === 'models';
              });
            var result = definitionNodes.map(function (node) {
                return {
                  text: search.qName(node, parentNode),
                  description: ''
                };
              });
            var typeDeclarationType = property.domain().universe().type('TypeDeclaration');
            //var annotationTypeDeclaration = property.domain().universe().type("AnnotationTypeDeclaration");
            if (typeDeclarationType) {
              var subTypes = typeDeclarationType.allSubTypes();
              result = result.concat(subTypes.filter(function (subType) {
                if (noArraysOrPrimitives && (isPrimitive(subType) || isArray(subType))) {
                  return false;
                }
                return true;
              }).map(function (subType) {
                return {
                  text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                  description: subType.description()
                };
              }));
            }
            return result;
          }
          if (universeHelpers.isSchemaStringType(property.range())) {
            if (property.range().universe().version() === 'RAML10') {
              var definitionNodes = search.globalDeclarations(parentNode).filter(function (node) {
                  if (universeHelpers.isGlobalSchemaType(node.definition())) {
                    return true;
                  }
                  var superTypesOfProposed = node.definition().allSuperTypes();
                  if (_.find(superTypesOfProposed, function (x) {
                      return universeHelpers.isTypeDeclarationType(x);
                    })) {
                    return true;
                  }
                  return universeHelpers.isTypeDeclarationType(node.definition()) && node.property().nameId() === 'models';
                });
              var result = definitionNodes.map(function (node) {
                  return {
                    text: search.qName(node, parentNode),
                    description: ''
                  };
                });
              var subTypes = search.subTypesWithLocals(property.domain().universe().type('TypeDeclaration'), parentNode);
              result = result.concat(subTypes.map(function (subType) {
                return {
                  text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                  description: subType.description()
                };
              }));
              return result;
            }
          }
          if (property.isDescriminator()) {
            var subTypes = search.subTypesWithLocals(property.domain(), parentNode);
            return subTypes.map(function (subType) {
              var suggestionText = subType.getAdapter(services.RAMLService).descriminatorValue();
              return {
                text: suggestionText,
                description: subType.description(),
                category: categoryByRanges(suggestionText, property.domain(), null)
              };
            });
          }
          if (property.isReference()) {
            return search.nodesDeclaringType(property.referencesTo(), parentNode).map(function (subType) {
              return nodeToProposalInfo(subType, parentNode);
            });
          }
          if (property.range().hasValueTypeInHierarchy()) {
            var valueTypeAdapter = property.range().getAdapter(services.RAMLService);
            if (valueTypeAdapter.globallyDeclaredBy().length > 0) {
              var definitionNodes = search.globalDeclarations(parentNode).filter(function (proposedNode) {
                  var proposedDefinition = proposedNode.definition();
                  return _.find(valueTypeAdapter.globallyDeclaredBy(), function (globalDefinition) {
                    return globalDefinition == proposedDefinition;
                  }) != null;
                });
              return definitionNodes.map(function (proposedNode) {
                return nodeToProposalInfo(proposedNode, parentNode);
              });
            }
            if (universeHelpers.isBooleanTypeType(property.range())) {
              return [
                'false',
                'true'
              ].map(function (value) {
                return { text: value };
              });
            }
            var propertyNode = property.node && property.node();
            if (propertyNode) {
              var suggestions = _.filter(propertyNode.children(), function (child) {
                  return child.name && child.value && child.property() && universeHelpers.isEnumProperty(child.property());
                }).map(function (child) {
                  return { text: child.value() };
                });
              return suggestions;
            }
          }
        }
        return search.enumValues(property, parentNode).map(function (proposed) {
          return {
            text: proposed,
            category: categoryByRanges(proposed, parentNode && parentNode.definition(), null)
          };
        });
      }
      function isPrimitive(definition) {
        var isPrimitive = !definition.isArray() && !isObject(definition) && !definition.hasUnionInHierarchy() && definition.key() !== universeModule.Universe10.TypeDeclaration;
        return isPrimitive;
      }
      function isObject(definition) {
        return definition.isAssignableFrom(universeModule.Universe10.ObjectTypeDeclaration.name) || definition.isAssignableFrom('object');
      }
      function isArray(definition) {
        return definition.isAssignableFrom(universeModule.Universe10.ArrayTypeDeclaration.name);
      }
      function allClassesForUnion(definition) {
        var result = [];
        if (!definition || !definition.isUnion()) {
          return definition ? [definition] : result;
        }
        if (definition.left) {
          result.push(definition.left);
          return result.concat(allClassesForUnion(definition.right));
        }
      }
      function addDefineInlineProposal(rs, offset, text) {
        rs = [{
            displayText: 'Define Inline',
            text: '|\n' + leadingIndent(offset - 1, text) + '  '
          }].concat(rs);
        return rs;
      }
      function addDefineInlineProposal2(rs, offset, text) {
        rs = [{
            displayText: 'Define Inline',
            text: '\n' + leadingIndent(offset - 1, text) + '  '
          }].concat(rs);
        return rs;
      }
      function leadingIndent(pos, text) {
        var leading = '';
        while (pos > 0) {
          var ch = text[pos];
          if (ch == '\r' || ch == '\n' || ch != ' ' && ch != '-')
            break;
          leading = leading + ' ';
          pos--;
        }
        return leading;
      }
      ;
      function getProposalText(proposal) {
        if (proposal.text) {
          return proposal.text;
        }
        if (proposal.snippet) {
          return proposal.snippet;
        }
        return proposal.displayText;
      }
      function updateProposalText(proposal, textToUpdateWith) {
        if (proposal.text) {
          proposal.text = textToUpdateWith;
          return;
        }
        if (proposal.snippet) {
          proposal.snippet = textToUpdateWith;
          return;
        }
        proposal.displayText = textToUpdateWith;
      }
      function isSiblingExists(attr, siblingName) {
        var parent = attr.parent && attr.parent();
        if (!parent) {
          return false;
        }
        var propertyName = attr.name && attr.name();
        if (!propertyName) {
          return false;
        }
        var siblings = parent.attributes && parent.attributes(propertyName);
        if (!siblings) {
          return false;
        }
        if (siblings.length === 0) {
          return false;
        }
        var names = [];
        siblings.forEach(function (sibling) {
          var name = sibling.value && sibling.value() && sibling.value().valueName && sibling.value().valueName();
          if (!name) {
            return;
          }
          names.push(name);
        });
        return _.find(names, function (name) {
          return siblingName === name;
        });
      }
      function isSquareBracketExpected(attr) {
        if (!attr) {
          return false;
        }
        if (!attr.definition()) {
          return false;
        }
        if (!attr.property()) {
          return false;
        }
        if (!attr.definition().isAssignableFrom(universeModule.Universe10.TraitRef.name)) {
          return false;
        }
        return true;
      }
      function isInResourceDescription(obj) {
        var definition = obj && obj.definition ? obj.definition() : null;
        if (definition) {
          var name = definition.nameId();
          if (name === 'Api') {
            return false;
          }
          if (name === 'ResourceType' || name === 'Trait') {
            return true;
          }
          var parent = obj.parent();
          if (!parent) {
            return false;
          }
          return isInResourceDescription(parent);
        }
        return false;
      }
      var transformers = parserApi.utils.getTransformerNames();
      var addTransformers = function (proposals, prefix) {
        var result = [];
        transformers.filter(function (transformer) {
          return transformer.indexOf(prefix) === 0;
        }).forEach(function (transformer) {
          result.push({
            displayText: transformer,
            text: transformer
          });
        });
        return result.concat(proposals);
      };
      function testVal(vl, offset, text) {
        if (vl && vl.length > 0) {
          var q = vl.trim();
          if (q.indexOf('{') == 0) {
            return false;
          }
          if (q.indexOf('<') == 0) {
            return false;
          }
          if (q.indexOf('[') == 0) {
            return false;
          }
        }
        for (var i = offset; i >= 0; i--) {
          var c = text[i];
          if (c == ':') {
            return true;
          }
          if (c == '|') {
            return false;
          }
          if (c == '\'') {
            return false;
          }
          if (c == '"') {
            return false;
          }
        }
        return true;
      }
      function nodeToProposalInfo(x, c) {
        var isResourceType = false;
        var d = x.attr('description');
        var ds = '';
        if (d) {
          ds = d.value();
        } else {
          d = x.attr('usage');
          if (d) {
            ds = d.value();
          }
        }
        var tr = x.localType();
        var req = tr.allProperties().filter(function (x) {
            return x.isRequired() && !x.getAdapter(services.RAMLPropertyService).isKey();
          });
        var txt = search.qName(x, c);
        if (!universeHelpers.isAnnotationTypeType(x.definition())) {
          if (req.length > 0) {
            txt += ': {';
            txt += req.map(function (x) {
              return x.nameId() + ' : ';
            }).join(', ') + '}';
            var extra = '';
            if (universeHelpers.isResourceTypeType(x.definition())) {
              txt = '' + txt + ' }';
              extra = ' { ';
              isResourceType = true;
            }
          }
        }
        return {
          displayText: search.qName(x, c),
          snippet: txt,
          description: ds,
          extra: extra,
          isResourceType: isResourceType
        };
      }
      function examplePropertyCompletion(node, request, provider) {
        if (!search.isExampleNode(node)) {
          return [];
        }
        var contentType = search.findExampleContentType(node);
        if (!contentType)
          return [];
        var parsedExample = search.parseStructuredExample(node, contentType);
        if (!parsedExample)
          return [];
        var project = node && node.lowLevel() && node.lowLevel().unit() && node.lowLevel().unit().project();
        return getSuggestions(request, provider, findASTNodeByOffset(parsedExample, request), project);
      }
      function postProcess(providerSuggestions, request) {
        var prepared = postProcess1(providerSuggestions, request);
        var added = [];
        var result = [];
        prepared.forEach(function (item) {
          var value = suggestionValue(item);
          if (added.indexOf(value) < 0) {
            result.push(item);
            added.push(value);
          }
        });
        return result;
      }
      exports.postProcess = postProcess;
      function postProcess1(providerSuggestions, request) {
        var hasDeprecations, hasEmpty, suggestion, _i, _len;
        if (providerSuggestions == null) {
          return;
        }
        if (hasDeprecations) {
          providerSuggestions = providerSuggestions.map(function (suggestion) {
            var newSuggestion, _ref1, _ref2;
            newSuggestion = {
              text: (_ref1 = suggestion.text) != null ? _ref1 : suggestion.word,
              snippet: suggestion.snippet,
              replacementPrefix: (_ref2 = suggestion.replacementPrefix) != null ? _ref2 : suggestion.prefix,
              className: suggestion.className,
              type: suggestion.type
            };
            if (newSuggestion.rightLabelHTML == null && suggestion.renderLabelAsHtml) {
              newSuggestion.rightLabelHTML = suggestion.label;
            }
            if (newSuggestion.rightLabel == null && !suggestion.renderLabelAsHtml) {
              newSuggestion.rightLabel = suggestion.label;
            }
            return newSuggestion;
          });
        }
        hasEmpty = false;
        for (_i = 0, _len = providerSuggestions.length; _i < _len; _i++) {
          suggestion = providerSuggestions[_i];
          if (!(suggestion.snippet || suggestion.text)) {
            hasEmpty = true;
          }
          if (suggestion.replacementPrefix == null) {
            suggestion.replacementPrefix = getDefaultReplacementPrefix(request.prefix());
          }
        }
        if (hasEmpty) {
          providerSuggestions = function () {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = providerSuggestions.length; _j < _len1; _j++) {
              suggestion = providerSuggestions[_j];
              if (suggestion.snippet || suggestion.text) {
                _results.push(suggestion);
              }
            }
            return _results;
          }();
        }
        providerSuggestions = filterSuggestions(providerSuggestions, request);
        return providerSuggestions;
      }
      var fuzzaldrinProvider = require('fuzzaldrin-plus');
      function filterSuggestions(suggestions, _arg) {
        var firstCharIsMatch, i, prefix, prefixIsEmpty, results, score, suggestion, suggestionPrefix, text, _i, _len, _ref1;
        prefix = _arg.prefix();
        results = [];
        for (i = _i = 0, _len = suggestions.length; _i < _len; i = ++_i) {
          suggestion = suggestions[i];
          suggestion.sortScore = Math.max(-i / 10 + 3, 0) + 1;
          suggestion.score = null;
          text = suggestion.snippet || suggestion.text;
          suggestionPrefix = (_ref1 = suggestion.replacementPrefix) != null ? _ref1 : prefix;
          prefixIsEmpty = !suggestionPrefix || suggestionPrefix === ' ';
          firstCharIsMatch = !prefixIsEmpty && suggestionPrefix[0].toLowerCase() === text[0].toLowerCase();
          if (prefixIsEmpty) {
            results.push(suggestion);
          }
          if (firstCharIsMatch && (score = fuzzaldrinProvider.score(text, suggestionPrefix)) > 0) {
            suggestion.score = score * suggestion.sortScore;
            results.push(suggestion);
          }
        }
        results.sort(reverseSortOnScoreComparator);
        return results;
      }
      var wordPrefixRegex = /^\w+[\w-]*$/;
      function reverseSortOnScoreComparator(a, b) {
        var _ref1, _ref2;
        return ((_ref1 = b.score) != null ? _ref1 : b.sortScore) - ((_ref2 = a.score) != null ? _ref2 : a.sortScore);
      }
      ;
      function getDefaultReplacementPrefix(prefix) {
        if (wordPrefixRegex.test(prefix)) {
          return prefix;
        } else {
          return '';
        }
      }
      ;
      function suggestionValue(suggestion) {
        return suggestion && (suggestion.displayText || suggestion.text) || null;
      }
      var prefixRegex = /(\b|['"~`!@#\$%^&*\(\)\{\}\[\]=\+,\/\?>])((\w+[\w-]*)|([.:;[{(< ]+))$/;
      function getPrefix(request) {
        var line, _ref1;
        line = getLine(request);
        return ((_ref1 = prefixRegex.exec(line)) != null ? _ref1[2] : void 0) || '';
      }
      exports.getPrefix = getPrefix;
      function getLine(request) {
        var offset = request.content.getOffset();
        var text = request.content.getText();
        for (var i = offset - 1; i >= 0; i--) {
          var c = text.charAt(i);
          if (c === '\r' || c === '\n' || c === ' ' || c === '\t') {
            return text.substring(i + 1, offset);
          }
        }
        return '';
      }
      var ResolvedProvider = function () {
          function ResolvedProvider(resolver) {
            this.resolver = resolver;
            this.fsResolver = resolver;
          }
          ResolvedProvider.prototype.contentDirName = function (content) {
            return this.resolver.dirname(content.getPath());
          };
          ResolvedProvider.prototype.dirName = function (path) {
            return this.resolver.dirname(path);
          };
          ResolvedProvider.prototype.exists = function (path) {
            return this.resolver.exists(path);
          };
          ResolvedProvider.prototype.resolve = function (contextPath, relativePath) {
            return this.resolver.resolve(contextPath, relativePath);
          };
          ResolvedProvider.prototype.isDirectory = function (path) {
            return this.resolver.isDirectory(path);
          };
          ResolvedProvider.prototype.isDirectoryAsync = function (path) {
            return this.resolver.isDirectoryAsync(path);
          };
          ResolvedProvider.prototype.readDir = function (path) {
            return this.resolver.list(path);
          };
          ResolvedProvider.prototype.existsAsync = function (path) {
            return this.resolver.existsAsync(path);
          };
          ResolvedProvider.prototype.readDirAsync = function (path) {
            return this.resolver.listAsync(path);
          };
          return ResolvedProvider;
        }();
      function getContentProvider(resolver) {
        return new ResolvedProvider(resolver);
      }
      exports.getContentProvider = getContentProvider;
    },
    {
      '../resources/categories.json': 11,
      'fuzzaldrin-plus': 2,
      'underscore': 12
    }
  ],
  10: [
    function (require, module, exports) {
      'use strict';
      var completionProvider = require('./completionProvider');
      var _editorStateProvider = null;
      var _astProvider = null;
      /**
 * Sets default editor state provider
 * @param editorStateProvider
 */
      function setDefaultEditorStateProvider(editorStateProvider) {
        _editorStateProvider = editorStateProvider;
      }
      exports.setDefaultEditorStateProvider = setDefaultEditorStateProvider;
      /**
 * Sets default AST provider
 * @param astProvider
 */
      function setDefaultASTProvider(astProvider) {
        _astProvider = astProvider;
      }
      exports.setDefaultASTProvider = setDefaultASTProvider;
      var _fsProvider = null;
      /**
 * Sets default FS provider.
 * @param fsProvider
 */
      function setDefaultFSProvider(fsProvider) {
        _fsProvider = fsProvider;
      }
      exports.setDefaultFSProvider = setDefaultFSProvider;
      /**
 * Finds suggestions. Requires setDefaultEditorStateProvider and setDefaultFSProvider methods to be called first.
 * @returns {Suggestion[]} - list of suggestions
 */
      function suggestDefault() {
        return completionProvider.suggest(_editorStateProvider, _fsProvider);
      }
      exports.suggestDefault = suggestDefault;
      /**
 * Finds suggestions.
 * @param editorState - editor state.
 * @param fsProvider - file system data provider.
 * @returns {Suggestion[]} - list of suggestions
 */
      function suggest(editorStateProvider, fsProvider) {
        return completionProvider.suggest(editorStateProvider, fsProvider);
      }
      exports.suggest = suggest;
      /**
 * Finds suggestions.
 * @param editorState - editor state.
 * @param fsProvider - file system data provider.
 * @returns {Promise<Suggestion[]>}
 */
      function suggestAsync(editorState, fsProvider) {
        return completionProvider.suggestAsync(editorState, fsProvider);
      }
      exports.suggestAsync = suggestAsync;
      /**
 * Converts extended fs resolver to FS provider.
 * @param resolver
 * @returns {IFSProvider}
 */
      function getContentProvider(resolver) {
        return completionProvider.getContentProvider(resolver);
      }
      exports.getContentProvider = getContentProvider;
    },
    { './completionProvider': 9 }
  ],
  11: [
    function (require, module, exports) {
      module.exports = {
        'docs': {
          'description': {
            'is': [
              'Universe10.MarkdownString',
              'Universe08.MarkdownString'
            ]
          },
          'displayName': {
            'parentIs': [
              'Universe10.ExampleSpec',
              'Universe10.TypeDeclaration',
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.AbstractSecurityScheme',
              'Universe10.ResourceType',
              'Universe10.Resource',
              'Universe08.Parameter',
              'Universe08.Resource',
              'Universe08.ResourceType',
              'Universe08.Trait'
            ]
          },
          'example': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter',
              'Universe08.BodyLike',
              'Universe08.XMLBody',
              'Universe08.JSONBody'
            ]
          },
          'usage': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe10.Trait',
              'Universe10.ResourceType',
              'Universe08.ResourceType',
              'Universe08.Trait'
            ]
          },
          'content': {
            'parentIs': [
              'Universe10.DocumentationItem',
              'Universe08.DocumentationItem'
            ]
          },
          'documentation': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'title': {
            'parentIs': [
              'Universe10.DocumentationItem',
              'Universe08.DocumentationItem'
            ]
          }
        },
        'parameters': {
          'default': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'enum': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'maximum': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'minimum': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'maxLength': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'minLength': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'required': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.Parameter'
            ]
          },
          'baseUriParameters': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api',
              'Universe08.Resource',
              'Universe08.ResourceType',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'uriParameters': {
            'parentIs': [
              'Universe10.ResourceType',
              'Universe10.ResourceBase',
              'Universe10.Resource',
              'Universe08.Api',
              'Universe08.Resource',
              'Universe08.ResourceType'
            ]
          },
          'headers': {
            'parentIs': [
              'Universe10.Response',
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.Operation',
              'Universe10.AbstractSecurityScheme',
              'Universe08.Response',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'queryParameters': {
            'parentIs': [
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.Operation',
              'Universe10.AbstractSecurityScheme',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'type': { 'parentIs': ['Universe08.Parameter'] }
        },
        'schemas': {
          'schema': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike',
              'Universe08.XMLBody',
              'Universe08.JSONBody'
            ]
          },
          'schemas': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          }
        },
        'root': {
          'baseUri': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'mediaType': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'protocols': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe08.Api',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'version': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'title': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          }
        },
        'responses': {
          'responses': {
            'parentIs': [
              'Universe10.Trait',
              'Universe10.MethodBase',
              'Universe10.Operation',
              'Universe10.AbstractSecurityScheme',
              'Universe08.MethodBase',
              'Universe08.Trait',
              'Universe08.AbstractSecurityScheme'
            ]
          }
        },
        'response': {
          'body': {
            'parentIs': [
              'Universe10.Response',
              'Universe08.Response'
            ]
          }
        },
        'security': {
          'securedBy': {
            'is': [
              'Universe10.SecuritySchemeRef',
              'Universe08.SecuritySchemeRef'
            ]
          },
          'securitySchemes': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'accessTokenUri': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'authorizationGrants': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'authorizationUri': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'requestTokenUri': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'scopes': {
            'parentIs': [
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'describedBy': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'settings': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'OAuth 1.0': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'OAuth 2.0': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'Basic Authentication': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'Digest Authentication': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          },
          'type': {
            'parentIs': [
              'Universe10.AbstractSecurityScheme',
              'Universe08.AbstractSecurityScheme'
            ]
          }
        },
        'types and traits': {
          'type': {
            'parentIs': [
              'Universe10.ResourceType',
              'Universe10.ResourceBase',
              'Universe10.Resource',
              'Universe08.Resource',
              'Universe08.ResourceType'
            ]
          },
          'is': {
            'is': [
              'Universe10.TraitRef',
              'Universe08.TraitRef'
            ]
          },
          'resourceTypes': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          },
          'traits': {
            'parentIs': [
              'Universe10.Library',
              'Universe10.LibraryBase',
              'Universe10.Api',
              'Universe10.Overlay',
              'Universe10.Extension',
              'Universe08.Api'
            ]
          }
        },
        'methods': {
          'options': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'get': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'head': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'post': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'put': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'delete': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'trace': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'connect': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'patch': {
            'is': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          }
        },
        'protocols': {
          'HTTP': {
            'parentIs': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          },
          'HTTPS': {
            'parentIs': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          }
        },
        'body': {
          'application/json': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'application/x-www-form-urlencoded': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'application/xml': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'multipart/form-data': {
            'parentIs': [
              'Universe10.TypeDeclaration',
              'Universe08.BodyLike'
            ]
          },
          'body': {
            'parentIs': [
              'Universe10.MethodBase',
              'Universe08.MethodBase'
            ]
          }
        }
      };
    },
    {}
  ],
  12: [
    function (require, module, exports) {
      //     Underscore.js 1.8.3
      //     http://underscorejs.org
      //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      //     Underscore may be freely distributed under the MIT license.
      (function () {
        // Baseline setup
        // --------------
        // Establish the root object, `window` in the browser, or `exports` on the server.
        var root = this;
        // Save the previous value of the `_` variable.
        var previousUnderscore = root._;
        // Save bytes in the minified (but not gzipped) version:
        var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
        // Create quick reference variables for speed access to core prototypes.
        var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
        // All **ECMAScript 5** native function implementations that we hope to use
        // are declared here.
        var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
        // Naked function reference for surrogate-prototype-swapping.
        var Ctor = function () {
        };
        // Create a safe reference to the Underscore object for use below.
        var _ = function (obj) {
          if (obj instanceof _)
            return obj;
          if (!(this instanceof _))
            return new _(obj);
          this._wrapped = obj;
        };
        // Export the Underscore object for **Node.js**, with
        // backwards-compatibility for the old `require()` API. If we're in
        // the browser, add `_` as a global object.
        if (typeof exports !== 'undefined') {
          if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
          }
          exports._ = _;
        } else {
          root._ = _;
        }
        // Current version.
        _.VERSION = '1.8.3';
        // Internal function that returns an efficient (for current engines) version
        // of the passed-in callback, to be repeatedly applied in other Underscore
        // functions.
        var optimizeCb = function (func, context, argCount) {
          if (context === void 0)
            return func;
          switch (argCount == null ? 3 : argCount) {
          case 1:
            return function (value) {
              return func.call(context, value);
            };
          case 2:
            return function (value, other) {
              return func.call(context, value, other);
            };
          case 3:
            return function (value, index, collection) {
              return func.call(context, value, index, collection);
            };
          case 4:
            return function (accumulator, value, index, collection) {
              return func.call(context, accumulator, value, index, collection);
            };
          }
          return function () {
            return func.apply(context, arguments);
          };
        };
        // A mostly-internal function to generate callbacks that can be applied
        // to each element in a collection, returning the desired result — either
        // identity, an arbitrary callback, a property matcher, or a property accessor.
        var cb = function (value, context, argCount) {
          if (value == null)
            return _.identity;
          if (_.isFunction(value))
            return optimizeCb(value, context, argCount);
          if (_.isObject(value))
            return _.matcher(value);
          return _.property(value);
        };
        _.iteratee = function (value, context) {
          return cb(value, context, Infinity);
        };
        // An internal function for creating assigner functions.
        var createAssigner = function (keysFunc, undefinedOnly) {
          return function (obj) {
            var length = arguments.length;
            if (length < 2 || obj == null)
              return obj;
            for (var index = 1; index < length; index++) {
              var source = arguments[index], keys = keysFunc(source), l = keys.length;
              for (var i = 0; i < l; i++) {
                var key = keys[i];
                if (!undefinedOnly || obj[key] === void 0)
                  obj[key] = source[key];
              }
            }
            return obj;
          };
        };
        // An internal function for creating a new object that inherits from another.
        var baseCreate = function (prototype) {
          if (!_.isObject(prototype))
            return {};
          if (nativeCreate)
            return nativeCreate(prototype);
          Ctor.prototype = prototype;
          var result = new Ctor();
          Ctor.prototype = null;
          return result;
        };
        var property = function (key) {
          return function (obj) {
            return obj == null ? void 0 : obj[key];
          };
        };
        // Helper for collection methods to determine whether a collection
        // should be iterated as an array or as an object
        // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
        // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
        var getLength = property('length');
        var isArrayLike = function (collection) {
          var length = getLength(collection);
          return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
        };
        // Collection Functions
        // --------------------
        // The cornerstone, an `each` implementation, aka `forEach`.
        // Handles raw objects in addition to array-likes. Treats all
        // sparse array-likes as if they were dense.
        _.each = _.forEach = function (obj, iteratee, context) {
          iteratee = optimizeCb(iteratee, context);
          var i, length;
          if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; i++) {
              iteratee(obj[i], i, obj);
            }
          } else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; i < length; i++) {
              iteratee(obj[keys[i]], keys[i], obj);
            }
          }
          return obj;
        };
        // Return the results of applying the iteratee to each element.
        _.map = _.collect = function (obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
          for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        };
        // Create a reducing function iterating left or right.
        function createReduce(dir) {
          // Optimized iterator function as using arguments.length
          // in the main function will deoptimize the, see #1991.
          function iterator(obj, iteratee, memo, keys, index, length) {
            for (; index >= 0 && index < length; index += dir) {
              var currentKey = keys ? keys[index] : index;
              memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
          }
          return function (obj, iteratee, memo, context) {
            iteratee = optimizeCb(iteratee, context, 4);
            var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
            // Determine the initial value if none is provided.
            if (arguments.length < 3) {
              memo = obj[keys ? keys[index] : index];
              index += dir;
            }
            return iterator(obj, iteratee, memo, keys, index, length);
          };
        }
        // **Reduce** builds up a single result from a list of values, aka `inject`,
        // or `foldl`.
        _.reduce = _.foldl = _.inject = createReduce(1);
        // The right-associative version of reduce, also known as `foldr`.
        _.reduceRight = _.foldr = createReduce(-1);
        // Return the first value which passes a truth test. Aliased as `detect`.
        _.find = _.detect = function (obj, predicate, context) {
          var key;
          if (isArrayLike(obj)) {
            key = _.findIndex(obj, predicate, context);
          } else {
            key = _.findKey(obj, predicate, context);
          }
          if (key !== void 0 && key !== -1)
            return obj[key];
        };
        // Return all the elements that pass a truth test.
        // Aliased as `select`.
        _.filter = _.select = function (obj, predicate, context) {
          var results = [];
          predicate = cb(predicate, context);
          _.each(obj, function (value, index, list) {
            if (predicate(value, index, list))
              results.push(value);
          });
          return results;
        };
        // Return all the elements for which a truth test fails.
        _.reject = function (obj, predicate, context) {
          return _.filter(obj, _.negate(cb(predicate)), context);
        };
        // Determine whether all of the elements match a truth test.
        // Aliased as `all`.
        _.every = _.all = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj))
              return false;
          }
          return true;
        };
        // Determine if at least one element in the object matches a truth test.
        // Aliased as `any`.
        _.some = _.any = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj))
              return true;
          }
          return false;
        };
        // Determine if the array or object contains a given item (using `===`).
        // Aliased as `includes` and `include`.
        _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
          if (!isArrayLike(obj))
            obj = _.values(obj);
          if (typeof fromIndex != 'number' || guard)
            fromIndex = 0;
          return _.indexOf(obj, item, fromIndex) >= 0;
        };
        // Invoke a method (with arguments) on every item in a collection.
        _.invoke = function (obj, method) {
          var args = slice.call(arguments, 2);
          var isFunc = _.isFunction(method);
          return _.map(obj, function (value) {
            var func = isFunc ? method : value[method];
            return func == null ? func : func.apply(value, args);
          });
        };
        // Convenience version of a common use case of `map`: fetching a property.
        _.pluck = function (obj, key) {
          return _.map(obj, _.property(key));
        };
        // Convenience version of a common use case of `filter`: selecting only objects
        // containing specific `key:value` pairs.
        _.where = function (obj, attrs) {
          return _.filter(obj, _.matcher(attrs));
        };
        // Convenience version of a common use case of `find`: getting the first object
        // containing specific `key:value` pairs.
        _.findWhere = function (obj, attrs) {
          return _.find(obj, _.matcher(attrs));
        };
        // Return the maximum element (or element-based computation).
        _.max = function (obj, iteratee, context) {
          var result = -Infinity, lastComputed = -Infinity, value, computed;
          if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value > result) {
                result = value;
              }
            }
          } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function (value, index, list) {
              computed = iteratee(value, index, list);
              if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = value;
                lastComputed = computed;
              }
            });
          }
          return result;
        };
        // Return the minimum element (or element-based computation).
        _.min = function (obj, iteratee, context) {
          var result = Infinity, lastComputed = Infinity, value, computed;
          if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value < result) {
                result = value;
              }
            }
          } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function (value, index, list) {
              computed = iteratee(value, index, list);
              if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = value;
                lastComputed = computed;
              }
            });
          }
          return result;
        };
        // Shuffle a collection, using the modern version of the
        // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
        _.shuffle = function (obj) {
          var set = isArrayLike(obj) ? obj : _.values(obj);
          var length = set.length;
          var shuffled = Array(length);
          for (var index = 0, rand; index < length; index++) {
            rand = _.random(0, index);
            if (rand !== index)
              shuffled[index] = shuffled[rand];
            shuffled[rand] = set[index];
          }
          return shuffled;
        };
        // Sample **n** random values from a collection.
        // If **n** is not specified, returns a single random element.
        // The internal `guard` argument allows it to work with `map`.
        _.sample = function (obj, n, guard) {
          if (n == null || guard) {
            if (!isArrayLike(obj))
              obj = _.values(obj);
            return obj[_.random(obj.length - 1)];
          }
          return _.shuffle(obj).slice(0, Math.max(0, n));
        };
        // Sort the object's values by a criterion produced by an iteratee.
        _.sortBy = function (obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          return _.pluck(_.map(obj, function (value, index, list) {
            return {
              value: value,
              index: index,
              criteria: iteratee(value, index, list)
            };
          }).sort(function (left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
              if (a > b || a === void 0)
                return 1;
              if (a < b || b === void 0)
                return -1;
            }
            return left.index - right.index;
          }), 'value');
        };
        // An internal function used for aggregate "group by" operations.
        var group = function (behavior) {
          return function (obj, iteratee, context) {
            var result = {};
            iteratee = cb(iteratee, context);
            _.each(obj, function (value, index) {
              var key = iteratee(value, index, obj);
              behavior(result, value, key);
            });
            return result;
          };
        };
        // Groups the object's values by a criterion. Pass either a string attribute
        // to group by, or a function that returns the criterion.
        _.groupBy = group(function (result, value, key) {
          if (_.has(result, key))
            result[key].push(value);
          else
            result[key] = [value];
        });
        // Indexes the object's values by a criterion, similar to `groupBy`, but for
        // when you know that your index values will be unique.
        _.indexBy = group(function (result, value, key) {
          result[key] = value;
        });
        // Counts instances of an object that group by a certain criterion. Pass
        // either a string attribute to count by, or a function that returns the
        // criterion.
        _.countBy = group(function (result, value, key) {
          if (_.has(result, key))
            result[key]++;
          else
            result[key] = 1;
        });
        // Safely create a real, live array from anything iterable.
        _.toArray = function (obj) {
          if (!obj)
            return [];
          if (_.isArray(obj))
            return slice.call(obj);
          if (isArrayLike(obj))
            return _.map(obj, _.identity);
          return _.values(obj);
        };
        // Return the number of elements in an object.
        _.size = function (obj) {
          if (obj == null)
            return 0;
          return isArrayLike(obj) ? obj.length : _.keys(obj).length;
        };
        // Split a collection into two arrays: one whose elements all satisfy the given
        // predicate, and one whose elements all do not satisfy the predicate.
        _.partition = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var pass = [], fail = [];
          _.each(obj, function (value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
          });
          return [
            pass,
            fail
          ];
        };
        // Array Functions
        // ---------------
        // Get the first element of an array. Passing **n** will return the first N
        // values in the array. Aliased as `head` and `take`. The **guard** check
        // allows it to work with `_.map`.
        _.first = _.head = _.take = function (array, n, guard) {
          if (array == null)
            return void 0;
          if (n == null || guard)
            return array[0];
          return _.initial(array, array.length - n);
        };
        // Returns everything but the last entry of the array. Especially useful on
        // the arguments object. Passing **n** will return all the values in
        // the array, excluding the last N.
        _.initial = function (array, n, guard) {
          return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
        };
        // Get the last element of an array. Passing **n** will return the last N
        // values in the array.
        _.last = function (array, n, guard) {
          if (array == null)
            return void 0;
          if (n == null || guard)
            return array[array.length - 1];
          return _.rest(array, Math.max(0, array.length - n));
        };
        // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
        // Especially useful on the arguments object. Passing an **n** will return
        // the rest N values in the array.
        _.rest = _.tail = _.drop = function (array, n, guard) {
          return slice.call(array, n == null || guard ? 1 : n);
        };
        // Trim out all falsy values from an array.
        _.compact = function (array) {
          return _.filter(array, _.identity);
        };
        // Internal implementation of a recursive `flatten` function.
        var flatten = function (input, shallow, strict, startIndex) {
          var output = [], idx = 0;
          for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
            var value = input[i];
            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
              //flatten current level of array or arguments object
              if (!shallow)
                value = flatten(value, shallow, strict);
              var j = 0, len = value.length;
              output.length += len;
              while (j < len) {
                output[idx++] = value[j++];
              }
            } else if (!strict) {
              output[idx++] = value;
            }
          }
          return output;
        };
        // Flatten out an array, either recursively (by default), or just one level.
        _.flatten = function (array, shallow) {
          return flatten(array, shallow, false);
        };
        // Return a version of the array that does not contain the specified value(s).
        _.without = function (array) {
          return _.difference(array, slice.call(arguments, 1));
        };
        // Produce a duplicate-free version of the array. If the array has already
        // been sorted, you have the option of using a faster algorithm.
        // Aliased as `unique`.
        _.uniq = _.unique = function (array, isSorted, iteratee, context) {
          if (!_.isBoolean(isSorted)) {
            context = iteratee;
            iteratee = isSorted;
            isSorted = false;
          }
          if (iteratee != null)
            iteratee = cb(iteratee, context);
          var result = [];
          var seen = [];
          for (var i = 0, length = getLength(array); i < length; i++) {
            var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
            if (isSorted) {
              if (!i || seen !== computed)
                result.push(value);
              seen = computed;
            } else if (iteratee) {
              if (!_.contains(seen, computed)) {
                seen.push(computed);
                result.push(value);
              }
            } else if (!_.contains(result, value)) {
              result.push(value);
            }
          }
          return result;
        };
        // Produce an array that contains the union: each distinct element from all of
        // the passed-in arrays.
        _.union = function () {
          return _.uniq(flatten(arguments, true, true));
        };
        // Produce an array that contains every item shared between all the
        // passed-in arrays.
        _.intersection = function (array) {
          var result = [];
          var argsLength = arguments.length;
          for (var i = 0, length = getLength(array); i < length; i++) {
            var item = array[i];
            if (_.contains(result, item))
              continue;
            for (var j = 1; j < argsLength; j++) {
              if (!_.contains(arguments[j], item))
                break;
            }
            if (j === argsLength)
              result.push(item);
          }
          return result;
        };
        // Take the difference between one array and a number of other arrays.
        // Only the elements present in just the first array will remain.
        _.difference = function (array) {
          var rest = flatten(arguments, true, true, 1);
          return _.filter(array, function (value) {
            return !_.contains(rest, value);
          });
        };
        // Zip together multiple lists into a single array -- elements that share
        // an index go together.
        _.zip = function () {
          return _.unzip(arguments);
        };
        // Complement of _.zip. Unzip accepts an array of arrays and groups
        // each array's elements on shared indices
        _.unzip = function (array) {
          var length = array && _.max(array, getLength).length || 0;
          var result = Array(length);
          for (var index = 0; index < length; index++) {
            result[index] = _.pluck(array, index);
          }
          return result;
        };
        // Converts lists into objects. Pass either a single array of `[key, value]`
        // pairs, or two parallel arrays of the same length -- one of keys, and one of
        // the corresponding values.
        _.object = function (list, values) {
          var result = {};
          for (var i = 0, length = getLength(list); i < length; i++) {
            if (values) {
              result[list[i]] = values[i];
            } else {
              result[list[i][0]] = list[i][1];
            }
          }
          return result;
        };
        // Generator function to create the findIndex and findLastIndex functions
        function createPredicateIndexFinder(dir) {
          return function (array, predicate, context) {
            predicate = cb(predicate, context);
            var length = getLength(array);
            var index = dir > 0 ? 0 : length - 1;
            for (; index >= 0 && index < length; index += dir) {
              if (predicate(array[index], index, array))
                return index;
            }
            return -1;
          };
        }
        // Returns the first index on an array-like that passes a predicate test
        _.findIndex = createPredicateIndexFinder(1);
        _.findLastIndex = createPredicateIndexFinder(-1);
        // Use a comparator function to figure out the smallest index at which
        // an object should be inserted so as to maintain order. Uses binary search.
        _.sortedIndex = function (array, obj, iteratee, context) {
          iteratee = cb(iteratee, context, 1);
          var value = iteratee(obj);
          var low = 0, high = getLength(array);
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (iteratee(array[mid]) < value)
              low = mid + 1;
            else
              high = mid;
          }
          return low;
        };
        // Generator function to create the indexOf and lastIndexOf functions
        function createIndexFinder(dir, predicateFind, sortedIndex) {
          return function (array, item, idx) {
            var i = 0, length = getLength(array);
            if (typeof idx == 'number') {
              if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
              } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
              }
            } else if (sortedIndex && idx && length) {
              idx = sortedIndex(array, item);
              return array[idx] === item ? idx : -1;
            }
            if (item !== item) {
              idx = predicateFind(slice.call(array, i, length), _.isNaN);
              return idx >= 0 ? idx + i : -1;
            }
            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
              if (array[idx] === item)
                return idx;
            }
            return -1;
          };
        }
        // Return the position of the first occurrence of an item in an array,
        // or -1 if the item is not included in the array.
        // If the array is large and already in sort order, pass `true`
        // for **isSorted** to use binary search.
        _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
        _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        _.range = function (start, stop, step) {
          if (stop == null) {
            stop = start || 0;
            start = 0;
          }
          step = step || 1;
          var length = Math.max(Math.ceil((stop - start) / step), 0);
          var range = Array(length);
          for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
          }
          return range;
        };
        // Function (ahem) Functions
        // ------------------
        // Determines whether to execute a function as a constructor
        // or a normal function with the provided arguments
        var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {
          if (!(callingContext instanceof boundFunc))
            return sourceFunc.apply(context, args);
          var self = baseCreate(sourceFunc.prototype);
          var result = sourceFunc.apply(self, args);
          if (_.isObject(result))
            return result;
          return self;
        };
        // Create a function bound to a given object (assigning `this`, and arguments,
        // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
        // available.
        _.bind = function (func, context) {
          if (nativeBind && func.bind === nativeBind)
            return nativeBind.apply(func, slice.call(arguments, 1));
          if (!_.isFunction(func))
            throw new TypeError('Bind must be called on a function');
          var args = slice.call(arguments, 2);
          var bound = function () {
            return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
          };
          return bound;
        };
        // Partially apply a function by creating a version that has had some of its
        // arguments pre-filled, without changing its dynamic `this` context. _ acts
        // as a placeholder, allowing any combination of arguments to be pre-filled.
        _.partial = function (func) {
          var boundArgs = slice.call(arguments, 1);
          var bound = function () {
            var position = 0, length = boundArgs.length;
            var args = Array(length);
            for (var i = 0; i < length; i++) {
              args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
            }
            while (position < arguments.length)
              args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
          };
          return bound;
        };
        // Bind a number of an object's methods to that object. Remaining arguments
        // are the method names to be bound. Useful for ensuring that all callbacks
        // defined on an object belong to it.
        _.bindAll = function (obj) {
          var i, length = arguments.length, key;
          if (length <= 1)
            throw new Error('bindAll must be passed function names');
          for (i = 1; i < length; i++) {
            key = arguments[i];
            obj[key] = _.bind(obj[key], obj);
          }
          return obj;
        };
        // Memoize an expensive function by storing its results.
        _.memoize = function (func, hasher) {
          var memoize = function (key) {
            var cache = memoize.cache;
            var address = '' + (hasher ? hasher.apply(this, arguments) : key);
            if (!_.has(cache, address))
              cache[address] = func.apply(this, arguments);
            return cache[address];
          };
          memoize.cache = {};
          return memoize;
        };
        // Delays a function for the given number of milliseconds, and then calls
        // it with the arguments supplied.
        _.delay = function (func, wait) {
          var args = slice.call(arguments, 2);
          return setTimeout(function () {
            return func.apply(null, args);
          }, wait);
        };
        // Defers a function, scheduling it to run after the current call stack has
        // cleared.
        _.defer = _.partial(_.delay, _, 1);
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _.throttle = function (func, wait, options) {
          var context, args, result;
          var timeout = null;
          var previous = 0;
          if (!options)
            options = {};
          var later = function () {
            previous = options.leading === false ? 0 : _.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout)
              context = args = null;
          };
          return function () {
            var now = _.now();
            if (!previous && options.leading === false)
              previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
              previous = now;
              result = func.apply(context, args);
              if (!timeout)
                context = args = null;
            } else if (!timeout && options.trailing !== false) {
              timeout = setTimeout(later, remaining);
            }
            return result;
          };
        };
        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds. If `immediate` is passed, trigger the function on the
        // leading edge, instead of the trailing.
        _.debounce = function (func, wait, immediate) {
          var timeout, args, context, timestamp, result;
          var later = function () {
            var last = _.now() - timestamp;
            if (last < wait && last >= 0) {
              timeout = setTimeout(later, wait - last);
            } else {
              timeout = null;
              if (!immediate) {
                result = func.apply(context, args);
                if (!timeout)
                  context = args = null;
              }
            }
          };
          return function () {
            context = this;
            args = arguments;
            timestamp = _.now();
            var callNow = immediate && !timeout;
            if (!timeout)
              timeout = setTimeout(later, wait);
            if (callNow) {
              result = func.apply(context, args);
              context = args = null;
            }
            return result;
          };
        };
        // Returns the first function passed as an argument to the second,
        // allowing you to adjust arguments, run code before and after, and
        // conditionally execute the original function.
        _.wrap = function (func, wrapper) {
          return _.partial(wrapper, func);
        };
        // Returns a negated version of the passed-in predicate.
        _.negate = function (predicate) {
          return function () {
            return !predicate.apply(this, arguments);
          };
        };
        // Returns a function that is the composition of a list of functions, each
        // consuming the return value of the function that follows.
        _.compose = function () {
          var args = arguments;
          var start = args.length - 1;
          return function () {
            var i = start;
            var result = args[start].apply(this, arguments);
            while (i--)
              result = args[i].call(this, result);
            return result;
          };
        };
        // Returns a function that will only be executed on and after the Nth call.
        _.after = function (times, func) {
          return function () {
            if (--times < 1) {
              return func.apply(this, arguments);
            }
          };
        };
        // Returns a function that will only be executed up to (but not including) the Nth call.
        _.before = function (times, func) {
          var memo;
          return function () {
            if (--times > 0) {
              memo = func.apply(this, arguments);
            }
            if (times <= 1)
              func = null;
            return memo;
          };
        };
        // Returns a function that will be executed at most one time, no matter how
        // often you call it. Useful for lazy initialization.
        _.once = _.partial(_.before, 2);
        // Object Functions
        // ----------------
        // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
          ];
        function collectNonEnumProps(obj, keys) {
          var nonEnumIdx = nonEnumerableProps.length;
          var constructor = obj.constructor;
          var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
          // Constructor is a special case.
          var prop = 'constructor';
          if (_.has(obj, prop) && !_.contains(keys, prop))
            keys.push(prop);
          while (nonEnumIdx--) {
            prop = nonEnumerableProps[nonEnumIdx];
            if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
              keys.push(prop);
            }
          }
        }
        // Retrieve the names of an object's own properties.
        // Delegates to **ECMAScript 5**'s native `Object.keys`
        _.keys = function (obj) {
          if (!_.isObject(obj))
            return [];
          if (nativeKeys)
            return nativeKeys(obj);
          var keys = [];
          for (var key in obj)
            if (_.has(obj, key))
              keys.push(key);
          // Ahem, IE < 9.
          if (hasEnumBug)
            collectNonEnumProps(obj, keys);
          return keys;
        };
        // Retrieve all the property names of an object.
        _.allKeys = function (obj) {
          if (!_.isObject(obj))
            return [];
          var keys = [];
          for (var key in obj)
            keys.push(key);
          // Ahem, IE < 9.
          if (hasEnumBug)
            collectNonEnumProps(obj, keys);
          return keys;
        };
        // Retrieve the values of an object's properties.
        _.values = function (obj) {
          var keys = _.keys(obj);
          var length = keys.length;
          var values = Array(length);
          for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
          }
          return values;
        };
        // Returns the results of applying the iteratee to each element of the object
        // In contrast to _.map it returns an object
        _.mapObject = function (obj, iteratee, context) {
          iteratee = cb(iteratee, context);
          var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
          for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        };
        // Convert an object into a list of `[key, value]` pairs.
        _.pairs = function (obj) {
          var keys = _.keys(obj);
          var length = keys.length;
          var pairs = Array(length);
          for (var i = 0; i < length; i++) {
            pairs[i] = [
              keys[i],
              obj[keys[i]]
            ];
          }
          return pairs;
        };
        // Invert the keys and values of an object. The values must be serializable.
        _.invert = function (obj) {
          var result = {};
          var keys = _.keys(obj);
          for (var i = 0, length = keys.length; i < length; i++) {
            result[obj[keys[i]]] = keys[i];
          }
          return result;
        };
        // Return a sorted list of the function names available on the object.
        // Aliased as `methods`
        _.functions = _.methods = function (obj) {
          var names = [];
          for (var key in obj) {
            if (_.isFunction(obj[key]))
              names.push(key);
          }
          return names.sort();
        };
        // Extend a given object with all the properties in passed-in object(s).
        _.extend = createAssigner(_.allKeys);
        // Assigns a given object with all the own properties in the passed-in object(s)
        // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
        _.extendOwn = _.assign = createAssigner(_.keys);
        // Returns the first key on an object that passes a predicate test
        _.findKey = function (obj, predicate, context) {
          predicate = cb(predicate, context);
          var keys = _.keys(obj), key;
          for (var i = 0, length = keys.length; i < length; i++) {
            key = keys[i];
            if (predicate(obj[key], key, obj))
              return key;
          }
        };
        // Return a copy of the object only containing the whitelisted properties.
        _.pick = function (object, oiteratee, context) {
          var result = {}, obj = object, iteratee, keys;
          if (obj == null)
            return result;
          if (_.isFunction(oiteratee)) {
            keys = _.allKeys(obj);
            iteratee = optimizeCb(oiteratee, context);
          } else {
            keys = flatten(arguments, false, false, 1);
            iteratee = function (value, key, obj) {
              return key in obj;
            };
            obj = Object(obj);
          }
          for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (iteratee(value, key, obj))
              result[key] = value;
          }
          return result;
        };
        // Return a copy of the object without the blacklisted properties.
        _.omit = function (obj, iteratee, context) {
          if (_.isFunction(iteratee)) {
            iteratee = _.negate(iteratee);
          } else {
            var keys = _.map(flatten(arguments, false, false, 1), String);
            iteratee = function (value, key) {
              return !_.contains(keys, key);
            };
          }
          return _.pick(obj, iteratee, context);
        };
        // Fill in a given object with default properties.
        _.defaults = createAssigner(_.allKeys, true);
        // Creates an object that inherits from the given prototype object.
        // If additional properties are provided then they will be added to the
        // created object.
        _.create = function (prototype, props) {
          var result = baseCreate(prototype);
          if (props)
            _.extendOwn(result, props);
          return result;
        };
        // Create a (shallow-cloned) duplicate of an object.
        _.clone = function (obj) {
          if (!_.isObject(obj))
            return obj;
          return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
        };
        // Invokes interceptor with the obj, and then returns obj.
        // The primary purpose of this method is to "tap into" a method chain, in
        // order to perform operations on intermediate results within the chain.
        _.tap = function (obj, interceptor) {
          interceptor(obj);
          return obj;
        };
        // Returns whether an object has a given set of `key:value` pairs.
        _.isMatch = function (object, attrs) {
          var keys = _.keys(attrs), length = keys.length;
          if (object == null)
            return !length;
          var obj = Object(object);
          for (var i = 0; i < length; i++) {
            var key = keys[i];
            if (attrs[key] !== obj[key] || !(key in obj))
              return false;
          }
          return true;
        };
        // Internal recursive comparison function for `isEqual`.
        var eq = function (a, b, aStack, bStack) {
          // Identical objects are equal. `0 === -0`, but they aren't identical.
          // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
          if (a === b)
            return a !== 0 || 1 / a === 1 / b;
          // A strict comparison is necessary because `null == undefined`.
          if (a == null || b == null)
            return a === b;
          // Unwrap any wrapped objects.
          if (a instanceof _)
            a = a._wrapped;
          if (b instanceof _)
            b = b._wrapped;
          // Compare `[[Class]]` names.
          var className = toString.call(a);
          if (className !== toString.call(b))
            return false;
          switch (className) {
          // Strings, numbers, regular expressions, dates, and booleans are compared by value.
          case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a)
              return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
          }
          var areArrays = className === '[object Array]';
          if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object')
              return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
              return false;
            }
          }
          // Assume equality for cyclic structures. The algorithm for detecting cyclic
          // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
          // Initializing stack of traversed objects.
          // It's done here since we only need them for objects and arrays comparison.
          aStack = aStack || [];
          bStack = bStack || [];
          var length = aStack.length;
          while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a)
              return bStack[length] === b;
          }
          // Add the first object to the stack of traversed objects.
          aStack.push(a);
          bStack.push(b);
          // Recursively compare objects and arrays.
          if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length)
              return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
              if (!eq(a[length], b[length], aStack, bStack))
                return false;
            }
          } else {
            // Deep compare objects.
            var keys = _.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (_.keys(b).length !== length)
              return false;
            while (length--) {
              // Deep compare each member
              key = keys[length];
              if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
                return false;
            }
          }
          // Remove the first object from the stack of traversed objects.
          aStack.pop();
          bStack.pop();
          return true;
        };
        // Perform a deep comparison to check if two objects are equal.
        _.isEqual = function (a, b) {
          return eq(a, b);
        };
        // Is a given array, string, or object empty?
        // An "empty" object has no enumerable own-properties.
        _.isEmpty = function (obj) {
          if (obj == null)
            return true;
          if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
            return obj.length === 0;
          return _.keys(obj).length === 0;
        };
        // Is a given value a DOM element?
        _.isElement = function (obj) {
          return !!(obj && obj.nodeType === 1);
        };
        // Is a given value an array?
        // Delegates to ECMA5's native Array.isArray
        _.isArray = nativeIsArray || function (obj) {
          return toString.call(obj) === '[object Array]';
        };
        // Is a given variable an object?
        _.isObject = function (obj) {
          var type = typeof obj;
          return type === 'function' || type === 'object' && !!obj;
        };
        // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
        _.each([
          'Arguments',
          'Function',
          'String',
          'Number',
          'Date',
          'RegExp',
          'Error'
        ], function (name) {
          _['is' + name] = function (obj) {
            return toString.call(obj) === '[object ' + name + ']';
          };
        });
        // Define a fallback version of the method in browsers (ahem, IE < 9), where
        // there isn't any inspectable "Arguments" type.
        if (!_.isArguments(arguments)) {
          _.isArguments = function (obj) {
            return _.has(obj, 'callee');
          };
        }
        // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
        // IE 11 (#1621), and in Safari 8 (#1929).
        if (typeof /./ != 'function' && typeof Int8Array != 'object') {
          _.isFunction = function (obj) {
            return typeof obj == 'function' || false;
          };
        }
        // Is a given object a finite number?
        _.isFinite = function (obj) {
          return isFinite(obj) && !isNaN(parseFloat(obj));
        };
        // Is the given value `NaN`? (NaN is the only number which does not equal itself).
        _.isNaN = function (obj) {
          return _.isNumber(obj) && obj !== +obj;
        };
        // Is a given value a boolean?
        _.isBoolean = function (obj) {
          return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
        };
        // Is a given value equal to null?
        _.isNull = function (obj) {
          return obj === null;
        };
        // Is a given variable undefined?
        _.isUndefined = function (obj) {
          return obj === void 0;
        };
        // Shortcut function for checking if an object has a given property directly
        // on itself (in other words, not on a prototype).
        _.has = function (obj, key) {
          return obj != null && hasOwnProperty.call(obj, key);
        };
        // Utility Functions
        // -----------------
        // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
        // previous owner. Returns a reference to the Underscore object.
        _.noConflict = function () {
          root._ = previousUnderscore;
          return this;
        };
        // Keep the identity function around for default iteratees.
        _.identity = function (value) {
          return value;
        };
        // Predicate-generating functions. Often useful outside of Underscore.
        _.constant = function (value) {
          return function () {
            return value;
          };
        };
        _.noop = function () {
        };
        _.property = property;
        // Generates a function for a given object that returns a given property.
        _.propertyOf = function (obj) {
          return obj == null ? function () {
          } : function (key) {
            return obj[key];
          };
        };
        // Returns a predicate for checking whether an object has a given set of
        // `key:value` pairs.
        _.matcher = _.matches = function (attrs) {
          attrs = _.extendOwn({}, attrs);
          return function (obj) {
            return _.isMatch(obj, attrs);
          };
        };
        // Run a function **n** times.
        _.times = function (n, iteratee, context) {
          var accum = Array(Math.max(0, n));
          iteratee = optimizeCb(iteratee, context, 1);
          for (var i = 0; i < n; i++)
            accum[i] = iteratee(i);
          return accum;
        };
        // Return a random integer between min and max (inclusive).
        _.random = function (min, max) {
          if (max == null) {
            max = min;
            min = 0;
          }
          return min + Math.floor(Math.random() * (max - min + 1));
        };
        // A (possibly faster) way to get the current timestamp as an integer.
        _.now = Date.now || function () {
          return new Date().getTime();
        };
        // List of HTML entities for escaping.
        var escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#x27;',
            '`': '&#x60;'
          };
        var unescapeMap = _.invert(escapeMap);
        // Functions for escaping and unescaping strings to/from HTML interpolation.
        var createEscaper = function (map) {
          var escaper = function (match) {
            return map[match];
          };
          // Regexes for identifying a key that needs to be escaped
          var source = '(?:' + _.keys(map).join('|') + ')';
          var testRegexp = RegExp(source);
          var replaceRegexp = RegExp(source, 'g');
          return function (string) {
            string = string == null ? '' : '' + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
          };
        };
        _.escape = createEscaper(escapeMap);
        _.unescape = createEscaper(unescapeMap);
        // If the value of the named `property` is a function then invoke it with the
        // `object` as context; otherwise, return it.
        _.result = function (object, property, fallback) {
          var value = object == null ? void 0 : object[property];
          if (value === void 0) {
            value = fallback;
          }
          return _.isFunction(value) ? value.call(object) : value;
        };
        // Generate a unique integer id (unique within the entire client session).
        // Useful for temporary DOM ids.
        var idCounter = 0;
        _.uniqueId = function (prefix) {
          var id = ++idCounter + '';
          return prefix ? prefix + id : id;
        };
        // By default, Underscore uses ERB-style template delimiters, change the
        // following template settings to use alternative delimiters.
        _.templateSettings = {
          evaluate: /<%([\s\S]+?)%>/g,
          interpolate: /<%=([\s\S]+?)%>/g,
          escape: /<%-([\s\S]+?)%>/g
        };
        // When customizing `templateSettings`, if you don't want to define an
        // interpolation, evaluation or escaping regex, we need one that is
        // guaranteed not to match.
        var noMatch = /(.)^/;
        // Certain characters need to be escaped so that they can be put into a
        // string literal.
        var escapes = {
            '\'': '\'',
            '\\': '\\',
            '\r': 'r',
            '\n': 'n',
            '\u2028': 'u2028',
            '\u2029': 'u2029'
          };
        var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
        var escapeChar = function (match) {
          return '\\' + escapes[match];
        };
        // JavaScript micro-templating, similar to John Resig's implementation.
        // Underscore templating handles arbitrary delimiters, preserves whitespace,
        // and correctly escapes quotes within interpolated code.
        // NB: `oldSettings` only exists for backwards compatibility.
        _.template = function (text, settings, oldSettings) {
          if (!settings && oldSettings)
            settings = oldSettings;
          settings = _.defaults({}, settings, _.templateSettings);
          // Combine delimiters into one regular expression via alternation.
          var matcher = RegExp([
              (settings.escape || noMatch).source,
              (settings.interpolate || noMatch).source,
              (settings.evaluate || noMatch).source
            ].join('|') + '|$', 'g');
          // Compile the template source, escaping string literals appropriately.
          var index = 0;
          var source = '__p+=\'';
          text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, escapeChar);
            index = offset + match.length;
            if (escape) {
              source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
            } else if (interpolate) {
              source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
            } else if (evaluate) {
              source += '\';\n' + evaluate + '\n__p+=\'';
            }
            // Adobe VMs need the match returned to produce the correct offest.
            return match;
          });
          source += '\';\n';
          // If a variable is not specified, place data values in local scope.
          if (!settings.variable)
            source = 'with(obj||{}){\n' + source + '}\n';
          source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
          try {
            var render = new Function(settings.variable || 'obj', '_', source);
          } catch (e) {
            e.source = source;
            throw e;
          }
          var template = function (data) {
            return render.call(this, data, _);
          };
          // Provide the compiled source as a convenience for precompilation.
          var argument = settings.variable || 'obj';
          template.source = 'function(' + argument + '){\n' + source + '}';
          return template;
        };
        // Add a "chain" function. Start chaining a wrapped Underscore object.
        _.chain = function (obj) {
          var instance = _(obj);
          instance._chain = true;
          return instance;
        };
        // OOP
        // ---------------
        // If Underscore is called as a function, it returns a wrapped object that
        // can be used OO-style. This wrapper holds altered versions of all the
        // underscore functions. Wrapped objects may be chained.
        // Helper function to continue chaining intermediate results.
        var result = function (instance, obj) {
          return instance._chain ? _(obj).chain() : obj;
        };
        // Add your own custom functions to the Underscore object.
        _.mixin = function (obj) {
          _.each(_.functions(obj), function (name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function () {
              var args = [this._wrapped];
              push.apply(args, arguments);
              return result(this, func.apply(_, args));
            };
          });
        };
        // Add all of the Underscore functions to the wrapper object.
        _.mixin(_);
        // Add all mutator Array functions to the wrapper.
        _.each([
          'pop',
          'push',
          'reverse',
          'shift',
          'sort',
          'splice',
          'unshift'
        ], function (name) {
          var method = ArrayProto[name];
          _.prototype[name] = function () {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name === 'shift' || name === 'splice') && obj.length === 0)
              delete obj[0];
            return result(this, obj);
          };
        });
        // Add all accessor Array functions to the wrapper.
        _.each([
          'concat',
          'join',
          'slice'
        ], function (name) {
          var method = ArrayProto[name];
          _.prototype[name] = function () {
            return result(this, method.apply(this._wrapped, arguments));
          };
        });
        // Extracts the result from a wrapped and chained object.
        _.prototype.value = function () {
          return this._wrapped;
        };
        // Provide unwrapping proxy for some methods used in engine operations
        // such as arithmetic and JSON stringification.
        _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
        _.prototype.toString = function () {
          return '' + this._wrapped;
        };
        // AMD registration happens at the end for compatibility with AMD loaders
        // that may not enforce next-turn semantics on modules. Even though general
        // practice for AMD registration is to be anonymous, underscore registers
        // as a named module because, like jQuery, it is a base library that is
        // popular enough to be bundled in a third party lib, but not be part of
        // an AMD load request. Those cases could generate an error when an
        // anonymous define() is called outside of a loader request.
        if (typeof define === 'function' && define.amd) {
          define('underscore', [], function () {
            return _;
          });
        }
      }.call(this));
    },
    {}
  ]
}, {}, [8]));
(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    g.oasRamlConverter = f();
  }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error('Cannot find module \'' + o + '\'');
          throw f.code = 'MODULE_NOT_FOUND', f;
        }
        var l = n[o] = { exports: {} };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == 'function' && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  }({
    1: [
      function (require, module, exports) {
        'use strict';
        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        ;
        (function (exports) {
          'use strict';
          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
          var PLUS = '+'.charCodeAt(0);
          var SLASH = '/'.charCodeAt(0);
          var NUMBER = '0'.charCodeAt(0);
          var LOWER = 'a'.charCodeAt(0);
          var UPPER = 'A'.charCodeAt(0);
          var PLUS_URL_SAFE = '-'.charCodeAt(0);
          var SLASH_URL_SAFE = '_'.charCodeAt(0);
          function decode(elt) {
            var code = elt.charCodeAt(0);
            if (code === PLUS || code === PLUS_URL_SAFE)
              return 62;
            // '+'
            if (code === SLASH || code === SLASH_URL_SAFE)
              return 63;
            // '/'
            if (code < NUMBER)
              return -1;
            //no match
            if (code < NUMBER + 10)
              return code - NUMBER + 26 + 26;
            if (code < UPPER + 26)
              return code - UPPER;
            if (code < LOWER + 26)
              return code - LOWER + 26;
          }
          function b64ToByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr;
            if (b64.length % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4');
            }
            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            var len = b64.length;
            placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
            // base64 is 4/3 + up to two characters of the original data
            arr = new Arr(b64.length * 3 / 4 - placeHolders);
            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? b64.length - 4 : b64.length;
            var L = 0;
            function push(v) {
              arr[L++] = v;
            }
            for (i = 0, j = 0; i < l; i += 4, j += 3) {
              tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
              push((tmp & 16711680) >> 16);
              push((tmp & 65280) >> 8);
              push(tmp & 255);
            }
            if (placeHolders === 2) {
              tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
              push(tmp & 255);
            } else if (placeHolders === 1) {
              tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
              push(tmp >> 8 & 255);
              push(tmp & 255);
            }
            return arr;
          }
          function uint8ToBase64(uint8) {
            var i, extraBytes = uint8.length % 3,
              // if we have 1 byte left, pad 2 bytes
              output = '', temp, length;
            function encode(num) {
              return lookup.charAt(num);
            }
            function tripletToBase64(num) {
              return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
            }
            // go through the array every three bytes, we'll deal with trailing stuff later
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
              temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
              output += tripletToBase64(temp);
            }
            // pad the end with zeros, but make sure to not forget the extra bytes
            switch (extraBytes) {
            case 1:
              temp = uint8[uint8.length - 1];
              output += encode(temp >> 2);
              output += encode(temp << 4 & 63);
              output += '==';
              break;
            case 2:
              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
              output += encode(temp >> 10);
              output += encode(temp >> 4 & 63);
              output += encode(temp << 2 & 63);
              output += '=';
              break;
            }
            return output;
          }
          exports.toByteArray = b64ToByteArray;
          exports.fromByteArray = uint8ToBase64;
        }(typeof exports === 'undefined' ? undefined.base64js = {} : exports));
      },
      {}
    ],
    2: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        // Browser Request
        //
        // Licensed under the Apache License, Version 2.0 (the "License");
        // you may not use this file except in compliance with the License.
        // You may obtain a copy of the License at
        //
        //     http://www.apache.org/licenses/LICENSE-2.0
        //
        // Unless required by applicable law or agreed to in writing, software
        // distributed under the License is distributed on an "AS IS" BASIS,
        // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        // See the License for the specific language governing permissions and
        // limitations under the License.
        // UMD HEADER START 
        (function (root, factory) {
          if (typeof define === 'function' && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
          } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like enviroments that support module.exports,
            // like Node.
            module.exports = factory();
          } else {
            // Browser globals (root is window)
            root.returnExports = factory();
          }
        }(undefined, function () {
          // UMD HEADER END
          var XHR = XMLHttpRequest;
          if (!XHR)
            throw new Error('missing XMLHttpRequest');
          request.log = {
            'trace': noop,
            'debug': noop,
            'info': noop,
            'warn': noop,
            'error': noop
          };
          var DEFAULT_TIMEOUT = 3 * 60 * 1000;
          // 3 minutes
          //
          // request
          //
          function request(options, callback) {
            // The entry-point to the API: prep the options object and pass the real work to run_xhr.
            if (typeof callback !== 'function')
              throw new Error('Bad callback given: ' + callback);
            if (!options)
              throw new Error('No options given');
            var options_onResponse = options.onResponse;
            // Save this for later.
            if (typeof options === 'string')
              options = { 'uri': options };
            else
              options = JSON.parse(JSON.stringify(options));
            // Use a duplicate for mutating.
            options.onResponse = options_onResponse;
            // And put it back.
            if (options.verbose)
              request.log = getLogger();
            if (options.url) {
              options.uri = options.url;
              delete options.url;
            }
            if (!options.uri && options.uri !== '')
              throw new Error('options.uri is a required argument');
            if (typeof options.uri != 'string')
              throw new Error('options.uri must be a string');
            var unsupported_options = [
                'proxy',
                '_redirectsFollowed',
                'maxRedirects',
                'followRedirect'
              ];
            for (var i = 0; i < unsupported_options.length; i++) {
              if (options[unsupported_options[i]])
                throw new Error('options.' + unsupported_options[i] + ' is not supported');
            }
            options.callback = callback;
            options.method = options.method || 'GET';
            options.headers = options.headers || {};
            options.body = options.body || null;
            options.timeout = options.timeout || request.DEFAULT_TIMEOUT;
            if (options.headers.host)
              throw new Error('Options.headers.host is not supported');
            if (options.json) {
              options.headers.accept = options.headers.accept || 'application/json';
              if (options.method !== 'GET')
                options.headers['content-type'] = 'application/json';
              if (typeof options.json !== 'boolean')
                options.body = JSON.stringify(options.json);
              else if (typeof options.body !== 'string')
                options.body = JSON.stringify(options.body);
            }
            //BEGIN QS Hack
            var serialize = function serialize(obj) {
              var str = [];
              for (var p in obj) {
                if (obj.hasOwnProperty(p)) {
                  str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
                }
              }
              return str.join('&');
            };
            if (options.qs) {
              var qs = typeof options.qs == 'string' ? options.qs : serialize(options.qs);
              if (options.uri.indexOf('?') !== -1) {
                //no get params
                options.uri = options.uri + '&' + qs;
              } else {
                //existing get params
                options.uri = options.uri + '?' + qs;
              }
            }
            //END QS Hack
            //BEGIN FORM Hack
            var multipart = function multipart(obj) {
              //todo: support file type (useful?)
              var result = {};
              result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);
              var lines = [];
              for (var p in obj) {
                if (obj.hasOwnProperty(p)) {
                  lines.push('--' + result.boundry + '\n' + 'Content-Disposition: form-data; name="' + p + '"' + '\n' + '\n' + obj[p] + '\n');
                }
              }
              lines.push('--' + result.boundry + '--');
              result.body = lines.join('');
              result.length = result.body.length;
              result.type = 'multipart/form-data; boundary=' + result.boundry;
              return result;
            };
            if (options.form) {
              if (typeof options.form == 'string')
                throw 'form name unsupported';
              if (options.method === 'POST') {
                var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
                options.headers['content-type'] = encoding;
                switch (encoding) {
                case 'application/x-www-form-urlencoded':
                  options.body = serialize(options.form).replace(/%20/g, '+');
                  break;
                case 'multipart/form-data':
                  var multi = multipart(options.form);
                  //options.headers['content-length'] = multi.length;
                  options.body = multi.body;
                  options.headers['content-type'] = multi.type;
                  break;
                default:
                  throw new Error('unsupported encoding:' + encoding);
                }
              }
            }
            //END FORM Hack
            // If onResponse is boolean true, call back immediately when the response is known,
            // not when the full request is complete.
            options.onResponse = options.onResponse || noop;
            if (options.onResponse === true) {
              options.onResponse = callback;
              options.callback = noop;
            }
            // XXX Browsers do not like this.
            //if(options.body)
            //  options.headers['content-length'] = options.body.length;
            // HTTP basic authentication
            if (!options.headers.authorization && options.auth)
              options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);
            return run_xhr(options);
          }
          var req_seq = 0;
          function run_xhr(options) {
            var xhr = new XHR(), timed_out = false, is_cors = is_crossDomain(options.uri), supports_cors = 'withCredentials' in xhr;
            req_seq += 1;
            xhr.seq_id = req_seq;
            xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;
            xhr._id = xhr.id;
            // I know I will type "_id" from habit all the time.
            if (is_cors && !supports_cors) {
              var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);
              cors_err.cors = 'unsupported';
              return options.callback(cors_err, xhr);
            }
            xhr.timeoutTimer = setTimeout(too_late, options.timeout);
            function too_late() {
              timed_out = true;
              var er = new Error('ETIMEDOUT');
              er.code = 'ETIMEDOUT';
              er.duration = options.timeout;
              request.log.error('Timeout', {
                'id': xhr._id,
                'milliseconds': options.timeout
              });
              return options.callback(er, xhr);
            }
            // Some states can be skipped over, so remember what is still incomplete.
            var did = {
                'response': false,
                'loading': false,
                'end': false
              };
            xhr.onreadystatechange = on_state_change;
            xhr.open(options.method, options.uri, true);
            // asynchronous
            if (is_cors)
              xhr.withCredentials = !!options.withCredentials;
            xhr.send(options.body);
            return xhr;
            function on_state_change(event) {
              if (timed_out)
                return request.log.debug('Ignoring timed out state change', {
                  'state': xhr.readyState,
                  'id': xhr.id
                });
              request.log.debug('State change', {
                'state': xhr.readyState,
                'id': xhr.id,
                'timed_out': timed_out
              });
              if (xhr.readyState === XHR.OPENED) {
                request.log.debug('Request started', { 'id': xhr.id });
                for (var key in options.headers) {
                  xhr.setRequestHeader(key, options.headers[key]);
                }
              } else if (xhr.readyState === XHR.HEADERS_RECEIVED)
                on_response();
              else if (xhr.readyState === XHR.LOADING) {
                on_response();
                on_loading();
              } else if (xhr.readyState === XHR.DONE) {
                on_response();
                on_loading();
                on_end();
              }
            }
            function on_response() {
              if (did.response)
                return;
              did.response = true;
              request.log.debug('Got response', {
                'id': xhr.id,
                'status': xhr.status
              });
              clearTimeout(xhr.timeoutTimer);
              xhr.statusCode = xhr.status;
              // Node request compatibility
              // Detect failed CORS requests.
              if (is_cors && xhr.statusCode == 0) {
                var cors_err = new Error('CORS request rejected: ' + options.uri);
                cors_err.cors = 'rejected';
                // Do not process this request further.
                did.loading = true;
                did.end = true;
                return options.callback(cors_err, xhr);
              }
              options.onResponse(null, xhr);
            }
            function on_loading() {
              if (did.loading)
                return;
              did.loading = true;
              request.log.debug('Response body loading', { 'id': xhr.id });  // TODO: Maybe simulate "data" events by watching xhr.responseText
            }
            function on_end() {
              if (did.end)
                return;
              did.end = true;
              request.log.debug('Request done', { 'id': xhr.id });
              xhr.body = xhr.responseText;
              if (options.json) {
                try {
                  xhr.body = JSON.parse(xhr.responseText);
                } catch (er) {
                  return options.callback(er, xhr);
                }
              }
              options.callback(null, xhr, xhr.body);
            }
          }
          // request
          request.withCredentials = false;
          request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
          //
          // defaults
          //
          request.defaults = function (options, requester) {
            var def = function def(method) {
              var d = function d(params, callback) {
                if (typeof params === 'string')
                  params = { 'uri': params };
                else {
                  params = JSON.parse(JSON.stringify(params));
                }
                for (var i in options) {
                  if (params[i] === undefined)
                    params[i] = options[i];
                }
                return method(params, callback);
              };
              return d;
            };
            var de = def(request);
            de.get = def(request.get);
            de.post = def(request.post);
            de.put = def(request.put);
            de.head = def(request.head);
            return de;
          };
          //
          // HTTP method shortcuts
          //
          var shortcuts = [
              'get',
              'put',
              'post',
              'head'
            ];
          shortcuts.forEach(function (shortcut) {
            var method = shortcut.toUpperCase();
            var func = shortcut.toLowerCase();
            request[func] = function (opts) {
              if (typeof opts === 'string')
                opts = {
                  'method': method,
                  'uri': opts
                };
              else {
                opts = JSON.parse(JSON.stringify(opts));
                opts.method = method;
              }
              var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
              return request.apply(this, args);
            };
          });
          //
          // CouchDB shortcut
          //
          request.couch = function (options, callback) {
            if (typeof options === 'string')
              options = { 'uri': options };
            options.json = true;
            if (options.body)
              options.json = options.body;
            delete options.body;
            callback = callback || noop;
            var xhr = request(options, couch_handler);
            return xhr;
            function couch_handler(er, resp, body) {
              if (er)
                return callback(er, resp, body);
              if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
                // The body is a Couch JSON object indicating the error.
                er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));
                for (var key in body) {
                  er[key] = body[key];
                }
                return callback(er, resp, body);
              }
              return callback(er, resp, body);
            }
          };
          //
          // Utility
          //
          function noop() {
          }
          function getLogger() {
            var logger = {}, levels = [
                'trace',
                'debug',
                'info',
                'warn',
                'error'
              ], level, i;
            for (i = 0; i < levels.length; i++) {
              level = levels[i];
              logger[level] = noop;
              if (typeof console !== 'undefined' && console && console[level])
                logger[level] = formatted(console, level);
            }
            return logger;
          }
          function formatted(obj, method) {
            return formatted_logger;
            function formatted_logger(str, context) {
              if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object')
                str += ' ' + JSON.stringify(context);
              return obj[method].call(obj, str);
            }
          }
          // Return whether a URL is a cross-domain request.
          function is_crossDomain(url) {
            var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/;
            // jQuery #8138, IE may throw an exception when accessing
            // a field from window.location if document.domain has been set
            var ajaxLocation;
            try {
              ajaxLocation = location.href;
            } catch (e) {
              // Use the href attribute of an A element since IE will modify it given document.location
              ajaxLocation = document.createElement('a');
              ajaxLocation.href = '';
              ajaxLocation = ajaxLocation.href;
            }
            var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], parts = rurl.exec(url.toLowerCase());
            var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? 80 : 443))));
            //console.debug('is_crossDomain('+url+') -> ' + result)
            return result;
          }
          // MIT License from http://phpjs.org/functions/base64_encode:358
          function b64_enc(data) {
            // Encodes string using MIME base64 algorithm
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = '', tmp_arr = [];
            if (!data) {
              return data;
            }
            // assume utf8 data
            // data = this.utf8_encode(data+'');
            do {
              // pack three octets into four hexets
              o1 = data.charCodeAt(i++);
              o2 = data.charCodeAt(i++);
              o3 = data.charCodeAt(i++);
              bits = o1 << 16 | o2 << 8 | o3;
              h1 = bits >> 18 & 63;
              h2 = bits >> 12 & 63;
              h3 = bits >> 6 & 63;
              h4 = bits & 63;
              // use hexets to index into b64, and append result to encoded string
              tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);
            enc = tmp_arr.join('');
            switch (data.length % 3) {
            case 1:
              enc = enc.slice(0, -2) + '==';
              break;
            case 2:
              enc = enc.slice(0, -1) + '=';
              break;
            }
            return enc;
          }
          return request;  //UMD FOOTER START
        }));  //UMD FOOTER END
      },
      {}
    ],
    3: [
      function (require, module, exports) {
      },
      {}
    ],
    4: [
      function (require, module, exports) {
        arguments[4][3][0].apply(exports, arguments);
      },
      { 'dup': 3 }
    ],
    5: [
      function (require, module, exports) {
        (function (global) {
          /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
          /* eslint-disable no-proto */
          'use strict';
          var base64 = require('base64-js');
          var ieee754 = require('ieee754');
          var isArray = require('isarray');
          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          Buffer.poolSize = 8192;
          // not used by this implementation
          var rootParent = {};
          /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
          Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
          function typedArraySupport() {
            function Bar() {
            }
            try {
              var arr = new Uint8Array(1);
              arr.foo = function () {
                return 42;
              };
              arr.constructor = Bar;
              return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
            } catch (e) {
              return false;
            }
          }
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          /**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
          function Buffer(arg) {
            if (!(this instanceof Buffer)) {
              // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
              if (arguments.length > 1)
                return new Buffer(arg, arguments[1]);
              return new Buffer(arg);
            }
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              this.length = 0;
              this.parent = undefined;
            }
            // Common case.
            if (typeof arg === 'number') {
              return fromNumber(this, arg);
            }
            // Slightly less common case.
            if (typeof arg === 'string') {
              return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
            }
            // Unusual.
            return fromObject(this, arg);
          }
          function fromNumber(that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < length; i++) {
                that[i] = 0;
              }
            }
            return that;
          }
          function fromString(that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '')
              encoding = 'utf8';
            // Assumption: byteLength() return value is always < kMaxLength.
            var length = byteLength(string, encoding) | 0;
            that = allocate(that, length);
            that.write(string, encoding);
            return that;
          }
          function fromObject(that, object) {
            if (Buffer.isBuffer(object))
              return fromBuffer(that, object);
            if (isArray(object))
              return fromArray(that, object);
            if (object == null) {
              throw new TypeError('must start with number, buffer, array or string');
            }
            if (typeof ArrayBuffer !== 'undefined') {
              if (object.buffer instanceof ArrayBuffer) {
                return fromTypedArray(that, object);
              }
              if (object instanceof ArrayBuffer) {
                return fromArrayBuffer(that, object);
              }
            }
            if (object.length)
              return fromArrayLike(that, object);
            return fromJsonObject(that, object);
          }
          function fromBuffer(that, buffer) {
            var length = checked(buffer.length) | 0;
            that = allocate(that, length);
            buffer.copy(that, 0, 0, length);
            return that;
          }
          function fromArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          // Duplicate of fromArray() to keep fromArray() monomorphic.
          function fromTypedArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            // Truncating the elements is probably not what people expect from typed
            // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
            // of the old Buffer constructor.
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              array.byteLength;
              that = Buffer._augment(new Uint8Array(array));
            } else {
              // Fallback: Return an object instance of the Buffer class
              that = fromTypedArray(that, new Uint8Array(array));
            }
            return that;
          }
          function fromArrayLike(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
          // Returns a zero-length buffer for inputs that don't conform to the spec.
          function fromJsonObject(that, object) {
            var array;
            var length = 0;
            if (object.type === 'Buffer' && isArray(object.data)) {
              array = object.data;
              length = checked(array.length) | 0;
            }
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
          } else {
            // pre-set for values that may exist in the future
            Buffer.prototype.length = undefined;
            Buffer.prototype.parent = undefined;
          }
          function allocate(that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = Buffer._augment(new Uint8Array(length));
              that.__proto__ = Buffer.prototype;
            } else {
              // Fallback: Return an object instance of the Buffer class
              that.length = length;
              that._isBuffer = true;
            }
            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
            if (fromPool)
              that.parent = rootParent;
            return that;
          }
          function checked(length) {
            // Note: cannot use `length < kMaxLength` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
            }
            return length | 0;
          }
          function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer))
              return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            delete buf.parent;
            return buf;
          }
          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };
          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers');
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            var i = 0;
            var len = Math.min(x, y);
            while (i < len) {
              if (a[i] !== b[i])
                break;
              ++i;
            }
            if (i !== len) {
              x = a[i];
              y = b[i];
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'raw':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;
            default:
              return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!isArray(list))
              throw new TypeError('list argument must be an Array of Buffers.');
            if (list.length === 0) {
              return new Buffer(0);
            }
            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; i++) {
                length += list[i].length;
              }
            }
            var buf = new Buffer(length);
            var pos = 0;
            for (i = 0; i < list.length; i++) {
              var item = list[i];
              item.copy(buf, pos);
              pos += item.length;
            }
            return buf;
          };
          function byteLength(string, encoding) {
            if (typeof string !== 'string')
              string = '' + string;
            var len = string.length;
            if (len === 0)
              return 0;
            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
              case 'ascii':
              case 'binary':
              // Deprecated
              case 'raw':
              case 'raws':
                return len;
              case 'utf8':
              case 'utf-8':
                return utf8ToBytes(string).length;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2;
              case 'hex':
                return len >>> 1;
              case 'base64':
                return base64ToBytes(string).length;
              default:
                if (loweredCase)
                  return utf8ToBytes(string).length;
                // assume utf8
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            start = start | 0;
            end = end === undefined || end === Infinity ? this.length : end | 0;
            if (!encoding)
              encoding = 'utf8';
            if (start < 0)
              start = 0;
            if (end > this.length)
              end = this.length;
            if (end <= start)
              return '';
            while (true) {
              switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end);
              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end);
              case 'ascii':
                return asciiSlice(this, start, end);
              case 'binary':
                return binarySlice(this, start, end);
              case 'base64':
                return base64Slice(this, start, end);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase)
                  throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
              }
            }
          }
          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0)
              return '';
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer');
            if (this === b)
              return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
              if (this.length > max)
                str += ' ... ';
            }
            return '<Buffer ' + str + '>';
          };
          Buffer.prototype.compare = function compare(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer');
            if (this === b)
              return 0;
            return Buffer.compare(this, b);
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
            if (byteOffset > 2147483647)
              byteOffset = 2147483647;
            else if (byteOffset < -2147483648)
              byteOffset = -2147483648;
            byteOffset >>= 0;
            if (this.length === 0)
              return -1;
            if (byteOffset >= this.length)
              return -1;
            // Negative offsets start from the end of the buffer
            if (byteOffset < 0)
              byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === 'string') {
              if (val.length === 0)
                return -1;
              // special case: looking for empty string always fails
              return String.prototype.indexOf.call(this, val, byteOffset);
            }
            if (Buffer.isBuffer(val)) {
              return arrayIndexOf(this, val, byteOffset);
            }
            if (typeof val === 'number') {
              if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
              }
              return arrayIndexOf(this, [val], byteOffset);
            }
            function arrayIndexOf(arr, val, byteOffset) {
              var foundIndex = -1;
              for (var i = 0; byteOffset + i < arr.length; i++) {
                if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === val.length)
                    return byteOffset + foundIndex;
                } else {
                  foundIndex = -1;
                }
              }
              return -1;
            }
            throw new TypeError('val must be string, number or Buffer');
          };
          // `get` is deprecated
          Buffer.prototype.get = function get(offset) {
            console.log('.get() is deprecated. Access using array indexes instead.');
            return this.readUInt8(offset);
          };
          // `set` is deprecated
          Buffer.prototype.set = function set(v, offset) {
            console.log('.set() is deprecated. Access using array indexes instead.');
            return this.writeUInt8(v, offset);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            // must be an even number of digits
            var strLen = string.length;
            if (strLen % 2 !== 0)
              throw new Error('Invalid hex string');
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed))
                throw new Error('Invalid hex string');
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset | 0;
              if (isFinite(length)) {
                length = length | 0;
                if (encoding === undefined)
                  encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }  // legacy write(string, encoding, offset, length) - remove in v0.13
            } else {
              var swap = encoding;
              encoding = offset;
              offset = length | 0;
              length = swap;
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('attempt to write outside buffer bounds');
            }
            if (!encoding)
              encoding = 'utf8';
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length);
              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length);
              case 'ascii':
                return asciiWrite(this, string, offset, length);
              case 'binary':
                return binaryWrite(this, string, offset, length);
              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase)
                  throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
                }
              }
              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            // Decode in chunks to avoid "call stack size exceeded".
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function binarySlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = '';
            for (var i = start; i < end; i++) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = Buffer._augment(this.subarray(start, end));
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, undefined);
              for (var i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start];
              }
            }
            if (newBuf.length)
              newBuf.parent = this.parent || this;
            return newBuf;
          };
          /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError('offset is not uint');
            if (offset + ext > length)
              throw new RangeError('Trying to access beyond buffer length');
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
              val += this[offset + --byteLength] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('buffer must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('value is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError('index out of range');
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
              buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
          }
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min)
              throw new RangeError('value is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError('index out of range');
            if (offset < 0)
              throw new RangeError('index out of range');
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157e+308, -1.7976931348623157e+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            // Copy 0 bytes; we're done
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length)
              throw new RangeError('sourceStart out of bounds');
            if (end < 0)
              throw new RangeError('sourceEnd out of bounds');
            // Are we oob?
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (i = len - 1; i >= 0; i--) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
              // ascending copy from start
              for (i = 0; i < len; i++) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              target._set(this.subarray(start, start + len), targetStart);
            }
            return len;
          };
          // fill(value, start=0, end=buffer.length)
          Buffer.prototype.fill = function fill(value, start, end) {
            if (!value)
              value = 0;
            if (!start)
              start = 0;
            if (!end)
              end = this.length;
            if (end < start)
              throw new RangeError('end < start');
            // Fill 0 bytes; we're done
            if (end === start)
              return;
            if (this.length === 0)
              return;
            if (start < 0 || start >= this.length)
              throw new RangeError('start out of bounds');
            if (end < 0 || end > this.length)
              throw new RangeError('end out of bounds');
            var i;
            if (typeof value === 'number') {
              for (i = start; i < end; i++) {
                this[i] = value;
              }
            } else {
              var bytes = utf8ToBytes(value.toString());
              var len = bytes.length;
              for (i = start; i < end; i++) {
                this[i] = bytes[i % len];
              }
            }
            return this;
          };
          /**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
          Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
            if (typeof Uint8Array !== 'undefined') {
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                return new Buffer(this).buffer;
              } else {
                var buf = new Uint8Array(this.length);
                for (var i = 0, len = buf.length; i < len; i += 1) {
                  buf[i] = this[i];
                }
                return buf.buffer;
              }
            } else {
              throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
            }
          };
          // HELPER FUNCTIONS
          // ================
          var BP = Buffer.prototype;
          /**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
          Buffer._augment = function _augment(arr) {
            arr.constructor = Buffer;
            arr._isBuffer = true;
            // save reference to original Uint8Array set method before overwriting
            arr._set = arr.set;
            // deprecated
            arr.get = BP.get;
            arr.set = BP.set;
            arr.write = BP.write;
            arr.toString = BP.toString;
            arr.toLocaleString = BP.toString;
            arr.toJSON = BP.toJSON;
            arr.equals = BP.equals;
            arr.compare = BP.compare;
            arr.indexOf = BP.indexOf;
            arr.copy = BP.copy;
            arr.slice = BP.slice;
            arr.readUIntLE = BP.readUIntLE;
            arr.readUIntBE = BP.readUIntBE;
            arr.readUInt8 = BP.readUInt8;
            arr.readUInt16LE = BP.readUInt16LE;
            arr.readUInt16BE = BP.readUInt16BE;
            arr.readUInt32LE = BP.readUInt32LE;
            arr.readUInt32BE = BP.readUInt32BE;
            arr.readIntLE = BP.readIntLE;
            arr.readIntBE = BP.readIntBE;
            arr.readInt8 = BP.readInt8;
            arr.readInt16LE = BP.readInt16LE;
            arr.readInt16BE = BP.readInt16BE;
            arr.readInt32LE = BP.readInt32LE;
            arr.readInt32BE = BP.readInt32BE;
            arr.readFloatLE = BP.readFloatLE;
            arr.readFloatBE = BP.readFloatBE;
            arr.readDoubleLE = BP.readDoubleLE;
            arr.readDoubleBE = BP.readDoubleBE;
            arr.writeUInt8 = BP.writeUInt8;
            arr.writeUIntLE = BP.writeUIntLE;
            arr.writeUIntBE = BP.writeUIntBE;
            arr.writeUInt16LE = BP.writeUInt16LE;
            arr.writeUInt16BE = BP.writeUInt16BE;
            arr.writeUInt32LE = BP.writeUInt32LE;
            arr.writeUInt32BE = BP.writeUInt32BE;
            arr.writeIntLE = BP.writeIntLE;
            arr.writeIntBE = BP.writeIntBE;
            arr.writeInt8 = BP.writeInt8;
            arr.writeInt16LE = BP.writeInt16LE;
            arr.writeInt16BE = BP.writeInt16BE;
            arr.writeInt32LE = BP.writeInt32LE;
            arr.writeInt32BE = BP.writeInt32BE;
            arr.writeFloatLE = BP.writeFloatLE;
            arr.writeFloatBE = BP.writeFloatBE;
            arr.writeDoubleLE = BP.writeDoubleLE;
            arr.writeDoubleBE = BP.writeDoubleBE;
            arr.fill = BP.fill;
            arr.inspect = BP.inspect;
            arr.toArrayBuffer = BP.toArrayBuffer;
            return arr;
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '');
            // Node converts strings with length < 2 to ''
            if (str.length < 2)
              return '';
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim)
              return str.trim();
            return str.replace(/^\s+|\s+$/g, '');
          }
          function toHex(n) {
            if (n < 16)
              return '0' + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; i++) {
              codePoint = string.charCodeAt(i);
              // is surrogate component
              if (codePoint > 55295 && codePoint < 57344) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  // valid lead
                  leadSurrogate = codePoint;
                  continue;
                }
                // 2 leads in a row
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                // valid surrogate pair
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              // encode utf8
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error('Invalid code point');
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {
        'base64-js': 1,
        'ieee754': 17,
        'isarray': 6
      }
    ],
    6: [
      function (require, module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function (arr) {
          return toString.call(arr) == '[object Array]';
        };
      },
      {}
    ],
    7: [
      function (require, module, exports) {
        'use strict';
        module.exports = {
          '100': 'Continue',
          '101': 'Switching Protocols',
          '102': 'Processing',
          '200': 'OK',
          '201': 'Created',
          '202': 'Accepted',
          '203': 'Non-Authoritative Information',
          '204': 'No Content',
          '205': 'Reset Content',
          '206': 'Partial Content',
          '207': 'Multi-Status',
          '300': 'Multiple Choices',
          '301': 'Moved Permanently',
          '302': 'Moved Temporarily',
          '303': 'See Other',
          '304': 'Not Modified',
          '305': 'Use Proxy',
          '307': 'Temporary Redirect',
          '308': 'Permanent Redirect',
          '400': 'Bad Request',
          '401': 'Unauthorized',
          '402': 'Payment Required',
          '403': 'Forbidden',
          '404': 'Not Found',
          '405': 'Method Not Allowed',
          '406': 'Not Acceptable',
          '407': 'Proxy Authentication Required',
          '408': 'Request Time-out',
          '409': 'Conflict',
          '410': 'Gone',
          '411': 'Length Required',
          '412': 'Precondition Failed',
          '413': 'Request Entity Too Large',
          '414': 'Request-URI Too Large',
          '415': 'Unsupported Media Type',
          '416': 'Requested Range Not Satisfiable',
          '417': 'Expectation Failed',
          '418': 'I\'m a teapot',
          '422': 'Unprocessable Entity',
          '423': 'Locked',
          '424': 'Failed Dependency',
          '425': 'Unordered Collection',
          '426': 'Upgrade Required',
          '428': 'Precondition Required',
          '429': 'Too Many Requests',
          '431': 'Request Header Fields Too Large',
          '500': 'Internal Server Error',
          '501': 'Not Implemented',
          '502': 'Bad Gateway',
          '503': 'Service Unavailable',
          '504': 'Gateway Time-out',
          '505': 'HTTP Version Not Supported',
          '506': 'Variant Also Negotiates',
          '507': 'Insufficient Storage',
          '509': 'Bandwidth Limit Exceeded',
          '510': 'Not Extended',
          '511': 'Network Authentication Required'
        };
      },
      {}
    ],
    8: [
      function (require, module, exports) {
        (function (process, global) {
          'use strict';
          var next = global.process && process.nextTick || global.setImmediate || function (f) {
              setTimeout(f, 0);
            };
          module.exports = function maybe(cb, promise) {
            if (cb) {
              promise.then(function (result) {
                next(function () {
                  cb(null, result);
                });
              }, function (err) {
                next(function () {
                  cb(err);
                });
              });
              return undefined;
            } else {
              return promise;
            }
          };
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      { '_process': 145 }
    ],
    9: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg);
            }
            return objectToString(arg) === '[object Array]';
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return objectToString(e) === '[object Error]' || e instanceof Error;
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          exports.isBuffer = Buffer.isBuffer;
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }.call(this, { 'isBuffer': require('../../is-buffer/index.js') }));
      },
      { '../../is-buffer/index.js': 20 }
    ],
    10: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = require('./debug');
        exports.log = log;
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
        /**
 * Colors.
 */
        exports.colors = [
          'lightseagreen',
          'forestgreen',
          'goldenrod',
          'dodgerblue',
          'darkorchid',
          'crimson'
        ];
        /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
        function useColors() {
          // is webkit? http://stackoverflow.com/a/16459606/376773
          return 'WebkitAppearance' in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
        }
        /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */
        exports.formatters.j = function (v) {
          return JSON.stringify(v);
        };
        /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */
        function formatArgs() {
          var args = arguments;
          var useColors = this.useColors;
          args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
          if (!useColors)
            return args;
          var c = 'color: ' + this.color;
          args = [
            args[0],
            c,
            'color: inherit'
          ].concat(Array.prototype.slice.call(args, 1));
          // the final "%c" is somewhat tricky, because there could be other
          // arguments passed either before or after the %c, so we need to
          // figure out the correct index to insert the CSS into
          var index = 0;
          var lastC = 0;
          args[0].replace(/%[a-z%]/g, function (match) {
            if ('%%' === match)
              return;
            index++;
            if ('%c' === match) {
              // we only are interested in the *last* %c
              // (the user may have provided their own)
              lastC = index;
            }
          });
          args.splice(lastC, 0, c);
          return args;
        }
        /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
        function log() {
          // this hackery is required for IE8/9, where
          // the `console.log` function doesn't have 'apply'
          return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
        function save(namespaces) {
          try {
            if (null == namespaces) {
              exports.storage.removeItem('debug');
            } else {
              exports.storage.debug = namespaces;
            }
          } catch (e) {
          }
        }
        /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
        function load() {
          var r;
          try {
            r = exports.storage.debug;
          } catch (e) {
          }
          return r;
        }
        /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */
        exports.enable(load());
        /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */
        function localstorage() {
          try {
            return window.localStorage;
          } catch (e) {
          }
        }
      },
      { './debug': 11 }
    ],
    11: [
      function (require, module, exports) {
        'use strict';
        /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = debug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require('ms');
        /**
 * The currently active debug mode names, and names to skip.
 */
        exports.names = [];
        exports.skips = [];
        /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */
        exports.formatters = {};
        /**
 * Previously assigned color.
 */
        var prevColor = 0;
        /**
 * Previous log timestamp.
 */
        var prevTime;
        /**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */
        function selectColor() {
          return exports.colors[prevColor++ % exports.colors.length];
        }
        /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */
        function debug(namespace) {
          // define the `disabled` version
          function disabled() {
          }
          disabled.enabled = false;
          // define the `enabled` version
          function enabled() {
            var self = enabled;
            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            // add the `color` if not set
            if (null == self.useColors)
              self.useColors = exports.useColors();
            if (null == self.color && self.useColors)
              self.color = selectColor();
            var args = Array.prototype.slice.call(arguments);
            args[0] = exports.coerce(args[0]);
            if ('string' !== typeof args[0]) {
              // anything else let's inspect with %o
              args = ['%o'].concat(args);
            }
            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
              // if we encounter an escaped % then don't increase the array index
              if (match === '%%')
                return match;
              index++;
              var formatter = exports.formatters[format];
              if ('function' === typeof formatter) {
                var val = args[index];
                match = formatter.call(self, val);
                // now we need to remove `args[index]` since it's inlined in the `format`
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            if ('function' === typeof exports.formatArgs) {
              args = exports.formatArgs.apply(self, args);
            }
            var logFn = enabled.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
          }
          enabled.enabled = true;
          var fn = exports.enabled(namespace) ? enabled : disabled;
          fn.namespace = namespace;
          return fn;
        }
        /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */
        function enable(namespaces) {
          exports.save(namespaces);
          var split = (namespaces || '').split(/[\s,]+/);
          var len = split.length;
          for (var i = 0; i < len; i++) {
            if (!split[i])
              continue;
            // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
              exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
              exports.names.push(new RegExp('^' + namespaces + '$'));
            }
          }
        }
        /**
 * Disable debug output.
 *
 * @api public
 */
        function disable() {
          exports.enable('');
        }
        /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */
        function enabled(name) {
          var i, len;
          for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */
        function coerce(val) {
          if (val instanceof Error)
            return val.stack || val.message;
          return val;
        }
      },
      { 'ms': 80 }
    ],
    12: [
      function (require, module, exports) {
        (function (process, global) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.1.1
 */
          (function (global, factory) {
            (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ES6Promise = factory();
          }(undefined, function () {
            'use strict';
            function objectOrFunction(x) {
              var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);
              return x !== null && (type === 'object' || type === 'function');
            }
            function isFunction(x) {
              return typeof x === 'function';
            }
            var _isArray = undefined;
            if (Array.isArray) {
              _isArray = Array.isArray;
            } else {
              _isArray = function _isArray(x) {
                return Object.prototype.toString.call(x) === '[object Array]';
              };
            }
            var isArray = _isArray;
            var len = 0;
            var vertxNext = undefined;
            var customSchedulerFn = undefined;
            var asap = function asap(callback, arg) {
              queue[len] = callback;
              queue[len + 1] = arg;
              len += 2;
              if (len === 2) {
                // If len is 2, that means that we need to schedule an async flush.
                // If additional callbacks are queued before the queue is flushed, they
                // will be processed by this flush that we are scheduling.
                if (customSchedulerFn) {
                  customSchedulerFn(flush);
                } else {
                  scheduleFlush();
                }
              }
            };
            function setScheduler(scheduleFn) {
              customSchedulerFn = scheduleFn;
            }
            function setAsap(asapFn) {
              asap = asapFn;
            }
            var browserWindow = typeof window !== 'undefined' ? window : undefined;
            var browserGlobal = browserWindow || {};
            var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
            var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
            // test for web worker but not in IE10
            var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
            // node
            function useNextTick() {
              // node version 0.10.x displays a deprecation warning when nextTick is used recursively
              // see https://github.com/cujojs/when/issues/410 for details
              return function () {
                return process.nextTick(flush);
              };
            }
            // vertx
            function useVertxTimer() {
              if (typeof vertxNext !== 'undefined') {
                return function () {
                  vertxNext(flush);
                };
              }
              return useSetTimeout();
            }
            function useMutationObserver() {
              var iterations = 0;
              var observer = new BrowserMutationObserver(flush);
              var node = document.createTextNode('');
              observer.observe(node, { characterData: true });
              return function () {
                node.data = iterations = ++iterations % 2;
              };
            }
            // web worker
            function useMessageChannel() {
              var channel = new MessageChannel();
              channel.port1.onmessage = flush;
              return function () {
                return channel.port2.postMessage(0);
              };
            }
            function useSetTimeout() {
              // Store setTimeout reference so es6-promise will be unaffected by
              // other code modifying setTimeout (like sinon.useFakeTimers())
              var globalSetTimeout = setTimeout;
              return function () {
                return globalSetTimeout(flush, 1);
              };
            }
            var queue = new Array(1000);
            function flush() {
              for (var i = 0; i < len; i += 2) {
                var callback = queue[i];
                var arg = queue[i + 1];
                callback(arg);
                queue[i] = undefined;
                queue[i + 1] = undefined;
              }
              len = 0;
            }
            function attemptVertx() {
              try {
                var r = require;
                var vertx = r('vertx');
                vertxNext = vertx.runOnLoop || vertx.runOnContext;
                return useVertxTimer();
              } catch (e) {
                return useSetTimeout();
              }
            }
            var scheduleFlush = undefined;
            // Decide what async method to use to triggering processing of queued callbacks:
            if (isNode) {
              scheduleFlush = useNextTick();
            } else if (BrowserMutationObserver) {
              scheduleFlush = useMutationObserver();
            } else if (isWorker) {
              scheduleFlush = useMessageChannel();
            } else if (browserWindow === undefined && typeof require === 'function') {
              scheduleFlush = attemptVertx();
            } else {
              scheduleFlush = useSetTimeout();
            }
            function then(onFulfillment, onRejection) {
              var _arguments = arguments;
              var parent = this;
              var child = new this.constructor(noop);
              if (child[PROMISE_ID] === undefined) {
                makePromise(child);
              }
              var _state = parent._state;
              if (_state) {
                (function () {
                  var callback = _arguments[_state - 1];
                  asap(function () {
                    return invokeCallback(_state, child, callback, parent._result);
                  });
                }());
              } else {
                subscribe(parent, child, onFulfillment, onRejection);
              }
              return child;
            }
            /**
    `Promise.resolve` returns a promise that will become resolved with the
    passed `value`. It is shorthand for the following:
  
    ```javascript
    let promise = new Promise(function(resolve, reject){
      resolve(1);
    });
  
    promise.then(function(value){
      // value === 1
    });
    ```
  
    Instead of writing the above, your code now simply becomes the following:
  
    ```javascript
    let promise = Promise.resolve(1);
  
    promise.then(function(value){
      // value === 1
    });
    ```
  
    @method resolve
    @static
    @param {Any} value value that the returned promise will be resolved with
    Useful for tooling.
    @return {Promise} a promise that will become fulfilled with the given
    `value`
  */
            function resolve$1(object) {
              /*jshint validthis:true */
              var Constructor = this;
              if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
                return object;
              }
              var promise = new Constructor(noop);
              resolve(promise, object);
              return promise;
            }
            var PROMISE_ID = Math.random().toString(36).substring(16);
            function noop() {
            }
            var PENDING = void 0;
            var FULFILLED = 1;
            var REJECTED = 2;
            var GET_THEN_ERROR = new ErrorObject();
            function selfFulfillment() {
              return new TypeError('You cannot resolve a promise with itself');
            }
            function cannotReturnOwn() {
              return new TypeError('A promises callback cannot return that same promise.');
            }
            function getThen(promise) {
              try {
                return promise.then;
              } catch (error) {
                GET_THEN_ERROR.error = error;
                return GET_THEN_ERROR;
              }
            }
            function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
              try {
                then$$1.call(value, fulfillmentHandler, rejectionHandler);
              } catch (e) {
                return e;
              }
            }
            function handleForeignThenable(promise, thenable, then$$1) {
              asap(function (promise) {
                var sealed = false;
                var error = tryThen(then$$1, thenable, function (value) {
                    if (sealed) {
                      return;
                    }
                    sealed = true;
                    if (thenable !== value) {
                      resolve(promise, value);
                    } else {
                      fulfill(promise, value);
                    }
                  }, function (reason) {
                    if (sealed) {
                      return;
                    }
                    sealed = true;
                    reject(promise, reason);
                  }, 'Settle: ' + (promise._label || ' unknown promise'));
                if (!sealed && error) {
                  sealed = true;
                  reject(promise, error);
                }
              }, promise);
            }
            function handleOwnThenable(promise, thenable) {
              if (thenable._state === FULFILLED) {
                fulfill(promise, thenable._result);
              } else if (thenable._state === REJECTED) {
                reject(promise, thenable._result);
              } else {
                subscribe(thenable, undefined, function (value) {
                  return resolve(promise, value);
                }, function (reason) {
                  return reject(promise, reason);
                });
              }
            }
            function handleMaybeThenable(promise, maybeThenable, then$$1) {
              if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
                handleOwnThenable(promise, maybeThenable);
              } else {
                if (then$$1 === GET_THEN_ERROR) {
                  reject(promise, GET_THEN_ERROR.error);
                  GET_THEN_ERROR.error = null;
                } else if (then$$1 === undefined) {
                  fulfill(promise, maybeThenable);
                } else if (isFunction(then$$1)) {
                  handleForeignThenable(promise, maybeThenable, then$$1);
                } else {
                  fulfill(promise, maybeThenable);
                }
              }
            }
            function resolve(promise, value) {
              if (promise === value) {
                reject(promise, selfFulfillment());
              } else if (objectOrFunction(value)) {
                handleMaybeThenable(promise, value, getThen(value));
              } else {
                fulfill(promise, value);
              }
            }
            function publishRejection(promise) {
              if (promise._onerror) {
                promise._onerror(promise._result);
              }
              publish(promise);
            }
            function fulfill(promise, value) {
              if (promise._state !== PENDING) {
                return;
              }
              promise._result = value;
              promise._state = FULFILLED;
              if (promise._subscribers.length !== 0) {
                asap(publish, promise);
              }
            }
            function reject(promise, reason) {
              if (promise._state !== PENDING) {
                return;
              }
              promise._state = REJECTED;
              promise._result = reason;
              asap(publishRejection, promise);
            }
            function subscribe(parent, child, onFulfillment, onRejection) {
              var _subscribers = parent._subscribers;
              var length = _subscribers.length;
              parent._onerror = null;
              _subscribers[length] = child;
              _subscribers[length + FULFILLED] = onFulfillment;
              _subscribers[length + REJECTED] = onRejection;
              if (length === 0 && parent._state) {
                asap(publish, parent);
              }
            }
            function publish(promise) {
              var subscribers = promise._subscribers;
              var settled = promise._state;
              if (subscribers.length === 0) {
                return;
              }
              var child = undefined, callback = undefined, detail = promise._result;
              for (var i = 0; i < subscribers.length; i += 3) {
                child = subscribers[i];
                callback = subscribers[i + settled];
                if (child) {
                  invokeCallback(settled, child, callback, detail);
                } else {
                  callback(detail);
                }
              }
              promise._subscribers.length = 0;
            }
            function ErrorObject() {
              this.error = null;
            }
            var TRY_CATCH_ERROR = new ErrorObject();
            function tryCatch(callback, detail) {
              try {
                return callback(detail);
              } catch (e) {
                TRY_CATCH_ERROR.error = e;
                return TRY_CATCH_ERROR;
              }
            }
            function invokeCallback(settled, promise, callback, detail) {
              var hasCallback = isFunction(callback), value = undefined, error = undefined, succeeded = undefined, failed = undefined;
              if (hasCallback) {
                value = tryCatch(callback, detail);
                if (value === TRY_CATCH_ERROR) {
                  failed = true;
                  error = value.error;
                  value.error = null;
                } else {
                  succeeded = true;
                }
                if (promise === value) {
                  reject(promise, cannotReturnOwn());
                  return;
                }
              } else {
                value = detail;
                succeeded = true;
              }
              if (promise._state !== PENDING) {
              } else if (hasCallback && succeeded) {
                resolve(promise, value);
              } else if (failed) {
                reject(promise, error);
              } else if (settled === FULFILLED) {
                fulfill(promise, value);
              } else if (settled === REJECTED) {
                reject(promise, value);
              }
            }
            function initializePromise(promise, resolver) {
              try {
                resolver(function resolvePromise(value) {
                  resolve(promise, value);
                }, function rejectPromise(reason) {
                  reject(promise, reason);
                });
              } catch (e) {
                reject(promise, e);
              }
            }
            var id = 0;
            function nextId() {
              return id++;
            }
            function makePromise(promise) {
              promise[PROMISE_ID] = id++;
              promise._state = undefined;
              promise._result = undefined;
              promise._subscribers = [];
            }
            function Enumerator$1(Constructor, input) {
              this._instanceConstructor = Constructor;
              this.promise = new Constructor(noop);
              if (!this.promise[PROMISE_ID]) {
                makePromise(this.promise);
              }
              if (isArray(input)) {
                this.length = input.length;
                this._remaining = input.length;
                this._result = new Array(this.length);
                if (this.length === 0) {
                  fulfill(this.promise, this._result);
                } else {
                  this.length = this.length || 0;
                  this._enumerate(input);
                  if (this._remaining === 0) {
                    fulfill(this.promise, this._result);
                  }
                }
              } else {
                reject(this.promise, validationError());
              }
            }
            function validationError() {
              return new Error('Array Methods must be provided an Array');
            }
            Enumerator$1.prototype._enumerate = function (input) {
              for (var i = 0; this._state === PENDING && i < input.length; i++) {
                this._eachEntry(input[i], i);
              }
            };
            Enumerator$1.prototype._eachEntry = function (entry, i) {
              var c = this._instanceConstructor;
              var resolve$$1 = c.resolve;
              if (resolve$$1 === resolve$1) {
                var _then = getThen(entry);
                if (_then === then && entry._state !== PENDING) {
                  this._settledAt(entry._state, i, entry._result);
                } else if (typeof _then !== 'function') {
                  this._remaining--;
                  this._result[i] = entry;
                } else if (c === Promise$2) {
                  var promise = new c(noop);
                  handleMaybeThenable(promise, entry, _then);
                  this._willSettleAt(promise, i);
                } else {
                  this._willSettleAt(new c(function (resolve$$1) {
                    return resolve$$1(entry);
                  }), i);
                }
              } else {
                this._willSettleAt(resolve$$1(entry), i);
              }
            };
            Enumerator$1.prototype._settledAt = function (state, i, value) {
              var promise = this.promise;
              if (promise._state === PENDING) {
                this._remaining--;
                if (state === REJECTED) {
                  reject(promise, value);
                } else {
                  this._result[i] = value;
                }
              }
              if (this._remaining === 0) {
                fulfill(promise, this._result);
              }
            };
            Enumerator$1.prototype._willSettleAt = function (promise, i) {
              var enumerator = this;
              subscribe(promise, undefined, function (value) {
                return enumerator._settledAt(FULFILLED, i, value);
              }, function (reason) {
                return enumerator._settledAt(REJECTED, i, reason);
              });
            };
            /**
    `Promise.all` accepts an array of promises, and returns a new promise which
    is fulfilled with an array of fulfillment values for the passed promises, or
    rejected with the reason of the first passed promise to be rejected. It casts all
    elements of the passed iterable to promises as it runs this algorithm.
  
    Example:
  
    ```javascript
    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);
    let promises = [ promise1, promise2, promise3 ];
  
    Promise.all(promises).then(function(array){
      // The array here would be [ 1, 2, 3 ];
    });
    ```
  
    If any of the `promises` given to `all` are rejected, the first promise
    that is rejected will be given as an argument to the returned promises's
    rejection handler. For example:
  
    Example:
  
    ```javascript
    let promise1 = resolve(1);
    let promise2 = reject(new Error("2"));
    let promise3 = reject(new Error("3"));
    let promises = [ promise1, promise2, promise3 ];
  
    Promise.all(promises).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(error) {
      // error.message === "2"
    });
    ```
  
    @method all
    @static
    @param {Array} entries array of promises
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when all `promises` have been
    fulfilled, or rejected if any of them become rejected.
    @static
  */
            function all$1(entries) {
              return new Enumerator$1(this, entries).promise;
            }
            /**
    `Promise.race` returns a new promise which is settled in the same way as the
    first passed promise to settle.
  
    Example:
  
    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });
  
    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 2');
      }, 100);
    });
  
    Promise.race([promise1, promise2]).then(function(result){
      // result === 'promise 2' because it was resolved before promise1
      // was resolved.
    });
    ```
  
    `Promise.race` is deterministic in that only the state of the first
    settled promise matters. For example, even if other promises given to the
    `promises` array argument are resolved, but the first settled promise has
    become rejected before the other promises became fulfilled, the returned
    promise will become rejected:
  
    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });
  
    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        reject(new Error('promise 2'));
      }, 100);
    });
  
    Promise.race([promise1, promise2]).then(function(result){
      // Code here never runs
    }, function(reason){
      // reason.message === 'promise 2' because promise 2 became rejected before
      // promise 1 became fulfilled
    });
    ```
  
    An example real-world use case is implementing timeouts:
  
    ```javascript
    Promise.race([ajax('foo.json'), timeout(5000)])
    ```
  
    @method race
    @static
    @param {Array} promises array of promises to observe
    Useful for tooling.
    @return {Promise} a promise which settles in the same way as the first passed
    promise to settle.
  */
            function race$1(entries) {
              /*jshint validthis:true */
              var Constructor = this;
              if (!isArray(entries)) {
                return new Constructor(function (_, reject) {
                  return reject(new TypeError('You must pass an array to race.'));
                });
              } else {
                return new Constructor(function (resolve, reject) {
                  var length = entries.length;
                  for (var i = 0; i < length; i++) {
                    Constructor.resolve(entries[i]).then(resolve, reject);
                  }
                });
              }
            }
            /**
    `Promise.reject` returns a promise rejected with the passed `reason`.
    It is shorthand for the following:
  
    ```javascript
    let promise = new Promise(function(resolve, reject){
      reject(new Error('WHOOPS'));
    });
  
    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```
  
    Instead of writing the above, your code now simply becomes the following:
  
    ```javascript
    let promise = Promise.reject(new Error('WHOOPS'));
  
    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```
  
    @method reject
    @static
    @param {Any} reason value that the returned promise will be rejected with.
    Useful for tooling.
    @return {Promise} a promise rejected with the given `reason`.
  */
            function reject$1(reason) {
              /*jshint validthis:true */
              var Constructor = this;
              var promise = new Constructor(noop);
              reject(promise, reason);
              return promise;
            }
            function needsResolver() {
              throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
            }
            function needsNew() {
              throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
            }
            /**
    Promise objects represent the eventual result of an asynchronous operation. The
    primary way of interacting with a promise is through its `then` method, which
    registers callbacks to receive either a promise's eventual value or the reason
    why the promise cannot be fulfilled.
  
    Terminology
    -----------
  
    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
    - `thenable` is an object or function that defines a `then` method.
    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
    - `exception` is a value that is thrown using the throw statement.
    - `reason` is a value that indicates why a promise was rejected.
    - `settled` the final resting state of a promise, fulfilled or rejected.
  
    A promise can be in one of three states: pending, fulfilled, or rejected.
  
    Promises that are fulfilled have a fulfillment value and are in the fulfilled
    state.  Promises that are rejected have a rejection reason and are in the
    rejected state.  A fulfillment value is never a thenable.
  
    Promises can also be said to *resolve* a value.  If this value is also a
    promise, then the original promise's settled state will match the value's
    settled state.  So a promise that *resolves* a promise that rejects will
    itself reject, and a promise that *resolves* a promise that fulfills will
    itself fulfill.
  
  
    Basic Usage:
    ------------
  
    ```js
    let promise = new Promise(function(resolve, reject) {
      // on success
      resolve(value);
  
      // on failure
      reject(reason);
    });
  
    promise.then(function(value) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```
  
    Advanced Usage:
    ---------------
  
    Promises shine when abstracting away asynchronous interactions such as
    `XMLHttpRequest`s.
  
    ```js
    function getJSON(url) {
      return new Promise(function(resolve, reject){
        let xhr = new XMLHttpRequest();
  
        xhr.open('GET', url);
        xhr.onreadystatechange = handler;
        xhr.responseType = 'json';
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.send();
  
        function handler() {
          if (this.readyState === this.DONE) {
            if (this.status === 200) {
              resolve(this.response);
            } else {
              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
            }
          }
        };
      });
    }
  
    getJSON('/posts.json').then(function(json) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```
  
    Unlike callbacks, promises are great composable primitives.
  
    ```js
    Promise.all([
      getJSON('/posts'),
      getJSON('/comments')
    ]).then(function(values){
      values[0] // => postsJSON
      values[1] // => commentsJSON
  
      return values;
    });
    ```
  
    @class Promise
    @param {function} resolver
    Useful for tooling.
    @constructor
  */
            function Promise$2(resolver) {
              this[PROMISE_ID] = nextId();
              this._result = this._state = undefined;
              this._subscribers = [];
              if (noop !== resolver) {
                typeof resolver !== 'function' && needsResolver();
                this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
              }
            }
            Promise$2.all = all$1;
            Promise$2.race = race$1;
            Promise$2.resolve = resolve$1;
            Promise$2.reject = reject$1;
            Promise$2._setScheduler = setScheduler;
            Promise$2._setAsap = setAsap;
            Promise$2._asap = asap;
            Promise$2.prototype = {
              constructor: Promise$2,
              then: then,
              'catch': function _catch(onRejection) {
                return this.then(null, onRejection);
              }
            };
            /*global self*/
            function polyfill$1() {
              var local = undefined;
              if (typeof global !== 'undefined') {
                local = global;
              } else if (typeof self !== 'undefined') {
                local = self;
              } else {
                try {
                  local = Function('return this')();
                } catch (e) {
                  throw new Error('polyfill failed because global object is unavailable in this environment');
                }
              }
              var P = local.Promise;
              if (P) {
                var promiseToString = null;
                try {
                  promiseToString = Object.prototype.toString.call(P.resolve());
                } catch (e) {
                }
                if (promiseToString === '[object Promise]' && !P.cast) {
                  return;
                }
              }
              local.Promise = Promise$2;
            }
            // Strange compat..
            Promise$2.polyfill = polyfill$1;
            Promise$2.Promise = Promise$2;
            return Promise$2;
          }));
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      { '_process': 145 }
    ],
    13: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        function EventEmitter() {
          this._events = this._events || {};
          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        EventEmitter.defaultMaxListeners = 10;
        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function (n) {
          if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
          this._maxListeners = n;
          return this;
        };
        EventEmitter.prototype.emit = function (type) {
          var er, handler, len, args, i, listeners;
          if (!this._events)
            this._events = {};
          // If there is no 'error' event listener then throw.
          if (type === 'error') {
            if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
              er = arguments[1];
              if (er instanceof Error) {
                throw er;  // Unhandled 'error' event
              }
              throw TypeError('Uncaught, unspecified "error" event.');
            }
          }
          handler = this._events[type];
          if (isUndefined(handler))
            return false;
          if (isFunction(handler)) {
            switch (arguments.length) {
            // fast cases
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            // slower
            default:
              len = arguments.length;
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              handler.apply(this, args);
            }
          } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
              listeners[i].apply(this, args);
          }
          return true;
        };
        EventEmitter.prototype.addListener = function (type, listener) {
          var m;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events)
            this._events = {};
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (this._events.newListener)
            this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
          if (!this._events[type])
            // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
          else if (isObject(this._events[type]))
            // If we've already got an array, just append.
            this._events[type].push(listener);
          else
            // Adding the second element, need to change to array.
            this._events[type] = [
              this._events[type],
              listener
            ];
          // Check for listener leak
          if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
              m = this._maxListeners;
            } else {
              m = EventEmitter.defaultMaxListeners;
            }
            if (m && m > 0 && this._events[type].length > m) {
              this._events[type].warned = true;
              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
              if (typeof console.trace === 'function') {
                // not supported in IE 10
                console.trace();
              }
            }
          }
          return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function (type, listener) {
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          var fired = false;
          function g() {
            this.removeListener(type, g);
            if (!fired) {
              fired = true;
              listener.apply(this, arguments);
            }
          }
          g.listener = listener;
          this.on(type, g);
          return this;
        };
        // emits a 'removeListener' event iff the listener was removed
        EventEmitter.prototype.removeListener = function (type, listener) {
          var list, position, length, i;
          if (!isFunction(listener))
            throw TypeError('listener must be a function');
          if (!this._events || !this._events[type])
            return this;
          list = this._events[type];
          length = list.length;
          position = -1;
          if (list === listener || isFunction(list.listener) && list.listener === listener) {
            delete this._events[type];
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
              if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (list.length === 1) {
              list.length = 0;
              delete this._events[type];
            } else {
              list.splice(position, 1);
            }
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function (type) {
          var key, listeners;
          if (!this._events)
            return this;
          // not listening for removeListener, no need to emit
          if (!this._events.removeListener) {
            if (arguments.length === 0)
              this._events = {};
            else if (this._events[type])
              delete this._events[type];
            return this;
          }
          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            for (key in this._events) {
              if (key === 'removeListener')
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
          }
          listeners = this._events[type];
          if (isFunction(listeners)) {
            this.removeListener(type, listeners);
          } else {
            // LIFO order
            while (listeners.length)
              this.removeListener(type, listeners[listeners.length - 1]);
          }
          delete this._events[type];
          return this;
        };
        EventEmitter.prototype.listeners = function (type) {
          var ret;
          if (!this._events || !this._events[type])
            ret = [];
          else if (isFunction(this._events[type]))
            ret = [this._events[type]];
          else
            ret = this._events[type].slice();
          return ret;
        };
        EventEmitter.listenerCount = function (emitter, type) {
          var ret;
          if (!emitter._events || !emitter._events[type])
            ret = 0;
          else if (isFunction(emitter._events[type]))
            ret = 1;
          else
            ret = emitter._events[type].length;
          return ret;
        };
        function isFunction(arg) {
          return typeof arg === 'function';
        }
        function isNumber(arg) {
          return typeof arg === 'number';
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isUndefined(arg) {
          return arg === void 0;
        }
      },
      {}
    ],
    14: [
      function (require, module, exports) {
        'use strict';
        var hasOwn = Object.prototype.hasOwnProperty;
        var toString = Object.prototype.toString;
        module.exports = function forEach(obj, fn, ctx) {
          if (toString.call(fn) !== '[object Function]') {
            throw new TypeError('iterator must be a function');
          }
          var l = obj.length;
          if (l === +l) {
            for (var i = 0; i < l; i++) {
              fn.call(ctx, obj[i], i, obj);
            }
          } else {
            for (var k in obj) {
              if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
              }
            }
          }
        };
      },
      {}
    ],
    15: [
      function (require, module, exports) {
        'use strict';
        function format(fmt) {
          var re = /(%?)(%([jds]))/g, args = Array.prototype.slice.call(arguments, 1);
          if (args.length) {
            fmt = fmt.replace(re, function (match, escaped, ptn, flag) {
              var arg = args.shift();
              switch (flag) {
              case 's':
                arg = '' + arg;
                break;
              case 'd':
                arg = Number(arg);
                break;
              case 'j':
                arg = JSON.stringify(arg);
                break;
              }
              if (!escaped) {
                return arg;
              }
              args.unshift(arg);
              return match;
            });
          }
          // arguments remain after formatting
          if (args.length) {
            fmt += ' ' + args.join(' ');
          }
          // update escaped %% values
          fmt = fmt.replace(/%{2,2}/g, '%');
          return '' + fmt;
        }
        module.exports = format;
      },
      {}
    ],
    16: [
      function (require, module, exports) {
        var http = require('http');
        var https = module.exports;
        for (var key in http) {
          if (http.hasOwnProperty(key))
            https[key] = http[key];
        }
        ;
        https.request = function (params, cb) {
          if (!params)
            params = {};
          params.scheme = 'https';
          params.protocol = 'https:';
          return http.request.call(this, params, cb);
        };
      },
      { 'http': 168 }
    ],
    17: [
      function (require, module, exports) {
        'use strict';
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      },
      {}
    ],
    18: [
      function (require, module, exports) {
        'use strict';
        var indexOf = [].indexOf;
        module.exports = function (arr, obj) {
          if (indexOf)
            return arr.indexOf(obj);
          for (var i = 0; i < arr.length; ++i) {
            if (arr[i] === obj)
              return i;
          }
          return -1;
        };
      },
      {}
    ],
    19: [
      function (require, module, exports) {
        'use strict';
        if (typeof Object.create === 'function') {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      },
      {}
    ],
    20: [
      function (require, module, exports) {
        'use strict';
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
        }
        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
        }
      },
      {}
    ],
    21: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var JsonSchemaCompatability = function () {
            function convert3to4Type(types, always) {
              if (!Array.isArray(types)) {
                types = [types];
              }
              var needsReplacement = !!always;
              var result = [];
              for (var i = 0; i < types.length; i++) {
                var entry = types[i];
                if ((typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) === 'object') {
                  result.push(entry);
                  needsReplacement = true;
                } else {
                  result.push({ 'type': entry });
                }
              }
              return needsReplacement && result;
            }
            function convert3to4(obj) {
              // Old-style "type"
              if (obj.type) {
                if (typeof obj.type !== 'string') {
                  var anyOf = convert3to4Type(obj.type);
                  if (anyOf) {
                    obj.anyOf = anyOf;
                    delete obj.type;
                  }
                } else if (obj.type == 'any') {
                  delete obj.type;
                }
              }
              if (obj['extends']) {
                var allOf = obj['extends'];
                if (!Array.isArray(allOf)) {
                  allOf = [allOf];
                }
                obj.allOf = allOf;
                delete obj['extends'];
              }
              if (obj.disallow) {
                if (typeof obj.disallow === 'string') {
                  obj.not = { 'type': obj.disallow };
                } else {
                  obj.not = { 'anyOf': convert3to4Type(obj.disallow, true) };
                }
                delete obj.disallow;
              }
              // Object concerns
              if (obj.properties) {
                var required = Array.isArray(obj.required) ? obj.required : [];
                for (var key in obj.properties) {
                  var subSchema = obj.properties[key];
                  if (subSchema && typeof subSchema.required === 'boolean') {
                    if (subSchema.required) {
                      required.push(key);
                    }
                    delete subSchema.required;
                  }
                }
                if (required.length) {
                  obj.required = required;
                }
              }
              if (obj.dependencies) {
                for (var key in obj.dependencies) {
                  if (typeof obj.dependencies[key] === 'string') {
                    obj.dependencies[key] = [obj.dependencies[key]];
                  }
                }
              }
              // This is safe as long as we process our children *after* we collect their "required" properties
              // - otherwise, they'd delete their "required" booleans before we got a chance to see them
              if (typeof obj.required === 'boolean') {
                delete obj.required;
              }
              // Numeric concerns
              if (typeof obj.divisibleBy !== 'undefined') {
                obj.multipleOf = obj.divisibleBy;
                delete obj.divisibleBy;
              }
              // This MUST happen at the end of the function, otherwise it'll screw up "required" collection
              for (var key in obj) {
                if (key === 'properties' || key === 'patternProperties' || key === 'dependencies') {
                  for (var subKey in obj[key]) {
                    obj[key][subKey] = convert3to4(obj[key][subKey]);
                  }
                } else if (key !== 'enum') {
                  if (Array.isArray(obj[key])) {
                    for (var i = 0; i < obj[key].length; i++) {
                      obj[key][i] = convert3to4(obj[key][i]);
                    }
                  } else if (_typeof(obj[key]) === 'object') {
                    obj[key] = convert3to4(obj[key]);
                  }
                }
              }
              return obj;
            }
            var api = { v4: convert3to4 };
            if (typeof module !== 'undefined') {
              module.exports = api;
            }
            return api;
          }();
      },
      {}
    ],
    22: [
      function (require, module, exports) {
        /** !
 * JSON Schema $Ref Parser v3.3.1
 *
 * @link https://github.com/BigstickCarpet/json-schema-ref-parser
 * @license MIT
 */
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var $Ref = require('./ref'), Pointer = require('./pointer'), debug = require('./util/debug'), url = require('./util/url');
        module.exports = bundle;
        /**
 * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that
 * only has *internal* references, not any *external* references.
 * This method mutates the JSON schema object, adding new references and re-mapping existing ones.
 *
 * @param {$RefParser} parser
 * @param {$RefParserOptions} options
 */
        function bundle(parser, options) {
          debug('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);
          // Build an inventory of all $ref pointers in the JSON Schema
          var inventory = [];
          crawl(parser, 'schema', parser.$refs._root$Ref.path + '#', '#', inventory, parser.$refs, options);
          // Remap all $ref pointers
          remap(inventory);
        }
        /**
 * Recursively crawls the given value, and inventories all JSON references.
 *
 * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.
 * @param {string} key - The property key of `parent` to be crawled
 * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of the property being crawled, from the schema root
 * @param {object[]} inventory - An array of already-inventoried $ref pointers
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 */
        function crawl(parent, key, path, pathFromRoot, inventory, $refs, options) {
          var obj = key === null ? parent : parent[key];
          if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
            if ($Ref.isAllowed$Ref(obj)) {
              inventory$Ref(parent, key, path, pathFromRoot, inventory, $refs, options);
            } else {
              var keys = Object.keys(obj);
              // Most people will expect references to be bundled into the the "definitions" property,
              // so we always crawl that property first, if it exists.
              var defs = keys.indexOf('definitions');
              if (defs > 0) {
                keys.splice(0, 0, keys.splice(defs, 1)[0]);
              }
              keys.forEach(function (key) {
                var keyPath = Pointer.join(path, key);
                var keyPathFromRoot = Pointer.join(pathFromRoot, key);
                var value = obj[key];
                if ($Ref.isAllowed$Ref(value)) {
                  inventory$Ref(obj, key, path, keyPathFromRoot, inventory, $refs, options);
                } else {
                  crawl(obj, key, keyPath, keyPathFromRoot, inventory, $refs, options);
                }
              });
            }
          }
        }
        /**
 * Inventories the given JSON Reference (i.e. records detailed information about it so we can
 * optimize all $refs in the schema), and then crawls the resolved value.
 *
 * @param {object} $refParent - The object that contains a JSON Reference as one of its keys
 * @param {string} $refKey - The key in `$refParent` that is a JSON Reference
 * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root
 * @param {object[]} inventory - An array of already-inventoried $ref pointers
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 */
        function inventory$Ref($refParent, $refKey, path, pathFromRoot, inventory, $refs, options) {
          if (inventory.some(function (i) {
              return i.parent === $refParent && i.key === $refKey;
            })) {
            // This $Ref has already been inventoried, so we don't need to process it again
            return;
          }
          var $ref = $refKey === null ? $refParent : $refParent[$refKey];
          var $refPath = url.resolve(path, $ref.$ref);
          var pointer = $refs._resolve($refPath, options);
          var depth = Pointer.parse(pathFromRoot).length;
          var file = url.stripHash(pointer.path);
          var hash = url.getHash(pointer.path);
          var external = file !== $refs._root$Ref.path;
          var extended = $Ref.isExtended$Ref($ref);
          inventory.push({
            $ref: $ref,
            parent: $refParent,
            key: $refKey,
            pathFromRoot: pathFromRoot,
            depth: depth,
            file: file,
            hash: hash,
            value: pointer.value,
            circular: pointer.circular,
            extended: extended,
            external: external
          });
          // Recursively crawl the resolved value
          crawl(pointer.value, null, pointer.path, pathFromRoot, inventory, $refs, options);
        }
        /**
 * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.
 * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same
 * value are re-mapped to point to the first reference.
 *
 * @example:
 *  {
 *    first: { $ref: somefile.json#/some/part },
 *    second: { $ref: somefile.json#/another/part },
 *    third: { $ref: somefile.json },
 *    fourth: { $ref: somefile.json#/some/part/sub/part }
 *  }
 *
 * In this example, there are four references to the same file, but since the third reference points
 * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be
 * remapped to point inside the third one.
 *
 * On the other hand, if the third reference DIDN'T exist, then the first and second would both need
 * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT
 * need to be dereferenced, because it can be remapped to point inside the first one.
 *
 * @param {object[]} inventory
 */
        function remap(inventory) {
          // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them
          inventory.sort(function (a, b) {
            if (a.file !== b.file) {
              return a.file < b.file ? -1 : +1;  // Group all the $refs that point to the same file
            } else if (a.hash !== b.hash) {
              return a.hash < b.hash ? -1 : +1;  // Group all the $refs that point to the same part of the file
            } else if (a.circular !== b.circular) {
              return a.circular ? -1 : +1;  // If the $ref points to itself, then sort it higher than other $refs that point to this $ref
            } else if (a.extended !== b.extended) {
              return a.extended ? +1 : -1;  // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value
            } else if (a.depth !== b.depth) {
              return a.depth - b.depth;  // Sort $refs by how close they are to the JSON Schema root
            } else {
              // If all else is equal, use the $ref that's in the "definitions" property
              return b.pathFromRoot.lastIndexOf('/definitions') - a.pathFromRoot.lastIndexOf('/definitions');
            }
          });
          var file, hash, pathFromRoot;
          inventory.forEach(function (i) {
            debug('Re-mapping $ref pointer "%s" at %s', i.$ref.$ref, i.pathFromRoot);
            if (!i.external) {
              // This $ref already resolves to the main JSON Schema file
              i.$ref.$ref = i.hash;
            } else if (i.file === file && i.hash === hash) {
              // This $ref points to the same value as the prevous $ref, so remap it to the same path
              i.$ref.$ref = pathFromRoot;
            } else if (i.file === file && i.hash.indexOf(hash + '/') === 0) {
              // This $ref points to the a sub-value as the prevous $ref, so remap it beneath that path
              i.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(i.hash));
            } else {
              // We've moved to a new file or new hash
              file = i.file;
              hash = i.hash;
              pathFromRoot = i.pathFromRoot;
              // This is the first $ref to point to this value, so dereference the value.
              // Any other $refs that point to the same value will point to this $ref instead
              i.$ref = i.parent[i.key] = $Ref.dereference(i.$ref, i.value);
              if (i.circular) {
                // This $ref points to itself
                i.$ref.$ref = i.pathFromRoot;
              }
            }
            debug('    new value: %s', i.$ref && i.$ref.$ref ? i.$ref.$ref : '[object Object]');
          });
        }
      },
      {
        './pointer': 31,
        './ref': 32,
        './util/debug': 37,
        './util/url': 40
      }
    ],
    23: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var $Ref = require('./ref'), Pointer = require('./pointer'), ono = require('ono'), debug = require('./util/debug'), url = require('./util/url');
        module.exports = dereference;
        /**
 * Crawls the JSON schema, finds all JSON references, and dereferences them.
 * This method mutates the JSON schema object, replacing JSON references with their resolved value.
 *
 * @param {$RefParser} parser
 * @param {$RefParserOptions} options
 */
        function dereference(parser, options) {
          debug('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);
          var dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, '#', [], parser.$refs, options);
          parser.$refs.circular = dereferenced.circular;
          parser.schema = dereferenced.value;
        }
        /**
 * Recursively crawls the given value, and dereferences any JSON references.
 *
 * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
 * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of `obj` from the schema root
 * @param {object[]} parents - An array of the parent objects that have already been dereferenced
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 * @returns {{value: object, circular: boolean}}
 */
        function crawl(obj, path, pathFromRoot, parents, $refs, options) {
          var dereferenced;
          var result = {
              value: obj,
              circular: false
            };
          if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
            parents.push(obj);
            if ($Ref.isAllowed$Ref(obj, options)) {
              dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, $refs, options);
              result.circular = dereferenced.circular;
              result.value = dereferenced.value;
            } else {
              Object.keys(obj).forEach(function (key) {
                var keyPath = Pointer.join(path, key);
                var keyPathFromRoot = Pointer.join(pathFromRoot, key);
                var value = obj[key];
                var circular = false;
                if ($Ref.isAllowed$Ref(value, options)) {
                  dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, $refs, options);
                  circular = dereferenced.circular;
                  obj[key] = dereferenced.value;
                } else {
                  if (parents.indexOf(value) === -1) {
                    dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, $refs, options);
                    circular = dereferenced.circular;
                    obj[key] = dereferenced.value;
                  } else {
                    circular = foundCircularReference(keyPath, $refs, options);
                  }
                }
                // Set the "isCircular" flag if this or any other property is circular
                result.circular = result.circular || circular;
              });
            }
            parents.pop();
          }
          return result;
        }
        /**
 * Dereferences the given JSON Reference, and then crawls the resulting value.
 *
 * @param {{$ref: string}} $ref - The JSON Reference to resolve
 * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
 * @param {string} pathFromRoot - The path of `$ref` from the schema root
 * @param {object[]} parents - An array of the parent objects that have already been dereferenced
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 * @returns {{value: object, circular: boolean}}
 */
        function dereference$Ref($ref, path, pathFromRoot, parents, $refs, options) {
          debug('Dereferencing $ref pointer "%s" at %s', $ref.$ref, path);
          var $refPath = url.resolve(path, $ref.$ref);
          var pointer = $refs._resolve($refPath, options);
          // Check for circular references
          var directCircular = pointer.circular;
          var circular = directCircular || parents.indexOf(pointer.value) !== -1;
          circular && foundCircularReference(path, $refs, options);
          // Dereference the JSON reference
          var dereferencedValue = $Ref.dereference($ref, pointer.value);
          // Crawl the dereferenced value (unless it's circular)
          if (!circular) {
            // Determine if the dereferenced value is circular
            var dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, $refs, options);
            circular = dereferenced.circular;
            dereferencedValue = dereferenced.value;
          }
          if (circular && !directCircular && options.dereference.circular === 'ignore') {
            // The user has chosen to "ignore" circular references, so don't change the value
            dereferencedValue = $ref;
          }
          if (directCircular) {
            // The pointer is a DIRECT circular reference (i.e. it references itself).
            // So replace the $ref path with the absolute path from the JSON Schema root
            dereferencedValue.$ref = pathFromRoot;
          }
          return {
            circular: circular,
            value: dereferencedValue
          };
        }
        /**
 * Called when a circular reference is found.
 * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.
 *
 * @param {string} keyPath - The JSON Reference path of the circular reference
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 * @returns {boolean} - always returns true, to indicate that a circular reference was found
 */
        function foundCircularReference(keyPath, $refs, options) {
          $refs.circular = true;
          if (!options.dereference.circular) {
            throw ono.reference('Circular $ref pointer found at %s', keyPath);
          }
          return true;
        }
      },
      {
        './pointer': 31,
        './ref': 32,
        './util/debug': 37,
        './util/url': 40,
        'ono': 76
      }
    ],
    24: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          var Promise = require('./util/promise'), Options = require('./options'), $Refs = require('./refs'), parse = require('./parse'), resolveExternal = require('./resolve-external'), bundle = require('./bundle'), dereference = require('./dereference'), url = require('./util/url'), maybe = require('call-me-maybe'), ono = require('ono');
          module.exports = $RefParser;
          module.exports.YAML = require('./util/yaml');
          /**
 * This class parses a JSON schema, builds a map of its JSON references and their resolved values,
 * and provides methods for traversing, manipulating, and dereferencing those references.
 *
 * @constructor
 */
          function $RefParser() {
            /**
   * The parsed (and possibly dereferenced) JSON schema object
   *
   * @type {object}
   * @readonly
   */
            this.schema = null;
            /**
   * The resolved JSON references
   *
   * @type {$Refs}
   * @readonly
   */
            this.$refs = new $Refs();
          }
          /**
 * Parses the given JSON schema.
 * This method does not resolve any JSON references.
 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
 * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
 */
          $RefParser.parse = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.parse.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema.
 * This method does not resolve any JSON references.
 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
 * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
 */
          $RefParser.prototype.parse = function (schema, options, callback) {
            var args = normalizeArgs(arguments);
            var promise;
            if (!args.path && !args.schema) {
              var err = ono('Expected a file path, URL, or object. Got %s', args.path || args.schema);
              return maybe(args.callback, Promise.reject(err));
            }
            // Reset everything
            this.schema = null;
            this.$refs = new $Refs();
            // If the path is a filesystem path, then convert it to a URL.
            // NOTE: According to the JSON Reference spec, these should already be URLs,
            // but, in practice, many people use local filesystem paths instead.
            // So we're being generous here and doing the conversion automatically.
            // This is not intended to be a 100% bulletproof solution.
            // If it doesn't work for your use-case, then use a URL instead.
            if (url.isFileSystemPath(args.path)) {
              args.path = url.fromFileSystemPath(args.path);
            }
            // Resolve the absolute path of the schema
            args.path = url.resolve(url.cwd(), args.path);
            if (args.schema && _typeof(args.schema) === 'object') {
              // A schema object was passed-in.
              // So immediately add a new $Ref with the schema object as its value
              this.$refs._add(args.path, args.schema);
              promise = Promise.resolve(args.schema);
            } else {
              // Parse the schema file/url
              promise = parse(args.path, this.$refs, args.options);
            }
            var me = this;
            return promise.then(function (result) {
              if (!result || (typeof result === 'undefined' ? 'undefined' : _typeof(result)) !== 'object' || Buffer.isBuffer(result)) {
                throw ono.syntax('"%s" is not a valid JSON Schema', me.$refs._root$Ref.path || result);
              } else {
                me.schema = result;
                return maybe(args.callback, Promise.resolve(me.schema));
              }
            }).catch(function (e) {
              return maybe(args.callback, Promise.reject(e));
            });
          };
          /**
 * Parses the given JSON schema and resolves any JSON references, including references in
 * externally-referenced files.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
 * @param {function} [callback]
 * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
 *
 * @returns {Promise}
 * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
 */
          $RefParser.resolve = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.resolve.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema and resolves any JSON references, including references in
 * externally-referenced files.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
 * @param {function} [callback]
 * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
 *
 * @returns {Promise}
 * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
 */
          $RefParser.prototype.resolve = function (schema, options, callback) {
            var me = this;
            var args = normalizeArgs(arguments);
            return this.parse(args.path, args.schema, args.options).then(function () {
              return resolveExternal(me, args.options);
            }).then(function () {
              return maybe(args.callback, Promise.resolve(me.$refs));
            }).catch(function (err) {
              return maybe(args.callback, Promise.reject(err));
            });
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and bundles all external references
 * into the main JSON schema. This produces a JSON schema that only has *internal* references,
 * not any *external* references.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
 * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
 */
          $RefParser.bundle = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.bundle.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and bundles all external references
 * into the main JSON schema. This produces a JSON schema that only has *internal* references,
 * not any *external* references.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
 * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
 */
          $RefParser.prototype.bundle = function (schema, options, callback) {
            var me = this;
            var args = normalizeArgs(arguments);
            return this.resolve(args.path, args.schema, args.options).then(function () {
              bundle(me, args.options);
              return maybe(args.callback, Promise.resolve(me.schema));
            }).catch(function (err) {
              return maybe(args.callback, Promise.reject(err));
            });
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
 * That is, all JSON references are replaced with their resolved values.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
 * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
 */
          $RefParser.dereference = function (schema, options, callback) {
            var Class = this;
            // eslint-disable-line consistent-this
            var instance = new Class();
            return instance.dereference.apply(instance, arguments);
          };
          /**
 * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
 * That is, all JSON references are replaced with their resolved values.
 *
 * @param {string|object} schema - The file path or URL of the JSON schema. Or a JSON schema object.
 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
 * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
 * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
 */
          $RefParser.prototype.dereference = function (schema, options, callback) {
            var me = this;
            var args = normalizeArgs(arguments);
            return this.resolve(args.path, args.schema, args.options).then(function () {
              dereference(me, args.options);
              return maybe(args.callback, Promise.resolve(me.schema));
            }).catch(function (err) {
              return maybe(args.callback, Promise.reject(err));
            });
          };
          /**
 * Normalizes the given arguments, accounting for optional args.
 *
 * @param {Arguments} args
 * @returns {object}
 */
          function normalizeArgs(args) {
            var path, schema, options, callback;
            args = Array.prototype.slice.call(args);
            if (typeof args[args.length - 1] === 'function') {
              // The last parameter is a callback function
              callback = args.pop();
            }
            if (typeof args[0] === 'string') {
              // The first parameter is the path
              path = args[0];
              if (_typeof(args[2]) === 'object') {
                // The second parameter is the schema, and the third parameter is the options
                schema = args[1];
                options = args[2];
              } else {
                // The second parameter is the options
                schema = undefined;
                options = args[1];
              }
            } else {
              // The first parameter is the schema
              path = '';
              schema = args[0];
              options = args[1];
            }
            if (!(options instanceof Options)) {
              options = new Options(options);
            }
            return {
              path: path,
              schema: schema,
              options: options,
              callback: callback
            };
          }
        }.call(this, { 'isBuffer': require('../../is-buffer/index.js') }));
      },
      {
        '../../is-buffer/index.js': 20,
        './bundle': 22,
        './dereference': 23,
        './options': 25,
        './parse': 26,
        './refs': 33,
        './resolve-external': 34,
        './util/promise': 39,
        './util/url': 40,
        './util/yaml': 41,
        'call-me-maybe': 8,
        'ono': 76
      }
    ],
    25: [
      function (require, module, exports) {
        /* eslint lines-around-comment: [2, {beforeBlockComment: false}] */
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var jsonParser = require('./parsers/json'), yamlParser = require('./parsers/yaml'), textParser = require('./parsers/text'), binaryParser = require('./parsers/binary'), fileResolver = require('./resolvers/file'), httpResolver = require('./resolvers/http'), zschemaValidator = require('./validators/z-schema');
        module.exports = $RefParserOptions;
        /**
 * Options that determine how JSON schemas are parsed, resolved, dereferenced, and validated.
 *
 * @param {object|$RefParserOptions} [options] - Overridden options
 * @constructor
 */
        function $RefParserOptions(options) {
          merge(this, $RefParserOptions.defaults);
          merge(this, options);
        }
        $RefParserOptions.defaults = {
          parse: {
            json: jsonParser,
            yaml: yamlParser,
            text: textParser,
            binary: binaryParser
          },
          resolve: {
            file: fileResolver,
            http: httpResolver,
            external: true
          },
          dereference: { circular: true },
          validate: { zschema: zschemaValidator }
        };
        /**
 * Merges the properties of the source object into the target object.
 *
 * @param {object} target - The object that we're populating
 * @param {?object} source - The options that are being merged
 * @returns {object}
 */
        function merge(target, source) {
          if (isMergeable(source)) {
            var keys = Object.keys(source);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var sourceSetting = source[key];
              var targetSetting = target[key];
              if (isMergeable(sourceSetting)) {
                // It's a nested object, so merge it recursively
                target[key] = merge(targetSetting || {}, sourceSetting);
              } else if (sourceSetting !== undefined) {
                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.
                target[key] = sourceSetting;
              }
            }
          }
          return target;
        }
        /**
 * Determines whether the given value can be merged,
 * or if it is a scalar value that should just override the target value.
 *
 * @param   {*}  val
 * @returns {Boolean}
 */
        function isMergeable(val) {
          return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);
        }
      },
      {
        './parsers/binary': 27,
        './parsers/json': 28,
        './parsers/text': 29,
        './parsers/yaml': 30,
        './resolvers/file': 35,
        './resolvers/http': 36,
        './validators/z-schema': 42
      }
    ],
    26: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          var ono = require('ono'), debug = require('./util/debug'), url = require('./util/url'), plugins = require('./util/plugins'), Promise = require('./util/promise');
          module.exports = parse;
          /**
 * Reads and parses the specified file path or URL.
 *
 * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.
 */
          function parse(path, $refs, options) {
            try {
              // Remove the URL fragment, if any
              path = url.stripHash(path);
              // Add a new $Ref for this file, even though we don't have the value yet.
              // This ensures that we don't simultaneously read & parse the same file multiple times
              var $ref = $refs._add(path);
              // This "file object" will be passed to all resolvers and parsers.
              var file = {
                  url: path,
                  extension: url.getExtension(path)
                };
              // Read the file and then parse the data
              return readFile(file, options).then(function (resolver) {
                $ref.pathType = resolver.plugin.name;
                file.data = resolver.result;
                return parseFile(file, options);
              }).then(function (parser) {
                $ref.value = parser.result;
                return parser.result;
              });
            } catch (e) {
              return Promise.reject(e);
            }
          }
          /**
 * Reads the given file, using the configured resolver plugins
 *
 * @param {object} file           - An object containing information about the referenced file
 * @param {string} file.url       - The full URL of the referenced file
 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves with the raw file contents and the resolver that was used.
 */
          function readFile(file, options) {
            return new Promise(function (resolve, reject) {
              debug('Reading %s', file.url);
              // Find the resolvers that can read this file
              var resolvers = plugins.all(options.resolve);
              resolvers = plugins.filter(resolvers, 'canRead', file);
              // Run the resolvers, in order, until one of them succeeds
              plugins.sort(resolvers);
              plugins.run(resolvers, 'read', file).then(resolve, onError);
              function onError(err) {
                // Throw the original error, if it's one of our own (user-friendly) errors.
                // Otherwise, throw a generic, friendly error.
                if (err && !(err instanceof SyntaxError)) {
                  reject(err);
                } else {
                  reject(ono.syntax('Unable to resolve $ref pointer "%s"', file.url));
                }
              }
            });
          }
          /**
 * Parses the given file's contents, using the configured parser plugins.
 *
 * @param {object} file           - An object containing information about the referenced file
 * @param {string} file.url       - The full URL of the referenced file
 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves with the parsed file contents and the parser that was used.
 */
          function parseFile(file, options) {
            return new Promise(function (resolve, reject) {
              debug('Parsing %s', file.url);
              // Find the parsers that can read this file type.
              // If none of the parsers are an exact match for this file, then we'll try ALL of them.
              // This handles situations where the file IS a supported type, just with an unknown extension.
              var allParsers = plugins.all(options.parse);
              var filteredParsers = plugins.filter(allParsers, 'canParse', file);
              var parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
              // Run the parsers, in order, until one of them succeeds
              plugins.sort(parsers);
              plugins.run(parsers, 'parse', file).then(onParsed, onError);
              function onParsed(parser) {
                if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
                  reject(ono.syntax('Error parsing "%s" as %s. \nParsed value is empty', file.url, parser.plugin.name));
                } else {
                  resolve(parser);
                }
              }
              function onError(err) {
                if (err) {
                  err = err instanceof Error ? err : new Error(err);
                  reject(ono.syntax(err, 'Error parsing %s', file.url));
                } else {
                  reject(ono.syntax('Unable to parse %s', file.url));
                }
              }
            });
          }
          /**
 * Determines whether the parsed value is "empty".
 *
 * @param {*} value
 * @returns {boolean}
 */
          function isEmpty(value) {
            return value === undefined || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;
          }
        }.call(this, { 'isBuffer': require('../../is-buffer/index.js') }));
      },
      {
        '../../is-buffer/index.js': 20,
        './util/debug': 37,
        './util/plugins': 38,
        './util/promise': 39,
        './util/url': 40,
        'ono': 76
      }
    ],
    27: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
          module.exports = {
            order: 400,
            allowEmpty: true,
            canParse: function isBinary(file) {
              // Use this parser if the file is a Buffer, and has a known binary extension
              return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
            },
            parse: function parseBinary(file) {
              if (Buffer.isBuffer(file.data)) {
                return file.data;
              } else {
                // This will reject if data is anything other than a string or typed array
                return new Buffer(file.data);
              }
            }
          };
        }.call(this, require('buffer').Buffer));
      },
      { 'buffer': 5 }
    ],
    28: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var Promise = require('../util/promise');
          module.exports = {
            order: 100,
            allowEmpty: true,
            canParse: '.json',
            parse: function parseJSON(file) {
              return new Promise(function (resolve, reject) {
                var data = file.data;
                if (Buffer.isBuffer(data)) {
                  data = data.toString();
                }
                if (typeof data === 'string') {
                  if (data.trim().length === 0) {
                    resolve(undefined);  // This mirrors the YAML behavior
                  } else {
                    resolve(JSON.parse(data));
                  }
                } else {
                  // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                  resolve(data);
                }
              });
            }
          };
        }.call(this, { 'isBuffer': require('../../../is-buffer/index.js') }));
      },
      {
        '../../../is-buffer/index.js': 20,
        '../util/promise': 39
      }
    ],
    29: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
          module.exports = {
            order: 300,
            allowEmpty: true,
            encoding: 'utf8',
            canParse: function isText(file) {
              // Use this parser if the file is a string or Buffer, and has a known text-based extension
              return (typeof file.data === 'string' || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
            },
            parse: function parseText(file) {
              if (typeof file.data === 'string') {
                return file.data;
              } else if (Buffer.isBuffer(file.data)) {
                return file.data.toString(this.encoding);
              } else {
                throw new Error('data is not text');
              }
            }
          };
        }.call(this, { 'isBuffer': require('../../../is-buffer/index.js') }));
      },
      { '../../../is-buffer/index.js': 20 }
    ],
    30: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var Promise = require('../util/promise'), YAML = require('../util/yaml');
          module.exports = {
            order: 200,
            allowEmpty: true,
            canParse: [
              '.yaml',
              '.yml',
              '.json'
            ],
            parse: function parseYAML(file) {
              return new Promise(function (resolve, reject) {
                var data = file.data;
                if (Buffer.isBuffer(data)) {
                  data = data.toString();
                }
                if (typeof data === 'string') {
                  resolve(YAML.parse(data));
                } else {
                  // data is already a JavaScript value (object, array, number, null, NaN, etc.)
                  resolve(data);
                }
              });
            }
          };
        }.call(this, { 'isBuffer': require('../../../is-buffer/index.js') }));
      },
      {
        '../../../is-buffer/index.js': 20,
        '../util/promise': 39,
        '../util/yaml': 41
      }
    ],
    31: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        module.exports = Pointer;
        var $Ref = require('./ref'), url = require('./util/url'), ono = require('ono'), slashes = /\//g, tildes = /~/g, escapedSlash = /~1/g, escapedTilde = /~0/g;
        /**
 * This class represents a single JSON pointer and its resolved value.
 *
 * @param {$Ref} $ref
 * @param {string} path
 * @constructor
 */
        function Pointer($ref, path) {
          /**
   * The {@link $Ref} object that contains this {@link Pointer} object.
   * @type {$Ref}
   */
          this.$ref = $ref;
          /**
   * The file path or URL, containing the JSON pointer in the hash.
   * This path is relative to the path of the main JSON schema file.
   * @type {string}
   */
          this.path = path;
          /**
   * The value of the JSON pointer.
   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
   * @type {?*}
   */
          this.value = undefined;
          /**
   * Indicates whether the pointer references itself.
   * @type {boolean}
   */
          this.circular = false;
        }
        /**
 * Resolves the value of a nested property within the given object.
 *
 * @param {*} obj - The object that will be crawled
 * @param {$RefParserOptions} options
 *
 * @returns {Pointer}
 * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.
 * If resolving this value required resolving other JSON references, then
 * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path
 * of the resolved value.
 */
        Pointer.prototype.resolve = function (obj, options) {
          var tokens = Pointer.parse(this.path);
          // Crawl the object, one token at a time
          this.value = obj;
          for (var i = 0; i < tokens.length; i++) {
            if (resolveIf$Ref(this, options)) {
              // The $ref path has changed, so append the remaining tokens to the path
              this.path = Pointer.join(this.path, tokens.slice(i));
            }
            var token = tokens[i];
            if (this.value[token] === undefined) {
              throw ono.syntax('Error resolving $ref pointer "%s". \nToken "%s" does not exist.', this.path, token);
            } else {
              this.value = this.value[token];
            }
          }
          // Resolve the final value
          resolveIf$Ref(this, options);
          return this;
        };
        /**
 * Sets the value of a nested property within the given object.
 *
 * @param {*} obj - The object that will be crawled
 * @param {*} value - the value to assign
 * @param {$RefParserOptions} options
 *
 * @returns {*}
 * Returns the modified object, or an entirely new object if the entire object is overwritten.
 */
        Pointer.prototype.set = function (obj, value, options) {
          var tokens = Pointer.parse(this.path);
          var token;
          if (tokens.length === 0) {
            // There are no tokens, replace the entire object with the new value
            this.value = value;
            return value;
          }
          // Crawl the object, one token at a time
          this.value = obj;
          for (var i = 0; i < tokens.length - 1; i++) {
            resolveIf$Ref(this, options);
            token = tokens[i];
            if (this.value && this.value[token] !== undefined) {
              // The token exists
              this.value = this.value[token];
            } else {
              // The token doesn't exist, so create it
              this.value = setValue(this, token, {});
            }
          }
          // Set the value of the final token
          resolveIf$Ref(this, options);
          token = tokens[tokens.length - 1];
          setValue(this, token, value);
          // Return the updated object
          return obj;
        };
        /**
 * Parses a JSON pointer (or a path containing a JSON pointer in the hash)
 * and returns an array of the pointer's tokens.
 * (e.g. "schema.json#/definitions/person/name" => ["definitions", "person", "name"])
 *
 * The pointer is parsed according to RFC 6901
 * {@link https://tools.ietf.org/html/rfc6901#section-3}
 *
 * @param {string} path
 * @returns {string[]}
 */
        Pointer.parse = function (path) {
          // Get the JSON pointer from the path's hash
          var pointer = url.getHash(path).substr(1);
          // If there's no pointer, then there are no tokens,
          // so return an empty array
          if (!pointer) {
            return [];
          }
          // Split into an array
          pointer = pointer.split('/');
          // Decode each part, according to RFC 6901
          for (var i = 0; i < pointer.length; i++) {
            pointer[i] = decodeURI(pointer[i].replace(escapedSlash, '/').replace(escapedTilde, '~'));
          }
          if (pointer[0] !== '') {
            throw ono.syntax('Invalid $ref pointer "%s". Pointers must begin with "#/"', pointer);
          }
          return pointer.slice(1);
        };
        /**
 * Creates a JSON pointer path, by joining one or more tokens to a base path.
 *
 * @param {string} base - The base path (e.g. "schema.json#/definitions/person")
 * @param {string|string[]} tokens - The token(s) to append (e.g. ["name", "first"])
 * @returns {string}
 */
        Pointer.join = function (base, tokens) {
          // Ensure that the base path contains a hash
          if (base.indexOf('#') === -1) {
            base += '#';
          }
          // Append each token to the base path
          tokens = Array.isArray(tokens) ? tokens : [tokens];
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            // Encode the token, according to RFC 6901
            base += '/' + encodeURI(token.replace(tildes, '~0').replace(slashes, '~1'));
          }
          return base;
        };
        /**
 * If the given pointer's {@link Pointer#value} is a JSON reference,
 * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.
 * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the
 * resolution path of the new value.
 *
 * @param {Pointer} pointer
 * @param {$RefParserOptions} options
 * @returns {boolean} - Returns `true` if the resolution path changed
 */
        function resolveIf$Ref(pointer, options) {
          // Is the value a JSON reference? (and allowed?)
          if ($Ref.isAllowed$Ref(pointer.value, options)) {
            var $refPath = url.resolve(pointer.path, pointer.value.$ref);
            if ($refPath === pointer.path) {
              // The value is a reference to itself, so there's nothing to do.
              pointer.circular = true;
            } else {
              var resolved = pointer.$ref.$refs._resolve($refPath, options);
              if ($Ref.isExtended$Ref(pointer.value)) {
                // This JSON reference "extends" the resolved value, rather than simply pointing to it.
                // So the resolved path does NOT change.  Just the value does.
                pointer.value = $Ref.dereference(pointer.value, resolved.value);
              } else {
                // Resolve the reference
                pointer.$ref = resolved.$ref;
                pointer.path = resolved.path;
                pointer.value = resolved.value;
              }
              return true;
            }
          }
        }
        /**
 * Sets the specified token value of the {@link Pointer#value}.
 *
 * The token is evaluated according to RFC 6901.
 * {@link https://tools.ietf.org/html/rfc6901#section-4}
 *
 * @param {Pointer} pointer - The JSON Pointer whose value will be modified
 * @param {string} token - A JSON Pointer token that indicates how to modify `obj`
 * @param {*} value - The value to assign
 * @returns {*} - Returns the assigned value
 */
        function setValue(pointer, token, value) {
          if (pointer.value && _typeof(pointer.value) === 'object') {
            if (token === '-' && Array.isArray(pointer.value)) {
              pointer.value.push(value);
            } else {
              pointer.value[token] = value;
            }
          } else {
            throw ono.syntax('Error assigning $ref pointer "%s". \nCannot set "%s" of a non-object.', pointer.path, token);
          }
          return value;
        }
      },
      {
        './ref': 32,
        './util/url': 40,
        'ono': 76
      }
    ],
    32: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        module.exports = $Ref;
        var Pointer = require('./pointer');
        /**
 * This class represents a single JSON reference and its resolved value.
 *
 * @constructor
 */
        function $Ref() {
          /**
   * The file path or URL of the referenced file.
   * This path is relative to the path of the main JSON schema file.
   *
   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.
   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get
   * specific JSON pointers within the file.
   *
   * @type {string}
   */
          this.path = undefined;
          /**
   * The resolved value of the JSON reference.
   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
   * @type {?*}
   */
          this.value = undefined;
          /**
   * The {@link $Refs} object that contains this {@link $Ref} object.
   * @type {$Refs}
   */
          this.$refs = undefined;
          /**
   * Indicates the type of {@link $Ref#path} (e.g. "file", "http", etc.)
   * @type {?string}
   */
          this.pathType = undefined;
        }
        /**
 * Determines whether the given JSON reference exists within this {@link $Ref#value}.
 *
 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} options
 * @returns {boolean}
 */
        $Ref.prototype.exists = function (path, options) {
          try {
            this.resolve(path, options);
            return true;
          } catch (e) {
            return false;
          }
        };
        /**
 * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.
 *
 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} options
 * @returns {*} - Returns the resolved value
 */
        $Ref.prototype.get = function (path, options) {
          return this.resolve(path, options).value;
        };
        /**
 * Resolves the given JSON reference within this {@link $Ref#value}.
 *
 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} options
 * @returns {Pointer}
 */
        $Ref.prototype.resolve = function (path, options) {
          var pointer = new Pointer(this, path);
          return pointer.resolve(this.value, options);
        };
        /**
 * Sets the value of a nested property within this {@link $Ref#value}.
 * If the property, or any of its parents don't exist, they will be created.
 *
 * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash
 * @param {*} value - The value to assign
 */
        $Ref.prototype.set = function (path, value) {
          var pointer = new Pointer(this, path);
          this.value = pointer.set(this.value, value);
        };
        /**
 * Determines whether the given value is a JSON reference.
 *
 * @param {*} value - The value to inspect
 * @returns {boolean}
 */
        $Ref.is$Ref = function (value) {
          return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.$ref === 'string' && value.$ref.length > 0;
        };
        /**
 * Determines whether the given value is an external JSON reference.
 *
 * @param {*} value - The value to inspect
 * @returns {boolean}
 */
        $Ref.isExternal$Ref = function (value) {
          return $Ref.is$Ref(value) && value.$ref[0] !== '#';
        };
        /**
 * Determines whether the given value is a JSON reference, and whether it is allowed by the options.
 * For example, if it references an external file, then options.resolve.external must be true.
 *
 * @param {*} value - The value to inspect
 * @param {$RefParserOptions} options
 * @returns {boolean}
 */
        $Ref.isAllowed$Ref = function (value, options) {
          if ($Ref.is$Ref(value)) {
            if (value.$ref.substr(0, 2) === '#/' || value.$ref === '#') {
              // It's a JSON Pointer reference, which is always allowed
              return true;
            } else if (value.$ref[0] !== '#' && (!options || options.resolve.external)) {
              // It's an external reference, which is allowed by the options
              return true;
            }
          }
        };
        /**
 * Determines whether the given value is a JSON reference that "extends" its resolved value.
 * That is, it has extra properties (in addition to "$ref"), so rather than simply pointing to
 * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved
 * value, plus the extra properties.
 *
 * @example:
 *  {
 *    person: {
 *      properties: {
 *        firstName: { type: string }
 *        lastName: { type: string }
 *      }
 *    }
 *    employee: {
 *      properties: {
 *        $ref: #/person/properties
 *        salary: { type: number }
 *      }
 *    }
 *  }
 *
 *  In this example, "employee" is an extended $ref, since it extends "person" with an additional
 *  property (salary).  The result is a NEW value that looks like this:
 *
 *  {
 *    properties: {
 *      firstName: { type: string }
 *      lastName: { type: string }
 *      salary: { type: number }
 *    }
 *  }
 *
 * @param {*} value - The value to inspect
 * @returns {boolean}
 */
        $Ref.isExtended$Ref = function (value) {
          return $Ref.is$Ref(value) && Object.keys(value).length > 1;
        };
        /**
 * Returns the resolved value of a JSON Reference.
 * If necessary, the resolved value is merged with the JSON Reference to create a new object
 *
 * @example:
 *  {
 *    person: {
 *      properties: {
 *        firstName: { type: string }
 *        lastName: { type: string }
 *      }
 *    }
 *    employee: {
 *      properties: {
 *        $ref: #/person/properties
 *        salary: { type: number }
 *      }
 *    }
 *  }
 *
 *  When "person" and "employee" are merged, you end up with the following object:
 *
 *  {
 *    properties: {
 *      firstName: { type: string }
 *      lastName: { type: string }
 *      salary: { type: number }
 *    }
 *  }
 *
 * @param {object} $ref - The JSON reference object (the one with the "$ref" property)
 * @param {*} resolvedValue - The resolved value, which can be any type
 * @returns {*} - Returns the dereferenced value
 */
        $Ref.dereference = function ($ref, resolvedValue) {
          if (resolvedValue && (typeof resolvedValue === 'undefined' ? 'undefined' : _typeof(resolvedValue)) === 'object' && $Ref.isExtended$Ref($ref)) {
            var merged = {};
            Object.keys($ref).forEach(function (key) {
              if (key !== '$ref') {
                merged[key] = $ref[key];
              }
            });
            Object.keys(resolvedValue).forEach(function (key) {
              if (!(key in merged)) {
                merged[key] = resolvedValue[key];
              }
            });
            return merged;
          } else {
            // Completely replace the original reference with the resolved value
            return resolvedValue;
          }
        };
      },
      { './pointer': 31 }
    ],
    33: [
      function (require, module, exports) {
        'use strict';
        var ono = require('ono'), $Ref = require('./ref'), url = require('./util/url');
        module.exports = $Refs;
        /**
 * This class is a map of JSON references and their resolved values.
 */
        function $Refs() {
          /**
   * Indicates whether the schema contains any circular references.
   *
   * @type {boolean}
   */
          this.circular = false;
          /**
   * A map of paths/urls to {@link $Ref} objects
   *
   * @type {object}
   * @protected
   */
          this._$refs = {};
          /**
   * The {@link $Ref} object that is the root of the JSON schema.
   *
   * @type {$Ref}
   * @protected
   */
          this._root$Ref = null;
        }
        /**
 * Returns the paths of all the files/URLs that are referenced by the JSON schema,
 * including the schema itself.
 *
 * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
 * @returns {string[]}
 */
        $Refs.prototype.paths = function (types) {
          var paths = getPaths(this._$refs, arguments);
          return paths.map(function (path) {
            return path.decoded;
          });
        };
        /**
 * Returns the map of JSON references and their resolved values.
 *
 * @param {...string|string[]} [types] - Only return references of the given types ("file", "http", etc.)
 * @returns {object}
 */
        $Refs.prototype.values = function (types) {
          var $refs = this._$refs;
          var paths = getPaths($refs, arguments);
          return paths.reduce(function (obj, path) {
            obj[path.decoded] = $refs[path.encoded].value;
            return obj;
          }, {});
        };
        /**
 * Returns a POJO (plain old JavaScript object) for serialization as JSON.
 *
 * @returns {object}
 */
        $Refs.prototype.toJSON = $Refs.prototype.values;
        /**
 * Determines whether the given JSON reference exists.
 *
 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} [options]
 * @returns {boolean}
 */
        $Refs.prototype.exists = function (path, options) {
          try {
            this._resolve(path, options);
            return true;
          } catch (e) {
            return false;
          }
        };
        /**
 * Resolves the given JSON reference and returns the resolved value.
 *
 * @param {string} path - The path being resolved, with a JSON pointer in the hash
 * @param {$RefParserOptions} [options]
 * @returns {*} - Returns the resolved value
 */
        $Refs.prototype.get = function (path, options) {
          return this._resolve(path, options).value;
        };
        /**
 * Sets the value of a nested property within this {@link $Ref#value}.
 * If the property, or any of its parents don't exist, they will be created.
 *
 * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash
 * @param {*} value - The value to assign
 */
        $Refs.prototype.set = function (path, value) {
          path = url.resolve(this._root$Ref.path, path);
          var withoutHash = url.stripHash(path);
          var $ref = this._$refs[withoutHash];
          if (!$ref) {
            throw ono('Error resolving $ref pointer "%s". \n"%s" not found.', path, withoutHash);
          }
          $ref.set(path, value);
        };
        /**
 * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.
 *
 * @param {string} path  - The file path or URL of the referenced file
 * @param {*} [value] - Optional. The value of the $ref.
 */
        $Refs.prototype._add = function (path, value) {
          var withoutHash = url.stripHash(path);
          var $ref = new $Ref();
          $ref.path = withoutHash;
          $ref.value = value;
          $ref.$refs = this;
          this._$refs[withoutHash] = $ref;
          this._root$Ref = this._root$Ref || $ref;
          return $ref;
        };
        /**
 * Resolves the given JSON reference.
 *
 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
 * @param {$RefParserOptions} [options]
 * @returns {Pointer}
 * @protected
 */
        $Refs.prototype._resolve = function (path, options) {
          path = url.resolve(this._root$Ref.path, path);
          var withoutHash = url.stripHash(path);
          var $ref = this._$refs[withoutHash];
          if (!$ref) {
            throw ono('Error resolving $ref pointer "%s". \n"%s" not found.', path, withoutHash);
          }
          return $ref.resolve(path, options);
        };
        /**
 * Returns the specified {@link $Ref} object, or undefined.
 *
 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
 * @returns {$Ref|undefined}
 * @protected
 */
        $Refs.prototype._get$Ref = function (path) {
          path = url.resolve(this._root$Ref.path, path);
          var withoutHash = url.stripHash(path);
          return this._$refs[withoutHash];
        };
        /**
 * Returns the encoded and decoded paths keys of the given object.
 *
 * @param {object} $refs - The object whose keys are URL-encoded paths
 * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
 * @returns {object[]}
 */
        function getPaths($refs, types) {
          var paths = Object.keys($refs);
          // Filter the paths by type
          types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);
          if (types.length > 0 && types[0]) {
            paths = paths.filter(function (key) {
              return types.indexOf($refs[key].pathType) !== -1;
            });
          }
          // Decode local filesystem paths
          return paths.map(function (path) {
            return {
              encoded: path,
              decoded: $refs[path].pathType === 'file' ? url.toFileSystemPath(path, true) : path
            };
          });
        }
      },
      {
        './ref': 32,
        './util/url': 40,
        'ono': 76
      }
    ],
    34: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var Promise = require('./util/promise'), $Ref = require('./ref'), Pointer = require('./pointer'), parse = require('./parse'), debug = require('./util/debug'), url = require('./util/url');
        module.exports = resolveExternal;
        /**
 * Crawls the JSON schema, finds all external JSON references, and resolves their values.
 * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.
 *
 * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.
 *
 * @param {$RefParser} parser
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves once all JSON references in the schema have been resolved,
 * including nested references that are contained in externally-referenced files.
 */
        function resolveExternal(parser, options) {
          if (!options.resolve.external) {
            // Nothing to resolve, so exit early
            return Promise.resolve();
          }
          try {
            debug('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);
            var promises = crawl(parser.schema, parser.$refs._root$Ref.path + '#', parser.$refs, options);
            return Promise.all(promises);
          } catch (e) {
            return Promise.reject(e);
          }
        }
        /**
 * Recursively crawls the given value, and resolves any external JSON references.
 *
 * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
 * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 *
 * @returns {Promise[]}
 * Returns an array of promises. There will be one promise for each JSON reference in `obj`.
 * If `obj` does not contain any JSON references, then the array will be empty.
 * If any of the JSON references point to files that contain additional JSON references,
 * then the corresponding promise will internally reference an array of promises.
 */
        function crawl(obj, path, $refs, options) {
          var promises = [];
          if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
            if ($Ref.isExternal$Ref(obj)) {
              promises.push(resolve$Ref(obj, path, $refs, options));
            } else {
              Object.keys(obj).forEach(function (key) {
                var keyPath = Pointer.join(path, key);
                var value = obj[key];
                if ($Ref.isExternal$Ref(value)) {
                  promises.push(resolve$Ref(value, keyPath, $refs, options));
                } else {
                  promises = promises.concat(crawl(value, keyPath, $refs, options));
                }
              });
            }
          }
          return promises;
        }
        /**
 * Resolves the given JSON Reference, and then crawls the resulting value.
 *
 * @param {{$ref: string}} $ref - The JSON Reference to resolve
 * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
 * @param {$Refs} $refs
 * @param {$RefParserOptions} options
 *
 * @returns {Promise}
 * The promise resolves once all JSON references in the object have been resolved,
 * including nested references that are contained in externally-referenced files.
 */
        function resolve$Ref($ref, path, $refs, options) {
          debug('Resolving $ref pointer "%s" at %s', $ref.$ref, path);
          var resolvedPath = url.resolve(path, $ref.$ref);
          var withoutHash = url.stripHash(resolvedPath);
          // Do we already have this $ref?
          $ref = $refs._$refs[withoutHash];
          if ($ref) {
            // We've already parsed this $ref, so use the existing value
            return Promise.resolve($ref.value);
          }
          // Parse the $referenced file/url
          return parse(resolvedPath, $refs, options).then(function (result) {
            // Crawl the parsed value
            debug('Resolving $ref pointers in %s', withoutHash);
            var promises = crawl(result, withoutHash + '#', $refs, options);
            return Promise.all(promises);
          });
        }
      },
      {
        './parse': 26,
        './pointer': 31,
        './ref': 32,
        './util/debug': 37,
        './util/promise': 39,
        './util/url': 40
      }
    ],
    35: [
      function (require, module, exports) {
        'use strict';
        var fs = require('fs'), ono = require('ono'), Promise = require('../util/promise'), url = require('../util/url'), debug = require('../util/debug');
        module.exports = {
          order: 100,
          canRead: function isFile(file) {
            return url.isFileSystemPath(file.url);
          },
          read: function readFile(file) {
            return new Promise(function (resolve, reject) {
              var path;
              try {
                path = url.toFileSystemPath(file.url);
              } catch (err) {
                reject(ono.uri(err, 'Malformed URI: %s', file.url));
              }
              debug('Opening file: %s', path);
              try {
                fs.readFile(path, function (err, data) {
                  if (err) {
                    reject(ono(err, 'Error opening file "%s"', path));
                  } else {
                    resolve(data);
                  }
                });
              } catch (err) {
                reject(ono(err, 'Error opening file "%s"', path));
              }
            });
          }
        };
      },
      {
        '../util/debug': 37,
        '../util/promise': 39,
        '../util/url': 40,
        'fs': 3,
        'ono': 76
      }
    ],
    36: [
      function (require, module, exports) {
        (function (process, Buffer) {
          'use strict';
          var http = require('http'), https = require('https'), ono = require('ono'), url = require('../util/url'), debug = require('../util/debug'), Promise = require('../util/promise');
          module.exports = {
            order: 200,
            headers: null,
            timeout: 5000,
            redirects: 5,
            withCredentials: false,
            canRead: function isHttp(file) {
              return url.isHttp(file.url);
            },
            read: function readHttp(file) {
              var u = url.parse(file.url);
              if (process.browser && !u.protocol) {
                // Use the protocol of the current page
                u.protocol = url.parse(location.href).protocol;
              }
              return download(u, this);
            }
          };
          /**
 * Downloads the given file.
 *
 * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)
 * @param {object} httpOptions  - The `options.resolve.http` object
 * @param {number} [redirects]  - The redirect URLs that have already been followed
 *
 * @returns {Promise<Buffer>}
 * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.
 */
          function download(u, httpOptions, redirects) {
            return new Promise(function (resolve, reject) {
              u = url.parse(u);
              redirects = redirects || [];
              redirects.push(u.href);
              get(u, httpOptions).then(function (res) {
                if (res.statusCode >= 400) {
                  throw ono({ status: res.statusCode }, 'HTTP ERROR %d', res.statusCode);
                } else if (res.statusCode >= 300) {
                  if (redirects.length > httpOptions.redirects) {
                    reject(ono({ status: res.statusCode }, 'Error downloading %s. \nToo many redirects: \n  %s', redirects[0], redirects.join(' \n  ')));
                  } else if (!res.headers.location) {
                    throw ono({ status: res.statusCode }, 'HTTP %d redirect with no location header', res.statusCode);
                  } else {
                    debug('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);
                    var redirectTo = url.resolve(u, res.headers.location);
                    download(redirectTo, httpOptions, redirects).then(resolve, reject);
                  }
                } else {
                  resolve(res.body || new Buffer(0));
                }
              }).catch(function (err) {
                reject(ono(err, 'Error downloading', u.href));
              });
            });
          }
          /**
 * Sends an HTTP GET request.
 *
 * @param {Url} u - A parsed {@link Url} object
 * @param {object} httpOptions - The `options.resolve.http` object
 *
 * @returns {Promise<Response>}
 * The promise resolves with the HTTP Response object.
 */
          function get(u, httpOptions) {
            return new Promise(function (resolve, reject) {
              debug('GET', u.href);
              var protocol = u.protocol === 'https:' ? https : http;
              var req = protocol.get({
                  hostname: u.hostname,
                  port: u.port,
                  path: u.path,
                  auth: u.auth,
                  headers: httpOptions.headers || {},
                  withCredentials: httpOptions.withCredentials
                });
              if (typeof req.setTimeout === 'function') {
                req.setTimeout(httpOptions.timeout);
              }
              req.on('timeout', function () {
                req.abort();
              });
              req.on('error', reject);
              req.once('response', function (res) {
                res.body = new Buffer(0);
                res.on('data', function (data) {
                  res.body = Buffer.concat([
                    res.body,
                    new Buffer(data)
                  ]);
                });
                res.on('error', reject);
                res.on('end', function () {
                  resolve(res);
                });
              });
            });
          }
        }.call(this, require('_process'), require('buffer').Buffer));
      },
      {
        '../util/debug': 37,
        '../util/promise': 39,
        '../util/url': 40,
        '_process': 145,
        'buffer': 5,
        'http': 168,
        'https': 16,
        'ono': 76
      }
    ],
    37: [
      function (require, module, exports) {
        'use strict';
        var debug = require('debug');
        /**
 * Writes messages to stdout.
 * Log messages are suppressed by default, but can be enabled by setting the DEBUG variable.
 * @type {function}
 */
        module.exports = debug('json-schema-ref-parser');
      },
      { 'debug': 43 }
    ],
    38: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var Promise = require('./promise'), debug = require('./debug');
        /**
 * Returns the given plugins as an array, rather than an object map.
 * All other methods in this module expect an array of plugins rather than an object map.
 *
 * @param  {object} plugins - A map of plugin objects
 * @return {object[]}
 */
        exports.all = function (plugins) {
          return Object.keys(plugins).filter(function (key) {
            return _typeof(plugins[key]) === 'object';
          }).map(function (key) {
            plugins[key].name = key;
            return plugins[key];
          });
        };
        /**
 * Filters the given plugins, returning only the ones return `true` for the given method.
 *
 * @param  {object[]} plugins - An array of plugin objects
 * @param  {string}   method  - The name of the filter method to invoke for each plugin
 * @param  {object}   file    - A file info object, which will be passed to each method
 * @return {object[]}
 */
        exports.filter = function (plugins, method, file) {
          return plugins.filter(function (plugin) {
            return !!getResult(plugin, method, file);
          });
        };
        /**
 * Sorts the given plugins, in place, by their `order` property.
 *
 * @param {object[]} plugins - An array of plugin objects
 * @returns {object[]}
 */
        exports.sort = function (plugins) {
          plugins.forEach(function (plugin) {
            plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
          });
          return plugins.sort(function (a, b) {
            return a.order - b.order;
          });
        };
        /**
 * Runs the specified method of the given plugins, in order, until one of them returns a successful result.
 * Each method can return a synchronous value, a Promise, or call an error-first callback.
 * If the promise resolves successfully, or the callback is called without an error, then the result
 * is immediately returned and no further plugins are called.
 * If the promise rejects, or the callback is called with an error, then the next plugin is called.
 * If ALL plugins fail, then the last error is thrown.
 *
 * @param {object[]}  plugins - An array of plugin objects
 * @param {string}    method  - The name of the method to invoke for each plugin
 * @param {object}    file    - A file info object, which will be passed to each method
 * @returns {Promise}
 */
        exports.run = function (plugins, method, file) {
          var plugin, lastError, index = 0;
          return new Promise(function (resolve, reject) {
            runNextPlugin();
            function runNextPlugin() {
              plugin = plugins[index++];
              if (!plugin) {
                // There are no more functions, so re-throw the last error
                return reject(lastError);
              }
              try {
                debug('  %s', plugin.name);
                var result = getResult(plugin, method, file, callback);
                if (result && typeof result.then === 'function') {
                  // A promise was returned
                  result.then(onSuccess, onError);
                } else if (result !== undefined) {
                  // A synchronous result was returned
                  onSuccess(result);
                }  // else { the callback will be called }
              } catch (e) {
                onError(e);
              }
            }
            function callback(err, result) {
              if (err) {
                onError(err);
              } else {
                onSuccess(result);
              }
            }
            function onSuccess(result) {
              debug('    success');
              resolve({
                plugin: plugin,
                result: result
              });
            }
            function onError(err) {
              debug('    %s', err.message || err);
              lastError = err;
              runNextPlugin();
            }
          });
        };
        /**
 * Returns the value of the given property.
 * If the property is a function, then the result of the function is returned.
 * If the value is a RegExp, then it will be tested against the file URL.
 * If the value is an aray, then it will be compared against the file extension.
 *
 * @param   {object}   obj        - The object whose property/method is called
 * @param   {string}   prop       - The name of the property/method to invoke
 * @param   {object}   file       - A file info object, which will be passed to the method
 * @param   {function} [callback] - A callback function, which will be passed to the method
 * @returns {*}
 */
        function getResult(obj, prop, file, callback) {
          var value = obj[prop];
          if (typeof value === 'function') {
            return value.apply(obj, [
              file,
              callback
            ]);
          }
          if (!callback) {
            // The synchronous plugin functions (canParse and canRead)
            // allow a "shorthand" syntax, where the user can match
            // files by RegExp or by file extension.
            if (value instanceof RegExp) {
              return value.test(file.url);
            } else if (typeof value === 'string') {
              return value === file.extension;
            } else if (Array.isArray(value)) {
              return value.indexOf(file.extension) !== -1;
            }
          }
          return value;
        }
      },
      {
        './debug': 37,
        './promise': 39
      }
    ],
    39: [
      function (require, module, exports) {
        'use strict';
        /** @type {Promise} **/
        module.exports = typeof Promise === 'function' ? Promise : require('es6-promise').Promise;
      },
      { 'es6-promise': 12 }
    ],
    40: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          var isWindows = /^win/.test(process.platform), forwardSlashPattern = /\//g, protocolPattern = /^([a-z0-9.+-]+):\/\//i, url = module.exports;
          // RegExp patterns to URL-encode special characters in local filesystem paths
          var urlEncodePatterns = [
              /\?/g,
              '%3F',
              /\#/g,
              '%23',
              isWindows ? /\\/g : /\//,
              '/'
            ];
          // RegExp patterns to URL-decode special characters for local filesystem paths
          var urlDecodePatterns = [
              /\%23/g,
              '#',
              /\%24/g,
              '$',
              /\%26/g,
              '&',
              /\%2C/g,
              ',',
              /\%40/g,
              '@'
            ];
          exports.parse = require('url').parse;
          exports.resolve = require('url').resolve;
          /**
 * Returns the current working directory (in Node) or the current page URL (in browsers).
 *
 * @returns {string}
 */
          exports.cwd = function cwd() {
            return process.browser ? location.href : process.cwd() + '/';
          };
          /**
 * Returns the protocol of the given URL, or `undefined` if it has no protocol.
 *
 * @param   {string} path
 * @returns {?string}
 */
          exports.getProtocol = function getProtocol(path) {
            var match = protocolPattern.exec(path);
            if (match) {
              return match[1].toLowerCase();
            }
          };
          /**
 * Returns the lowercased file extension of the given URL,
 * or an empty string if it has no extension.
 *
 * @param   {string} path
 * @returns {string}
 */
          exports.getExtension = function getExtension(path) {
            var lastDot = path.lastIndexOf('.');
            if (lastDot >= 0) {
              return path.substr(lastDot).toLowerCase();
            }
            return '';
          };
          /**
 * Returns the hash (URL fragment), of the given path.
 * If there is no hash, then the root hash ("#") is returned.
 *
 * @param   {string} path
 * @returns {string}
 */
          exports.getHash = function getHash(path) {
            var hashIndex = path.indexOf('#');
            if (hashIndex >= 0) {
              return path.substr(hashIndex);
            }
            return '#';
          };
          /**
 * Removes the hash (URL fragment), if any, from the given path.
 *
 * @param   {string} path
 * @returns {string}
 */
          exports.stripHash = function stripHash(path) {
            var hashIndex = path.indexOf('#');
            if (hashIndex >= 0) {
              path = path.substr(0, hashIndex);
            }
            return path;
          };
          /**
 * Determines whether the given path is an HTTP(S) URL.
 *
 * @param   {string} path
 * @returns {boolean}
 */
          exports.isHttp = function isHttp(path) {
            var protocol = url.getProtocol(path);
            if (protocol === 'http' || protocol === 'https') {
              return true;
            } else if (protocol === undefined) {
              // There is no protocol.  If we're running in a browser, then assume it's HTTP.
              return process.browser;
            } else {
              // It's some other protocol, such as "ftp://", "mongodb://", etc.
              return false;
            }
          };
          /**
 * Determines whether the given path is a filesystem path.
 * This includes "file://" URLs.
 *
 * @param   {string} path
 * @returns {boolean}
 */
          exports.isFileSystemPath = function isFileSystemPath(path) {
            if (process.browser) {
              // We're running in a browser, so assume that all paths are URLs.
              // This way, even relative paths will be treated as URLs rather than as filesystem paths
              return false;
            }
            var protocol = url.getProtocol(path);
            return protocol === undefined || protocol === 'file';
          };
          /**
 * Converts a filesystem path to a properly-encoded URL.
 *
 * This is intended to handle situations where JSON Schema $Ref Parser is called
 * with a filesystem path that contains characters which are not allowed in URLs.
 *
 * @example
 * The following filesystem paths would be converted to the following URLs:
 *
 *    <"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\'%3E.json
 *    C:\\My Documents\\File (1).json   ==>   C:/My%20Documents/File%20(1).json
 *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json
 *
 * @param {string} path
 * @returns {string}
 */
          exports.fromFileSystemPath = function fromFileSystemPath(path) {
            // Step 1: Manually encode characters that are not encoded by `encodeURI`.
            // This includes characters such as "#" and "?", which have special meaning in URLs,
            // but are just normal characters in a filesystem path.
            // On Windows, this will also replace backslashes with forward slashes,
            // rather than encoding them as special characters.
            for (var i = 0; i < urlEncodePatterns.length; i += 2) {
              path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
            }
            // Step 2: `encodeURI` will take care of all other characters
            return encodeURI(path);
          };
          /**
 * Converts a URL to a local filesystem path.
 *
 * @param {string}  path
 * @param {boolean} [keepFileProtocol] - If true, then "file://" will NOT be stripped
 * @returns {string}
 */
          exports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
            // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.
            path = decodeURI(path);
            // Step 2: Manually decode characters that are not decoded by `decodeURI`.
            // This includes characters such as "#" and "?", which have special meaning in URLs,
            // but are just normal characters in a filesystem path.
            for (var i = 0; i < urlDecodePatterns.length; i += 2) {
              path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
            }
            // Step 3: If it's a "file://" URL, then format it consistently
            // or convert it to a local filesystem path
            var isFileUrl = path.substr(0, 7).toLowerCase() === 'file://';
            if (isFileUrl) {
              // Strip-off the protocol, and the initial "/", if there is one
              path = path[7] === '/' ? path.substr(8) : path.substr(7);
              // insert a colon (":") after the drive letter on Windows
              if (isWindows && path[1] === '/') {
                path = path[0] + ':' + path.substr(1);
              }
              if (keepFileProtocol) {
                // Return the consistently-formatted "file://" URL
                path = 'file:///' + path;
              } else {
                // Convert the "file://" URL to a local filesystem path.
                // On Windows, it will start with something like "C:/".
                // On Posix, it will start with "/"
                isFileUrl = false;
                path = isWindows ? path : '/' + path;
              }
            }
            // Step 4: On Windows, convert backslashes to forward slashes,
            // unless it's a "file://" URL
            if (isWindows && !isFileUrl) {
              path = path.replace(forwardSlashPattern, '\\');
            }
            return path;
          };
        }.call(this, require('_process')));
      },
      {
        '_process': 145,
        'url': 183
      }
    ],
    41: [
      function (require, module, exports) {
        /* eslint lines-around-comment: [2, {beforeBlockComment: false}] */
        'use strict';
        var yaml = require('js-yaml'), ono = require('ono');
        /**
 * Simple YAML parsing functions, similar to {@link JSON.parse} and {@link JSON.stringify}
 */
        module.exports = {
          parse: function yamlParse(text, reviver) {
            try {
              return yaml.safeLoad(text);
            } catch (e) {
              if (e instanceof Error) {
                throw e;
              } else {
                // https://github.com/nodeca/js-yaml/issues/153
                throw ono(e, e.message);
              }
            }
          },
          stringify: function yamlStringify(value, replacer, space) {
            try {
              var indent = (typeof space === 'string' ? space.length : space) || 2;
              return yaml.safeDump(value, { indent: indent });
            } catch (e) {
              if (e instanceof Error) {
                throw e;
              } else {
                // https://github.com/nodeca/js-yaml/issues/153
                throw ono(e, e.message);
              }
            }
          }
        };
      },
      {
        'js-yaml': 45,
        'ono': 76
      }
    ],
    42: [
      function (require, module, exports) {
        'use strict';
        module.exports = {
          order: 100,
          canValidate: function canValidate(file) {
            // Z-Schema requires JSON References to already be resolved (but not dereferenced)
            return !!file.resolved;
          },
          validate: function validate(file) {
          }
        };
      },
      {}
    ],
    43: [
      function (require, module, exports) {
        (function (process) {
          /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
          exports = module.exports = require('./debug');
          exports.log = log;
          exports.formatArgs = formatArgs;
          exports.save = save;
          exports.load = load;
          exports.useColors = useColors;
          exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
          /**
 * Colors.
 */
          exports.colors = [
            '#0000CC',
            '#0000FF',
            '#0033CC',
            '#0033FF',
            '#0066CC',
            '#0066FF',
            '#0099CC',
            '#0099FF',
            '#00CC00',
            '#00CC33',
            '#00CC66',
            '#00CC99',
            '#00CCCC',
            '#00CCFF',
            '#3300CC',
            '#3300FF',
            '#3333CC',
            '#3333FF',
            '#3366CC',
            '#3366FF',
            '#3399CC',
            '#3399FF',
            '#33CC00',
            '#33CC33',
            '#33CC66',
            '#33CC99',
            '#33CCCC',
            '#33CCFF',
            '#6600CC',
            '#6600FF',
            '#6633CC',
            '#6633FF',
            '#66CC00',
            '#66CC33',
            '#9900CC',
            '#9900FF',
            '#9933CC',
            '#9933FF',
            '#99CC00',
            '#99CC33',
            '#CC0000',
            '#CC0033',
            '#CC0066',
            '#CC0099',
            '#CC00CC',
            '#CC00FF',
            '#CC3300',
            '#CC3333',
            '#CC3366',
            '#CC3399',
            '#CC33CC',
            '#CC33FF',
            '#CC6600',
            '#CC6633',
            '#CC9900',
            '#CC9933',
            '#CCCC00',
            '#CCCC33',
            '#FF0000',
            '#FF0033',
            '#FF0066',
            '#FF0099',
            '#FF00CC',
            '#FF00FF',
            '#FF3300',
            '#FF3333',
            '#FF3366',
            '#FF3399',
            '#FF33CC',
            '#FF33FF',
            '#FF6600',
            '#FF6633',
            '#FF9900',
            '#FF9933',
            '#FFCC00',
            '#FFCC33'
          ];
          /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
          function useColors() {
            // NB: In an Electron preload script, document will be defined but not fully
            // initialized. Since we know we're in Chrome, we'll just detect this case
            // explicitly
            if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
              return true;
            }
            // Internet Explorer and Edge do not support colors.
            if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
              return false;
            }
            // is webkit? http://stackoverflow.com/a/16459606/376773
            // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
            return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */
          exports.formatters.j = function (v) {
            try {
              return JSON.stringify(v);
            } catch (err) {
              return '[UnexpectedJSONParseError]: ' + err.message;
            }
          };
          /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */
          function formatArgs(args) {
            var useColors = this.useColors;
            args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
            if (!useColors)
              return;
            var c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            // the final "%c" is somewhat tricky, because there could be other
            // arguments passed either before or after the %c, so we need to
            // figure out the correct index to insert the CSS into
            var index = 0;
            var lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, function (match) {
              if ('%%' === match)
                return;
              index++;
              if ('%c' === match) {
                // we only are interested in the *last* %c
                // (the user may have provided their own)
                lastC = index;
              }
            });
            args.splice(lastC, 0, c);
          }
          /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
          function log() {
            // this hackery is required for IE8/9, where
            // the `console.log` function doesn't have 'apply'
            return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
          }
          /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
          function save(namespaces) {
            try {
              if (null == namespaces) {
                exports.storage.removeItem('debug');
              } else {
                exports.storage.debug = namespaces;
              }
            } catch (e) {
            }
          }
          /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
          function load() {
            var r;
            try {
              r = exports.storage.debug;
            } catch (e) {
            }
            // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
            if (!r && typeof process !== 'undefined' && 'env' in process) {
              r = process.env.DEBUG;
            }
            return r;
          }
          /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */
          exports.enable(load());
          /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */
          function localstorage() {
            try {
              return window.localStorage;
            } catch (e) {
            }
          }
        }.call(this, require('_process')));
      },
      {
        './debug': 44,
        '_process': 145
      }
    ],
    44: [
      function (require, module, exports) {
        /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require('ms');
        /**
 * Active `debug` instances.
 */
        exports.instances = [];
        /**
 * The currently active debug mode names, and names to skip.
 */
        exports.names = [];
        exports.skips = [];
        /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */
        exports.formatters = {};
        /**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */
        function selectColor(namespace) {
          var hash = 0, i;
          for (i in namespace) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;  // Convert to 32bit integer
          }
          return exports.colors[Math.abs(hash) % exports.colors.length];
        }
        /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */
        function createDebug(namespace) {
          var prevTime;
          function debug() {
            // disabled?
            if (!debug.enabled)
              return;
            var self = debug;
            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            // turn the `arguments` into a proper Array
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            args[0] = exports.coerce(args[0]);
            if ('string' !== typeof args[0]) {
              // anything else let's inspect with %O
              args.unshift('%O');
            }
            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
              // if we encounter an escaped % then don't increase the array index
              if (match === '%%')
                return match;
              index++;
              var formatter = exports.formatters[format];
              if ('function' === typeof formatter) {
                var val = args[index];
                match = formatter.call(self, val);
                // now we need to remove `args[index]` since it's inlined in the `format`
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            // apply env-specific formatting (colors, etc.)
            exports.formatArgs.call(self, args);
            var logFn = debug.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.enabled = exports.enabled(namespace);
          debug.useColors = exports.useColors();
          debug.color = selectColor(namespace);
          debug.destroy = destroy;
          // env-specific initialization logic for debug instances
          if ('function' === typeof exports.init) {
            exports.init(debug);
          }
          exports.instances.push(debug);
          return debug;
        }
        function destroy() {
          var index = exports.instances.indexOf(this);
          if (index !== -1) {
            exports.instances.splice(index, 1);
            return true;
          } else {
            return false;
          }
        }
        /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */
        function enable(namespaces) {
          exports.save(namespaces);
          exports.names = [];
          exports.skips = [];
          var i;
          var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
          var len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i])
              continue;
            // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
              exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
              exports.names.push(new RegExp('^' + namespaces + '$'));
            }
          }
          for (i = 0; i < exports.instances.length; i++) {
            var instance = exports.instances[i];
            instance.enabled = exports.enabled(instance.namespace);
          }
        }
        /**
 * Disable debug output.
 *
 * @api public
 */
        function disable() {
          exports.enable('');
        }
        /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */
        function enabled(name) {
          if (name[name.length - 1] === '*') {
            return true;
          }
          var i, len;
          for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */
        function coerce(val) {
          if (val instanceof Error)
            return val.stack || val.message;
          return val;
        }
      },
      { 'ms': 75 }
    ],
    45: [
      function (require, module, exports) {
        'use strict';
        var yaml = require('./lib/js-yaml.js');
        module.exports = yaml;
      },
      { './lib/js-yaml.js': 46 }
    ],
    46: [
      function (require, module, exports) {
        'use strict';
        var loader = require('./js-yaml/loader');
        var dumper = require('./js-yaml/dumper');
        function deprecated(name) {
          return function () {
            throw new Error('Function ' + name + ' is deprecated and cannot be used.');
          };
        }
        module.exports.Type = require('./js-yaml/type');
        module.exports.Schema = require('./js-yaml/schema');
        module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');
        module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');
        module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');
        module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
        module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
        module.exports.load = loader.load;
        module.exports.loadAll = loader.loadAll;
        module.exports.safeLoad = loader.safeLoad;
        module.exports.safeLoadAll = loader.safeLoadAll;
        module.exports.dump = dumper.dump;
        module.exports.safeDump = dumper.safeDump;
        module.exports.YAMLException = require('./js-yaml/exception');
        // Deprecated schema names from JS-YAML 2.0.x
        module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
        module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
        module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');
        // Deprecated functions from JS-YAML 1.x.x
        module.exports.scan = deprecated('scan');
        module.exports.parse = deprecated('parse');
        module.exports.compose = deprecated('compose');
        module.exports.addConstructor = deprecated('addConstructor');
      },
      {
        './js-yaml/dumper': 48,
        './js-yaml/exception': 49,
        './js-yaml/loader': 50,
        './js-yaml/schema': 52,
        './js-yaml/schema/core': 53,
        './js-yaml/schema/default_full': 54,
        './js-yaml/schema/default_safe': 55,
        './js-yaml/schema/failsafe': 56,
        './js-yaml/schema/json': 57,
        './js-yaml/type': 58
      }
    ],
    47: [
      function (require, module, exports) {
        'use strict';
        function isNothing(subject) {
          return typeof subject === 'undefined' || subject === null;
        }
        function isObject(subject) {
          return typeof subject === 'object' && subject !== null;
        }
        function toArray(sequence) {
          if (Array.isArray(sequence))
            return sequence;
          else if (isNothing(sequence))
            return [];
          return [sequence];
        }
        function extend(target, source) {
          var index, length, key, sourceKeys;
          if (source) {
            sourceKeys = Object.keys(source);
            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }
          return target;
        }
        function repeat(string, count) {
          var result = '', cycle;
          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }
          return result;
        }
        function isNegativeZero(number) {
          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
        }
        module.exports.isNothing = isNothing;
        module.exports.isObject = isObject;
        module.exports.toArray = toArray;
        module.exports.repeat = repeat;
        module.exports.isNegativeZero = isNegativeZero;
        module.exports.extend = extend;
      },
      {}
    ],
    48: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable no-use-before-define*/
        var common = require('./common');
        var YAMLException = require('./exception');
        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CHAR_TAB = 9;
        /* Tab */
        var CHAR_LINE_FEED = 10;
        /* LF */
        var CHAR_SPACE = 32;
        /* Space */
        var CHAR_EXCLAMATION = 33;
        /* ! */
        var CHAR_DOUBLE_QUOTE = 34;
        /* " */
        var CHAR_SHARP = 35;
        /* # */
        var CHAR_PERCENT = 37;
        /* % */
        var CHAR_AMPERSAND = 38;
        /* & */
        var CHAR_SINGLE_QUOTE = 39;
        /* ' */
        var CHAR_ASTERISK = 42;
        /* * */
        var CHAR_COMMA = 44;
        /* , */
        var CHAR_MINUS = 45;
        /* - */
        var CHAR_COLON = 58;
        /* : */
        var CHAR_GREATER_THAN = 62;
        /* > */
        var CHAR_QUESTION = 63;
        /* ? */
        var CHAR_COMMERCIAL_AT = 64;
        /* @ */
        var CHAR_LEFT_SQUARE_BRACKET = 91;
        /* [ */
        var CHAR_RIGHT_SQUARE_BRACKET = 93;
        /* ] */
        var CHAR_GRAVE_ACCENT = 96;
        /* ` */
        var CHAR_LEFT_CURLY_BRACKET = 123;
        /* { */
        var CHAR_VERTICAL_LINE = 124;
        /* | */
        var CHAR_RIGHT_CURLY_BRACKET = 125;
        /* } */
        var ESCAPE_SEQUENCES = {};
        ESCAPE_SEQUENCES[0] = '\\0';
        ESCAPE_SEQUENCES[7] = '\\a';
        ESCAPE_SEQUENCES[8] = '\\b';
        ESCAPE_SEQUENCES[9] = '\\t';
        ESCAPE_SEQUENCES[10] = '\\n';
        ESCAPE_SEQUENCES[11] = '\\v';
        ESCAPE_SEQUENCES[12] = '\\f';
        ESCAPE_SEQUENCES[13] = '\\r';
        ESCAPE_SEQUENCES[27] = '\\e';
        ESCAPE_SEQUENCES[34] = '\\"';
        ESCAPE_SEQUENCES[92] = '\\\\';
        ESCAPE_SEQUENCES[133] = '\\N';
        ESCAPE_SEQUENCES[160] = '\\_';
        ESCAPE_SEQUENCES[8232] = '\\L';
        ESCAPE_SEQUENCES[8233] = '\\P';
        var DEPRECATED_BOOLEANS_SYNTAX = [
            'y',
            'Y',
            'yes',
            'Yes',
            'YES',
            'on',
            'On',
            'ON',
            'n',
            'N',
            'no',
            'No',
            'NO',
            'off',
            'Off',
            'OFF'
          ];
        function compileStyleMap(schema, map) {
          var result, keys, index, length, tag, style, type;
          if (map === null)
            return {};
          result = {};
          keys = Object.keys(map);
          for (index = 0, length = keys.length; index < length; index += 1) {
            tag = keys[index];
            style = String(map[tag]);
            if (tag.slice(0, 2) === '!!') {
              tag = 'tag:yaml.org,2002:' + tag.slice(2);
            }
            type = schema.compiledTypeMap['fallback'][tag];
            if (type && _hasOwnProperty.call(type.styleAliases, style)) {
              style = type.styleAliases[style];
            }
            result[tag] = style;
          }
          return result;
        }
        function encodeHex(character) {
          var string, handle, length;
          string = character.toString(16).toUpperCase();
          if (character <= 255) {
            handle = 'x';
            length = 2;
          } else if (character <= 65535) {
            handle = 'u';
            length = 4;
          } else if (character <= 4294967295) {
            handle = 'U';
            length = 8;
          } else {
            throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
          }
          return '\\' + handle + common.repeat('0', length - string.length) + string;
        }
        function State(options) {
          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
          this.indent = Math.max(1, options['indent'] || 2);
          this.skipInvalid = options['skipInvalid'] || false;
          this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
          this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
          this.sortKeys = options['sortKeys'] || false;
          this.lineWidth = options['lineWidth'] || 80;
          this.noRefs = options['noRefs'] || false;
          this.noCompatMode = options['noCompatMode'] || false;
          this.condenseFlow = options['condenseFlow'] || false;
          this.implicitTypes = this.schema.compiledImplicit;
          this.explicitTypes = this.schema.compiledExplicit;
          this.tag = null;
          this.result = '';
          this.duplicates = [];
          this.usedDuplicates = null;
        }
        // Indents every line in a string. Empty lines (\n only) are not indented.
        function indentString(string, spaces) {
          var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
          while (position < length) {
            next = string.indexOf('\n', position);
            if (next === -1) {
              line = string.slice(position);
              position = length;
            } else {
              line = string.slice(position, next + 1);
              position = next + 1;
            }
            if (line.length && line !== '\n')
              result += ind;
            result += line;
          }
          return result;
        }
        function generateNextLine(state, level) {
          return '\n' + common.repeat(' ', state.indent * level);
        }
        function testImplicitResolving(state, str) {
          var index, length, type;
          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
            type = state.implicitTypes[index];
            if (type.resolve(str)) {
              return true;
            }
          }
          return false;
        }
        // [33] s-white ::= s-space | s-tab
        function isWhitespace(c) {
          return c === CHAR_SPACE || c === CHAR_TAB;
        }
        // Returns true if the character can be printed without escaping.
        // From YAML 1.2: "any allowed characters known to be non-printable
        // should also be escaped. [However,] This isn’t mandatory"
        // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
        function isPrintable(c) {
          return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
        }
        // Simplified test for values allowed after the first character in plain style.
        function isPlainSafe(c) {
          // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
          // where nb-char ::= c-printable - b-char - c-byte-order-mark.
          return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;
        }
        // Simplified test for values allowed as the first character in plain style.
        function isPlainSafeFirst(c) {
          // Uses a subset of ns-char - c-indicator
          // where ns-char = nb-char - s-white.
          return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
        }
        var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
        // Determines which scalar styles are possible and returns the preferred style.
        // lineWidth = -1 => no limit.
        // Pre-conditions: str.length > 0.
        // Post-conditions:
        //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
        //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
        //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
          var i;
          var char;
          var hasLineBreak = false;
          var hasFoldableLine = false;
          // only checked if shouldTrackWidth
          var shouldTrackWidth = lineWidth !== -1;
          var previousLineBreak = -1;
          // count the first line correctly
          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
          if (singleLineOnly) {
            // Case: no block styles.
            // Check for disallowed characters to rule out plain and single.
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              plain = plain && isPlainSafe(char);
            }
          } else {
            // Case: block styles permitted.
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                  hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
                  previousLineBreak = i;
                }
              } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              plain = plain && isPlainSafe(char);
            }
            // in case the end is missing a \n
            hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ');
          }
          // Although every style can represent \n without escaping, prefer block styles
          // for multiline, since they're more readable and they don't add empty lines.
          // Also prefer folding a super-long line.
          if (!hasLineBreak && !hasFoldableLine) {
            // Strings interpretable as another type have to be quoted;
            // e.g. the string 'true' vs. the boolean true.
            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
          }
          // Edge case: block indentation indicator can only have one digit.
          if (string[0] === ' ' && indentPerLevel > 9) {
            return STYLE_DOUBLE;
          }
          // At this point we know block styles are valid.
          // Prefer literal style unless we want to fold.
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }
        // Note: line breaking/folding is implemented for only the folded style.
        // NB. We drop the last trailing newline (if any) of a returned block scalar
        //  since the dumper adds its own newline. This always works:
        //    • No ending newline => unaffected; already using strip "-" chomping.
        //    • Ending newline    => removed then restored.
        //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
        function writeScalar(state, string, level, iskey) {
          state.dump = function () {
            if (string.length === 0) {
              return '\'\'';
            }
            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
              return '\'' + string + '\'';
            }
            var indent = state.indent * Math.max(1, level);
            // no 0-indent scalars
            // As indentation gets deeper, let the width decrease monotonically
            // to the lower bound min(state.lineWidth, 40).
            // Note that this implies
            //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
            //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
            // This behaves better than a constant minimum width which disallows narrower options,
            // or an indent threshold which causes the width to suddenly increase.
            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
            // Without knowing if keys are implicit/explicit, assume implicit for safety.
            var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
            function testAmbiguity(string) {
              return testImplicitResolving(state, string);
            }
            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
            case STYLE_PLAIN:
              return string;
            case STYLE_SINGLE:
              return '\'' + string.replace(/'/g, '\'\'') + '\'';
            case STYLE_LITERAL:
              return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
              return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"';
            default:
              throw new YAMLException('impossible error: invalid scalar style');
            }
          }();
        }
        // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
        function blockHeader(string, indentPerLevel) {
          var indentIndicator = string[0] === ' ' ? String(indentPerLevel) : '';
          // note the special case: the string '\n' counts as a "trailing" empty line.
          var clip = string[string.length - 1] === '\n';
          var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
          var chomp = keep ? '+' : clip ? '' : '-';
          return indentIndicator + chomp + '\n';
        }
        // (See the note for writeScalar.)
        function dropEndingNewline(string) {
          return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
        }
        // Note: a long line without a suitable break point will exceed the width limit.
        // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
        function foldString(string, width) {
          // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
          // unless they're before or after a more-indented line, or at the very
          // beginning or end, in which case $k$ maps to $k$.
          // Therefore, parse each chunk as newline(s) followed by a content line.
          var lineRe = /(\n+)([^\n]*)/g;
          // first line (possibly an empty line)
          var result = function () {
              var nextLF = string.indexOf('\n');
              nextLF = nextLF !== -1 ? nextLF : string.length;
              lineRe.lastIndex = nextLF;
              return foldLine(string.slice(0, nextLF), width);
            }();
          // If we haven't reached the first content line yet, don't add an extra \n.
          var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
          var moreIndented;
          // rest of the lines
          var match;
          while (match = lineRe.exec(string)) {
            var prefix = match[1], line = match[2];
            moreIndented = line[0] === ' ';
            result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
            prevMoreIndented = moreIndented;
          }
          return result;
        }
        // Greedy line breaking.
        // Picks the longest line under the limit each time,
        // otherwise settles for the shortest line over the limit.
        // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
        function foldLine(line, width) {
          if (line === '' || line[0] === ' ')
            return line;
          // Since a more-indented line adds a \n, breaks can't be followed by a space.
          var breakRe = / [^ ]/g;
          // note: the match index will always be <= length-2.
          var match;
          // start is an inclusive index. end, curr, and next are exclusive.
          var start = 0, end, curr = 0, next = 0;
          var result = '';
          // Invariants: 0 <= start <= length-1.
          //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
          // Inside the loop:
          //   A match implies length >= 2, so curr and next are <= length-2.
          while (match = breakRe.exec(line)) {
            next = match.index;
            // maintain invariant: curr - start <= width
            if (next - start > width) {
              end = curr > start ? curr : next;
              // derive end <= length-2
              result += '\n' + line.slice(start, end);
              // skip the space that was output as \n
              start = end + 1;  // derive start <= length-1
            }
            curr = next;
          }
          // By the invariants, start <= length-1, so there is something left over.
          // It is either the whole string or a part starting from non-whitespace.
          result += '\n';
          // Insert a break if the remainder is too long and there is a break available.
          if (line.length - start > width && curr > start) {
            result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
          } else {
            result += line.slice(start);
          }
          return result.slice(1);  // drop extra \n joiner
        }
        // Escapes a double-quoted string.
        function escapeString(string) {
          var result = '';
          var char, nextChar;
          var escapeSeq;
          for (var i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
            if (char >= 55296 && char <= 56319) {
              nextChar = string.charCodeAt(i + 1);
              if (nextChar >= 56320 && nextChar <= 57343) {
                // Combine the surrogate pair and store it escaped.
                result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
                // Advance index one extra since we already used that char here.
                i++;
                continue;
              }
            }
            escapeSeq = ESCAPE_SEQUENCES[char];
            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
          }
          return result;
        }
        function writeFlowSequence(state, level, object) {
          var _result = '', _tag = state.tag, index, length;
          for (index = 0, length = object.length; index < length; index += 1) {
            // Write only valid elements.
            if (writeNode(state, level, object[index], false, false)) {
              if (index !== 0)
                _result += ',' + (!state.condenseFlow ? ' ' : '');
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = '[' + _result + ']';
        }
        function writeBlockSequence(state, level, object, compact) {
          var _result = '', _tag = state.tag, index, length;
          for (index = 0, length = object.length; index < length; index += 1) {
            // Write only valid elements.
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += '-';
              } else {
                _result += '- ';
              }
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = _result || '[]';  // Empty sequence if no valid values.
        }
        function writeFlowMapping(state, level, object) {
          var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = state.condenseFlow ? '"' : '';
            if (index !== 0)
              pairBuffer += ', ';
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level, objectKey, false, false)) {
              continue;  // Skip this pair because of invalid key;
            }
            if (state.dump.length > 1024)
              pairBuffer += '? ';
            pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
            if (!writeNode(state, level, objectValue, false, false)) {
              continue;  // Skip this pair because of invalid value.
            }
            pairBuffer += state.dump;
            // Both key and value are valid.
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = '{' + _result + '}';
        }
        function writeBlockMapping(state, level, object, compact) {
          var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
          // Allow sorting keys so that the output file is deterministic
          if (state.sortKeys === true) {
            // Default sorting
            objectKeyList.sort();
          } else if (typeof state.sortKeys === 'function') {
            // Custom sort function
            objectKeyList.sort(state.sortKeys);
          } else if (state.sortKeys) {
            // Something is wrong
            throw new YAMLException('sortKeys must be a boolean or a function');
          }
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (!compact || index !== 0) {
              pairBuffer += generateNextLine(state, level);
            }
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level + 1, objectKey, true, true, true)) {
              continue;  // Skip this pair because of invalid key.
            }
            explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
            if (explicitPair) {
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += '?';
              } else {
                pairBuffer += '? ';
              }
            }
            pairBuffer += state.dump;
            if (explicitPair) {
              pairBuffer += generateNextLine(state, level);
            }
            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
              continue;  // Skip this pair because of invalid value.
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += ':';
            } else {
              pairBuffer += ': ';
            }
            pairBuffer += state.dump;
            // Both key and value are valid.
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = _result || '{}';  // Empty mapping if no valid pairs.
        }
        function detectType(state, object, explicit) {
          var _result, typeList, index, length, type, style;
          typeList = explicit ? state.explicitTypes : state.implicitTypes;
          for (index = 0, length = typeList.length; index < length; index += 1) {
            type = typeList[index];
            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
              state.tag = explicit ? type.tag : '?';
              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === '[object Function]') {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
              }
              return true;
            }
          }
          return false;
        }
        // Serializes `object` and writes it to global `result`.
        // Returns true on success, or false on invalid object.
        //
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;
          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }
          var type = _toString.call(state.dump);
          if (block) {
            block = state.flowLevel < 0 || state.flowLevel > level;
          }
          var objectOrArray = type === '[object Object]' || type === '[object Array]', duplicateIndex, duplicate;
          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }
          if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
            compact = false;
          }
          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = '*ref_' + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if (type === '[object Object]') {
              if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object Array]') {
              if (block && state.dump.length !== 0) {
                writeBlockSequence(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object String]') {
              if (state.tag !== '?') {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid)
                return false;
              throw new YAMLException('unacceptable kind of an object to dump ' + type);
            }
            if (state.tag !== null && state.tag !== '?') {
              state.dump = '!<' + state.tag + '> ' + state.dump;
            }
          }
          return true;
        }
        function getDuplicateReferences(object, state) {
          var objects = [], duplicatesIndexes = [], index, length;
          inspectNode(object, objects, duplicatesIndexes);
          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
            state.duplicates.push(objects[duplicatesIndexes[index]]);
          }
          state.usedDuplicates = new Array(length);
        }
        function inspectNode(object, objects, duplicatesIndexes) {
          var objectKeyList, index, length;
          if (object !== null && typeof object === 'object') {
            index = objects.indexOf(object);
            if (index !== -1) {
              if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
              }
            } else {
              objects.push(object);
              if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                  inspectNode(object[index], objects, duplicatesIndexes);
                }
              } else {
                objectKeyList = Object.keys(object);
                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
              }
            }
          }
        }
        function dump(input, options) {
          options = options || {};
          var state = new State(options);
          if (!state.noRefs)
            getDuplicateReferences(input, state);
          if (writeNode(state, 0, input, true, true))
            return state.dump + '\n';
          return '';
        }
        function safeDump(input, options) {
          return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        module.exports.dump = dump;
        module.exports.safeDump = safeDump;
      },
      {
        './common': 47,
        './exception': 49,
        './schema/default_full': 54,
        './schema/default_safe': 55
      }
    ],
    49: [
      function (require, module, exports) {
        // YAML error class. http://stackoverflow.com/questions/8458984
        //
        'use strict';
        function YAMLException(reason, mark) {
          // Super constructor
          Error.call(this);
          this.name = 'YAMLException';
          this.reason = reason;
          this.mark = mark;
          this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
          // Include stack trace in error object
          if (Error.captureStackTrace) {
            // Chrome and NodeJS
            Error.captureStackTrace(this, this.constructor);
          } else {
            // FF, IE 10+ and Safari 6+. Fallback for others
            this.stack = new Error().stack || '';
          }
        }
        // Inherit from Error
        YAMLException.prototype = Object.create(Error.prototype);
        YAMLException.prototype.constructor = YAMLException;
        YAMLException.prototype.toString = function toString(compact) {
          var result = this.name + ': ';
          result += this.reason || '(unknown reason)';
          if (!compact && this.mark) {
            result += ' ' + this.mark.toString();
          }
          return result;
        };
        module.exports = YAMLException;
      },
      {}
    ],
    50: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable max-len,no-use-before-define*/
        var common = require('./common');
        var YAMLException = require('./exception');
        var Mark = require('./mark');
        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;
        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;
        var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function is_EOL(c) {
          return c === 10 || c === 13;
        }
        function is_WHITE_SPACE(c) {
          return c === 9 || c === 32;
        }
        function is_WS_OR_EOL(c) {
          return c === 9 || c === 32 || c === 10 || c === 13;
        }
        function is_FLOW_INDICATOR(c) {
          return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
        }
        function fromHexCode(c) {
          var lc;
          if (48 <= c && c <= 57) {
            return c - 48;
          }
          /*eslint-disable no-bitwise*/
          lc = c | 32;
          if (97 <= lc && lc <= 102) {
            return lc - 97 + 10;
          }
          return -1;
        }
        function escapedHexLen(c) {
          if (c === 120) {
            return 2;
          }
          if (c === 117) {
            return 4;
          }
          if (c === 85) {
            return 8;
          }
          return 0;
        }
        function fromDecimalCode(c) {
          if (48 <= c && c <= 57) {
            return c - 48;
          }
          return -1;
        }
        function simpleEscapeSequence(c) {
          /* eslint-disable indent */
          return c === 48 ? '\0' : c === 97 ? '\x07' : c === 98 ? '\b' : c === 116 ? '\t' : c === 9 ? '\t' : c === 110 ? '\n' : c === 118 ? '\x0B' : c === 102 ? '\f' : c === 114 ? '\r' : c === 101 ? '\x1b' : c === 32 ? ' ' : c === 34 ? '"' : c === 47 ? '/' : c === 92 ? '\\' : c === 78 ? '\x85' : c === 95 ? '\xa0' : c === 76 ? '\u2028' : c === 80 ? '\u2029' : '';
        }
        function charFromCodepoint(c) {
          if (c <= 65535) {
            return String.fromCharCode(c);
          }
          // Encode UTF-16 surrogate pair
          // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
          return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
        }
        var simpleEscapeCheck = new Array(256);
        // integer, for fast access
        var simpleEscapeMap = new Array(256);
        for (var i = 0; i < 256; i++) {
          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
          simpleEscapeMap[i] = simpleEscapeSequence(i);
        }
        function State(input, options) {
          this.input = input;
          this.filename = options['filename'] || null;
          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
          this.onWarning = options['onWarning'] || null;
          this.legacy = options['legacy'] || false;
          this.json = options['json'] || false;
          this.listener = options['listener'] || null;
          this.implicitTypes = this.schema.compiledImplicit;
          this.typeMap = this.schema.compiledTypeMap;
          this.length = input.length;
          this.position = 0;
          this.line = 0;
          this.lineStart = 0;
          this.lineIndent = 0;
          this.documents = [];  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
        }
        function generateError(state, message) {
          return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
        }
        function throwError(state, message) {
          throw generateError(state, message);
        }
        function throwWarning(state, message) {
          if (state.onWarning) {
            state.onWarning.call(null, generateError(state, message));
          }
        }
        var directiveHandlers = {
            YAML: function handleYamlDirective(state, name, args) {
              var match, major, minor;
              if (state.version !== null) {
                throwError(state, 'duplication of %YAML directive');
              }
              if (args.length !== 1) {
                throwError(state, 'YAML directive accepts exactly one argument');
              }
              match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
              if (match === null) {
                throwError(state, 'ill-formed argument of the YAML directive');
              }
              major = parseInt(match[1], 10);
              minor = parseInt(match[2], 10);
              if (major !== 1) {
                throwError(state, 'unacceptable YAML version of the document');
              }
              state.version = args[0];
              state.checkLineBreaks = minor < 2;
              if (minor !== 1 && minor !== 2) {
                throwWarning(state, 'unsupported YAML version of the document');
              }
            },
            TAG: function handleTagDirective(state, name, args) {
              var handle, prefix;
              if (args.length !== 2) {
                throwError(state, 'TAG directive accepts exactly two arguments');
              }
              handle = args[0];
              prefix = args[1];
              if (!PATTERN_TAG_HANDLE.test(handle)) {
                throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
              }
              if (_hasOwnProperty.call(state.tagMap, handle)) {
                throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
              }
              if (!PATTERN_TAG_URI.test(prefix)) {
                throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
              }
              state.tagMap[handle] = prefix;
            }
          };
        function captureSegment(state, start, end, checkJson) {
          var _position, _length, _character, _result;
          if (start < end) {
            _result = state.input.slice(start, end);
            if (checkJson) {
              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                  throwError(state, 'expected valid JSON character');
                }
              }
            } else if (PATTERN_NON_PRINTABLE.test(_result)) {
              throwError(state, 'the stream contains non-printable characters');
            }
            state.result += _result;
          }
        }
        function mergeMappings(state, destination, source, overridableKeys) {
          var sourceKeys, key, index, quantity;
          if (!common.isObject(source)) {
            throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
          }
          sourceKeys = Object.keys(source);
          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
            key = sourceKeys[index];
            if (!_hasOwnProperty.call(destination, key)) {
              destination[key] = source[key];
              overridableKeys[key] = true;
            }
          }
        }
        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
          var index, quantity;
          keyNode = String(keyNode);
          if (_result === null) {
            _result = {};
          }
          if (keyTag === 'tag:yaml.org,2002:merge') {
            if (Array.isArray(valueNode)) {
              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                mergeMappings(state, _result, valueNode[index], overridableKeys);
              }
            } else {
              mergeMappings(state, _result, valueNode, overridableKeys);
            }
          } else {
            if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
              state.line = startLine || state.line;
              state.position = startPos || state.position;
              throwError(state, 'duplicated mapping key');
            }
            _result[keyNode] = valueNode;
            delete overridableKeys[keyNode];
          }
          return _result;
        }
        function readLineBreak(state) {
          var ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 10) {
            state.position++;
          } else if (ch === 13) {
            state.position++;
            if (state.input.charCodeAt(state.position) === 10) {
              state.position++;
            }
          } else {
            throwError(state, 'a line break is expected');
          }
          state.line += 1;
          state.lineStart = state.position;
        }
        function skipSeparationSpace(state, allowComments, checkIndent) {
          var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (allowComments && ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 10 && ch !== 13 && ch !== 0);
            }
            if (is_EOL(ch)) {
              readLineBreak(state);
              ch = state.input.charCodeAt(state.position);
              lineBreaks++;
              state.lineIndent = 0;
              while (ch === 32) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
            } else {
              break;
            }
          }
          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
            throwWarning(state, 'deficient indentation');
          }
          return lineBreaks;
        }
        function testDocumentSeparator(state) {
          var _position = state.position, ch;
          ch = state.input.charCodeAt(_position);
          // Condition state.position === state.lineStart is tested
          // in parent on each call, for efficiency. No needs to test here again.
          if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
            _position += 3;
            ch = state.input.charCodeAt(_position);
            if (ch === 0 || is_WS_OR_EOL(ch)) {
              return true;
            }
          }
          return false;
        }
        function writeFoldedLines(state, count) {
          if (count === 1) {
            state.result += ' ';
          } else if (count > 1) {
            state.result += common.repeat('\n', count - 1);
          }
        }
        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
          var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
          ch = state.input.charCodeAt(state.position);
          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
            return false;
          }
          if (ch === 63 || ch === 45) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              return false;
            }
          }
          state.kind = 'scalar';
          state.result = '';
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
          while (ch !== 0) {
            if (ch === 58) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
              }
            } else if (ch === 35) {
              preceding = state.input.charCodeAt(state.position - 1);
              if (is_WS_OR_EOL(preceding)) {
                break;
              }
            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
              break;
            } else if (is_EOL(ch)) {
              _line = state.line;
              _lineStart = state.lineStart;
              _lineIndent = state.lineIndent;
              skipSeparationSpace(state, false, -1);
              if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
              } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
              }
            }
            if (hasPendingContent) {
              captureSegment(state, captureStart, captureEnd, false);
              writeFoldedLines(state, state.line - _line);
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
            }
            if (!is_WHITE_SPACE(ch)) {
              captureEnd = state.position + 1;
            }
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, captureEnd, false);
          if (state.result) {
            return true;
          }
          state.kind = _kind;
          state.result = _result;
          return false;
        }
        function readSingleQuotedScalar(state, nodeIndent) {
          var ch, captureStart, captureEnd;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 39) {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 39) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (ch === 39) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
              } else {
                return true;
              }
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a single quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a single quoted scalar');
        }
        function readDoubleQuotedScalar(state, nodeIndent) {
          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 34) {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 34) {
              captureSegment(state, captureStart, state.position, true);
              state.position++;
              return true;
            } else if (ch === 92) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);  // TODO: rework to inline fn with no type cast?
              } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
              } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for (; hexLength > 0; hexLength--) {
                  ch = state.input.charCodeAt(++state.position);
                  if ((tmp = fromHexCode(ch)) >= 0) {
                    hexResult = (hexResult << 4) + tmp;
                  } else {
                    throwError(state, 'expected hexadecimal character');
                  }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
              } else {
                throwError(state, 'unknown escape sequence');
              }
              captureStart = captureEnd = state.position;
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a double quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a double quoted scalar');
        }
        function readFlowCollection(state, nodeIndent) {
          var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 91) {
            terminator = 93;
            /* ] */
            isMapping = false;
            _result = [];
          } else if (ch === 123) {
            terminator = 125;
            /* } */
            isMapping = true;
            _result = {};
          } else {
            return false;
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(++state.position);
          while (ch !== 0) {
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === terminator) {
              state.position++;
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = isMapping ? 'mapping' : 'sequence';
              state.result = _result;
              return true;
            } else if (!readNext) {
              throwError(state, 'missed comma between flow collection entries');
            }
            keyTag = keyNode = valueNode = null;
            isPair = isExplicitPair = false;
            if (ch === 63) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            keyTag = state.tag;
            keyNode = state.result;
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if ((isExplicitPair || state.line === _line) && ch === 58) {
              isPair = true;
              ch = state.input.charCodeAt(++state.position);
              skipSeparationSpace(state, true, nodeIndent);
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              valueNode = state.result;
            }
            if (isMapping) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
            } else if (isPair) {
              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
            } else {
              _result.push(keyNode);
            }
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === 44) {
              readNext = true;
              ch = state.input.charCodeAt(++state.position);
            } else {
              readNext = false;
            }
          }
          throwError(state, 'unexpected end of the stream within a flow collection');
        }
        function readBlockScalar(state, nodeIndent) {
          var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 124) {
            folding = false;
          } else if (ch === 62) {
            folding = true;
          } else {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          while (ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
            if (ch === 43 || ch === 45) {
              if (CHOMPING_CLIP === chomping) {
                chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
              } else {
                throwError(state, 'repeat of a chomping mode identifier');
              }
            } else if ((tmp = fromDecimalCode(ch)) >= 0) {
              if (tmp === 0) {
                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
              } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
              } else {
                throwError(state, 'repeat of an indentation width identifier');
              }
            } else {
              break;
            }
          }
          if (is_WHITE_SPACE(ch)) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (is_WHITE_SPACE(ch));
            if (ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (!is_EOL(ch) && ch !== 0);
            }
          }
          while (ch !== 0) {
            readLineBreak(state);
            state.lineIndent = 0;
            ch = state.input.charCodeAt(state.position);
            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
            if (!detectedIndent && state.lineIndent > textIndent) {
              textIndent = state.lineIndent;
            }
            if (is_EOL(ch)) {
              emptyLines++;
              continue;
            }
            // End of the scalar.
            if (state.lineIndent < textIndent) {
              // Perform the chomping.
              if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
              } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                  // i.e. only if the scalar is not empty.
                  state.result += '\n';
                }
              }
              // Break this `while` cycle and go to the funciton's epilogue.
              break;
            }
            // Folded style: use fancy rules to handle line breaks.
            if (folding) {
              // Lines starting with white space characters (more-indented lines) are not folded.
              if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);  // End of more-indented block.
              } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat('\n', emptyLines + 1);  // Just one line break - perceive as the same line.
              } else if (emptyLines === 0) {
                if (didReadContent) {
                  // i.e. only if we have already read some scalar content.
                  state.result += ' ';
                }  // Several line breaks - perceive as different lines.
              } else {
                state.result += common.repeat('\n', emptyLines);
              }  // Literal style: just add exact number of line breaks between content lines.
            } else {
              // Keep all line breaks except the header line break.
              state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
            }
            didReadContent = true;
            detectedIndent = true;
            emptyLines = 0;
            captureStart = state.position;
            while (!is_EOL(ch) && ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, state.position, false);
          }
          return true;
        }
        function readBlockSequence(state, nodeIndent) {
          var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            if (ch !== 45) {
              break;
            }
            following = state.input.charCodeAt(state.position + 1);
            if (!is_WS_OR_EOL(following)) {
              break;
            }
            detected = true;
            state.position++;
            if (skipSeparationSpace(state, true, -1)) {
              if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
            _result.push(state.result);
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
              throwError(state, 'bad indentation of a sequence entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'sequence';
            state.result = _result;
            return true;
          }
          return false;
        }
        function readBlockMapping(state, nodeIndent, flowIndent) {
          var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            following = state.input.charCodeAt(state.position + 1);
            _line = state.line;
            // Save the current line.
            _pos = state.position;
            //
            // Explicit notation case. There are two separate blocks:
            // first for the key (denoted by "?") and second for the value (denoted by ":")
            //
            if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
              if (ch === 63) {
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
              } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
              } else {
                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
              }
              state.position += 1;
              ch = following;  //
                               // Implicit notation case. Flow-style node as the key first, then ":", and the value.
                               //
            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 58) {
                  ch = state.input.charCodeAt(++state.position);
                  if (!is_WS_OR_EOL(ch)) {
                    throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                  }
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = false;
                  allowCompact = false;
                  keyTag = state.tag;
                  keyNode = state.result;
                } else if (detected) {
                  throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;  // Keep the result of `composeNode`.
                }
              } else if (detected) {
                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;  // Keep the result of `composeNode`.
              }
            } else {
              break;  // Reading is done. Go to the epilogue.
            }
            //
            // Common reading code for both explicit and implicit notations.
            //
            if (state.line === _line || state.lineIndent > nodeIndent) {
              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                  keyNode = state.result;
                } else {
                  valueNode = state.result;
                }
              }
              if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
              }
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
            }
            if (state.lineIndent > nodeIndent && ch !== 0) {
              throwError(state, 'bad indentation of a mapping entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          //
          // Epilogue.
          //
          // Special case: last mapping's node contains only the key in explicit notation.
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          }
          // Expose the resulting mapping.
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'mapping';
            state.result = _result;
          }
          return detected;
        }
        function readTagProperty(state) {
          var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 33)
            return false;
          if (state.tag !== null) {
            throwError(state, 'duplication of a tag property');
          }
          ch = state.input.charCodeAt(++state.position);
          if (ch === 60) {
            isVerbatim = true;
            ch = state.input.charCodeAt(++state.position);
          } else if (ch === 33) {
            isNamed = true;
            tagHandle = '!!';
            ch = state.input.charCodeAt(++state.position);
          } else {
            tagHandle = '!';
          }
          _position = state.position;
          if (isVerbatim) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && ch !== 62);
            if (state.position < state.length) {
              tagName = state.input.slice(_position, state.position);
              ch = state.input.charCodeAt(++state.position);
            } else {
              throwError(state, 'unexpected end of the stream within a verbatim tag');
            }
          } else {
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              if (ch === 33) {
                if (!isNamed) {
                  tagHandle = state.input.slice(_position - 1, state.position + 1);
                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                    throwError(state, 'named tag handle cannot contain such characters');
                  }
                  isNamed = true;
                  _position = state.position + 1;
                } else {
                  throwError(state, 'tag suffix cannot contain exclamation marks');
                }
              }
              ch = state.input.charCodeAt(++state.position);
            }
            tagName = state.input.slice(_position, state.position);
            if (PATTERN_FLOW_INDICATORS.test(tagName)) {
              throwError(state, 'tag suffix cannot contain flow indicator characters');
            }
          }
          if (tagName && !PATTERN_TAG_URI.test(tagName)) {
            throwError(state, 'tag name cannot contain such characters: ' + tagName);
          }
          if (isVerbatim) {
            state.tag = tagName;
          } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
            state.tag = state.tagMap[tagHandle] + tagName;
          } else if (tagHandle === '!') {
            state.tag = '!' + tagName;
          } else if (tagHandle === '!!') {
            state.tag = 'tag:yaml.org,2002:' + tagName;
          } else {
            throwError(state, 'undeclared tag handle "' + tagHandle + '"');
          }
          return true;
        }
        function readAnchorProperty(state) {
          var _position, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 38)
            return false;
          if (state.anchor !== null) {
            throwError(state, 'duplication of an anchor property');
          }
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an anchor node must contain at least one character');
          }
          state.anchor = state.input.slice(_position, state.position);
          return true;
        }
        function readAlias(state) {
          var _position, alias, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 42)
            return false;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an alias node must contain at least one character');
          }
          alias = state.input.slice(_position, state.position);
          if (!state.anchorMap.hasOwnProperty(alias)) {
            throwError(state, 'unidentified alias "' + alias + '"');
          }
          state.result = state.anchorMap[alias];
          skipSeparationSpace(state, true, -1);
          return true;
        }
        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
          var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1,
            // 1: this>parent, 0: this=parent, -1: this<parent
            atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
          if (state.listener !== null) {
            state.listener('open', state);
          }
          state.tag = null;
          state.anchor = null;
          state.kind = null;
          state.result = null;
          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
          if (allowToSeek) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            }
          }
          if (indentStatus === 1) {
            while (readTagProperty(state) || readAnchorProperty(state)) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              } else {
                allowBlockCollections = false;
              }
            }
          }
          if (allowBlockCollections) {
            allowBlockCollections = atNewLine || allowCompact;
          }
          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
              flowIndent = parentIndent;
            } else {
              flowIndent = parentIndent + 1;
            }
            blockIndent = state.position - state.lineStart;
            if (indentStatus === 1) {
              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
              } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                  hasContent = true;
                } else if (readAlias(state)) {
                  hasContent = true;
                  if (state.tag !== null || state.anchor !== null) {
                    throwError(state, 'alias node should not have any properties');
                  }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                  hasContent = true;
                  if (state.tag === null) {
                    state.tag = '?';
                  }
                }
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else if (indentStatus === 0) {
              // Special case: block sequences are allowed to have same indentation level as the parent.
              // http://www.yaml.org/spec/1.2/spec.html#id2799784
              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
          }
          if (state.tag !== null && state.tag !== '!') {
            if (state.tag === '?') {
              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                // Implicit resolving is not allowed for non-scalar types, and '?'
                // non-specific tag is only assigned to plain scalars. So, it isn't
                // needed to check for 'kind' conformity.
                if (type.resolve(state.result)) {
                  // `state.result` updated in resolver if matched
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
              type = state.typeMap[state.kind || 'fallback'][state.tag];
              if (state.result !== null && type.kind !== state.kind) {
                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
              }
              if (!type.resolve(state.result)) {
                // `state.result` updated in resolver if matched
                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
              } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else {
              throwError(state, 'unknown tag !<' + state.tag + '>');
            }
          }
          if (state.listener !== null) {
            state.listener('close', state);
          }
          return state.tag !== null || state.anchor !== null || hasContent;
        }
        function readDocument(state) {
          var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
          state.version = null;
          state.checkLineBreaks = state.legacy;
          state.tagMap = {};
          state.anchorMap = {};
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if (state.lineIndent > 0 || ch !== 37) {
              break;
            }
            hasDirectives = true;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveName = state.input.slice(_position, state.position);
            directiveArgs = [];
            if (directiveName.length < 1) {
              throwError(state, 'directive name must not be less than one character in length');
            }
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 35) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && !is_EOL(ch));
                break;
              }
              if (is_EOL(ch))
                break;
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveArgs.push(state.input.slice(_position, state.position));
            }
            if (ch !== 0)
              readLineBreak(state);
            if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
              directiveHandlers[directiveName](state, directiveName, directiveArgs);
            } else {
              throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
          }
          skipSeparationSpace(state, true, -1);
          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          } else if (hasDirectives) {
            throwError(state, 'directives end mark is expected');
          }
          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
          skipSeparationSpace(state, true, -1);
          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
            throwWarning(state, 'non-ASCII line breaks are interpreted as content');
          }
          state.documents.push(state.result);
          if (state.position === state.lineStart && testDocumentSeparator(state)) {
            if (state.input.charCodeAt(state.position) === 46) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            }
            return;
          }
          if (state.position < state.length - 1) {
            throwError(state, 'end of the stream or a document separator is expected');
          } else {
            return;
          }
        }
        function loadDocuments(input, options) {
          input = String(input);
          options = options || {};
          if (input.length !== 0) {
            // Add tailing `\n` if not exists
            if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
              input += '\n';
            }
            // Strip BOM
            if (input.charCodeAt(0) === 65279) {
              input = input.slice(1);
            }
          }
          var state = new State(input, options);
          // Use 0 as string terminator. That significantly simplifies bounds check.
          state.input += '\0';
          while (state.input.charCodeAt(state.position) === 32) {
            state.lineIndent += 1;
            state.position += 1;
          }
          while (state.position < state.length - 1) {
            readDocument(state);
          }
          return state.documents;
        }
        function loadAll(input, iterator, options) {
          var documents = loadDocuments(input, options), index, length;
          if (typeof iterator !== 'function') {
            return documents;
          }
          for (index = 0, length = documents.length; index < length; index += 1) {
            iterator(documents[index]);
          }
        }
        function load(input, options) {
          var documents = loadDocuments(input, options);
          if (documents.length === 0) {
            /*eslint-disable no-undefined*/
            return undefined;
          } else if (documents.length === 1) {
            return documents[0];
          }
          throw new YAMLException('expected a single document in the stream, but found more');
        }
        function safeLoadAll(input, output, options) {
          if (typeof output === 'function') {
            loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
          } else {
            return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
          }
        }
        function safeLoad(input, options) {
          return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        module.exports.loadAll = loadAll;
        module.exports.load = load;
        module.exports.safeLoadAll = safeLoadAll;
        module.exports.safeLoad = safeLoad;
      },
      {
        './common': 47,
        './exception': 49,
        './mark': 51,
        './schema/default_full': 54,
        './schema/default_safe': 55
      }
    ],
    51: [
      function (require, module, exports) {
        'use strict';
        var common = require('./common');
        function Mark(name, buffer, position, line, column) {
          this.name = name;
          this.buffer = buffer;
          this.position = position;
          this.line = line;
          this.column = column;
        }
        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
          var head, start, tail, end, snippet;
          if (!this.buffer)
            return null;
          indent = indent || 4;
          maxLength = maxLength || 75;
          head = '';
          start = this.position;
          while (start > 0 && '\0\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
              head = ' ... ';
              start += 5;
              break;
            }
          }
          tail = '';
          end = this.position;
          while (end < this.buffer.length && '\0\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
              tail = ' ... ';
              end -= 5;
              break;
            }
          }
          snippet = this.buffer.slice(start, end);
          return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
        };
        Mark.prototype.toString = function toString(compact) {
          var snippet, where = '';
          if (this.name) {
            where += 'in "' + this.name + '" ';
          }
          where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
          if (!compact) {
            snippet = this.getSnippet();
            if (snippet) {
              where += ':\n' + snippet;
            }
          }
          return where;
        };
        module.exports = Mark;
      },
      { './common': 47 }
    ],
    52: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable max-len*/
        var common = require('./common');
        var YAMLException = require('./exception');
        var Type = require('./type');
        function compileList(schema, name, result) {
          var exclude = [];
          schema.include.forEach(function (includedSchema) {
            result = compileList(includedSchema, name, result);
          });
          schema[name].forEach(function (currentType) {
            result.forEach(function (previousType, previousIndex) {
              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
              }
            });
            result.push(currentType);
          });
          return result.filter(function (type, index) {
            return exclude.indexOf(index) === -1;
          });
        }
        function compileMap() {
          var result = {
              scalar: {},
              sequence: {},
              mapping: {},
              fallback: {}
            }, index, length;
          function collectType(type) {
            result[type.kind][type.tag] = result['fallback'][type.tag] = type;
          }
          for (index = 0, length = arguments.length; index < length; index += 1) {
            arguments[index].forEach(collectType);
          }
          return result;
        }
        function Schema(definition) {
          this.include = definition.include || [];
          this.implicit = definition.implicit || [];
          this.explicit = definition.explicit || [];
          this.implicit.forEach(function (type) {
            if (type.loadKind && type.loadKind !== 'scalar') {
              throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
            }
          });
          this.compiledImplicit = compileList(this, 'implicit', []);
          this.compiledExplicit = compileList(this, 'explicit', []);
          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
        }
        Schema.DEFAULT = null;
        Schema.create = function createSchema() {
          var schemas, types;
          switch (arguments.length) {
          case 1:
            schemas = Schema.DEFAULT;
            types = arguments[0];
            break;
          case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
          default:
            throw new YAMLException('Wrong number of arguments for Schema.create function');
          }
          schemas = common.toArray(schemas);
          types = common.toArray(types);
          if (!schemas.every(function (schema) {
              return schema instanceof Schema;
            })) {
            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
          }
          if (!types.every(function (type) {
              return type instanceof Type;
            })) {
            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
          }
          return new Schema({
            include: schemas,
            explicit: types
          });
        };
        module.exports = Schema;
      },
      {
        './common': 47,
        './exception': 49,
        './type': 58
      }
    ],
    53: [
      function (require, module, exports) {
        // Standard YAML's Core schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2804923
        //
        // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
        // So, Core schema has no distinctions from JSON schema is JS-YAML.
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({ include: [require('./json')] });
      },
      {
        '../schema': 52,
        './json': 57
      }
    ],
    54: [
      function (require, module, exports) {
        // JS-YAML's default schema for `load` function.
        // It is not described in the YAML specification.
        //
        // This schema is based on JS-YAML's default safe schema and includes
        // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
        //
        // Also this schema is used as default base schema at `Schema.create` function.
        'use strict';
        var Schema = require('../schema');
        module.exports = Schema.DEFAULT = new Schema({
          include: [require('./default_safe')],
          explicit: [
            require('../type/js/undefined'),
            require('../type/js/regexp'),
            require('../type/js/function')
          ]
        });
      },
      {
        '../schema': 52,
        '../type/js/function': 63,
        '../type/js/regexp': 64,
        '../type/js/undefined': 65,
        './default_safe': 55
      }
    ],
    55: [
      function (require, module, exports) {
        // JS-YAML's default schema for `safeLoad` function.
        // It is not described in the YAML specification.
        //
        // This schema is based on standard YAML's Core schema and includes most of
        // extra types described at YAML tag repository. (http://yaml.org/type/)
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({
          include: [require('./core')],
          implicit: [
            require('../type/timestamp'),
            require('../type/merge')
          ],
          explicit: [
            require('../type/binary'),
            require('../type/omap'),
            require('../type/pairs'),
            require('../type/set')
          ]
        });
      },
      {
        '../schema': 52,
        '../type/binary': 59,
        '../type/merge': 67,
        '../type/omap': 69,
        '../type/pairs': 70,
        '../type/set': 72,
        '../type/timestamp': 74,
        './core': 53
      }
    ],
    56: [
      function (require, module, exports) {
        // Standard YAML's Failsafe schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2802346
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({
          explicit: [
            require('../type/str'),
            require('../type/seq'),
            require('../type/map')
          ]
        });
      },
      {
        '../schema': 52,
        '../type/map': 66,
        '../type/seq': 71,
        '../type/str': 73
      }
    ],
    57: [
      function (require, module, exports) {
        // Standard YAML's JSON schema.
        // http://www.yaml.org/spec/1.2/spec.html#id2803231
        //
        // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
        // So, this schema is not such strict as defined in the YAML specification.
        // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
        'use strict';
        var Schema = require('../schema');
        module.exports = new Schema({
          include: [require('./failsafe')],
          implicit: [
            require('../type/null'),
            require('../type/bool'),
            require('../type/int'),
            require('../type/float')
          ]
        });
      },
      {
        '../schema': 52,
        '../type/bool': 60,
        '../type/float': 61,
        '../type/int': 62,
        '../type/null': 68,
        './failsafe': 56
      }
    ],
    58: [
      function (require, module, exports) {
        'use strict';
        var YAMLException = require('./exception');
        var TYPE_CONSTRUCTOR_OPTIONS = [
            'kind',
            'resolve',
            'construct',
            'instanceOf',
            'predicate',
            'represent',
            'defaultStyle',
            'styleAliases'
          ];
        var YAML_NODE_KINDS = [
            'scalar',
            'sequence',
            'mapping'
          ];
        function compileStyleAliases(map) {
          var result = {};
          if (map !== null) {
            Object.keys(map).forEach(function (style) {
              map[style].forEach(function (alias) {
                result[String(alias)] = style;
              });
            });
          }
          return result;
        }
        function Type(tag, options) {
          options = options || {};
          Object.keys(options).forEach(function (name) {
            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
              throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            }
          });
          // TODO: Add tag format check.
          this.tag = tag;
          this.kind = options['kind'] || null;
          this.resolve = options['resolve'] || function () {
            return true;
          };
          this.construct = options['construct'] || function (data) {
            return data;
          };
          this.instanceOf = options['instanceOf'] || null;
          this.predicate = options['predicate'] || null;
          this.represent = options['represent'] || null;
          this.defaultStyle = options['defaultStyle'] || null;
          this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
            throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
          }
        }
        module.exports = Type;
      },
      { './exception': 49 }
    ],
    59: [
      function (require, module, exports) {
        'use strict';
        /*eslint-disable no-bitwise*/
        var NodeBuffer;
        try {
          // A trick for browserified version, to not include `Buffer` shim
          var _require = require;
          NodeBuffer = _require('buffer').Buffer;
        } catch (__) {
        }
        var Type = require('../type');
        // [ 64, 65, 66 ] -> [ padding, CR, LF ]
        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
        function resolveYamlBinary(data) {
          if (data === null)
            return false;
          var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
          // Convert one by one.
          for (idx = 0; idx < max; idx++) {
            code = map.indexOf(data.charAt(idx));
            // Skip CR/LF
            if (code > 64)
              continue;
            // Fail on illegal characters
            if (code < 0)
              return false;
            bitlen += 6;
          }
          // If there are any bits left, source was corrupted
          return bitlen % 8 === 0;
        }
        function constructYamlBinary(data) {
          var idx, tailbits, input = data.replace(/[\r\n=]/g, ''),
            // remove CR/LF & padding to simplify scan
            max = input.length, map = BASE64_MAP, bits = 0, result = [];
          // Collect by 6*4 bits (3 bytes)
          for (idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              result.push(bits >> 16 & 255);
              result.push(bits >> 8 & 255);
              result.push(bits & 255);
            }
            bits = bits << 6 | map.indexOf(input.charAt(idx));
          }
          // Dump tail
          tailbits = max % 4 * 6;
          if (tailbits === 0) {
            result.push(bits >> 16 & 255);
            result.push(bits >> 8 & 255);
            result.push(bits & 255);
          } else if (tailbits === 18) {
            result.push(bits >> 10 & 255);
            result.push(bits >> 2 & 255);
          } else if (tailbits === 12) {
            result.push(bits >> 4 & 255);
          }
          // Wrap into Buffer for NodeJS and leave Array for browser
          if (NodeBuffer) {
            // Support node 6.+ Buffer API when available
            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
          }
          return result;
        }
        function representYamlBinary(object) {
          var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
          // Convert every three bytes to 4 ASCII characters.
          for (idx = 0; idx < max; idx++) {
            if (idx % 3 === 0 && idx) {
              result += map[bits >> 18 & 63];
              result += map[bits >> 12 & 63];
              result += map[bits >> 6 & 63];
              result += map[bits & 63];
            }
            bits = (bits << 8) + object[idx];
          }
          // Dump tail
          tail = max % 3;
          if (tail === 0) {
            result += map[bits >> 18 & 63];
            result += map[bits >> 12 & 63];
            result += map[bits >> 6 & 63];
            result += map[bits & 63];
          } else if (tail === 2) {
            result += map[bits >> 10 & 63];
            result += map[bits >> 4 & 63];
            result += map[bits << 2 & 63];
            result += map[64];
          } else if (tail === 1) {
            result += map[bits >> 2 & 63];
            result += map[bits << 4 & 63];
            result += map[64];
            result += map[64];
          }
          return result;
        }
        function isBinary(object) {
          return NodeBuffer && NodeBuffer.isBuffer(object);
        }
        module.exports = new Type('tag:yaml.org,2002:binary', {
          kind: 'scalar',
          resolve: resolveYamlBinary,
          construct: constructYamlBinary,
          predicate: isBinary,
          represent: representYamlBinary
        });
      },
      { '../type': 58 }
    ],
    60: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        function resolveYamlBoolean(data) {
          if (data === null)
            return false;
          var max = data.length;
          return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
        }
        function constructYamlBoolean(data) {
          return data === 'true' || data === 'True' || data === 'TRUE';
        }
        function isBoolean(object) {
          return Object.prototype.toString.call(object) === '[object Boolean]';
        }
        module.exports = new Type('tag:yaml.org,2002:bool', {
          kind: 'scalar',
          resolve: resolveYamlBoolean,
          construct: constructYamlBoolean,
          predicate: isBoolean,
          represent: {
            lowercase: function (object) {
              return object ? 'true' : 'false';
            },
            uppercase: function (object) {
              return object ? 'TRUE' : 'FALSE';
            },
            camelcase: function (object) {
              return object ? 'True' : 'False';
            }
          },
          defaultStyle: 'lowercase'
        });
      },
      { '../type': 58 }
    ],
    61: [
      function (require, module, exports) {
        'use strict';
        var common = require('../common');
        var Type = require('../type');
        var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');
        function resolveYamlFloat(data) {
          if (data === null)
            return false;
          if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === '_') {
            return false;
          }
          return true;
        }
        function constructYamlFloat(data) {
          var value, sign, base, digits;
          value = data.replace(/_/g, '').toLowerCase();
          sign = value[0] === '-' ? -1 : 1;
          digits = [];
          if ('+-'.indexOf(value[0]) >= 0) {
            value = value.slice(1);
          }
          if (value === '.inf') {
            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          } else if (value === '.nan') {
            return NaN;
          } else if (value.indexOf(':') >= 0) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseFloat(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseFloat(value, 10);
        }
        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
        function representYamlFloat(object, style) {
          var res;
          if (isNaN(object)) {
            switch (style) {
            case 'lowercase':
              return '.nan';
            case 'uppercase':
              return '.NAN';
            case 'camelcase':
              return '.NaN';
            }
          } else if (Number.POSITIVE_INFINITY === object) {
            switch (style) {
            case 'lowercase':
              return '.inf';
            case 'uppercase':
              return '.INF';
            case 'camelcase':
              return '.Inf';
            }
          } else if (Number.NEGATIVE_INFINITY === object) {
            switch (style) {
            case 'lowercase':
              return '-.inf';
            case 'uppercase':
              return '-.INF';
            case 'camelcase':
              return '-.Inf';
            }
          } else if (common.isNegativeZero(object)) {
            return '-0.0';
          }
          res = object.toString(10);
          // JS stringifier can build scientific format without dots: 5e-100,
          // while YAML requres dot: 5.e-100. Fix it with simple hack
          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
        }
        function isFloat(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
        }
        module.exports = new Type('tag:yaml.org,2002:float', {
          kind: 'scalar',
          resolve: resolveYamlFloat,
          construct: constructYamlFloat,
          predicate: isFloat,
          represent: representYamlFloat,
          defaultStyle: 'lowercase'
        });
      },
      {
        '../common': 47,
        '../type': 58
      }
    ],
    62: [
      function (require, module, exports) {
        'use strict';
        var common = require('../common');
        var Type = require('../type');
        function isHexCode(c) {
          return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
        }
        function isOctCode(c) {
          return 48 <= c && c <= 55;
        }
        function isDecCode(c) {
          return 48 <= c && c <= 57;
        }
        function resolveYamlInteger(data) {
          if (data === null)
            return false;
          var max = data.length, index = 0, hasDigits = false, ch;
          if (!max)
            return false;
          ch = data[index];
          // sign
          if (ch === '-' || ch === '+') {
            ch = data[++index];
          }
          if (ch === '0') {
            // 0
            if (index + 1 === max)
              return true;
            ch = data[++index];
            // base 2, base 8, base 16
            if (ch === 'b') {
              // base 2
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_')
                  continue;
                if (ch !== '0' && ch !== '1')
                  return false;
                hasDigits = true;
              }
              return hasDigits && ch !== '_';
            }
            if (ch === 'x') {
              // base 16
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_')
                  continue;
                if (!isHexCode(data.charCodeAt(index)))
                  return false;
                hasDigits = true;
              }
              return hasDigits && ch !== '_';
            }
            // base 8
            for (; index < max; index++) {
              ch = data[index];
              if (ch === '_')
                continue;
              if (!isOctCode(data.charCodeAt(index)))
                return false;
              hasDigits = true;
            }
            return hasDigits && ch !== '_';
          }
          // base 10 (except 0) or base 60
          // value should not start with `_`;
          if (ch === '_')
            return false;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_')
              continue;
            if (ch === ':')
              break;
            if (!isDecCode(data.charCodeAt(index))) {
              return false;
            }
            hasDigits = true;
          }
          // Should have digits and should not end with `_`
          if (!hasDigits || ch === '_')
            return false;
          // if !base60 - done;
          if (ch !== ':')
            return true;
          // base60 almost not used, no needs to optimize
          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
        }
        function constructYamlInteger(data) {
          var value = data, sign = 1, ch, base, digits = [];
          if (value.indexOf('_') !== -1) {
            value = value.replace(/_/g, '');
          }
          ch = value[0];
          if (ch === '-' || ch === '+') {
            if (ch === '-')
              sign = -1;
            value = value.slice(1);
            ch = value[0];
          }
          if (value === '0')
            return 0;
          if (ch === '0') {
            if (value[1] === 'b')
              return sign * parseInt(value.slice(2), 2);
            if (value[1] === 'x')
              return sign * parseInt(value, 16);
            return sign * parseInt(value, 8);
          }
          if (value.indexOf(':') !== -1) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseInt(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseInt(value, 10);
        }
        function isInteger(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 === 0 && !common.isNegativeZero(object));
        }
        module.exports = new Type('tag:yaml.org,2002:int', {
          kind: 'scalar',
          resolve: resolveYamlInteger,
          construct: constructYamlInteger,
          predicate: isInteger,
          represent: {
            binary: function (object) {
              return '0b' + object.toString(2);
            },
            octal: function (object) {
              return '0' + object.toString(8);
            },
            decimal: function (object) {
              return object.toString(10);
            },
            hexadecimal: function (object) {
              return '0x' + object.toString(16).toUpperCase();
            }
          },
          defaultStyle: 'decimal',
          styleAliases: {
            binary: [
              2,
              'bin'
            ],
            octal: [
              8,
              'oct'
            ],
            decimal: [
              10,
              'dec'
            ],
            hexadecimal: [
              16,
              'hex'
            ]
          }
        });
      },
      {
        '../common': 47,
        '../type': 58
      }
    ],
    63: [
      function (require, module, exports) {
        'use strict';
        var esprima;
        // Browserified version does not have esprima
        //
        // 1. For node.js just require module as deps
        // 2. For browser try to require mudule via external AMD system.
        //    If not found - try to fallback to window.esprima. If not
        //    found too - then fail to parse.
        //
        try {
          // workaround to exclude package from browserify list.
          var _require = require;
          esprima = _require('esprima');
        } catch (_) {
          /*global window */
          if (typeof window !== 'undefined')
            esprima = window.esprima;
        }
        var Type = require('../../type');
        function resolveJavascriptFunction(data) {
          if (data === null)
            return false;
          try {
            var source = '(' + data + ')', ast = esprima.parse(source, { range: true });
            if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        function constructJavascriptFunction(data) {
          /*jslint evil:true*/
          var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
            throw new Error('Failed to resolve function');
          }
          ast.body[0].expression.params.forEach(function (param) {
            params.push(param.name);
          });
          body = ast.body[0].expression.body.range;
          // Esprima's ranges include the first '{' and the last '}' characters on
          // function expressions. So cut them out.
          /*eslint-disable no-new-func*/
          return new Function(params, source.slice(body[0] + 1, body[1] - 1));
        }
        function representJavascriptFunction(object) {
          return object.toString();
        }
        function isFunction(object) {
          return Object.prototype.toString.call(object) === '[object Function]';
        }
        module.exports = new Type('tag:yaml.org,2002:js/function', {
          kind: 'scalar',
          resolve: resolveJavascriptFunction,
          construct: constructJavascriptFunction,
          predicate: isFunction,
          represent: representJavascriptFunction
        });
      },
      { '../../type': 58 }
    ],
    64: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../../type');
        function resolveJavascriptRegExp(data) {
          if (data === null)
            return false;
          if (data.length === 0)
            return false;
          var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
          // if regexp starts with '/' it can have modifiers and must be properly closed
          // `/foo/gim` - modifiers tail can be maximum 3 chars
          if (regexp[0] === '/') {
            if (tail)
              modifiers = tail[1];
            if (modifiers.length > 3)
              return false;
            // if expression starts with /, is should be properly terminated
            if (regexp[regexp.length - modifiers.length - 1] !== '/')
              return false;
          }
          return true;
        }
        function constructJavascriptRegExp(data) {
          var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
          // `/foo/gim` - tail can be maximum 4 chars
          if (regexp[0] === '/') {
            if (tail)
              modifiers = tail[1];
            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
          }
          return new RegExp(regexp, modifiers);
        }
        function representJavascriptRegExp(object) {
          var result = '/' + object.source + '/';
          if (object.global)
            result += 'g';
          if (object.multiline)
            result += 'm';
          if (object.ignoreCase)
            result += 'i';
          return result;
        }
        function isRegExp(object) {
          return Object.prototype.toString.call(object) === '[object RegExp]';
        }
        module.exports = new Type('tag:yaml.org,2002:js/regexp', {
          kind: 'scalar',
          resolve: resolveJavascriptRegExp,
          construct: constructJavascriptRegExp,
          predicate: isRegExp,
          represent: representJavascriptRegExp
        });
      },
      { '../../type': 58 }
    ],
    65: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../../type');
        function resolveJavascriptUndefined() {
          return true;
        }
        function constructJavascriptUndefined() {
          /*eslint-disable no-undefined*/
          return undefined;
        }
        function representJavascriptUndefined() {
          return '';
        }
        function isUndefined(object) {
          return typeof object === 'undefined';
        }
        module.exports = new Type('tag:yaml.org,2002:js/undefined', {
          kind: 'scalar',
          resolve: resolveJavascriptUndefined,
          construct: constructJavascriptUndefined,
          predicate: isUndefined,
          represent: representJavascriptUndefined
        });
      },
      { '../../type': 58 }
    ],
    66: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        module.exports = new Type('tag:yaml.org,2002:map', {
          kind: 'mapping',
          construct: function (data) {
            return data !== null ? data : {};
          }
        });
      },
      { '../type': 58 }
    ],
    67: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        function resolveYamlMerge(data) {
          return data === '<<' || data === null;
        }
        module.exports = new Type('tag:yaml.org,2002:merge', {
          kind: 'scalar',
          resolve: resolveYamlMerge
        });
      },
      { '../type': 58 }
    ],
    68: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        function resolveYamlNull(data) {
          if (data === null)
            return true;
          var max = data.length;
          return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
        }
        function constructYamlNull() {
          return null;
        }
        function isNull(object) {
          return object === null;
        }
        module.exports = new Type('tag:yaml.org,2002:null', {
          kind: 'scalar',
          resolve: resolveYamlNull,
          construct: constructYamlNull,
          predicate: isNull,
          represent: {
            canonical: function () {
              return '~';
            },
            lowercase: function () {
              return 'null';
            },
            uppercase: function () {
              return 'NULL';
            },
            camelcase: function () {
              return 'Null';
            }
          },
          defaultStyle: 'lowercase'
        });
      },
      { '../type': 58 }
    ],
    69: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var _toString = Object.prototype.toString;
        function resolveYamlOmap(data) {
          if (data === null)
            return true;
          var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            pairHasKey = false;
            if (_toString.call(pair) !== '[object Object]')
              return false;
            for (pairKey in pair) {
              if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey)
                  pairHasKey = true;
                else
                  return false;
              }
            }
            if (!pairHasKey)
              return false;
            if (objectKeys.indexOf(pairKey) === -1)
              objectKeys.push(pairKey);
            else
              return false;
          }
          return true;
        }
        function constructYamlOmap(data) {
          return data !== null ? data : [];
        }
        module.exports = new Type('tag:yaml.org,2002:omap', {
          kind: 'sequence',
          resolve: resolveYamlOmap,
          construct: constructYamlOmap
        });
      },
      { '../type': 58 }
    ],
    70: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var _toString = Object.prototype.toString;
        function resolveYamlPairs(data) {
          if (data === null)
            return true;
          var index, length, pair, keys, result, object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            if (_toString.call(pair) !== '[object Object]')
              return false;
            keys = Object.keys(pair);
            if (keys.length !== 1)
              return false;
            result[index] = [
              keys[0],
              pair[keys[0]]
            ];
          }
          return true;
        }
        function constructYamlPairs(data) {
          if (data === null)
            return [];
          var index, length, pair, keys, result, object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            keys = Object.keys(pair);
            result[index] = [
              keys[0],
              pair[keys[0]]
            ];
          }
          return result;
        }
        module.exports = new Type('tag:yaml.org,2002:pairs', {
          kind: 'sequence',
          resolve: resolveYamlPairs,
          construct: constructYamlPairs
        });
      },
      { '../type': 58 }
    ],
    71: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        module.exports = new Type('tag:yaml.org,2002:seq', {
          kind: 'sequence',
          construct: function (data) {
            return data !== null ? data : [];
          }
        });
      },
      { '../type': 58 }
    ],
    72: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        function resolveYamlSet(data) {
          if (data === null)
            return true;
          var key, object = data;
          for (key in object) {
            if (_hasOwnProperty.call(object, key)) {
              if (object[key] !== null)
                return false;
            }
          }
          return true;
        }
        function constructYamlSet(data) {
          return data !== null ? data : {};
        }
        module.exports = new Type('tag:yaml.org,2002:set', {
          kind: 'mapping',
          resolve: resolveYamlSet,
          construct: constructYamlSet
        });
      },
      { '../type': 58 }
    ],
    73: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        module.exports = new Type('tag:yaml.org,2002:str', {
          kind: 'scalar',
          construct: function (data) {
            return data !== null ? data : '';
          }
        });
      },
      { '../type': 58 }
    ],
    74: [
      function (require, module, exports) {
        'use strict';
        var Type = require('../type');
        var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9])' + '-([0-9][0-9])$');
        // [3] day
        var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?$');
        // [11] tz_minute
        function resolveYamlTimestamp(data) {
          if (data === null)
            return false;
          if (YAML_DATE_REGEXP.exec(data) !== null)
            return true;
          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
            return true;
          return false;
        }
        function constructYamlTimestamp(data) {
          var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
          match = YAML_DATE_REGEXP.exec(data);
          if (match === null)
            match = YAML_TIMESTAMP_REGEXP.exec(data);
          if (match === null)
            throw new Error('Date resolve error');
          // match: [1] year [2] month [3] day
          year = +match[1];
          month = +match[2] - 1;
          // JS month starts with 0
          day = +match[3];
          if (!match[4]) {
            // no hour
            return new Date(Date.UTC(year, month, day));
          }
          // match: [4] hour [5] minute [6] second [7] fraction
          hour = +match[4];
          minute = +match[5];
          second = +match[6];
          if (match[7]) {
            fraction = match[7].slice(0, 3);
            while (fraction.length < 3) {
              // milli-seconds
              fraction += '0';
            }
            fraction = +fraction;
          }
          // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
          if (match[9]) {
            tz_hour = +match[10];
            tz_minute = +(match[11] || 0);
            delta = (tz_hour * 60 + tz_minute) * 60000;
            // delta in mili-seconds
            if (match[9] === '-')
              delta = -delta;
          }
          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
          if (delta)
            date.setTime(date.getTime() - delta);
          return date;
        }
        function representYamlTimestamp(object) {
          return object.toISOString();
        }
        module.exports = new Type('tag:yaml.org,2002:timestamp', {
          kind: 'scalar',
          resolve: resolveYamlTimestamp,
          construct: constructYamlTimestamp,
          instanceOf: Date,
          represent: representYamlTimestamp
        });
      },
      { '../type': 58 }
    ],
    75: [
      function (require, module, exports) {
        /**
 * Helpers.
 */
        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;
        /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */
        module.exports = function (val, options) {
          options = options || {};
          var type = typeof val;
          if (type === 'string' && val.length > 0) {
            return parse(val);
          } else if (type === 'number' && isNaN(val) === false) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
        };
        /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || 'ms').toLowerCase();
          switch (type) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;
          default:
            return undefined;
          }
        }
        /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function fmtShort(ms) {
          if (ms >= d) {
            return Math.round(ms / d) + 'd';
          }
          if (ms >= h) {
            return Math.round(ms / h) + 'h';
          }
          if (ms >= m) {
            return Math.round(ms / m) + 'm';
          }
          if (ms >= s) {
            return Math.round(ms / s) + 's';
          }
          return ms + 'ms';
        }
        /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function fmtLong(ms) {
          return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
        }
        /**
 * Pluralization helper.
 */
        function plural(ms, n, name) {
          if (ms < n) {
            return;
          }
          if (ms < n * 1.5) {
            return Math.floor(ms / n) + ' ' + name;
          }
          return Math.ceil(ms / n) + ' ' + name + 's';
        }
      },
      {}
    ],
    76: [
      function (require, module, exports) {
        'use strict';
        var format = require('format-util');
        var slice = Array.prototype.slice;
        var protectedProperties = [
            'name',
            'message',
            'stack'
          ];
        var errorPrototypeProperties = [
            'name',
            'message',
            'description',
            'number',
            'code',
            'fileName',
            'lineNumber',
            'columnNumber',
            'sourceURL',
            'line',
            'column',
            'stack'
          ];
        module.exports = create(Error);
        module.exports.error = create(Error);
        module.exports.eval = create(EvalError);
        module.exports.range = create(RangeError);
        module.exports.reference = create(ReferenceError);
        module.exports.syntax = create(SyntaxError);
        module.exports.type = create(TypeError);
        module.exports.uri = create(URIError);
        module.exports.formatter = format;
        /**
 * Creates a new {@link ono} function that creates the given Error class.
 *
 * @param {Class} Klass - The Error subclass to create
 * @returns {ono}
 */
        function create(Klass) {
          /**
   * @param {Error}   [err]     - The original error, if any
   * @param {object}  [props]   - An object whose properties will be added to the error object
   * @param {string}  [message] - The error message. May contain {@link util#format} placeholders
   * @param {...*}    [params]  - Parameters that map to the `message` placeholders
   * @returns {Error}
   */
          return function onoFactory(err, props, message, params) {
            // eslint-disable-line no-unused-vars
            var formatArgs = [];
            var formattedMessage = '';
            // Determine which arguments were actually specified
            if (typeof err === 'string') {
              formatArgs = slice.call(arguments);
              err = props = undefined;
            } else if (typeof props === 'string') {
              formatArgs = slice.call(arguments, 1);
              props = undefined;
            } else if (typeof message === 'string') {
              formatArgs = slice.call(arguments, 2);
            }
            // If there are any format arguments, then format the error message
            if (formatArgs.length > 0) {
              formattedMessage = module.exports.formatter.apply(null, formatArgs);
            }
            if (err && err.message) {
              // The inner-error's message will be added to the new message
              formattedMessage += (formattedMessage ? ' \n' : '') + err.message;
            }
            // Create the new error
            // NOTE: DON'T move this to a separate function! We don't want to pollute the stack trace
            var newError = new Klass(formattedMessage);
            // Extend the new error with the additional properties
            extendError(newError, err);
            // Copy properties of the original error
            extendToJSON(newError);
            // Replace the original toJSON method
            extend(newError, props);
            // Copy custom properties, possibly including a custom toJSON method
            return newError;
          };
        }
        /**
 * Extends the targetError with the properties of the source error.
 *
 * @param {Error}   targetError - The error object to extend
 * @param {?Error}  sourceError - The source error object, if any
 */
        function extendError(targetError, sourceError) {
          extendStack(targetError, sourceError);
          extend(targetError, sourceError);
        }
        /**
 * JavaScript engines differ in how errors are serialized to JSON - especially when it comes
 * to custom error properties and stack traces.  So we add our own toJSON method that ALWAYS
 * outputs every property of the error.
 */
        function extendToJSON(error) {
          error.toJSON = errorToJSON;
          // Also add an inspect() method, for compatibility with Node.js' `util.inspect()` method
          error.inspect = errorToString;
        }
        /**
 * Extends the target object with the properties of the source object.
 *
 * @param {object}  target - The object to extend
 * @param {?source} source - The object whose properties are copied
 */
        function extend(target, source) {
          if (source && typeof source === 'object') {
            var keys = Object.keys(source);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              // Don't copy "protected" properties, since they have special meaning/behavior
              // and are set by the onoFactory function
              if (protectedProperties.indexOf(key) >= 0) {
                continue;
              }
              try {
                target[key] = source[key];
              } catch (e) {
              }
            }
          }
        }
        /**
 * Custom JSON serializer for Error objects.
 * Returns all built-in error properties, as well as extended properties.
 *
 * @returns {object}
 */
        function errorToJSON() {
          var json = {};
          // Get all the properties of this error
          var keys = Object.keys(this);
          // Also include properties from the Error prototype
          keys = keys.concat(errorPrototypeProperties);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this[key];
            var type = typeof value;
            if (type !== 'undefined' && type !== 'function') {
              json[key] = value;
            }
          }
          return json;
        }
        /**
 * Serializes Error objects as human-readable JSON strings for debugging/logging purposes.
 *
 * @returns {string}
 */
        function errorToString() {
          return JSON.stringify(this, null, 2).replace(/\\n/g, '\n');
        }
        /**
 * Extend the error stack to include its cause
 *
 * @param {Error} targetError
 * @param {Error} sourceError
 */
        function extendStack(targetError, sourceError) {
          if (hasLazyStack(targetError)) {
            if (sourceError) {
              lazyJoinStacks(targetError, sourceError);
            } else {
              lazyPopStack(targetError);
            }
          } else {
            if (sourceError) {
              targetError.stack = joinStacks(targetError.stack, sourceError.stack);
            } else {
              targetError.stack = popStack(targetError.stack);
            }
          }
        }
        /**
 * Appends the original {@link Error#stack} property to the new Error's stack.
 *
 * @param {string} newStack
 * @param {string} originalStack
 * @returns {string}
 */
        function joinStacks(newStack, originalStack) {
          newStack = popStack(newStack);
          if (newStack && originalStack) {
            return newStack + '\n\n' + originalStack;
          } else {
            return newStack || originalStack;
          }
        }
        /**
 * Removes Ono from the stack, so that the stack starts at the original error location
 *
 * @param {string} stack
 * @returns {string}
 */
        function popStack(stack) {
          if (stack) {
            var lines = stack.split('\n');
            if (lines.length < 2) {
              // The stack only has one line, so there's nothing we can remove
              return stack;
            }
            // Find the `onoFactory` call in the stack, and remove it
            for (var i = 0; i < lines.length; i++) {
              var line = lines[i];
              if (line.indexOf('onoFactory') >= 0) {
                lines.splice(i, 1);
                return lines.join('\n');
              }
            }
            // If we get here, then the stack doesn't contain a call to `onoFactory`.
            // This may be due to minification or some optimization of the JS engine.
            // So just return the stack as-is.
            return stack;
          }
        }
        /**
 * Does a one-time determination of whether this JavaScript engine
 * supports lazy `Error.stack` properties.
 */
        var supportsLazyStack = function () {
            return !!(Object.getOwnPropertyDescriptor && Object.defineProperty && (typeof navigator === 'undefined' || !/Android/.test(navigator.userAgent)));
          }();
        /**
 * Does this error have a lazy stack property?
 *
 * @param {Error} err
 * @returns {boolean}
 */
        function hasLazyStack(err) {
          if (!supportsLazyStack) {
            return false;
          }
          var descriptor = Object.getOwnPropertyDescriptor(err, 'stack');
          if (!descriptor) {
            return false;
          }
          return typeof descriptor.get === 'function';
        }
        /**
 * Calls {@link joinStacks} lazily, when the {@link Error#stack} property is accessed.
 *
 * @param {Error} targetError
 * @param {Error} sourceError
 */
        function lazyJoinStacks(targetError, sourceError) {
          var targetStack = Object.getOwnPropertyDescriptor(targetError, 'stack');
          Object.defineProperty(targetError, 'stack', {
            get: function () {
              return joinStacks(targetStack.get.apply(targetError), sourceError.stack);
            },
            enumerable: false,
            configurable: true
          });
        }
        /**
 * Calls {@link popStack} lazily, when the {@link Error#stack} property is accessed.
 *
 * @param {Error} error
 */
        function lazyPopStack(error) {
          var targetStack = Object.getOwnPropertyDescriptor(error, 'stack');
          Object.defineProperty(error, 'stack', {
            get: function () {
              return popStack(targetStack.get.apply(error));
            },
            enumerable: false,
            configurable: true
          });
        }
      },
      { 'format-util': 15 }
    ],
    77: [
      function (require, module, exports) {
        (function (global) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          /**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
          /** Used as the `TypeError` message for "Functions" methods. */
          var FUNC_ERROR_TEXT = 'Expected a function';
          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';
          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0;
          /** `Object#toString` result references. */
          var funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
          /** Used to match property names within property paths. */
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          /**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          /** Used to match backslashes in property paths. */
          var reEscapeChar = /\\(\\)?/g;
          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          /** Detect free variable `global` from Node.js. */
          var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;
          /** Detect free variable `self`. */
          var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;
          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();
          /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }
          /**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
          function isHostObject(value) {
            // Many host objects are `Object` objects that can coerce to strings
            // despite having improperly defined `toString` methods.
            var result = false;
            if (value != null && typeof value.toString != 'function') {
              try {
                result = !!(value + '');
              } catch (e) {
              }
            }
            return result;
          }
          /** Used for built-in method references. */
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];
          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
              var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
              return uid ? 'Symbol(src)_1.' + uid : '';
            }();
          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;
          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;
          /**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
          var objectToString = objectProto.toString;
          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
          /** Built-in value references. */
          var _Symbol = root.Symbol, splice = arrayProto.splice;
          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
          /** Used to convert symbols to primitives and strings. */
          var symbolProto = _Symbol ? _Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
          /**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function Hash(entries) {
            var index = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }
          /**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }
          /**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }
          /**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }
          /**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }
          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          /**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function ListCache(entries) {
            var index = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
          function listCacheClear() {
            this.__data__ = [];
          }
          /**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            return true;
          }
          /**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }
          /**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          /**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              data.push([
                key,
                value
              ]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          /**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function MapCache(entries) {
            var index = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
          function mapCacheClear() {
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }
          /**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function mapCacheDelete(key) {
            return getMapData(this, key)['delete'](key);
          }
          /**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          /**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          /**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }
          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          /**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          /**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
          function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined;
          }
          /**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          /**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value;
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : '';
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
          function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
          }
          /**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }
          /**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }
          /**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          /**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
          function isKeyable(value) {
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }
          /**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          /**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
          var stringToPath = memoize(function (string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function (match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
              });
              return result;
            });
          /**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value;
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + '';
              } catch (e) {
              }
            }
            return '';
          }
          /**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
          function memoize(func, resolver) {
            if (typeof func != 'function' || resolver && typeof resolver != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function memoized() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result);
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          // Assign cache to `_.memoize`.
          memoize.Cache = MapCache;
          /**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          /**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
          var isArray = Array.isArray;
          /**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
          function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 8-9 which returns 'object' for typed array and other constructors.
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
          }
          /**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
          function isObject(value) {
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            return !!value && (type == 'object' || type == 'function');
          }
          /**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
          function isObjectLike(value) {
            return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
          }
          /**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
          function isSymbol(value) {
            return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
          }
          /**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
          function toString(value) {
            return value == null ? '' : baseToString(value);
          }
          /**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }
          module.exports = get;
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    78: [
      function (require, module, exports) {
        (function (global) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          /**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200;
          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';
          /** Used to compose bitmasks for value comparisons. */
          var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991;
          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
          /**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          /** Used to identify `toStringTag` values of typed arrays. */
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
          /** Detect free variable `global` from Node.js. */
          var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;
          /** Detect free variable `self`. */
          var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;
          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();
          /** Detect free variable `exports`. */
          var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */
          var freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process;
          /** Used to access faster Node.js helpers. */
          var nodeUtil = function () {
              try {
                return freeProcess && freeProcess.binding && freeProcess.binding('util');
              } catch (e) {
              }
            }();
          /* Node.js helper references. */
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
          /**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
          function arrayFilter(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result[resIndex++] = value;
              }
            }
            return result;
          }
          /**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
          function arrayPush(array, values) {
            var index = -1, length = values.length, offset = array.length;
            while (++index < length) {
              array[offset + index] = values[index];
            }
            return array;
          }
          /**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
          function arraySome(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true;
              }
            }
            return false;
          }
          /**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
          function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }
          /**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
          function baseUnary(func) {
            return function (value) {
              return func(value);
            };
          }
          /**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function cacheHas(cache, key) {
            return cache.has(key);
          }
          /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }
          /**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
          function mapToArray(map) {
            var index = -1, result = Array(map.size);
            map.forEach(function (value, key) {
              result[++index] = [
                key,
                value
              ];
            });
            return result;
          }
          /**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
          function overArg(func, transform) {
            return function (arg) {
              return func(transform(arg));
            };
          }
          /**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
          function setToArray(set) {
            var index = -1, result = Array(set.size);
            set.forEach(function (value) {
              result[++index] = value;
            });
            return result;
          }
          /** Used for built-in method references. */
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];
          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;
          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;
          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
              var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
              return uid ? 'Symbol(src)_1.' + uid : '';
            }();
          /**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
          var nativeObjectToString = objectProto.toString;
          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined, _Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
          /* Built-in method references that are verified to be native. */
          var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
          /** Used to detect maps, sets, and weakmaps. */
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
          /** Used to convert symbols to primitives and strings. */
          var symbolProto = _Symbol ? _Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
          /**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          /**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          /**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }
          /**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }
          /**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }
          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          /**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          /**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          /**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }
          /**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          /**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([
                key,
                value
              ]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          /**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }
          /**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          /**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          /**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          /**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }
          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          /**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
          function SetCache(values) {
            var index = -1, length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values[index]);
            }
          }
          /**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          /**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          // Add methods to `SetCache`.
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          /**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          /**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          /**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function stackDelete(key) {
            var data = this.__data__, result = data['delete'](key);
            this.size = data.size;
            return result;
          }
          /**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function stackGet(key) {
            return this.__data__.get(key);
          }
          /**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function stackHas(key) {
            return this.__data__.has(key);
          }
          /**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([
                  key,
                  value
                ]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          /**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }
          /**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          /**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          /**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          /**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          /**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          /**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          /**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          /**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          /**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
              }
            }
            return result;
          }
          /**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(array);
            if (stacked && stack.get(other)) {
              return stacked == other;
            }
            var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            stack.set(array, other);
            stack.set(other, array);
            // Ignore non-index properties.
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined) {
                if (compared) {
                  continue;
                }
                result = false;
                break;
              }
              // Recursively compare arrays (susceptible to call stack limits).
              if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      return seen.push(othIndex);
                    }
                  })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }
            stack['delete'](array);
            stack['delete'](other);
            return result;
          }
          /**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + '';
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
            }
            return false;
          }
          /**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked && stack.get(other)) {
              return stacked == other;
            }
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              // Recursively compare objects (susceptible to call stack limits).
              if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = key == 'constructor');
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              // Non `Object` object instances with different constructors are not equal.
              if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
              }
            }
            stack['delete'](object);
            stack['delete'](other);
            return result;
          }
          /**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          /**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }
          /**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }
          /**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }
          /**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
          var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
              if (object == null) {
                return [];
              }
              object = Object(object);
              return arrayFilter(nativeGetSymbols(object), function (symbol) {
                return propertyIsEnumerable.call(object, symbol);
              });
            };
          /**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
          var getTag = baseGetTag;
          // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function getTag(value) {
              var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
              if (ctorString) {
                switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
                }
              }
              return result;
            };
          }
          /**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }
          /**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
          function isKeyable(value) {
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }
          /**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          /**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }
          /**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          /**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + '';
              } catch (e) {
              }
            }
            return '';
          }
          /**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          /**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
          var isArguments = baseIsArguments(function () {
              return arguments;
            }()) ? baseIsArguments : function (value) {
              return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
            };
          /**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
          var isArray = Array.isArray;
          /**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          /**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
          var isBuffer = nativeIsBuffer || stubFalse;
          /**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          /**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          /**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          /**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
          function isObject(value) {
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            return value != null && (type == 'object' || type == 'function');
          }
          /**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
          function isObjectLike(value) {
            return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
          }
          /**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          /**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          /**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
          function stubArray() {
            return [];
          }
          /**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
          function stubFalse() {
            return false;
          }
          module.exports = isEqual;
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    79: [
      function (require, module, exports) {
        (function (global) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          /**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
          ;
          (function () {
            /** Used as a safe reference for `undefined` in pre-ES5 environments. */
            var undefined;
            /** Used as the semantic version number. */
            var VERSION = '4.17.4';
            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;
            /** Error message constants. */
            var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.', FUNC_ERROR_TEXT = 'Expected a function';
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500;
            /** Used as the internal argument placeholder. */
            var PLACEHOLDER = '__lodash_placeholder__';
            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
            /** Used to compose bitmasks for function metadata. */
            var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
            /** Used as default options for `_.truncate`. */
            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 800, HOT_SPAN = 16;
            /** Used to indicate the type of lazy iteratees. */
            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
            /** Used as references for the maximum length and index of an array. */
            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
            /** Used to associate wrap methods with their bit flags. */
            var wrapFlags = [
                [
                  'ary',
                  WRAP_ARY_FLAG
                ],
                [
                  'bind',
                  WRAP_BIND_FLAG
                ],
                [
                  'bindKey',
                  WRAP_BIND_KEY_FLAG
                ],
                [
                  'curry',
                  WRAP_CURRY_FLAG
                ],
                [
                  'curryRight',
                  WRAP_CURRY_RIGHT_FLAG
                ],
                [
                  'flip',
                  WRAP_FLIP_FLAG
                ],
                [
                  'partial',
                  WRAP_PARTIAL_FLAG
                ],
                [
                  'partialRight',
                  WRAP_PARTIAL_RIGHT_FLAG
                ],
                [
                  'rearg',
                  WRAP_REARG_FLAG
                ]
              ];
            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
            var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
            /** Used to match empty string literals in compiled template source. */
            var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            /** Used to match HTML entities and HTML characters. */
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            /** Used to match template delimiters. */
            var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
            /** Used to match leading and trailing whitespace. */
            var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
            /** Used to match wrap detail comments. */
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
            /** Used to match words composed of alphanumeric characters. */
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g;
            /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/;
            /** Used to detect bad signed hexadecimal string values. */
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            /** Used to detect binary string values. */
            var reIsBinary = /^0b[01]+$/i;
            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            /** Used to detect octal string values. */
            var reIsOctal = /^0o[0-7]+$/i;
            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            /** Used to match Latin Unicode letters (excluding mathematical operators). */
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            /** Used to ensure capturing order of template delimiters. */
            var reNoMatch = /($^)/;
            /** Used to match unescaped characters in compiled string literals. */
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            /** Used to compose unicode character classes. */
            var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
            /** Used to compose unicode capture groups. */
            var rsApos = '[\'\u2019]', rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
            /** Used to compose unicode regexes. */
            var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
                rsNonAstral,
                rsRegional,
                rsSurrPair
              ].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)', rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [
                rsDingbat,
                rsRegional,
                rsSurrPair
              ].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [
                rsNonAstral + rsCombo + '?',
                rsCombo,
                rsRegional,
                rsSurrPair,
                rsAstral
              ].join('|') + ')';
            /** Used to match apostrophes. */
            var reApos = RegExp(rsApos, 'g');
            /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
            var reComboMark = RegExp(rsCombo, 'g');
            /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
            var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
            /** Used to match complex or compound words. */
            var reUnicodeWord = RegExp([
                rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [
                  rsBreak,
                  rsUpper,
                  '$'
                ].join('|') + ')',
                rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [
                  rsBreak,
                  rsUpper + rsMiscLower,
                  '$'
                ].join('|') + ')',
                rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
                rsUpper + '+' + rsOptContrUpper,
                rsOrdUpper,
                rsOrdLower,
                rsDigits,
                rsEmoji
              ].join('|'), 'g');
            /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
            var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
            /** Used to detect strings that need a more robust regexp to match words. */
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
            /** Used to assign default `context` object properties. */
            var contextProps = [
                'Array',
                'Buffer',
                'DataView',
                'Date',
                'Error',
                'Float32Array',
                'Float64Array',
                'Function',
                'Int8Array',
                'Int16Array',
                'Int32Array',
                'Map',
                'Math',
                'Object',
                'Promise',
                'RegExp',
                'Set',
                'String',
                'Symbol',
                'TypeError',
                'Uint8Array',
                'Uint8ClampedArray',
                'Uint16Array',
                'Uint32Array',
                'WeakMap',
                '_',
                'clearTimeout',
                'isFinite',
                'parseInt',
                'setTimeout'
              ];
            /** Used to make template sourceURLs easier to identify. */
            var templateCounter = -1;
            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
            /** Used to map Latin Unicode letters to basic Latin letters. */
            var deburredLetters = {
                '\xc0': 'A',
                '\xc1': 'A',
                '\xc2': 'A',
                '\xc3': 'A',
                '\xc4': 'A',
                '\xc5': 'A',
                '\xe0': 'a',
                '\xe1': 'a',
                '\xe2': 'a',
                '\xe3': 'a',
                '\xe4': 'a',
                '\xe5': 'a',
                '\xc7': 'C',
                '\xe7': 'c',
                '\xd0': 'D',
                '\xf0': 'd',
                '\xc8': 'E',
                '\xc9': 'E',
                '\xca': 'E',
                '\xcb': 'E',
                '\xe8': 'e',
                '\xe9': 'e',
                '\xea': 'e',
                '\xeb': 'e',
                '\xcc': 'I',
                '\xcd': 'I',
                '\xce': 'I',
                '\xcf': 'I',
                '\xec': 'i',
                '\xed': 'i',
                '\xee': 'i',
                '\xef': 'i',
                '\xd1': 'N',
                '\xf1': 'n',
                '\xd2': 'O',
                '\xd3': 'O',
                '\xd4': 'O',
                '\xd5': 'O',
                '\xd6': 'O',
                '\xd8': 'O',
                '\xf2': 'o',
                '\xf3': 'o',
                '\xf4': 'o',
                '\xf5': 'o',
                '\xf6': 'o',
                '\xf8': 'o',
                '\xd9': 'U',
                '\xda': 'U',
                '\xdb': 'U',
                '\xdc': 'U',
                '\xf9': 'u',
                '\xfa': 'u',
                '\xfb': 'u',
                '\xfc': 'u',
                '\xdd': 'Y',
                '\xfd': 'y',
                '\xff': 'y',
                '\xc6': 'Ae',
                '\xe6': 'ae',
                '\xde': 'Th',
                '\xfe': 'th',
                '\xdf': 'ss',
                '\u0100': 'A',
                '\u0102': 'A',
                '\u0104': 'A',
                '\u0101': 'a',
                '\u0103': 'a',
                '\u0105': 'a',
                '\u0106': 'C',
                '\u0108': 'C',
                '\u010a': 'C',
                '\u010c': 'C',
                '\u0107': 'c',
                '\u0109': 'c',
                '\u010b': 'c',
                '\u010d': 'c',
                '\u010e': 'D',
                '\u0110': 'D',
                '\u010f': 'd',
                '\u0111': 'd',
                '\u0112': 'E',
                '\u0114': 'E',
                '\u0116': 'E',
                '\u0118': 'E',
                '\u011a': 'E',
                '\u0113': 'e',
                '\u0115': 'e',
                '\u0117': 'e',
                '\u0119': 'e',
                '\u011b': 'e',
                '\u011c': 'G',
                '\u011e': 'G',
                '\u0120': 'G',
                '\u0122': 'G',
                '\u011d': 'g',
                '\u011f': 'g',
                '\u0121': 'g',
                '\u0123': 'g',
                '\u0124': 'H',
                '\u0126': 'H',
                '\u0125': 'h',
                '\u0127': 'h',
                '\u0128': 'I',
                '\u012a': 'I',
                '\u012c': 'I',
                '\u012e': 'I',
                '\u0130': 'I',
                '\u0129': 'i',
                '\u012b': 'i',
                '\u012d': 'i',
                '\u012f': 'i',
                '\u0131': 'i',
                '\u0134': 'J',
                '\u0135': 'j',
                '\u0136': 'K',
                '\u0137': 'k',
                '\u0138': 'k',
                '\u0139': 'L',
                '\u013b': 'L',
                '\u013d': 'L',
                '\u013f': 'L',
                '\u0141': 'L',
                '\u013a': 'l',
                '\u013c': 'l',
                '\u013e': 'l',
                '\u0140': 'l',
                '\u0142': 'l',
                '\u0143': 'N',
                '\u0145': 'N',
                '\u0147': 'N',
                '\u014a': 'N',
                '\u0144': 'n',
                '\u0146': 'n',
                '\u0148': 'n',
                '\u014b': 'n',
                '\u014c': 'O',
                '\u014e': 'O',
                '\u0150': 'O',
                '\u014d': 'o',
                '\u014f': 'o',
                '\u0151': 'o',
                '\u0154': 'R',
                '\u0156': 'R',
                '\u0158': 'R',
                '\u0155': 'r',
                '\u0157': 'r',
                '\u0159': 'r',
                '\u015a': 'S',
                '\u015c': 'S',
                '\u015e': 'S',
                '\u0160': 'S',
                '\u015b': 's',
                '\u015d': 's',
                '\u015f': 's',
                '\u0161': 's',
                '\u0162': 'T',
                '\u0164': 'T',
                '\u0166': 'T',
                '\u0163': 't',
                '\u0165': 't',
                '\u0167': 't',
                '\u0168': 'U',
                '\u016a': 'U',
                '\u016c': 'U',
                '\u016e': 'U',
                '\u0170': 'U',
                '\u0172': 'U',
                '\u0169': 'u',
                '\u016b': 'u',
                '\u016d': 'u',
                '\u016f': 'u',
                '\u0171': 'u',
                '\u0173': 'u',
                '\u0174': 'W',
                '\u0175': 'w',
                '\u0176': 'Y',
                '\u0177': 'y',
                '\u0178': 'Y',
                '\u0179': 'Z',
                '\u017b': 'Z',
                '\u017d': 'Z',
                '\u017a': 'z',
                '\u017c': 'z',
                '\u017e': 'z',
                '\u0132': 'IJ',
                '\u0133': 'ij',
                '\u0152': 'Oe',
                '\u0153': 'oe',
                '\u0149': '\'n',
                '\u017f': 's'
              };
            /** Used to map characters to HTML entities. */
            var htmlEscapes = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                '\'': '&#39;'
              };
            /** Used to map HTML entities to characters. */
            var htmlUnescapes = {
                '&amp;': '&',
                '&lt;': '<',
                '&gt;': '>',
                '&quot;': '"',
                '&#39;': '\''
              };
            /** Used to escape characters for inclusion in compiled string literals. */
            var stringEscapes = {
                '\\': '\\',
                '\'': '\'',
                '\n': 'n',
                '\r': 'r',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
              };
            /** Built-in method references without a dependency on `root`. */
            var freeParseFloat = parseFloat, freeParseInt = parseInt;
            /** Detect free variable `global` from Node.js. */
            var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;
            /** Detect free variable `self`. */
            var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;
            /** Used as a reference to the global object. */
            var root = freeGlobal || freeSelf || Function('return this')();
            /** Detect free variable `exports`. */
            var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
            /** Detect free variable `module`. */
            var freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
            /** Detect the popular CommonJS extension `module.exports`. */
            var moduleExports = freeModule && freeModule.exports === freeExports;
            /** Detect free variable `process` from Node.js. */
            var freeProcess = moduleExports && freeGlobal.process;
            /** Used to access faster Node.js helpers. */
            var nodeUtil = function () {
                try {
                  return freeProcess && freeProcess.binding && freeProcess.binding('util');
                } catch (e) {
                }
              }();
            /* Node.js helper references. */
            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            /*--------------------------------------------------------------------------*/
            /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
            function addMapEntry(map, pair) {
              // Don't return `map.set` because it's not chainable in IE 11.
              map.set(pair[0], pair[1]);
              return map;
            }
            /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
            function addSetEntry(set, value) {
              // Don't return `set.add` because it's not chainable in IE 11.
              set.add(value);
              return set;
            }
            /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
            function apply(func, thisArg, args) {
              switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                var value = array[index];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }
            /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
            function arrayEach(array, iteratee) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
            function arrayEachRight(array, iteratee) {
              var length = array == null ? 0 : array.length;
              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }
            /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
            function arrayEvery(array, predicate) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (!predicate(array[index], index, array)) {
                  return false;
                }
              }
              return true;
            }
            /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
            function arrayFilter(array, predicate) {
              var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
            function arrayIncludes(array, value) {
              var length = array == null ? 0 : array.length;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
            function arrayIncludesWith(array, value, comparator) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (comparator(value, array[index])) {
                  return true;
                }
              }
              return false;
            }
            /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
            function arrayMap(array, iteratee) {
              var index = -1, length = array == null ? 0 : array.length, result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
            function arrayPush(array, values) {
              var index = -1, length = values.length, offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1, length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
              }
              return accumulator;
            }
            /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
            function arraySome(array, predicate) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
            var asciiSize = baseProperty('length');
            /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
            function asciiToArray(string) {
              return string.split('');
            }
            /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
            function asciiWords(string) {
              return string.match(reAsciiWord) || [];
            }
            /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function (value, key, collection) {
                if (predicate(value, key, collection)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }
            /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index-- : ++index < length) {
                if (predicate(array[index], index, array)) {
                  return index;
                }
              }
              return -1;
            }
            /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function baseIndexOf(array, value, fromIndex) {
              return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index = fromIndex - 1, length = array.length;
              while (++index < length) {
                if (comparator(array[index], value)) {
                  return index;
                }
              }
              return -1;
            }
            /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
            function baseIsNaN(value) {
              return value !== value;
            }
            /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
            function baseMean(array, iteratee) {
              var length = array == null ? 0 : array.length;
              return length ? baseSum(array, iteratee) / length : NAN;
            }
            /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
            function baseProperty(key) {
              return function (object) {
                return object == null ? undefined : object[key];
              };
            }
            /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
            function basePropertyOf(object) {
              return function (key) {
                return object == null ? undefined : object[key];
              };
            }
            /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
              eachFunc(collection, function (value, index, collection) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
              });
              return accumulator;
            }
            /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
            function baseSortBy(array, comparer) {
              var length = array.length;
              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }
            /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
            function baseSum(array, iteratee) {
              var result, index = -1, length = array.length;
              while (++index < length) {
                var current = iteratee(array[index]);
                if (current !== undefined) {
                  result = result === undefined ? current : result + current;
                }
              }
              return result;
            }
            /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
            function baseTimes(n, iteratee) {
              var index = -1, result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
            function baseToPairs(object, props) {
              return arrayMap(props, function (key) {
                return [
                  key,
                  object[key]
                ];
              });
            }
            /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
            function baseUnary(func) {
              return function (value) {
                return func(value);
              };
            }
            /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
            function baseValues(object, props) {
              return arrayMap(props, function (key) {
                return object[key];
              });
            }
            /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
            function cacheHas(cache, key) {
              return cache.has(key);
            }
            /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
            function charsStartIndex(strSymbols, chrSymbols) {
              var index = -1, length = strSymbols.length;
              while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
              }
              return index;
            }
            /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
            function charsEndIndex(strSymbols, chrSymbols) {
              var index = strSymbols.length;
              while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
              }
              return index;
            }
            /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
            function countHolders(array, placeholder) {
              var length = array.length, result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }
            /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
            var deburrLetter = basePropertyOf(deburredLetters);
            /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
            var escapeHtmlChar = basePropertyOf(htmlEscapes);
            /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
            function escapeStringChar(chr) {
              return '\\' + stringEscapes[chr];
            }
            /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
            function hasUnicode(string) {
              return reHasUnicode.test(string);
            }
            /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
            function hasUnicodeWord(string) {
              return reHasUnicodeWord.test(string);
            }
            /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
            function iteratorToArray(iterator) {
              var data, result = [];
              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }
            /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
            function mapToArray(map) {
              var index = -1, result = Array(map.size);
              map.forEach(function (value, key) {
                result[++index] = [
                  key,
                  value
                ];
              });
              return result;
            }
            /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
            function overArg(func, transform) {
              return function (arg) {
                return func(transform(arg));
              };
            }
            /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
            function replaceHolders(array, placeholder) {
              var index = -1, length = array.length, resIndex = 0, result = [];
              while (++index < length) {
                var value = array[index];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index] = PLACEHOLDER;
                  result[resIndex++] = index;
                }
              }
              return result;
            }
            /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
            function setToArray(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function (value) {
                result[++index] = value;
              });
              return result;
            }
            /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
            function setToPairs(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function (value) {
                result[++index] = [
                  value,
                  value
                ];
              });
              return result;
            }
            /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function strictIndexOf(array, value, fromIndex) {
              var index = fromIndex - 1, length = array.length;
              while (++index < length) {
                if (array[index] === value) {
                  return index;
                }
              }
              return -1;
            }
            /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
            function strictLastIndexOf(array, value, fromIndex) {
              var index = fromIndex + 1;
              while (index--) {
                if (array[index] === value) {
                  return index;
                }
              }
              return index;
            }
            /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
            function stringSize(string) {
              return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
            }
            /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
            function stringToArray(string) {
              return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
            }
            /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
            /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
            function unicodeSize(string) {
              var result = reUnicode.lastIndex = 0;
              while (reUnicode.test(string)) {
                ++result;
              }
              return result;
            }
            /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
            function unicodeToArray(string) {
              return string.match(reUnicode) || [];
            }
            /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
            function unicodeWords(string) {
              return string.match(reUnicodeWord) || [];
            }
            /*--------------------------------------------------------------------------*/
            /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
            var runInContext = function runInContext(context) {
              context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
              /** Built-in constructor references. */
              var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
              /** Used for built-in method references. */
              var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
              /** Used to detect overreaching core-js shims. */
              var coreJsData = context['__core-js_shared__'];
              /** Used to resolve the decompiled source of functions. */
              var funcToString = funcProto.toString;
              /** Used to check objects for own properties. */
              var hasOwnProperty = objectProto.hasOwnProperty;
              /** Used to generate unique IDs. */
              var idCounter = 0;
              /** Used to detect methods masquerading as native. */
              var maskSrcKey = function () {
                  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                  return uid ? 'Symbol(src)_1.' + uid : '';
                }();
              /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
              var nativeObjectToString = objectProto.toString;
              /** Used to infer the `Object` constructor. */
              var objectCtorString = funcToString.call(Object);
              /** Used to restore the original `_` reference in `_.noConflict`. */
              var oldDash = root._;
              /** Used to detect if a method is native. */
              var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
              /** Built-in value references. */
              var Buffer = moduleExports ? context.Buffer : undefined, _Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined, symIterator = _Symbol ? _Symbol.iterator : undefined, symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
              var defineProperty = function () {
                  try {
                    var func = getNative(Object, 'defineProperty');
                    func({}, '', {});
                    return func;
                  } catch (e) {
                  }
                }();
              /** Mocked built-ins. */
              var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
              /* Built-in method references for those with the same name as other `lodash` methods. */
              var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
              /* Built-in method references that are verified to be native. */
              var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');
              /** Used to store function metadata. */
              var metaMap = WeakMap && new WeakMap();
              /** Used to lookup unminified function names. */
              var realNames = {};
              /** Used to detect maps, sets, and weakmaps. */
              var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
              /** Used to convert symbols to primitives and strings. */
              var symbolProto = _Symbol ? _Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
              function lodash(value) {
                if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }
              /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
              var baseCreate = function () {
                  function object() {
                  }
                  return function (proto) {
                    if (!isObject(proto)) {
                      return {};
                    }
                    if (objectCreate) {
                      return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result = new object();
                    object.prototype = undefined;
                    return result;
                  };
                }();
              /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
              function baseLodash() {
              }
              // No operation performed.
              /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined;
              }
              /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
              lodash.templateSettings = {
                'escape': reEscape,
                'evaluate': reEvaluate,
                'interpolate': reInterpolate,
                'variable': '',
                'imports': { '_': lodash }
              };
              // Ensure wrappers are instances of `baseLodash`.
              lodash.prototype = baseLodash.prototype;
              lodash.prototype.constructor = lodash;
              LodashWrapper.prototype = baseCreate(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }
              /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
              function lazyClone() {
                var result = new LazyWrapper(this.__wrapped__);
                result.__actions__ = copyArray(this.__actions__);
                result.__dir__ = this.__dir__;
                result.__filtered__ = this.__filtered__;
                result.__iteratees__ = copyArray(this.__iteratees__);
                result.__takeCount__ = this.__takeCount__;
                result.__views__ = copyArray(this.__views__);
                return result;
              }
              /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
              function lazyReverse() {
                if (this.__filtered__) {
                  var result = new LazyWrapper(this);
                  result.__dir__ = -1;
                  result.__filtered__ = true;
                } else {
                  result = this.clone();
                  result.__dir__ *= -1;
                }
                return result;
              }
              /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
              function lazyValue() {
                var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                if (!isArr || !isRight && arrLength == length && takeCount == length) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result = [];
                outer:
                  while (length-- && resIndex < takeCount) {
                    index += dir;
                    var iterIndex = -1, value = array[index];
                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                      if (type == LAZY_MAP_FLAG) {
                        value = computed;
                      } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result[resIndex++] = value;
                  }
                return result;
              }
              // Ensure `LazyWrapper` is an instance of `baseLodash`.
              LazyWrapper.prototype = baseCreate(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function Hash(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
              }
              /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
              }
              /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
              }
              /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                return this;
              }
              // Add methods to `Hash`.
              Hash.prototype.clear = hashClear;
              Hash.prototype['delete'] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              /*------------------------------------------------------------------------*/
              /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function ListCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                --this.size;
                return true;
              }
              /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? undefined : data[index][1];
              }
              /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
              function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  ++this.size;
                  data.push([
                    key,
                    value
                  ]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }
              // Add methods to `ListCache`.
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype['delete'] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function MapCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  'hash': new Hash(),
                  'map': new (Map || ListCache)(),
                  'string': new Hash()
                };
              }
              /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function mapCacheDelete(key) {
                var result = getMapData(this, key)['delete'](key);
                this.size -= result ? 1 : 0;
                return result;
              }
              /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
              function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
              }
              // Add methods to `MapCache`.
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype['delete'] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              /*------------------------------------------------------------------------*/
              /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
              function SetCache(values) {
                var index = -1, length = values == null ? 0 : values.length;
                this.__data__ = new MapCache();
                while (++index < length) {
                  this.add(values[index]);
                }
              }
              /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              // Add methods to `SetCache`.
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              /*------------------------------------------------------------------------*/
              /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }
              /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
              function stackDelete(key) {
                var data = this.__data__, result = data['delete'](key);
                this.size = data.size;
                return result;
              }
              /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
              function stackGet(key) {
                return this.__data__.get(key);
              }
              /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
              function stackHas(key) {
                return this.__data__.has(key);
              }
              /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([
                      key,
                      value
                    ]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              // Add methods to `Stack`.
              Stack.prototype.clear = stackClear;
              Stack.prototype['delete'] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              /*------------------------------------------------------------------------*/
              /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined;
              }
              /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
              function arraySampleSize(array, n) {
                return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
              }
              /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
              function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
              }
              /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
              function assignMergeValue(object, key, value) {
                if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
              function baseAggregator(collection, setter, iteratee, accumulator) {
                baseEach(collection, function (value, key, collection) {
                  setter(accumulator, value, iteratee(value), collection);
                });
                return accumulator;
              }
              /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
              function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }
              /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
              function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
              }
              /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
              function baseAssignValue(object, key, value) {
                if (key == '__proto__' && defineProperty) {
                  defineProperty(object, key, {
                    'configurable': true,
                    'enumerable': true,
                    'value': value,
                    'writable': true
                  });
                } else {
                  object[key] = value;
                }
              }
              /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
              function baseAt(object, paths) {
                var index = -1, length = paths.length, result = Array(length), skip = object == null;
                while (++index < length) {
                  result[index] = skip ? undefined : get(object, paths[index]);
                }
                return result;
              }
              /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }
              /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
              function baseClone(value, bitmask, customizer, key, object, stack) {
                var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                  result = object ? customizer(value, key, object, stack) : customizer(value);
                }
                if (result !== undefined) {
                  return result;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result);
                  }
                } else {
                  var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = isFlat || isFunc ? {} : initCloneObject(value);
                    if (!isDeep) {
                      return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                  }
                }
                // Check for circular references and return its corresponding clone.
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result);
                var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                var props = isArr ? undefined : keysFunc(value);
                arrayEach(props || value, function (subValue, key) {
                  if (props) {
                    key = subValue;
                    subValue = value[key];
                  }
                  // Recursively populate clone (susceptible to call stack limits).
                  assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                });
                return result;
              }
              /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
              function baseConforms(source) {
                var props = keys(source);
                return function (object) {
                  return baseConformsTo(object, source, props);
                };
              }
              /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (length--) {
                  var key = props[length], predicate = source[key], value = object[key];
                  if (value === undefined && !(key in object) || !predicate(value)) {
                    return false;
                  }
                }
                return true;
              }
              /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
              function baseDelay(func, wait, args) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return setTimeout(function () {
                  func.apply(undefined, args);
                }, wait);
              }
              /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
              function baseDifference(array, values, iteratee, comparator) {
                var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
                if (!length) {
                  return result;
                }
                if (iteratee) {
                  values = arrayMap(values, baseUnary(iteratee));
                }
                if (comparator) {
                  includes = arrayIncludesWith;
                  isCommon = false;
                } else if (values.length >= LARGE_ARRAY_SIZE) {
                  includes = cacheHas;
                  isCommon = false;
                  values = new SetCache(values);
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed = iteratee == null ? value : iteratee(value);
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result.push(value);
                    } else if (!includes(values, computed, comparator)) {
                      result.push(value);
                    }
                  }
                return result;
              }
              /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
              var baseEach = createBaseEach(baseForOwn);
              /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
              var baseEachRight = createBaseEach(baseForOwnRight, true);
              /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
              function baseEvery(collection, predicate) {
                var result = true;
                baseEach(collection, function (value, index, collection) {
                  result = !!predicate(value, index, collection);
                  return result;
                });
                return result;
              }
              /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
              function baseExtremum(array, iteratee, comparator) {
                var index = -1, length = array.length;
                while (++index < length) {
                  var value = array[index], current = iteratee(value);
                  if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                    var computed = current, result = value;
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
              function baseFill(array, value, start, end) {
                var length = array.length;
                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }
              /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
              function baseFilter(collection, predicate) {
                var result = [];
                baseEach(collection, function (value, index, collection) {
                  if (predicate(value, index, collection)) {
                    result.push(value);
                  }
                });
                return result;
              }
              /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
              function baseFlatten(array, depth, predicate, isStrict, result) {
                var index = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result || (result = []);
                while (++index < length) {
                  var value = array[index];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      // Recursively flatten arrays (susceptible to call stack limits).
                      baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                      arrayPush(result, value);
                    }
                  } else if (!isStrict) {
                    result[result.length] = value;
                  }
                }
                return result;
              }
              /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
              var baseFor = createBaseFor();
              /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
              var baseForRight = createBaseFor(true);
              /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
              function baseForOwn(object, iteratee) {
                return object && baseFor(object, iteratee, keys);
              }
              /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
              function baseForOwnRight(object, iteratee) {
                return object && baseForRight(object, iteratee, keys);
              }
              /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
              function baseFunctions(object, props) {
                return arrayFilter(props, function (key) {
                  return isFunction(object[key]);
                });
              }
              /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
              function baseGet(object, path) {
                path = castPath(path, object);
                var index = 0, length = path.length;
                while (object != null && index < length) {
                  object = object[toKey(path[index++])];
                }
                return index && index == length ? object : undefined;
              }
              /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
              }
              /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
              function baseGetTag(value) {
                if (value == null) {
                  return value === undefined ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
              }
              /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
              function baseGt(value, other) {
                return value > other;
              }
              /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
              function baseHas(object, key) {
                return object != null && hasOwnProperty.call(object, key);
              }
              /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
              function baseHasIn(object, key) {
                return object != null && key in Object(object);
              }
              /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
              function baseInRange(number, start, end) {
                return number >= nativeMin(start, end) && number < nativeMax(start, end);
              }
              /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
              function baseIntersection(arrays, iteratee, comparator) {
                var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee) {
                    array = arrayMap(array, baseUnary(iteratee));
                  }
                  maxLength = nativeMin(array.length, maxLength);
                  caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
                }
                array = arrays[0];
                var index = -1, seen = caches[0];
                outer:
                  while (++index < length && result.length < maxLength) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                          continue outer;
                        }
                      }
                      if (seen) {
                        seen.push(computed);
                      }
                      result.push(value);
                    }
                  }
                return result;
              }
              /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
              function baseInverter(object, setter, iteratee, accumulator) {
                baseForOwn(object, function (value, key, object) {
                  setter(accumulator, iteratee(value), key, object);
                });
                return accumulator;
              }
              /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
              function baseInvoke(object, path, args) {
                path = castPath(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey(last(path))];
                return func == null ? undefined : apply(func, object, args);
              }
              /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
              function baseIsArrayBuffer(value) {
                return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
              }
              /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
              function baseIsDate(value) {
                return isObjectLike(value) && baseGetTag(value) == dateTag;
              }
              /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
              }
              /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
              function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
              }
              /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
              function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
              }
              /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
              function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length, length = index, noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (index--) {
                  var data = matchData[index];
                  if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                  }
                }
                while (++index < length) {
                  data = matchData[index];
                  var key = data[0], objValue = object[key], srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
              function baseIsRegExp(value) {
                return isObjectLike(value) && baseGetTag(value) == regexpTag;
              }
              /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
              function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
              }
              /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }
              /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
              function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
                  return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
              }
              /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != 'constructor') {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object), result = [];
                for (var key in object) {
                  if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
              function baseLt(value, other) {
                return value < other;
              }
              /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
              function baseMap(collection, iteratee) {
                var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                baseEach(collection, function (value, key, collection) {
                  result[++index] = iteratee(value, key, collection);
                });
                return result;
              }
              /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function (object) {
                  return object === source || baseIsMatch(object, source, matchData);
                };
              }
              /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function (object) {
                  var objValue = get(object, path);
                  return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
              }
              /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
              function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                  return;
                }
                baseFor(source, function (srcValue, key) {
                  if (isObject(srcValue)) {
                    stack || (stack = new Stack());
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                  } else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;
                    if (newValue === undefined) {
                      newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                  }
                }, keysIn);
              }
              /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
              function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
                if (stacked) {
                  assignMergeValue(object, key, stacked);
                  return;
                }
                var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
                var isCommon = newValue === undefined;
                if (isCommon) {
                  var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                  newValue = srcValue;
                  if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) {
                      newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                      newValue = copyArray(objValue);
                    } else if (isBuff) {
                      isCommon = false;
                      newValue = cloneBuffer(srcValue, true);
                    } else if (isTyped) {
                      isCommon = false;
                      newValue = cloneTypedArray(srcValue, true);
                    } else {
                      newValue = [];
                    }
                  } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) {
                      newValue = toPlainObject(objValue);
                    } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                      newValue = initCloneObject(srcValue);
                    }
                  } else {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  // Recursively merge objects and arrays (susceptible to call stack limits).
                  stack.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                  stack['delete'](srcValue);
                }
                assignMergeValue(object, key, newValue);
              }
              /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex(n, length) ? array[n] : undefined;
              }
              /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
              function baseOrderBy(collection, iteratees, orders) {
                var index = -1;
                iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
                var result = baseMap(collection, function (value, key, collection) {
                    var criteria = arrayMap(iteratees, function (iteratee) {
                        return iteratee(value);
                      });
                    return {
                      'criteria': criteria,
                      'index': ++index,
                      'value': value
                    };
                  });
                return baseSortBy(result, function (object, other) {
                  return compareMultiple(object, other, orders);
                });
              }
              /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
              function basePick(object, paths) {
                return basePickBy(object, paths, function (value, path) {
                  return hasIn(object, path);
                });
              }
              /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
              function basePickBy(object, paths, predicate) {
                var index = -1, length = paths.length, result = {};
                while (++index < length) {
                  var path = paths[index], value = baseGet(object, path);
                  if (predicate(value, path)) {
                    baseSet(result, castPath(path, object), value);
                  }
                }
                return result;
              }
              /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
              function basePropertyDeep(path) {
                return function (object) {
                  return baseGet(object, path);
                };
              }
              /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
              function basePullAll(array, values, iteratee, comparator) {
                var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                if (array === values) {
                  values = copyArray(values);
                }
                if (iteratee) {
                  seen = arrayMap(array, baseUnary(iteratee));
                }
                while (++index < length) {
                  var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                  while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                    if (seen !== array) {
                      splice.call(seen, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                  }
                }
                return array;
              }
              /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0, lastIndex = length - 1;
                while (length--) {
                  var index = indexes[length];
                  if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) {
                      splice.call(array, index, 1);
                    } else {
                      baseUnset(array, index);
                    }
                  }
                }
                return array;
              }
              /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
              function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
              }
              /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
              function baseRange(start, end, step, fromRight) {
                var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                while (length--) {
                  result[fromRight ? length : ++index] = start;
                  start += step;
                }
                return result;
              }
              /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
              function baseRepeat(string, n) {
                var result = '';
                if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                  return result;
                }
                // Leverage the exponentiation by squaring algorithm for a faster repeat.
                // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                do {
                  if (n % 2) {
                    result += string;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string += string;
                  }
                } while (n);
                return result;
              }
              /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + '');
              }
              /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
              function baseSample(collection) {
                return arraySample(values(collection));
              }
              /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
              function baseSampleSize(collection, n) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n, 0, array.length));
              }
              /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
              function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                  return object;
                }
                path = castPath(path, object);
                var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                while (nested != null && ++index < length) {
                  var key = toKey(path[index]), newValue = value;
                  if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                    if (newValue === undefined) {
                      newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                    }
                  }
                  assignValue(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }
              /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
              var baseSetData = !metaMap ? identity : function (func, data) {
                  metaMap.set(func, data);
                  return func;
                };
              /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
              var baseSetToString = !defineProperty ? identity : function (func, string) {
                  return defineProperty(func, 'toString', {
                    'configurable': true,
                    'enumerable': false,
                    'value': constant(string),
                    'writable': true
                  });
                };
              /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
              function baseShuffle(collection) {
                return shuffleSelf(values(collection));
              }
              /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
              function baseSlice(array, start, end) {
                var index = -1, length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result = Array(length);
                while (++index < length) {
                  result[index] = array[index + start];
                }
                return result;
              }
              /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
              function baseSome(collection, predicate) {
                var result;
                baseEach(collection, function (value, index, collection) {
                  result = predicate(value, index, collection);
                  return !result;
                });
                return !!result;
              }
              /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
              function baseSortedIndex(array, value, retHighest) {
                var low = 0, high = array == null ? low : array.length;
                if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity, retHighest);
              }
              /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
              function baseSortedIndexBy(array, value, iteratee, retHighest) {
                value = iteratee(value);
                var low = 0, high = array == null ? 0 : array.length, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
                while (low < high) {
                  var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }
              /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
              function baseSortedUniq(array, iteratee) {
                var index = -1, length = array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index], computed = iteratee ? iteratee(value) : value;
                  if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result;
              }
              /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
              function baseToNumber(value) {
                if (typeof value == 'number') {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                return +value;
              }
              /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
              function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                  return value;
                }
                if (isArray(value)) {
                  // Recursively convert values (susceptible to call stack limits).
                  return arrayMap(value, baseToString) + '';
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : '';
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
              }
              /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
              function baseUniq(array, iteratee, comparator) {
                var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
                if (comparator) {
                  isCommon = false;
                  includes = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                  var set = iteratee ? null : createSet(array);
                  if (set) {
                    return setToArray(set);
                  }
                  isCommon = false;
                  includes = cacheHas;
                  seen = new SetCache();
                } else {
                  seen = iteratee ? [] : result;
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var seenIndex = seen.length;
                      while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                          continue outer;
                        }
                      }
                      if (iteratee) {
                        seen.push(computed);
                      }
                      result.push(value);
                    } else if (!includes(seen, computed, comparator)) {
                      if (seen !== result) {
                        seen.push(computed);
                      }
                      result.push(value);
                    }
                  }
                return result;
              }
              /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
              function baseUnset(object, path) {
                path = castPath(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey(last(path))];
              }
              /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet(object, path)), customizer);
              }
              /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length, index = fromRight ? length : -1;
                while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                }
                return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
              }
              /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
              function baseWrapperValue(value, actions) {
                var result = value;
                if (result instanceof LazyWrapper) {
                  result = result.value();
                }
                return arrayReduce(actions, function (result, action) {
                  return action.func.apply(action.thisArg, arrayPush([result], action.args));
                }, result);
              }
              /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
              function baseXor(arrays, iteratee, comparator) {
                var length = arrays.length;
                if (length < 2) {
                  return length ? baseUniq(arrays[0]) : [];
                }
                var index = -1, result = Array(length);
                while (++index < length) {
                  var array = arrays[index], othIndex = -1;
                  while (++othIndex < length) {
                    if (othIndex != index) {
                      result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                    }
                  }
                }
                return baseUniq(baseFlatten(result, 1), iteratee, comparator);
              }
              /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
              function baseZipObject(props, values, assignFunc) {
                var index = -1, length = props.length, valsLength = values.length, result = {};
                while (++index < length) {
                  var value = index < valsLength ? values[index] : undefined;
                  assignFunc(result, props[index], value);
                }
                return result;
              }
              /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
              function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
              }
              /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
              function castFunction(value) {
                return typeof value == 'function' ? value : identity;
              }
              /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
              function castPath(value, object) {
                if (isArray(value)) {
                  return value;
                }
                return isKey(value, object) ? [value] : stringToPath(toString(value));
              }
              /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
              var castRest = baseRest;
              /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
              function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined ? length : end;
                return !start && end >= length ? array : baseSlice(array, start, end);
              }
              /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
              var clearTimeout = ctxClearTimeout || function (id) {
                  return root.clearTimeout(id);
                };
              /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
              function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                buffer.copy(result);
                return result;
              }
              /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
              function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                return result;
              }
              /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
              }
              /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */
              function cloneMap(map, isDeep, cloneFunc) {
                var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
                return arrayReduce(array, addMapEntry, new map.constructor());
              }
              /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
              function cloneRegExp(regexp) {
                var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result.lastIndex = regexp.lastIndex;
                return result;
              }
              /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */
              function cloneSet(set, isDeep, cloneFunc) {
                var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
                return arrayReduce(array, addSetEntry, new set.constructor());
              }
              /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
              function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
              }
              /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
              function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
              }
              /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                  var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                  if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                    return 1;
                  }
                  if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                    return -1;
                  }
                }
                return 0;
              }
              /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
              function compareMultiple(object, other, orders) {
                var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index < length) {
                  var result = compareAscending(objCriteria[index], othCriteria[index]);
                  if (result) {
                    if (index >= ordersLength) {
                      return result;
                    }
                    var order = orders[index];
                    return result * (order == 'desc' ? -1 : 1);
                  }
                }
                // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                // that causes it, under certain circumstances, to provide the same value for
                // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                // for more details.
                //
                // This also ensures a stable sort in V8 and other engines.
                // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                return object.index - other.index;
              }
              /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                  result[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result[leftIndex++] = args[argsIndex++];
                }
                return result;
              }
              /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                  result[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result;
              }
              /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
              function copyArray(source, array) {
                var index = -1, length = source.length;
                array || (array = Array(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }
              /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index = -1, length = props.length;
                while (++index < length) {
                  var key = props[index];
                  var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                  if (newValue === undefined) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }
              /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
              function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }
              /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
              function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
              }
              /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
              function createAggregator(setter, initializer) {
                return function (collection, iteratee) {
                  var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                  return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                };
              }
              /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
              function createAssigner(assigner) {
                return baseRest(function (object, sources) {
                  var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                  customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                  }
                  object = Object(object);
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, index, customizer);
                    }
                  }
                  return object;
                });
              }
              /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
              function createBaseEach(eachFunc, fromRight) {
                return function (collection, iteratee) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                  }
                  var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                  while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }
              /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
              function createBaseFor(fromRight) {
                return function (object, iteratee, keysFunc) {
                  var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                  while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }
              /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }
              /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
              function createCaseFirst(methodName) {
                return function (string) {
                  string = toString(string);
                  var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
                  var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                  var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
                  return chr[methodName]() + trailing;
                };
              }
              /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
              function createCompounder(callback) {
                return function (string) {
                  return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                };
              }
              /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
              function createCtor(Ctor) {
                return function () {
                  // Use a `switch` statement to work with class constructors. See
                  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                  // for more details.
                  var args = arguments;
                  switch (args.length) {
                  case 0:
                    return new Ctor();
                  case 1:
                    return new Ctor(args[0]);
                  case 2:
                    return new Ctor(args[0], args[1]);
                  case 3:
                    return new Ctor(args[0], args[1], args[2]);
                  case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);
                  case 5:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                  case 6:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                  case 7:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                  }
                  var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                  // Mimic the constructor's `return` behavior.
                  // See https://es5.github.io/#x13.2.2 for more details.
                  return isObject(result) ? result : thisBinding;
                };
              }
              /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                  }
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return apply(fn, this, args);
                }
                return wrapper;
              }
              /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
              function createFind(findIndexFunc) {
                return function (collection, predicate, fromIndex) {
                  var iterable = Object(collection);
                  if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function predicate(key) {
                      return iteratee(iterable[key], key, iterable);
                    };
                  }
                  var index = findIndexFunc(collection, predicate, fromIndex);
                  return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                };
              }
              /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
              function createFlow(fromRight) {
                return flatRest(function (funcs) {
                  var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index--) {
                    var func = funcs[index];
                    if (typeof func != 'function') {
                      throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index = wrapper ? index : length;
                  while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
                    if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                      wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                      wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                  }
                  return function () {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value)) {
                      return wrapper.plant(value).value();
                    }
                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                    while (++index < length) {
                      result = funcs[index].call(this, result);
                    }
                    return result;
                  };
                });
              }
              /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array(length), index = length;
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                  }
                  var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary < length) {
                    args.length = ary;
                  }
                  if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }
              /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
              function createInverter(setter, toIteratee) {
                return function (object, iteratee) {
                  return baseInverter(object, setter, toIteratee(iteratee), {});
                };
              }
              /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
              function createMathOperation(operator, defaultValue) {
                return function (value, other) {
                  var result;
                  if (value === undefined && other === undefined) {
                    return defaultValue;
                  }
                  if (value !== undefined) {
                    result = value;
                  }
                  if (other !== undefined) {
                    if (result === undefined) {
                      return other;
                    }
                    if (typeof value == 'string' || typeof other == 'string') {
                      value = baseToString(value);
                      other = baseToString(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result = operator(value, other);
                  }
                  return result;
                };
              }
              /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
              function createOver(arrayFunc) {
                return flatRest(function (iteratees) {
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  return baseRest(function (args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function (iteratee) {
                      return apply(iteratee, thisArg, args);
                    });
                  });
                });
              }
              /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
              function createPadding(length, chars) {
                chars = chars === undefined ? ' ' : baseToString(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
              }
              /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }
              /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
              function createRange(fromRight) {
                return function (start, end, step) {
                  if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                    end = step = undefined;
                  }
                  // Ensure the sign of `-0` is preserved.
                  start = toFinite(start);
                  if (end === undefined) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }
              /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
              function createRelationalOperation(operator) {
                return function (value, other) {
                  if (!(typeof value == 'string' && typeof other == 'string')) {
                    value = toNumber(value);
                    other = toNumber(other);
                  }
                  return operator(value, other);
                };
              }
              /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
                bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                  bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                }
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newHolders,
                    newPartialsRight,
                    newHoldersRight,
                    argPos,
                    ary,
                    arity
                  ];
                var result = wrapFunc.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return setWrapToString(result, func, bitmask);
              }
              /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
              function createRound(methodName) {
                var func = Math[methodName];
                return function (number, precision) {
                  number = toNumber(number);
                  precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                  if (precision) {
                    // Shift with exponential notation to avoid floating-point issues.
                    // See [MDN](https://mdn.io/round#Examples) for more details.
                    var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
                    pair = (toString(value) + 'e').split('e');
                    return +(pair[0] + 'e' + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }
              /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
              var createSet = !(Set && 1 / setToArray(new Set([
                  ,
                  -0
                ]))[1] == INFINITY) ? noop : function (values) {
                  return new Set(values);
                };
              /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
              function createToPairs(keysFunc) {
                return function (object) {
                  var tag = getTag(object);
                  if (tag == mapTag) {
                    return mapToArray(object);
                  }
                  if (tag == setTag) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }
              /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
              function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                  partials = holders = undefined;
                }
                ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                arity = arity === undefined ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials, holdersRight = holders;
                  partials = holders = undefined;
                }
                var data = isBindKey ? undefined : getData(func);
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary,
                    arity
                  ];
                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                  bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                  var result = createBind(func, bitmask, thisArg);
                } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                  result = createCurry(func, bitmask, arity);
                } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                  result = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result = createHybrid.apply(undefined, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result, newData), func, bitmask);
              }
              /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }
              /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
              function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                if (isObject(objValue) && isObject(srcValue)) {
                  // Recursively merge objects and arrays (susceptible to call stack limits).
                  stack.set(srcValue, objValue);
                  baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                  stack['delete'](srcValue);
                }
                return objValue;
              }
              /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
              function customOmitClone(value) {
                return isPlainObject(value) ? undefined : value;
              }
              /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
              function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
                stack.set(array, other);
                stack.set(other, array);
                // Ignore non-index properties.
                while (++index < arrLength) {
                  var arrValue = array[index], othValue = other[index];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                  }
                  if (compared !== undefined) {
                    if (compared) {
                      continue;
                    }
                    result = false;
                    break;
                  }
                  // Recursively compare arrays (susceptible to call stack limits).
                  if (seen) {
                    if (!arraySome(other, function (othValue, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                          return seen.push(othIndex);
                        }
                      })) {
                      result = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result = false;
                    break;
                  }
                }
                stack['delete'](array);
                stack['delete'](other);
                return result;
              }
              /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
              function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                case dataViewTag:
                  if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  // Coerce booleans to `1` or `0` and dates to milliseconds.
                  // Invalid dates are coerced to `NaN`.
                  return eq(+object, +other);
                case errorTag:
                  return object.name == other.name && object.message == other.message;
                case regexpTag:
                case stringTag:
                  // Coerce regexes to strings and treat strings, primitives and objects,
                  // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                  // for more details.
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  // Assume cyclic values are equal.
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= COMPARE_UNORDERED_FLAG;
                  // Recursively compare objects (susceptible to call stack limits).
                  stack.set(object, other);
                  var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                  }
                }
                return false;
              }
              /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
              function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  }
                  // Recursively compare objects (susceptible to call stack limits).
                  if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == 'constructor');
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  // Non `Object` object instances with different constructors are not equal.
                  if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    result = false;
                  }
                }
                stack['delete'](object);
                stack['delete'](other);
                return result;
              }
              /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
              function flatRest(func) {
                return setToString(overRest(func, undefined, flatten), func + '');
              }
              /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
              function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
              }
              /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
              var getData = !metaMap ? noop : function (func) {
                  return metaMap.get(func);
                };
              /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
              function getFuncName(func) {
                var result = func.name + '', array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
                while (length--) {
                  var data = array[length], otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result;
              }
              /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
              function getHolder(func) {
                var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                return object.placeholder;
              }
              /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
              function getIteratee() {
                var result = lodash.iteratee || iteratee;
                result = result === iteratee ? baseIteratee : result;
                return arguments.length ? result(arguments[0], arguments[1]) : result;
              }
              /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
              function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
              }
              /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
              function getMatchData(object) {
                var result = keys(object), length = result.length;
                while (length--) {
                  var key = result[length], value = object[key];
                  result[length] = [
                    key,
                    value,
                    isStrictComparable(value)
                  ];
                }
                return result;
              }
              /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined;
              }
              /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = undefined;
                  var unmasked = true;
                } catch (e) {
                }
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }
              /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
              var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
                  if (object == null) {
                    return [];
                  }
                  object = Object(object);
                  return arrayFilter(nativeGetSymbols(object), function (symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                  });
                };
              /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
              var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
                  var result = [];
                  while (object) {
                    arrayPush(result, getSymbols(object));
                    object = getPrototype(object);
                  }
                  return result;
                };
              /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
              var getTag = baseGetTag;
              // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
              if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
                getTag = function getTag(value) {
                  var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
                  if (ctorString) {
                    switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                    }
                  }
                  return result;
                };
              }
              /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
              function getView(start, end, transforms) {
                var index = -1, length = transforms.length;
                while (++index < length) {
                  var data = transforms[index], size = data.size;
                  switch (data.type) {
                  case 'drop':
                    start += size;
                    break;
                  case 'dropRight':
                    end -= size;
                    break;
                  case 'take':
                    end = nativeMin(end, start + size);
                    break;
                  case 'takeRight':
                    start = nativeMax(start, end - size);
                    break;
                  }
                }
                return {
                  'start': start,
                  'end': end
                };
              }
              /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
              function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
              }
              /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
              function hasPath(object, path, hasFunc) {
                path = castPath(path, object);
                var index = -1, length = path.length, result = false;
                while (++index < length) {
                  var key = toKey(path[index]);
                  if (!(result = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result || ++index != length) {
                  return result;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
              }
              /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
              function initCloneArray(array) {
                var length = array.length, result = array.constructor(length);
                // Add properties assigned by `RegExp#exec`.
                if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                  result.index = array.index;
                  result.input = array.input;
                }
                return result;
              }
              /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
              function initCloneObject(object) {
                return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
              }
              /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
              function initCloneByTag(object, tag, cloneFunc, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                case arrayBufferTag:
                  return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                  return new Ctor(+object);
                case dataViewTag:
                  return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                  return cloneTypedArray(object, isDeep);
                case mapTag:
                  return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                  return new Ctor(object);
                case regexpTag:
                  return cloneRegExp(object);
                case setTag:
                  return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                  return cloneSymbol(object);
                }
              }
              /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                details = details.join(length > 2 ? ', ' : ' ');
                return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
              }
              /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
              function isFlattenable(value) {
                return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
              }
              /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
              function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
              }
              /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
                if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
                  return eq(object[index], value);
                }
                return false;
              }
              /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
                if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
                  return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
              }
              /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
              function isKeyable(value) {
                var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
                return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
              }
              /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
              function isLaziable(func) {
                var funcName = getFuncName(func), other = lodash[funcName];
                if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }
              /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
              var isMaskable = coreJsData ? isFunction : stubFalse;
              /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
                return value === proto;
              }
              /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }
              /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
              function matchesStrictComparable(key, srcValue) {
                return function (object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
                };
              }
              /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
              function memoizeCapped(func) {
                var result = memoize(func, function (key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                      cache.clear();
                    }
                    return key;
                  });
                var cache = result.cache;
                return result;
              }
              /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
              function mergeData(data, source) {
                var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                // Exit early if metadata can't be merged.
                if (!(isCommon || isCombo)) {
                  return data;
                }
                // Use source `thisArg` if available.
                if (srcBitmask & WRAP_BIND_FLAG) {
                  data[2] = source[2];
                  // Set when currying a bound function.
                  newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                // Compose partial arguments.
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                  data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                // Compose partial right arguments.
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                  data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                // Use source `argPos` if available.
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                // Use source `ary` if it's smaller.
                if (srcBitmask & WRAP_ARY_FLAG) {
                  data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                // Use source `arity` if one is not provided.
                if (data[9] == null) {
                  data[9] = source[9];
                }
                // Use source `func` and merge bitmasks.
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
              }
              /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
              function nativeKeysIn(object) {
                var result = [];
                if (object != null) {
                  for (var key in Object(object)) {
                    result.push(key);
                  }
                }
                return result;
              }
              /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }
              /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
              function overRest(func, start, transform) {
                start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                return function () {
                  var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform(array);
                  return apply(func, this, otherArgs);
                };
              }
              /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
              function parent(object, path) {
                return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
              }
              /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
              function reorder(array, indexes) {
                var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                while (length--) {
                  var index = indexes[length];
                  array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                }
                return array;
              }
              /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
              var setData = shortOut(baseSetData);
              /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
              var setTimeout = ctxSetTimeout || function (func, wait) {
                  return root.setTimeout(func, wait);
                };
              /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
              var setToString = shortOut(baseSetToString);
              /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + '';
                return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
              }
              /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
              function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function () {
                  var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined, arguments);
                };
              }
              /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
              function shuffleSelf(array, size) {
                var index = -1, length = array.length, lastIndex = length - 1;
                size = size === undefined ? length : size;
                while (++index < size) {
                  var rand = baseRandom(index, lastIndex), value = array[rand];
                  array[rand] = array[index];
                  array[index] = value;
                }
                array.length = size;
                return array;
              }
              /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
              var stringToPath = memoizeCapped(function (string) {
                  var result = [];
                  if (reLeadingDot.test(string)) {
                    result.push('');
                  }
                  string.replace(rePropName, function (match, number, quote, string) {
                    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                  });
                  return result;
                });
              /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
              function toKey(value) {
                if (typeof value == 'string' || isSymbol(value)) {
                  return value;
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
              }
              /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + '';
                  } catch (e) {
                  }
                }
                return '';
              }
              /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
              function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function (pair) {
                  var value = '_.' + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }
              /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result.__actions__ = copyArray(wrapper.__actions__);
                result.__index__ = wrapper.__index__;
                result.__values__ = wrapper.__values__;
                return result;
              }
              /*------------------------------------------------------------------------*/
              /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
              function chunk(array, size, guard) {
                if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                  size = 1;
                } else {
                  size = nativeMax(toInteger(size), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size < 1) {
                  return [];
                }
                var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                while (index < length) {
                  result[resIndex++] = baseSlice(array, index, index += size);
                }
                return result;
              }
              /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
              function compact(array) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (value) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array(length - 1), array = arguments[0], index = length;
                while (index--) {
                  args[index - 1] = arguments[index];
                }
                return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
              }
              /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
              var difference = baseRest(function (array, values) {
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
                });
              /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
              var differenceBy = baseRest(function (array, values) {
                  var iteratee = last(values);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
                });
              /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
              var differenceWith = baseRest(function (array, values) {
                  var comparator = last(values);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
                });
              /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
              function drop(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
              function dropRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
              function dropRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
              }
              /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
              function dropWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
              }
              /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
              function fill(array, value, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }
              /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
              function findIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index);
              }
              /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
              function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length - 1;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index, true);
              }
              /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
              function flatten(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
              }
              /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
              function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
              }
              /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
              function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }
              /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
              function fromPairs(pairs) {
                var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
                while (++index < length) {
                  var pair = pairs[index];
                  result[pair[0]] = pair[1];
                }
                return result;
              }
              /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
              function head(array) {
                return array && array.length ? array[0] : undefined;
              }
              /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
              function indexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseIndexOf(array, value, index);
              }
              /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
              function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 0, -1) : [];
              }
              /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
              var intersection = baseRest(function (arrays) {
                  var mapped = arrayMap(arrays, castArrayLikeObject);
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                });
              /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
              var intersectionBy = baseRest(function (arrays) {
                  var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  if (iteratee === last(mapped)) {
                    iteratee = undefined;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
                });
              /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
              var intersectionWith = baseRest(function (arrays) {
                  var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  comparator = typeof comparator == 'function' ? comparator : undefined;
                  if (comparator) {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
                });
              /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
              function join(array, separator) {
                return array == null ? '' : nativeJoin.call(array, separator);
              }
              /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined;
              }
              /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
              function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                }
                return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
              }
              /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
              function nth(array, n) {
                return array && array.length ? baseNth(array, toInteger(n)) : undefined;
              }
              /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
              var pull = baseRest(pullAll);
              /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
              function pullAll(array, values) {
                return array && array.length && values && values.length ? basePullAll(array, values) : array;
              }
              /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
              function pullAllBy(array, values, iteratee) {
                return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
              }
              /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
              function pullAllWith(array, values, comparator) {
                return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
              }
              /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
              var pullAt = flatRest(function (array, indexes) {
                  var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
                  basePullAt(array, arrayMap(indexes, function (index) {
                    return isIndex(index, length) ? +index : index;
                  }).sort(compareAscending));
                  return result;
                });
              /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
              function remove(array, predicate) {
                var result = [];
                if (!(array && array.length)) {
                  return result;
                }
                var index = -1, indexes = [], length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                  }
                }
                basePullAt(array, indexes);
                return result;
              }
              /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
              function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
              }
              /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
              function slice(array, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                  start = 0;
                  end = length;
                } else {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined ? length : toInteger(end);
                }
                return baseSlice(array, start, end);
              }
              /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }
              /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
              function sortedIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
              }
              /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
              function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value);
                  if (index < length && eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }
              /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
              function sortedLastIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
              }
              /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
              function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value, true) - 1;
                  if (eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
              function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
              }
              /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
              function sortedUniqBy(array, iteratee) {
                return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
              }
              /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
              function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 1, length) : [];
              }
              /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
              function takeRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
              function takeRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
              }
              /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
              function takeWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
              }
              /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
              var union = baseRest(function (arrays) {
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });
              /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
              var unionBy = baseRest(function (arrays) {
                  var iteratee = last(arrays);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                });
              /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
              var unionWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == 'function' ? comparator : undefined;
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                });
              /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }
              /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
              function uniqBy(array, iteratee) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
              }
              /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
              function uniqWith(array, comparator) {
                comparator = typeof comparator == 'function' ? comparator : undefined;
                return array && array.length ? baseUniq(array, undefined, comparator) : [];
              }
              /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter(array, function (group) {
                  if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                  }
                });
                return baseTimes(length, function (index) {
                  return arrayMap(array, baseProperty(index));
                });
              }
              /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
              function unzipWith(array, iteratee) {
                if (!(array && array.length)) {
                  return [];
                }
                var result = unzip(array);
                if (iteratee == null) {
                  return result;
                }
                return arrayMap(result, function (group) {
                  return apply(iteratee, undefined, group);
                });
              }
              /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
              var without = baseRest(function (array, values) {
                  return isArrayLikeObject(array) ? baseDifference(array, values) : [];
                });
              /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
              var xor = baseRest(function (arrays) {
                  return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });
              /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
              var xorBy = baseRest(function (arrays) {
                  var iteratee = last(arrays);
                  if (isArrayLikeObject(iteratee)) {
                    iteratee = undefined;
                  }
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                });
              /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
              var xorWith = baseRest(function (arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == 'function' ? comparator : undefined;
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                });
              /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
              var zip = baseRest(unzip);
              /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
              function zipObject(props, values) {
                return baseZipObject(props || [], values || [], assignValue);
              }
              /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
              function zipObjectDeep(props, values) {
                return baseZipObject(props || [], values || [], baseSet);
              }
              /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
              var zipWith = baseRest(function (arrays) {
                  var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                  return unzipWith(arrays, iteratee);
                });
              /*------------------------------------------------------------------------*/
              /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
              function chain(value) {
                var result = lodash(value);
                result.__chain__ = true;
                return result;
              }
              /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }
              /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
              function thru(value, interceptor) {
                return interceptor(value);
              }
              /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
              var wrapperAt = flatRest(function (paths) {
                  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function interceptor(object) {
                      return baseAt(object, paths);
                    };
                  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                    return this.thru(interceptor);
                  }
                  value = value.slice(start, +start + (length ? 1 : 0));
                  value.__actions__.push({
                    'func': thru,
                    'args': [interceptor],
                    'thisArg': undefined
                  });
                  return new LodashWrapper(value, this.__chain__).thru(function (array) {
                    if (length && !array.length) {
                      array.push(undefined);
                    }
                    return array;
                  });
                });
              /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
              function wrapperChain() {
                return chain(this);
              }
              /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }
              /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
              function wrapperNext() {
                if (this.__values__ === undefined) {
                  this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
                return {
                  'done': done,
                  'value': value
                };
              }
              /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
              function wrapperToIterator() {
                return this;
              }
              /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
              function wrapperPlant(value) {
                var result, parent = this;
                while (parent instanceof baseLodash) {
                  var clone = wrapperClone(parent);
                  clone.__index__ = 0;
                  clone.__values__ = undefined;
                  if (result) {
                    previous.__wrapped__ = clone;
                  } else {
                    result = clone;
                  }
                  var previous = clone;
                  parent = parent.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result;
              }
              /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    'func': thru,
                    'args': [reverse],
                    'thisArg': undefined
                  });
                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }
              /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
              var countBy = createAggregator(function (result, value, key) {
                  if (hasOwnProperty.call(result, key)) {
                    ++result[key];
                  } else {
                    baseAssignValue(result, key, 1);
                  }
                });
              /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
              function every(collection, predicate, guard) {
                var func = isArray(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
              function filter(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }
              /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
              var find = createFind(findIndex);
              /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
              var findLast = createFind(findLastIndex);
              /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
              function flatMap(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), 1);
              }
              /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
              function flatMapDeep(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), INFINITY);
              }
              /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
              function flatMapDepth(collection, iteratee, depth) {
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee), depth);
              }
              /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
              function forEach(collection, iteratee) {
                var func = isArray(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee, 3));
              }
              /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
              function forEachRight(collection, iteratee) {
                var func = isArray(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee, 3));
              }
              /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
              var groupBy = createAggregator(function (result, value, key) {
                  if (hasOwnProperty.call(result, key)) {
                    result[key].push(value);
                  } else {
                    baseAssignValue(result, key, [value]);
                  }
                });
              /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }
              /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
              var invokeMap = baseRest(function (collection, path, args) {
                  var index = -1, isFunc = typeof path == 'function', result = isArrayLike(collection) ? Array(collection.length) : [];
                  baseEach(collection, function (value) {
                    result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                  });
                  return result;
                });
              /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
              var keyBy = createAggregator(function (result, value, key) {
                  baseAssignValue(result, key, value);
                });
              /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
              function map(collection, iteratee) {
                var func = isArray(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee, 3));
              }
              /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined : orders;
                if (!isArray(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }
              /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
              var partition = createAggregator(function (result, value, key) {
                  result[key ? 0 : 1].push(value);
                }, function () {
                  return [
                    [],
                    []
                  ];
                });
              /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
              function reduce(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
              }
              /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
              function reduceRight(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
              }
              /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
              function reject(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }
              /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
              function sample(collection) {
                var func = isArray(collection) ? arraySample : baseSample;
                return func(collection);
              }
              /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
              function sampleSize(collection, n, guard) {
                if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                return func(collection, n);
              }
              /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
              function shuffle(collection) {
                var func = isArray(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
              }
              /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
              function size(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike(collection)) {
                  return isString(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                  return collection.size;
                }
                return baseKeys(collection).length;
              }
              /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
              function some(collection, predicate, guard) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
              var sortBy = baseRest(function (collection, iteratees) {
                  if (collection == null) {
                    return [];
                  }
                  var length = iteratees.length;
                  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                    iteratees = [];
                  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                    iteratees = [iteratees[0]];
                  }
                  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });
              /*------------------------------------------------------------------------*/
              /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
              var now = ctxNow || function () {
                  return root.Date.now();
                };
              /*------------------------------------------------------------------------*/
              /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
              function after(n, func) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function () {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }
              /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
              function ary(func, n, guard) {
                n = guard ? undefined : n;
                n = func && n == null ? func.length : n;
                return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
              }
              /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
              function before(n, func) {
                var result;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function () {
                  if (--n > 0) {
                    result = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined;
                  }
                  return result;
                };
              }
              /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
              var bind = baseRest(function (func, thisArg, partials) {
                  var bitmask = WRAP_BIND_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(func, bitmask, thisArg, partials, holders);
                });
              /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
              var bindKey = baseRest(function (object, key, partials) {
                  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(key, bitmask, object, partials, holders);
                });
              /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
              function curry(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                result.placeholder = curry.placeholder;
                return result;
              }
              /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
              function curryRight(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                result.placeholder = curryRight.placeholder;
                return result;
              }
              /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
              function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = 'maxWait' in options;
                  maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                  trailing = 'trailing' in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                  var args = lastArgs, thisArg = lastThis;
                  lastArgs = lastThis = undefined;
                  lastInvokeTime = time;
                  result = func.apply(thisArg, args);
                  return result;
                }
                function leadingEdge(time) {
                  // Reset any `maxWait` timer.
                  lastInvokeTime = time;
                  // Start the timer for the trailing edge.
                  timerId = setTimeout(timerExpired, wait);
                  // Invoke the leading edge.
                  return leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                  return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                  // Either this is the first call, activity has stopped and we're at the
                  // trailing edge, the system time has gone backwards and we're treating
                  // it as the trailing edge, or we've hit the `maxWait` limit.
                  return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  // Restart the timer.
                  timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                  timerId = undefined;
                  // Only invoke if we have `lastArgs` which means `func` has been
                  // debounced at least once.
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = undefined;
                  return result;
                }
                function cancel() {
                  if (timerId !== undefined) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined;
                }
                function flush() {
                  return timerId === undefined ? result : trailingEdge(now());
                }
                function debounced() {
                  var time = now(), isInvoking = shouldInvoke(time);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;
                  if (isInvoking) {
                    if (timerId === undefined) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      // Handle invocations in a tight loop.
                      timerId = setTimeout(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                  }
                  return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
              var defer = baseRest(function (func, args) {
                  return baseDelay(func, 1, args);
                });
              /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
              var delay = baseRest(function (func, wait, args) {
                  return baseDelay(func, toNumber(wait) || 0, args);
                });
              /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
              function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
              }
              /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
              function memoize(func, resolver) {
                if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function memoized() {
                  var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result = func.apply(this, args);
                  memoized.cache = cache.set(key, result) || cache;
                  return result;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }
              // Expose `MapCache`.
              memoize.Cache = MapCache;
              /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
              function negate(predicate) {
                if (typeof predicate != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return function () {
                  var args = arguments;
                  switch (args.length) {
                  case 0:
                    return !predicate.call(this);
                  case 1:
                    return !predicate.call(this, args[0]);
                  case 2:
                    return !predicate.call(this, args[0], args[1]);
                  case 3:
                    return !predicate.call(this, args[0], args[1], args[2]);
                  }
                  return !predicate.apply(this, args);
                };
              }
              /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
              function once(func) {
                return before(2, func);
              }
              /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
              var overArgs = castRest(function (func, transforms) {
                  transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                  var funcsLength = transforms.length;
                  return baseRest(function (args) {
                    var index = -1, length = nativeMin(args.length, funcsLength);
                    while (++index < length) {
                      args[index] = transforms[index].call(this, args[index]);
                    }
                    return apply(func, this, args);
                  });
                });
              /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
              var partial = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partial));
                  return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
                });
              /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
              var partialRight = baseRest(function (func, partials) {
                  var holders = replaceHolders(partials, getHolder(partialRight));
                  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                });
              /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
              var rearg = flatRest(function (func, indexes) {
                  return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
                });
              /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
              function rest(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start === undefined ? start : toInteger(start);
                return baseRest(func, start);
              }
              /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
              function spread(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start == null ? 0 : nativeMax(toInteger(start), 0);
                return baseRest(function (args) {
                  var array = args[start], otherArgs = castSlice(args, 0, start);
                  if (array) {
                    arrayPush(otherArgs, array);
                  }
                  return apply(func, this, otherArgs);
                });
              }
              /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
              function throttle(func, wait, options) {
                var leading = true, trailing = true;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (isObject(options)) {
                  leading = 'leading' in options ? !!options.leading : leading;
                  trailing = 'trailing' in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                  'leading': leading,
                  'maxWait': wait,
                  'trailing': trailing
                });
              }
              /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
              function unary(func) {
                return ary(func, 1);
              }
              /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
              function wrap(value, wrapper) {
                return partial(castFunction(wrapper), value);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray(value) ? value : [value];
              }
              /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
              function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
              }
              /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
              function cloneWith(value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
              }
              /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
              function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
              }
              /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
              function cloneDeepWith(value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
              }
              /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
              function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys(source));
              }
              /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
              var gt = createRelationalOperation(baseGt);
              /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
              var gte = createRelationalOperation(function (value, other) {
                  return value >= other;
                });
              /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
              var isArguments = baseIsArguments(function () {
                  return arguments;
                }()) ? baseIsArguments : function (value) {
                  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                };
              /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
              var isArray = Array.isArray;
              /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
              var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
              /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
              }
              /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
              function isBoolean(value) {
                return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
              }
              /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
              var isBuffer = nativeIsBuffer || stubFalse;
              /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
              var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
              /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
              function isElement(value) {
                return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
              }
              /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                  return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                  return !value.size;
                }
                if (isPrototype(value)) {
                  return !baseKeys(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }
              /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }
              /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
              function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                var result = customizer ? customizer(value, other) : undefined;
                return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
              }
              /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
              }
              /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
              function isFinite(value) {
                return typeof value == 'number' && nativeIsFinite(value);
              }
              /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
              function isFunction(value) {
                if (!isObject(value)) {
                  return false;
                }
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }
              /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
              function isInteger(value) {
                return typeof value == 'number' && value == toInteger(value);
              }
              /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
              function isLength(value) {
                return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
              function isObject(value) {
                var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
                return value != null && (type == 'object' || type == 'function');
              }
              /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
              function isObjectLike(value) {
                return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
              }
              /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
              var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
              /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
              function isMatch(object, source) {
                return object === source || baseIsMatch(object, source, getMatchData(source));
              }
              /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
              function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseIsMatch(object, source, getMatchData(source), customizer);
              }
              /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
              function isNaN(value) {
                // An `NaN` primitive is the only value that is not equal to itself.
                // Perform the `toStringTag` check first to avoid errors with some
                // ActiveX objects in IE.
                return isNumber(value) && value != +value;
              }
              /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error(CORE_ERROR_TEXT);
                }
                return baseIsNative(value);
              }
              /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
              function isNull(value) {
                return value === null;
              }
              /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
              function isNil(value) {
                return value == null;
              }
              /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
              function isNumber(value) {
                return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
              }
              /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
              function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
              }
              /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
              var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
              /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
              function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
              }
              /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
              var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
              /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
              function isString(value) {
                return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
              }
              /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
              function isSymbol(value) {
                return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
              }
              /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
              function isUndefined(value) {
                return value === undefined;
              }
              /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
              function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
              }
              /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
              function isWeakSet(value) {
                return isObjectLike(value) && baseGetTag(value) == weakSetTag;
              }
              /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
              var lt = createRelationalOperation(baseLt);
              /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
              var lte = createRelationalOperation(function (value, other) {
                  return value <= other;
                });
              /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
              function toArray(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike(value)) {
                  return isString(value) ? stringToArray(value) : copyArray(value);
                }
                if (symIterator && value[symIterator]) {
                  return iteratorToArray(value[symIterator]());
                }
                var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                return func(value);
              }
              /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
              function toInteger(value) {
                var result = toFinite(value), remainder = result % 1;
                return result === result ? remainder ? result - remainder : result : 0;
              }
              /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
              function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
              }
              /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
              function toNumber(value) {
                if (typeof value == 'number') {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                  value = isObject(other) ? other + '' : other;
                }
                if (typeof value != 'string') {
                  return value === 0 ? value : +value;
                }
                value = value.replace(reTrim, '');
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
              }
              /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
              function toPlainObject(value) {
                return copyObject(value, keysIn(value));
              }
              /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
              function toSafeInteger(value) {
                return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
              }
              /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
              function toString(value) {
                return value == null ? '' : baseToString(value);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
              var assign = createAssigner(function (object, source) {
                  if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                  }
                  for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                      assignValue(object, key, source[key]);
                    }
                  }
                });
              /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
              var assignIn = createAssigner(function (object, source) {
                  copyObject(source, keysIn(source), object);
                });
              /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
              var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                  copyObject(source, keysIn(source), object, customizer);
                });
              /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
              var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                  copyObject(source, keys(source), object, customizer);
                });
              /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
              var at = flatRest(baseAt);
              /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
              function create(prototype, properties) {
                var result = baseCreate(prototype);
                return properties == null ? result : baseAssign(result, properties);
              }
              /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
              var defaults = baseRest(function (args) {
                  args.push(undefined, customDefaultsAssignIn);
                  return apply(assignInWith, undefined, args);
                });
              /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
              var defaultsDeep = baseRest(function (args) {
                  args.push(undefined, customDefaultsMerge);
                  return apply(mergeWith, undefined, args);
                });
              /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
              function findKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
              }
              /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
              function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
              }
              /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
              function forIn(object, iteratee) {
                return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
              }
              /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
              function forInRight(object, iteratee) {
                return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
              }
              /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
              function forOwn(object, iteratee) {
                return object && baseForOwn(object, getIteratee(iteratee, 3));
              }
              /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
              function forOwnRight(object, iteratee) {
                return object && baseForOwnRight(object, getIteratee(iteratee, 3));
              }
              /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
              function functions(object) {
                return object == null ? [] : baseFunctions(object, keys(object));
              }
              /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
              function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn(object));
              }
              /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
              function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path);
                return result === undefined ? defaultValue : result;
              }
              /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
              function has(object, path) {
                return object != null && hasPath(object, path, baseHas);
              }
              /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }
              /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
              var invert = createInverter(function (result, value, key) {
                  result[value] = key;
                }, constant(identity));
              /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
              var invertBy = createInverter(function (result, value, key) {
                  if (hasOwnProperty.call(result, value)) {
                    result[value].push(key);
                  } else {
                    result[value] = [key];
                  }
                }, getIteratee);
              /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
              var invoke = baseRest(baseInvoke);
              /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
              function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
              }
              /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
              function mapKeys(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);
                baseForOwn(object, function (value, key, object) {
                  baseAssignValue(result, iteratee(value, key, object), value);
                });
                return result;
              }
              /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
              function mapValues(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);
                baseForOwn(object, function (value, key, object) {
                  baseAssignValue(result, key, iteratee(value, key, object));
                });
                return result;
              }
              /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
              var merge = createAssigner(function (object, source, srcIndex) {
                  baseMerge(object, source, srcIndex);
                });
              /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
              var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                  baseMerge(object, source, srcIndex, customizer);
                });
              /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
              var omit = flatRest(function (object, paths) {
                  var result = {};
                  if (object == null) {
                    return result;
                  }
                  var isDeep = false;
                  paths = arrayMap(paths, function (path) {
                    path = castPath(path, object);
                    isDeep || (isDeep = path.length > 1);
                    return path;
                  });
                  copyObject(object, getAllKeysIn(object), result);
                  if (isDeep) {
                    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                  }
                  var length = paths.length;
                  while (length--) {
                    baseUnset(result, paths[length]);
                  }
                  return result;
                });
              /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }
              /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
              var pick = flatRest(function (object, paths) {
                  return object == null ? {} : basePick(object, paths);
                });
              /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
              function pickBy(object, predicate) {
                if (object == null) {
                  return {};
                }
                var props = arrayMap(getAllKeysIn(object), function (prop) {
                    return [prop];
                  });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function (value, path) {
                  return predicate(value, path[0]);
                });
              }
              /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
              function result(object, path, defaultValue) {
                path = castPath(path, object);
                var index = -1, length = path.length;
                // Ensure the loop is entered when path is empty.
                if (!length) {
                  length = 1;
                  object = undefined;
                }
                while (++index < length) {
                  var value = object == null ? undefined : object[toKey(path[index])];
                  if (value === undefined) {
                    index = length;
                    value = defaultValue;
                  }
                  object = isFunction(value) ? value.call(object) : value;
                }
                return object;
              }
              /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }
              /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
              function setWith(object, path, value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return object == null ? object : baseSet(object, path, value, customizer);
              }
              /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
              var toPairs = createToPairs(keys);
              /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
              var toPairsIn = createToPairs(keysIn);
              /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
              function transform(object, iteratee, accumulator) {
                var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                iteratee = getIteratee(iteratee, 4);
                if (accumulator == null) {
                  var Ctor = object && object.constructor;
                  if (isArrLike) {
                    accumulator = isArr ? new Ctor() : [];
                  } else if (isObject(object)) {
                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                  } else {
                    accumulator = {};
                  }
                }
                (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
                  return iteratee(accumulator, value, index, object);
                });
                return accumulator;
              }
              /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }
              /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
              function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction(updater));
              }
              /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
              function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
              }
              /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
              function values(object) {
                return object == null ? [] : baseValues(object, keys(object));
              }
              /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
              }
              /*------------------------------------------------------------------------*/
              /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
              function clamp(number, lower, upper) {
                if (upper === undefined) {
                  upper = lower;
                  lower = undefined;
                }
                if (upper !== undefined) {
                  upper = toNumber(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined) {
                  lower = toNumber(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number), lower, upper);
              }
              /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber(number);
                return baseInRange(number, start, end);
              }
              /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
              function random(lower, upper, floating) {
                if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                  upper = floating = undefined;
                }
                if (floating === undefined) {
                  if (typeof upper == 'boolean') {
                    floating = upper;
                    upper = undefined;
                  } else if (typeof lower == 'boolean') {
                    floating = lower;
                    lower = undefined;
                  }
                }
                if (lower === undefined && upper === undefined) {
                  lower = 0;
                  upper = 1;
                } else {
                  lower = toFinite(lower);
                  if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
                }
                return baseRandom(lower, upper);
              }
              /*------------------------------------------------------------------------*/
              /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
              var camelCase = createCompounder(function (result, word, index) {
                  word = word.toLowerCase();
                  return result + (index ? capitalize(word) : word);
                });
              /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
              function capitalize(string) {
                return upperFirst(toString(string).toLowerCase());
              }
              /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
              function deburr(string) {
                string = toString(string);
                return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
              }
              /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
              function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);
                var length = string.length;
                position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                var end = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end) == target;
              }
              /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
              function escape(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
              }
              /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
              function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
              }
              /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
              var kebabCase = createCompounder(function (result, word, index) {
                  return result + (index ? '-' : '') + word.toLowerCase();
                });
              /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
              var lowerCase = createCompounder(function (result, word, index) {
                  return result + (index ? ' ' : '') + word.toLowerCase();
                });
              /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
              var lowerFirst = createCaseFirst('toLowerCase');
              /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
              function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                  return string;
                }
                var mid = (length - strLength) / 2;
                return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
              }
              /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
              function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
              }
              /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
              function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
              }
              /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
              function parseInt(string, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
              }
              /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
              function repeat(string, n, guard) {
                if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString(string), n);
              }
              /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
              function replace() {
                var args = arguments, string = toString(args[0]);
                return args.length < 3 ? string : string.replace(args[1], args[2]);
              }
              /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
              var snakeCase = createCompounder(function (result, word, index) {
                  return result + (index ? '_' : '') + word.toLowerCase();
                });
              /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
              function split(string, separator, limit) {
                if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                  separator = limit = undefined;
                }
                limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string = toString(string);
                if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
                  separator = baseToString(separator);
                  if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                  }
                }
                return string.split(separator, limit);
              }
              /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
              var startCase = createCompounder(function (result, word, index) {
                  return result + (index ? ' ' : '') + upperFirst(word);
                });
              /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
              function startsWith(string, target, position) {
                string = toString(string);
                position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                target = baseToString(target);
                return string.slice(position, position + target.length) == target;
              }
              /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
              function template(string, options, guard) {
                // Based on John Resig's `tmpl` implementation
                // (http://ejohn.org/blog/javascript-micro-templating/)
                // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                var settings = lodash.templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                  options = undefined;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);
                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
                // Compile the regexp to match each delimiter.
                var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
                // Use a sourceURL for easier debugging.
                var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
                string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  // Escape characters that can't be included in string literals.
                  source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                  // Replace delimiters with snippets.
                  if (escapeValue) {
                    isEscaping = true;
                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                  }
                  if (interpolateValue) {
                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                  }
                  index = offset + match.length;
                  // The JS engine embedded in Adobe products needs `match` returned in
                  // order to produce the correct `offset` value.
                  return match;
                });
                source += '\';\n';
                // If `variable` is not specified wrap a with-statement around the generated
                // code to add the data object to the top of the scope chain.
                var variable = options.variable;
                if (!variable) {
                  source = 'with (obj) {\n' + source + '\n}\n';
                }
                // Cleanup code by stripping empty strings.
                source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
                // Frame code as the function body.
                source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + 'var __t, __p = \'\'' + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
                var result = attempt(function () {
                    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
                  });
                // Provide the compiled function's source by its `toString` method or
                // the `source` property as a convenience for inlining compiled templates.
                result.source = source;
                if (isError(result)) {
                  throw result;
                }
                return result;
              }
              /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
              function toLower(value) {
                return toString(value).toLowerCase();
              }
              /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
              function toUpper(value) {
                return toString(value).toUpperCase();
              }
              /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
              function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrim, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start, end).join('');
              }
              /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
              function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimEnd, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                return castSlice(strSymbols, 0, end).join('');
              }
              /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
              function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimStart, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                return castSlice(strSymbols, start).join('');
              }
              /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
              function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                if (isObject(options)) {
                  var separator = 'separator' in options ? options.separator : separator;
                  length = 'length' in options ? toInteger(options.length) : length;
                  omission = 'omission' in options ? baseToString(options.omission) : omission;
                }
                string = toString(string);
                var strLength = string.length;
                if (hasUnicode(string)) {
                  var strSymbols = stringToArray(string);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
                if (separator === undefined) {
                  return result + omission;
                }
                if (strSymbols) {
                  end += result.length - end;
                }
                if (isRegExp(separator)) {
                  if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    if (!separator.global) {
                      separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                      var newEnd = match.index;
                    }
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                  }
                } else if (string.indexOf(baseToString(separator), end) != end) {
                  var index = result.lastIndexOf(separator);
                  if (index > -1) {
                    result = result.slice(0, index);
                  }
                }
                return result + omission;
              }
              /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
              function unescape(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
              }
              /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
              var upperCase = createCompounder(function (result, word, index) {
                  return result + (index ? ' ' : '') + word.toUpperCase();
                });
              /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
              var upperFirst = createCaseFirst('toUpperCase');
              /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
              function words(string, pattern, guard) {
                string = toString(string);
                pattern = guard ? undefined : pattern;
                if (pattern === undefined) {
                  return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                }
                return string.match(pattern) || [];
              }
              /*------------------------------------------------------------------------*/
              /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
              var attempt = baseRest(function (func, args) {
                  try {
                    return apply(func, undefined, args);
                  } catch (e) {
                    return isError(e) ? e : new Error(e);
                  }
                });
              /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
              var bindAll = flatRest(function (object, methodNames) {
                  arrayEach(methodNames, function (key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                  });
                  return object;
                });
              /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
              function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                pairs = !length ? [] : arrayMap(pairs, function (pair) {
                  if (typeof pair[1] != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return [
                    toIteratee(pair[0]),
                    pair[1]
                  ];
                });
                return baseRest(function (args) {
                  var index = -1;
                  while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) {
                      return apply(pair[1], this, args);
                    }
                  }
                });
              }
              /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
              function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
              }
              /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
              function constant(value) {
                return function () {
                  return value;
                };
              }
              /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }
              /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
              var flow = createFlow();
              /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
              var flowRight = createFlow(true);
              /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
              function identity(value) {
                return value;
              }
              /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
              function iteratee(func) {
                return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
              }
              /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
              function matches(source) {
                return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
              }
              /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
              }
              /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
              var method = baseRest(function (path, args) {
                  return function (object) {
                    return baseInvoke(object, path, args);
                  };
                });
              /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
              var methodOf = baseRest(function (object, args) {
                  return function (path) {
                    return baseInvoke(object, path, args);
                  };
                });
              /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
              function mixin(object, source, options) {
                var props = keys(source), methodNames = baseFunctions(source, props);
                if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys(source));
                }
                var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
                arrayEach(methodNames, function (methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function () {
                      var chainAll = this.__chain__;
                      if (chain || chainAll) {
                        var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                        actions.push({
                          'func': func,
                          'args': arguments,
                          'thisArg': object
                        });
                        result.__chain__ = chainAll;
                        return result;
                      }
                      return func.apply(object, arrayPush([this.value()], arguments));
                    };
                  }
                });
                return object;
              }
              /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
              function noConflict() {
                if (root._ === this) {
                  root._ = oldDash;
                }
                return this;
              }
              /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
              function noop() {
              }
              // No operation performed.
              /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
              function nthArg(n) {
                n = toInteger(n);
                return baseRest(function (args) {
                  return baseNth(args, n);
                });
              }
              /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
              var over = createOver(arrayMap);
              /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
              var overEvery = createOver(arrayEvery);
              /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
              var overSome = createOver(arraySome);
              /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
              function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
              }
              /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
              function propertyOf(object) {
                return function (path) {
                  return object == null ? undefined : baseGet(object, path);
                };
              }
              /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
              var range = createRange();
              /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
              var rangeRight = createRange(true);
              /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
              function stubArray() {
                return [];
              }
              /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
              function stubFalse() {
                return false;
              }
              /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
              function stubObject() {
                return {};
              }
              /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
              function stubString() {
                return '';
              }
              /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
              function stubTrue() {
                return true;
              }
              /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
              function times(n, iteratee) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER) {
                  return [];
                }
                var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                iteratee = getIteratee(iteratee);
                n -= MAX_ARRAY_LENGTH;
                var result = baseTimes(length, iteratee);
                while (++index < n) {
                  iteratee(index);
                }
                return result;
              }
              /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
              function toPath(value) {
                if (isArray(value)) {
                  return arrayMap(value, toKey);
                }
                return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
              }
              /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
              function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
              }
              /*------------------------------------------------------------------------*/
              /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
              var add = createMathOperation(function (augend, addend) {
                  return augend + addend;
                }, 0);
              /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
              var ceil = createRound('ceil');
              /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
              var divide = createMathOperation(function (dividend, divisor) {
                  return dividend / divisor;
                }, 1);
              /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
              var floor = createRound('floor');
              /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
              function max(array) {
                return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
              }
              /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
              function maxBy(array, iteratee) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
              }
              /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
              function mean(array) {
                return baseMean(array, identity);
              }
              /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
              function meanBy(array, iteratee) {
                return baseMean(array, getIteratee(iteratee, 2));
              }
              /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
              function min(array) {
                return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
              }
              /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
              function minBy(array, iteratee) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
              }
              /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
              var multiply = createMathOperation(function (multiplier, multiplicand) {
                  return multiplier * multiplicand;
                }, 1);
              /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
              var round = createRound('round');
              /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
              var subtract = createMathOperation(function (minuend, subtrahend) {
                  return minuend - subtrahend;
                }, 0);
              /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
              function sum(array) {
                return array && array.length ? baseSum(array, identity) : 0;
              }
              /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
              function sumBy(array, iteratee) {
                return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
              }
              /*------------------------------------------------------------------------*/
              // Add methods that return wrapped values in chain sequences.
              lodash.after = after;
              lodash.ary = ary;
              lodash.assign = assign;
              lodash.assignIn = assignIn;
              lodash.assignInWith = assignInWith;
              lodash.assignWith = assignWith;
              lodash.at = at;
              lodash.before = before;
              lodash.bind = bind;
              lodash.bindAll = bindAll;
              lodash.bindKey = bindKey;
              lodash.castArray = castArray;
              lodash.chain = chain;
              lodash.chunk = chunk;
              lodash.compact = compact;
              lodash.concat = concat;
              lodash.cond = cond;
              lodash.conforms = conforms;
              lodash.constant = constant;
              lodash.countBy = countBy;
              lodash.create = create;
              lodash.curry = curry;
              lodash.curryRight = curryRight;
              lodash.debounce = debounce;
              lodash.defaults = defaults;
              lodash.defaultsDeep = defaultsDeep;
              lodash.defer = defer;
              lodash.delay = delay;
              lodash.difference = difference;
              lodash.differenceBy = differenceBy;
              lodash.differenceWith = differenceWith;
              lodash.drop = drop;
              lodash.dropRight = dropRight;
              lodash.dropRightWhile = dropRightWhile;
              lodash.dropWhile = dropWhile;
              lodash.fill = fill;
              lodash.filter = filter;
              lodash.flatMap = flatMap;
              lodash.flatMapDeep = flatMapDeep;
              lodash.flatMapDepth = flatMapDepth;
              lodash.flatten = flatten;
              lodash.flattenDeep = flattenDeep;
              lodash.flattenDepth = flattenDepth;
              lodash.flip = flip;
              lodash.flow = flow;
              lodash.flowRight = flowRight;
              lodash.fromPairs = fromPairs;
              lodash.functions = functions;
              lodash.functionsIn = functionsIn;
              lodash.groupBy = groupBy;
              lodash.initial = initial;
              lodash.intersection = intersection;
              lodash.intersectionBy = intersectionBy;
              lodash.intersectionWith = intersectionWith;
              lodash.invert = invert;
              lodash.invertBy = invertBy;
              lodash.invokeMap = invokeMap;
              lodash.iteratee = iteratee;
              lodash.keyBy = keyBy;
              lodash.keys = keys;
              lodash.keysIn = keysIn;
              lodash.map = map;
              lodash.mapKeys = mapKeys;
              lodash.mapValues = mapValues;
              lodash.matches = matches;
              lodash.matchesProperty = matchesProperty;
              lodash.memoize = memoize;
              lodash.merge = merge;
              lodash.mergeWith = mergeWith;
              lodash.method = method;
              lodash.methodOf = methodOf;
              lodash.mixin = mixin;
              lodash.negate = negate;
              lodash.nthArg = nthArg;
              lodash.omit = omit;
              lodash.omitBy = omitBy;
              lodash.once = once;
              lodash.orderBy = orderBy;
              lodash.over = over;
              lodash.overArgs = overArgs;
              lodash.overEvery = overEvery;
              lodash.overSome = overSome;
              lodash.partial = partial;
              lodash.partialRight = partialRight;
              lodash.partition = partition;
              lodash.pick = pick;
              lodash.pickBy = pickBy;
              lodash.property = property;
              lodash.propertyOf = propertyOf;
              lodash.pull = pull;
              lodash.pullAll = pullAll;
              lodash.pullAllBy = pullAllBy;
              lodash.pullAllWith = pullAllWith;
              lodash.pullAt = pullAt;
              lodash.range = range;
              lodash.rangeRight = rangeRight;
              lodash.rearg = rearg;
              lodash.reject = reject;
              lodash.remove = remove;
              lodash.rest = rest;
              lodash.reverse = reverse;
              lodash.sampleSize = sampleSize;
              lodash.set = set;
              lodash.setWith = setWith;
              lodash.shuffle = shuffle;
              lodash.slice = slice;
              lodash.sortBy = sortBy;
              lodash.sortedUniq = sortedUniq;
              lodash.sortedUniqBy = sortedUniqBy;
              lodash.split = split;
              lodash.spread = spread;
              lodash.tail = tail;
              lodash.take = take;
              lodash.takeRight = takeRight;
              lodash.takeRightWhile = takeRightWhile;
              lodash.takeWhile = takeWhile;
              lodash.tap = tap;
              lodash.throttle = throttle;
              lodash.thru = thru;
              lodash.toArray = toArray;
              lodash.toPairs = toPairs;
              lodash.toPairsIn = toPairsIn;
              lodash.toPath = toPath;
              lodash.toPlainObject = toPlainObject;
              lodash.transform = transform;
              lodash.unary = unary;
              lodash.union = union;
              lodash.unionBy = unionBy;
              lodash.unionWith = unionWith;
              lodash.uniq = uniq;
              lodash.uniqBy = uniqBy;
              lodash.uniqWith = uniqWith;
              lodash.unset = unset;
              lodash.unzip = unzip;
              lodash.unzipWith = unzipWith;
              lodash.update = update;
              lodash.updateWith = updateWith;
              lodash.values = values;
              lodash.valuesIn = valuesIn;
              lodash.without = without;
              lodash.words = words;
              lodash.wrap = wrap;
              lodash.xor = xor;
              lodash.xorBy = xorBy;
              lodash.xorWith = xorWith;
              lodash.zip = zip;
              lodash.zipObject = zipObject;
              lodash.zipObjectDeep = zipObjectDeep;
              lodash.zipWith = zipWith;
              // Add aliases.
              lodash.entries = toPairs;
              lodash.entriesIn = toPairsIn;
              lodash.extend = assignIn;
              lodash.extendWith = assignInWith;
              // Add methods to `lodash.prototype`.
              mixin(lodash, lodash);
              /*------------------------------------------------------------------------*/
              // Add methods that return unwrapped values in chain sequences.
              lodash.add = add;
              lodash.attempt = attempt;
              lodash.camelCase = camelCase;
              lodash.capitalize = capitalize;
              lodash.ceil = ceil;
              lodash.clamp = clamp;
              lodash.clone = clone;
              lodash.cloneDeep = cloneDeep;
              lodash.cloneDeepWith = cloneDeepWith;
              lodash.cloneWith = cloneWith;
              lodash.conformsTo = conformsTo;
              lodash.deburr = deburr;
              lodash.defaultTo = defaultTo;
              lodash.divide = divide;
              lodash.endsWith = endsWith;
              lodash.eq = eq;
              lodash.escape = escape;
              lodash.escapeRegExp = escapeRegExp;
              lodash.every = every;
              lodash.find = find;
              lodash.findIndex = findIndex;
              lodash.findKey = findKey;
              lodash.findLast = findLast;
              lodash.findLastIndex = findLastIndex;
              lodash.findLastKey = findLastKey;
              lodash.floor = floor;
              lodash.forEach = forEach;
              lodash.forEachRight = forEachRight;
              lodash.forIn = forIn;
              lodash.forInRight = forInRight;
              lodash.forOwn = forOwn;
              lodash.forOwnRight = forOwnRight;
              lodash.get = get;
              lodash.gt = gt;
              lodash.gte = gte;
              lodash.has = has;
              lodash.hasIn = hasIn;
              lodash.head = head;
              lodash.identity = identity;
              lodash.includes = includes;
              lodash.indexOf = indexOf;
              lodash.inRange = inRange;
              lodash.invoke = invoke;
              lodash.isArguments = isArguments;
              lodash.isArray = isArray;
              lodash.isArrayBuffer = isArrayBuffer;
              lodash.isArrayLike = isArrayLike;
              lodash.isArrayLikeObject = isArrayLikeObject;
              lodash.isBoolean = isBoolean;
              lodash.isBuffer = isBuffer;
              lodash.isDate = isDate;
              lodash.isElement = isElement;
              lodash.isEmpty = isEmpty;
              lodash.isEqual = isEqual;
              lodash.isEqualWith = isEqualWith;
              lodash.isError = isError;
              lodash.isFinite = isFinite;
              lodash.isFunction = isFunction;
              lodash.isInteger = isInteger;
              lodash.isLength = isLength;
              lodash.isMap = isMap;
              lodash.isMatch = isMatch;
              lodash.isMatchWith = isMatchWith;
              lodash.isNaN = isNaN;
              lodash.isNative = isNative;
              lodash.isNil = isNil;
              lodash.isNull = isNull;
              lodash.isNumber = isNumber;
              lodash.isObject = isObject;
              lodash.isObjectLike = isObjectLike;
              lodash.isPlainObject = isPlainObject;
              lodash.isRegExp = isRegExp;
              lodash.isSafeInteger = isSafeInteger;
              lodash.isSet = isSet;
              lodash.isString = isString;
              lodash.isSymbol = isSymbol;
              lodash.isTypedArray = isTypedArray;
              lodash.isUndefined = isUndefined;
              lodash.isWeakMap = isWeakMap;
              lodash.isWeakSet = isWeakSet;
              lodash.join = join;
              lodash.kebabCase = kebabCase;
              lodash.last = last;
              lodash.lastIndexOf = lastIndexOf;
              lodash.lowerCase = lowerCase;
              lodash.lowerFirst = lowerFirst;
              lodash.lt = lt;
              lodash.lte = lte;
              lodash.max = max;
              lodash.maxBy = maxBy;
              lodash.mean = mean;
              lodash.meanBy = meanBy;
              lodash.min = min;
              lodash.minBy = minBy;
              lodash.stubArray = stubArray;
              lodash.stubFalse = stubFalse;
              lodash.stubObject = stubObject;
              lodash.stubString = stubString;
              lodash.stubTrue = stubTrue;
              lodash.multiply = multiply;
              lodash.nth = nth;
              lodash.noConflict = noConflict;
              lodash.noop = noop;
              lodash.now = now;
              lodash.pad = pad;
              lodash.padEnd = padEnd;
              lodash.padStart = padStart;
              lodash.parseInt = parseInt;
              lodash.random = random;
              lodash.reduce = reduce;
              lodash.reduceRight = reduceRight;
              lodash.repeat = repeat;
              lodash.replace = replace;
              lodash.result = result;
              lodash.round = round;
              lodash.runInContext = runInContext;
              lodash.sample = sample;
              lodash.size = size;
              lodash.snakeCase = snakeCase;
              lodash.some = some;
              lodash.sortedIndex = sortedIndex;
              lodash.sortedIndexBy = sortedIndexBy;
              lodash.sortedIndexOf = sortedIndexOf;
              lodash.sortedLastIndex = sortedLastIndex;
              lodash.sortedLastIndexBy = sortedLastIndexBy;
              lodash.sortedLastIndexOf = sortedLastIndexOf;
              lodash.startCase = startCase;
              lodash.startsWith = startsWith;
              lodash.subtract = subtract;
              lodash.sum = sum;
              lodash.sumBy = sumBy;
              lodash.template = template;
              lodash.times = times;
              lodash.toFinite = toFinite;
              lodash.toInteger = toInteger;
              lodash.toLength = toLength;
              lodash.toLower = toLower;
              lodash.toNumber = toNumber;
              lodash.toSafeInteger = toSafeInteger;
              lodash.toString = toString;
              lodash.toUpper = toUpper;
              lodash.trim = trim;
              lodash.trimEnd = trimEnd;
              lodash.trimStart = trimStart;
              lodash.truncate = truncate;
              lodash.unescape = unescape;
              lodash.uniqueId = uniqueId;
              lodash.upperCase = upperCase;
              lodash.upperFirst = upperFirst;
              // Add aliases.
              lodash.each = forEach;
              lodash.eachRight = forEachRight;
              lodash.first = head;
              mixin(lodash, function () {
                var source = {};
                baseForOwn(lodash, function (func, methodName) {
                  if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                    source[methodName] = func;
                  }
                });
                return source;
              }(), { 'chain': false });
              /*------------------------------------------------------------------------*/
              /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
              lodash.VERSION = VERSION;
              // Assign default placeholders.
              arrayEach([
                'bind',
                'bindKey',
                'curry',
                'curryRight',
                'partial',
                'partialRight'
              ], function (methodName) {
                lodash[methodName].placeholder = lodash;
              });
              // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
              arrayEach([
                'drop',
                'take'
              ], function (methodName, index) {
                LazyWrapper.prototype[methodName] = function (n) {
                  n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                  var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                  if (result.__filtered__) {
                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                  } else {
                    result.__views__.push({
                      'size': nativeMin(n, MAX_ARRAY_LENGTH),
                      'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                    });
                  }
                  return result;
                };
                LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                  return this.reverse()[methodName](n).reverse();
                };
              });
              // Add `LazyWrapper` methods that accept an `iteratee` value.
              arrayEach([
                'filter',
                'map',
                'takeWhile'
              ], function (methodName, index) {
                var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function (iteratee) {
                  var result = this.clone();
                  result.__iteratees__.push({
                    'iteratee': getIteratee(iteratee, 3),
                    'type': type
                  });
                  result.__filtered__ = result.__filtered__ || isFilter;
                  return result;
                };
              });
              // Add `LazyWrapper` methods for `_.head` and `_.last`.
              arrayEach([
                'head',
                'last'
              ], function (methodName, index) {
                var takeName = 'take' + (index ? 'Right' : '');
                LazyWrapper.prototype[methodName] = function () {
                  return this[takeName](1).value()[0];
                };
              });
              // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
              arrayEach([
                'initial',
                'tail'
              ], function (methodName, index) {
                var dropName = 'drop' + (index ? '' : 'Right');
                LazyWrapper.prototype[methodName] = function () {
                  return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
              });
              LazyWrapper.prototype.compact = function () {
                return this.filter(identity);
              };
              LazyWrapper.prototype.find = function (predicate) {
                return this.filter(predicate).head();
              };
              LazyWrapper.prototype.findLast = function (predicate) {
                return this.reverse().find(predicate);
              };
              LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
                if (typeof path == 'function') {
                  return new LazyWrapper(this);
                }
                return this.map(function (value) {
                  return baseInvoke(value, path, args);
                });
              });
              LazyWrapper.prototype.reject = function (predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };
              LazyWrapper.prototype.slice = function (start, end) {
                start = toInteger(start);
                var result = this;
                if (result.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result);
                }
                if (start < 0) {
                  result = result.takeRight(-start);
                } else if (start) {
                  result = result.drop(start);
                }
                if (end !== undefined) {
                  end = toInteger(end);
                  result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                }
                return result;
              };
              LazyWrapper.prototype.takeRightWhile = function (predicate) {
                return this.reverse().takeWhile(predicate).reverse();
              };
              LazyWrapper.prototype.toArray = function () {
                return this.take(MAX_ARRAY_LENGTH);
              };
              // Add `LazyWrapper` methods to `lodash.prototype`.
              baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                  return;
                }
                lodash.prototype[methodName] = function () {
                  var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                  var interceptor = function interceptor(value) {
                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                    return isTaker && chainAll ? result[0] : result;
                  };
                  if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                    // Avoid lazy use if the iteratee has a "length" value other than `1`.
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({
                      'func': thru,
                      'args': [interceptor],
                      'thisArg': undefined
                    });
                    return new LodashWrapper(result, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result = this.thru(interceptor);
                  return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
                };
              });
              // Add `Array` methods to `lodash.prototype`.
              arrayEach([
                'pop',
                'push',
                'shift',
                'sort',
                'splice',
                'unshift'
              ], function (methodName) {
                var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                lodash.prototype[methodName] = function () {
                  var args = arguments;
                  if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                  }
                  return this[chainName](function (value) {
                    return func.apply(isArray(value) ? value : [], args);
                  });
                };
              });
              // Map minified method names to their real names.
              baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                var lodashFunc = lodash[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + '', names = realNames[key] || (realNames[key] = []);
                  names.push({
                    'name': methodName,
                    'func': lodashFunc
                  });
                }
              });
              realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                  'name': 'wrapper',
                  'func': undefined
                }];
              // Add methods to `LazyWrapper`.
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;
              // Add chain sequence methods to the `lodash` wrapper.
              lodash.prototype.at = wrapperAt;
              lodash.prototype.chain = wrapperChain;
              lodash.prototype.commit = wrapperCommit;
              lodash.prototype.next = wrapperNext;
              lodash.prototype.plant = wrapperPlant;
              lodash.prototype.reverse = wrapperReverse;
              lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
              // Add lazy aliases.
              lodash.prototype.first = lodash.prototype.head;
              if (symIterator) {
                lodash.prototype[symIterator] = wrapperToIterator;
              }
              return lodash;
            };
            /*--------------------------------------------------------------------------*/
            // Export lodash.
            var _ = runInContext();
            // Some AMD build optimizers, like r.js, check for condition patterns like:
            if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
              // Expose Lodash on the global object to prevent errors when Lodash is
              // loaded by a script tag in the presence of an AMD loader.
              // See http://requirejs.org/docs/errors.html#mismatch for more details.
              // Use `_.noConflict` to remove Lodash from the global object.
              root._ = _;
              // Define as an anonymous module so, through path mapping, it can be
              // referenced as the "underscore" module.
              define(function () {
                return _;
              });
            }  // Check for `exports` after `define` in case a build optimizer adds it.
            else if (freeModule) {
              // Export for Node.js.
              (freeModule.exports = _)._ = _;
              // Export for CommonJS support.
              freeExports._ = _;
            } else {
              // Export to the global object.
              root._ = _;
            }
          }.call(undefined));
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    80: [
      function (require, module, exports) {
        'use strict';
        /**
 * Helpers.
 */
        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;
        /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */
        module.exports = function (val, options) {
          options = options || {};
          if ('string' == typeof val)
            return parse(val);
          return options.long ? long(val) : short(val);
        };
        /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */
        function parse(str) {
          str = '' + str;
          if (str.length > 10000)
            return;
          var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
          if (!match)
            return;
          var n = parseFloat(match[1]);
          var type = (match[2] || 'ms').toLowerCase();
          switch (type) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;
          }
        }
        /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function short(ms) {
          if (ms >= d)
            return Math.round(ms / d) + 'd';
          if (ms >= h)
            return Math.round(ms / h) + 'h';
          if (ms >= m)
            return Math.round(ms / m) + 'm';
          if (ms >= s)
            return Math.round(ms / s) + 's';
          return ms + 'ms';
        }
        /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function long(ms) {
          return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
        }
        /**
 * Pluralization helper.
 */
        function plural(ms, n, name) {
          if (ms < n)
            return;
          if (ms < n * 1.5)
            return Math.floor(ms / n) + ' ' + name;
          return Math.ceil(ms / n) + ' ' + name + 's';
        }
      },
      {}
    ],
    81: [
      function (require, module, exports) {
        'use strict';
        var converter = require('./lib/converter'), Importer = require('./lib/importers/index'), Exporter = require('./lib/exporters/index'), Formats = require('./lib/formats');
        module.exports = {
          Converter: converter.Converter,
          Formats: Formats,
          Importer: Importer,
          Exporter: Exporter
        };
      },
      {
        './lib/converter': 82,
        './lib/exporters/index': 92,
        './lib/formats': 96,
        './lib/importers/index': 102
      }
    ],
    82: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Importers = require('./importers/index');
        var Exporters = require('./exporters/index');
        var Converter = function () {
            function Converter(fromFormat, toFormat) {
              _classCallCheck(this, Converter);
              this.importer = Importers.factory(fromFormat);
              if (!this.importer) {
                throw new Error('from format ' + fromFormat.name + ' not supported');
              }
              this.importer.type = fromFormat;
              this.exporter = Exporters.factory(toFormat);
              if (!this.exporter) {
                throw new Error('to format ' + toFormat.name + ' not supported');
              }
              this.exporter.type = toFormat;
              this.format = this.exporter.type.formats[0];
            }
            _createClass(Converter, [
              {
                key: 'convertFile',
                value: function convertFile(file, options) {
                  var _this = this;
                  return new Promise(function (resolve, reject) {
                    _this.loadFile(file, options).then(function () {
                      _this.convert(_this._format(options), options).then(resolve).catch(reject);
                    }).catch(reject);
                  });
                }
              },
              {
                key: 'convertData',
                value: function convertData(json, options) {
                  var _this2 = this;
                  return new Promise(function (resolve, reject) {
                    _this2.loadData(json, options).then(function () {
                      _this2.convert(_this2._format(options), options).then(resolve).catch(reject);
                    }).catch(reject);
                  });
                }
              },
              {
                key: 'loadFile',
                value: function loadFile(filePath, options) {
                  return this.importer.loadFile(filePath, options);
                }
              },
              {
                key: 'loadData',
                value: function loadData(rawData, options) {
                  var _this3 = this;
                  return new Promise(function (resolve, reject) {
                    _this3.importer.loadData(rawData, options).then(resolve).catch(reject);
                  });
                }
              },
              {
                key: 'convert',
                value: function convert(format, options) {
                  var _this4 = this;
                  return new Promise(function (resolve, reject) {
                    try {
                      _this4.exporter.loadProject(_this4.importer.import());
                      _this4.exporter.export(format, options).then(resolve).catch(reject);
                    } catch (e) {
                      reject(e);
                    }
                  });
                }
              },
              {
                key: '_format',
                value: function _format(options) {
                  return options && options.format || this.format;
                }
              }
            ]);
            return Converter;
          }();
        exports.Converter = Converter;
      },
      {
        './exporters/index': 92,
        './importers/index': 102
      }
    ],
    83: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Endpoint = function () {
            function Endpoint(name) {
              _classCallCheck(this, Endpoint);
              this._id = null;
              this.name = name;
              this.description = '';
              this.tags = [];
              this.request = {};
              this.request.pathParams = {};
              this.request.bodies = [];
              this.request.headers = '{}';
              this.responses = [];
              this.produces;
              this.consumes;
              this.middlewareBefore = '';
              this.middlewareAfter = '';
              // this.securedBy = {
              // 	none: true
              // };
              this.public = true;
              this.deprecated = null;
              this.externalDocs = null;
            }
            _createClass(Endpoint, [
              {
                key: 'SetOperationId',
                value: function SetOperationId(operationId) {
                  if (operationId)
                    this.operationId = operationId;
                }
              },
              {
                key: 'Id',
                get: function get() {
                  return this._id;
                },
                set: function set(id) {
                  this._id = id;
                }
              },
              {
                key: 'Path',
                get: function get() {
                  return this.request.path;
                },
                set: function set(path) {
                  this.request.path = path;
                }
              },
              {
                key: 'Method',
                get: function get() {
                  return this.request.method;
                },
                set: function set(requestMethod) {
                  this.request.method = requestMethod.toLowerCase();
                }
              },
              {
                key: 'Name',
                set: function set(name) {
                  if (!name) {
                    return;
                  }
                  if (name.length > 120) {
                    this.name = name.substring(0, 119);
                  } else {
                    this.name = name;
                  }
                },
                get: function get() {
                  return this.name || '';
                }
              },
              {
                key: 'Consumes',
                get: function get() {
                  return this.consumes;
                },
                set: function set(consumes) {
                  this.consumes = consumes;
                }
              },
              {
                key: 'Produces',
                get: function get() {
                  return this.produces;
                },
                set: function set(produces) {
                  this.produces = produces;
                }
              },
              {
                key: 'Headers',
                get: function get() {
                  return this.request.headers;
                },
                set: function set(headers) {
                  this.request.headers = headers;
                }
              },
              {
                key: 'Before',
                get: function get() {
                  return this.middlewareBefore;
                },
                set: function set(before) {
                  this.middlewareBefore = before;
                }
              },
              {
                key: 'After',
                get: function get() {
                  return this.middlewareAfter;
                },
                set: function set(after) {
                  this.middlewareAfter = after;
                }
              },
              {
                key: 'Body',
                set: function set(body) {
                  this.request.bodies.push(body);
                },
                get: function get() {
                  if (Array.isArray(this.request.bodies) && this.request.bodies.length > 0) {
                    return this.request.bodies;
                  }
                  return {};
                }
              },
              {
                key: 'QueryString',
                set: function set(queryString) {
                  this.request.queryString = queryString;
                },
                get: function get() {
                  if (!this.request.queryString) {
                    this.request.queryString = {};
                  }
                  return this.request.queryString;
                }
              },
              {
                key: 'PathParams',
                set: function set(uriParams) {
                  this.request.pathParams = uriParams;
                },
                get: function get() {
                  if (!this.request.pathParams) {
                    this.request.pathParams = {};
                  }
                  return this.request.pathParams;
                }
              },
              {
                key: 'Responses',
                set: function set(res) {
                  this.responses = res;
                },
                get: function get() {
                  return this.responses;
                }
              },
              {
                key: 'SLData',
                set: function set(data) {
                  for (var key in data) {
                    if (!data.hasOwnProperty(key))
                      continue;
                    this[key] = data[key];
                  }
                }
              },
              {
                key: 'Description',
                set: function set(desc) {
                  this.description = desc;
                },
                get: function get() {
                  return this.description || '';
                }
              },
              {
                key: 'Tags',
                get: function get() {
                  return this.tags;
                },
                set: function set(tags) {
                  this.tags = tags;
                }
              },
              {
                key: 'Summary',
                set: function set(desc) {
                  this.summary = desc;
                },
                get: function get() {
                  return this.summary || '';
                }
              },
              {
                key: 'SecuredBy',
                set: function set(security) {
                  this.securedBy = security;
                },
                get: function get() {
                  return this.securedBy;
                }  // get Request() {
                   // 	return this.request;
                   // };
              },
              {
                key: 'Public',
                get: function get() {
                  return this.public;
                },
                set: function set(p) {
                  this.public = p;
                }
              },
              {
                key: 'Deprecated',
                get: function get() {
                  return this.deprecated;
                },
                set: function set(deprecated) {
                  this.deprecated = deprecated;
                }
              },
              {
                key: 'ExternalDocs',
                get: function get() {
                  return this.externalDocs;
                },
                set: function set(externalDocs) {
                  this.externalDocs = externalDocs;
                }
              }
            ]);
            return Endpoint;
          }();
        module.exports = Endpoint;
      },
      {}
    ],
    84: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Environment = function () {
            function Environment() {
              _classCallCheck(this, Environment);
              this.summary = '';
              this.forwardHost = null;
              this.basePath = '';
              this.protocols = [];
              this.version = '';
              this.produces = null;
              this.consumes = null;
              this.middlewareBefore = '';
              this.middlewareAfter = '';
              this.proxy = {};
              this.securitySchemes = {};
              this.resourcesOrder = {
                utilFuncs: [],
                docs: [],
                savedEntries: []
              };
            }
            _createClass(Environment, [
              {
                key: 'Host',
                set: function set(host) {
                  this.forwardHost = host;
                },
                get: function get() {
                  return this.forwardHost;
                }
              },
              {
                key: 'BasePath',
                set: function set(basePath) {
                  this.basePath = basePath;
                },
                get: function get() {
                  return this.basePath || '';
                }
              },
              {
                key: 'Consumes',
                set: function set(consumes) {
                  this.consumes = consumes;
                },
                get: function get() {
                  return this.consumes;
                }
              },
              {
                key: 'Produces',
                set: function set(produces) {
                  this.produces = produces;
                },
                get: function get() {
                  return this.produces;
                }
              },
              {
                key: 'Protocols',
                get: function get() {
                  return this.protocols;
                },
                set: function set(protocols) {
                  this.protocols = protocols;
                }
              },
              {
                key: 'Version',
                get: function get() {
                  return this.version || '';
                },
                set: function set(version) {
                  this.version = version;
                }  // set Proxy(proxy) {
                   // 	this.proxy = proxy;
                   // };
                   // get Proxy() {
                   // 	if(this.proxy) {
                   // 		delete this.proxy['sslCert'];
                   // 		delete this.proxy['sslKey'];
                   // 	}
                   // 	return this.proxy;
                   // };
                   // set MiddlewareBefore(before) {
                   // 	this.middlewareBefore = before;
                   // };
                   // get MiddlewareBefore() {
                   // 	return this.middlewareBefore;
                   // };
                   // set MiddlewareAfter(after) {
                   // 	this.middlewareAfter = after;
                   // };
                   // get MiddlewareAfter() {
                   // 	return this.middlewareAfter;
                   // };
              },
              {
                key: 'GroupsOrder',
                set: function set(eo) {
                  this.resourcesOrder = eo;
                },
                get: function get() {
                  return this.resourcesOrder;
                }
              },
              {
                key: 'SecuritySchemes',
                set: function set(schemes) {
                  this.securitySchemes = schemes;
                },
                get: function get() {
                  return this.securitySchemes;
                }  // addSecurityScheme (key, securityScheme) {
                   // 	this.securitySchemes[key] = securityScheme;
                   // };
              }
            ]);
            return Environment;
          }();
        module.exports = Environment;
      },
      {}
    ],
    85: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Environment = require('./environment');
        var Project = function () {
            function Project(name) {
              _classCallCheck(this, Project);
              this.name = name;
              this.description = '';
              this.environment = new Environment();
              this.endpoints = [];
              this.resources = [];
              this.schemas = [];
              this.texts = [];
              this.traits = [];
              this.pathParamsRef = {};
            }
            _createClass(Project, [
              {
                key: 'addResource',
                value: function addResource(resource) {
                  this.resources.push(resource);
                }
              },
              {
                key: 'addEndpoint',
                value: function addEndpoint(endpoint) {
                  this.endpoints.push(endpoint);
                }
              },
              {
                key: 'addSchema',
                value: function addSchema(schema) {
                  this.schemas.push(schema);
                }
              },
              {
                key: 'addText',
                value: function addText(txt) {
                  this.texts.push(txt);
                }
              },
              {
                key: 'addTrait',
                value: function addTrait(trait) {
                  this.traits.push(trait);
                }
              },
              {
                key: 'addPathParamRef',
                value: function addPathParamRef(path, paramName) {
                  this.pathParamsRef[path] = paramName;
                }
              },
              {
                key: 'getPathParamRef',
                value: function getPathParamRef(path) {
                  return this.pathParamsRef[path];
                }
              },
              {
                key: 'Description',
                set: function set(desc) {
                  this.description = desc || '';
                },
                get: function get() {
                  return this.description || '';
                }
              },
              {
                key: 'Name',
                get: function get() {
                  return this.name;
                }
              },
              {
                key: 'Endpoints',
                get: function get() {
                  return this.endpoints;
                },
                set: function set(endpoints) {
                  this.endpoints = endpoints;
                }
              },
              {
                key: 'Resources',
                get: function get() {
                  return this.resources;
                },
                set: function set(resources) {
                  this.resources = resources;
                }
              },
              {
                key: 'Schemas',
                get: function get() {
                  return this.schemas;
                },
                set: function set(schemas) {
                  this.schemas = schemas;
                }
              },
              {
                key: 'Environment',
                get: function get() {
                  return this.environment;
                },
                set: function set(env) {
                  this.environment = env;
                }
              },
              {
                key: 'Texts',
                get: function get() {
                  return this.texts;
                }
              },
              {
                key: 'Traits',
                get: function get() {
                  return this.traits;
                }
              }
            ]);
            return Project;
          }();
        module.exports = Project;
      },
      { './environment': 84 }
    ],
    86: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Schema = function () {
            function Schema(namespace) {
              _classCallCheck(this, Schema);
              this.name = '';
              this.namespace = namespace;
              this.definition = '';
            }
            _createClass(Schema, [
              {
                key: 'Name',
                get: function get() {
                  return this.name;
                },
                set: function set(name) {
                  this.name = name;
                }
              },
              {
                key: 'NameSpace',
                get: function get() {
                  return this.namespace;
                }
              },
              {
                key: 'Definition',
                set: function set(definition) {
                  this.definition = definition;
                },
                get: function get() {
                  return this.definition;
                }
              }
            ]);
            return Schema;
          }();
        module.exports = Schema;
      },
      {}
    ],
    87: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var SwaggerDefinition = function () {
            function SwaggerDefinition(title, description) {
              _classCallCheck(this, SwaggerDefinition);
              this.swagger = '2.0';
              this.info = {
                'version': '',
                'title': title
              };
              if (description) {
                this.info['description'] = description;
              }
              this.host = '';
              this.basePath = '';
              this.schemes = [];
              this.consumes = [];
              this.produces = [];
              this.securityDefinitions = {};
              this.paths = {};
              this.parameters = {};
              this.responses = [];
            }
            _createClass(SwaggerDefinition, [
              {
                key: 'BasePath',
                set: function set(basePath) {
                  if (basePath && basePath.length > 0) {
                    this.basePath = basePath;
                  } else {
                    delete this.basePath;
                  }
                }
              },
              {
                key: 'Host',
                set: function set(host) {
                  if (host && host.length > 0) {
                    this.host = host;
                  } else {
                    delete this.host;
                  }
                }
              }
            ]);
            return SwaggerDefinition;
          }();
        module.exports = SwaggerDefinition;
      },
      {}
    ],
    88: [
      function (require, module, exports) {
        'use strict';
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Method = function Method(method, methodResolved) {
          _classCallCheck(this, Method);
          this.method = method;
          this.methodResolved = methodResolved;
          this.summary = this.method.summary || this.methodResolved.summary;
          this.tags = this.method.tags || this.methodResolved.tags;
          this.description = this.method.description || this.methodResolved.description;
          this.deprecated = this.method.deprecated || this.methodResolved.deprecated;
          this.operationId = this.method.operationId || this.methodResolved.operationId;
          this.externalDocs = this.method.externalDocs || this.methodResolved.externalDocs;
          this.schemes = this.method.schemes || this.methodResolved.schemes;
          this.parameters = this.method.parameters || this.methodResolved.parameters;
          this.consumes = this.method.consumes || this.methodResolved.consumes;
          this.produces = this.method.produces || this.methodResolved.produces;
          this.responses = this.method.responses || this.methodResolved.responses;
          this.security = this.method.security || this.methodResolved.security;
        };
        module.exports = Method;
      },
      {}
    ],
    89: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Text = function () {
            function Text(name) {
              _classCallCheck(this, Text);
              this._id = null;
              this.name = name;
              this.content = '';
              this.public = '';
            }
            _createClass(Text, [
              {
                key: 'Id',
                get: function get() {
                  return this._id;
                },
                set: function set(id) {
                  this._id = id;
                }
              },
              {
                key: 'Name',
                get: function get() {
                  return this.name;
                },
                set: function set(name) {
                  this.name = name;
                }
              },
              {
                key: 'Content',
                set: function set(content) {
                  this.content = content;
                },
                get: function get() {
                  return this.content;
                }
              },
              {
                key: 'Public',
                get: function get() {
                  return this.public;
                },
                set: function set(p) {
                  this.public = p;
                }
              }
            ]);
            return Text;
          }();
        module.exports = Text;
      },
      {}
    ],
    90: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var _ = require('lodash'), Exporter = require('./exporter'), ramlHelper = require('../helpers/raml'), stringHelper = require('../utils/strings'), jsonHelper = require('../utils/json'), YAML = require('js-yaml');
        var RAMLDefinition = function () {
            function RAMLDefinition(title, env) {
              _classCallCheck(this, RAMLDefinition);
              this.title = title;
              //TODO anyway to know version?
              this.version = env.Version;
              var baseUri = env.Host + env.BasePath;
              if (baseUri) {
                this.baseUri = baseUri;
              }
              this.mediaType = env.DefaultResponseType || '';
              var protocols = RAMLExporter.mapProtocols(env.Protocols);
              if (!_.isEmpty(protocols)) {
                this.protocols = protocols;
              }
            }
            _createClass(RAMLDefinition, [{
                key: 'addMethod',
                value: function addMethod(resource, methodURIs, methodKey, method, pathParamsRef) {
                  if (!methodURIs)
                    return;
                  if (methodURIs.length <= 0) {
                    //reach the leaf of tree
                    //TODO optional: check same method existence
                    if (!resource.uriParameters) {
                      resource.uriParameters = {};
                    }
                    for (var attrname in method.uriParameters) {
                      if (!method.uriParameters.hasOwnProperty(attrname))
                        continue;
                      //uri not available, so check with displayName, which is same
                      if (resource.displayName) {
                        var isURIParamExist = resource.displayName.split(attrname).length - 1;
                        if (isURIParamExist) {
                          resource.uriParameters[attrname] = method.uriParameters[attrname];
                        }
                      }
                    }
                    delete method.uriParameters;
                    if (_.isEmpty(resource.uriParameters))
                      delete resource.uriParameters;
                    resource[methodKey] = method;
                    if (!_.isEmpty(pathParamsRef)) {
                      var is = [];
                      for (var key in pathParamsRef) {
                        if (!pathParamsRef.hasOwnProperty(key))
                          continue;
                        is.push(_.camelCase(pathParamsRef[key]));
                      }
                      resource.is = is;
                    }
                  } else {
                    var currentURI = '/' + methodURIs[0];
                    if (!resource[currentURI]) {
                      resource[currentURI] = {};
                      if (!_.isEmpty(methodURIs[0])) {
                        resource[currentURI].displayName = methodURIs[0];
                      }  //TODO uriParams?!?
                    }
                    methodURIs.splice(0, 1);
                    this.addMethod(resource[currentURI], methodURIs, methodKey, method, pathParamsRef);
                  }
                }
              }]);
            return RAMLDefinition;
          }();
        var RAMLExporter = function (_Exporter) {
            _inherits(RAMLExporter, _Exporter);
            function RAMLExporter() {
              _classCallCheck(this, RAMLExporter);
              return _possibleConstructorReturn(this, (RAMLExporter.__proto__ || Object.getPrototypeOf(RAMLExporter)).call(this));
            }
            _createClass(RAMLExporter, [
              {
                key: '_mapSecurityScheme',
                value: function _mapSecurityScheme(slSecuritySchemes) {
                  var ramlSecuritySchemes = {};
                  if (slSecuritySchemes.hasOwnProperty('oauth2')) {
                    for (var index in slSecuritySchemes.oauth2) {
                      if (!slSecuritySchemes.oauth2.hasOwnProperty(index))
                        continue;
                      var current = slSecuritySchemes.oauth2[index];
                      var name = current.name || 'oauth2';
                      // missing describedBy
                      ramlSecuritySchemes[name] = {
                        type: 'OAuth 2.0',
                        settings: {
                          authorizationUri: current.authorizationUrl || undefined,
                          accessTokenUri: current.tokenUrl || '',
                          authorizationGrants: this.mapAuthorizationGrants(current.flow)
                        }
                      };
                      if (current.description) {
                        ramlSecuritySchemes[name]['description'] = current.description;
                      }
                      var scopes = [];
                      if (current.scopes && !_.isEmpty(current.scopes)) {
                        for (var _index in current.scopes) {
                          if (!current.scopes.hasOwnProperty(_index))
                            continue;
                          var scope = current.scopes[_index].name;
                          scopes.push(scope);
                        }
                        ramlSecuritySchemes[name]['settings']['scopes'] = scopes;
                      }
                    }
                  }
                  if (slSecuritySchemes.hasOwnProperty('basic')) {
                    for (var _index2 in slSecuritySchemes.basic) {
                      if (!slSecuritySchemes.basic.hasOwnProperty(_index2))
                        continue;
                      var _current = slSecuritySchemes.basic[_index2];
                      var basicName = _current.name;
                      if (basicName) {
                        ramlSecuritySchemes[basicName] = {
                          type: 'Basic Authentication',
                          description: _current.description
                        };
                      }
                    }
                  }
                  if (slSecuritySchemes.hasOwnProperty('apiKey')) {
                    // add header auth
                    if (!_.isEmpty(slSecuritySchemes.apiKey.headers)) {
                      for (var _index3 in slSecuritySchemes.apiKey.headers) {
                        if (!slSecuritySchemes.apiKey.headers.hasOwnProperty(_index3))
                          continue;
                        var _current2 = slSecuritySchemes.apiKey.headers[_index3];
                        var content = { headers: {} };
                        content.headers[_current2.name] = { type: 'string' };
                        if (!_.isEmpty(content)) {
                          ramlSecuritySchemes[_current2.externalName || 'apiKey'] = {
                            type: this.getApiKeyType(),
                            describedBy: content,
                            description: _current2.description
                          };
                        }
                      }
                    }
                    // add query auth
                    if (!_.isEmpty(slSecuritySchemes.apiKey.queryString)) {
                      for (var _index4 in slSecuritySchemes.apiKey.queryString) {
                        if (!slSecuritySchemes.apiKey.queryString.hasOwnProperty(_index4))
                          continue;
                        var _current3 = slSecuritySchemes.apiKey.queryString[_index4];
                        var _content = { queryParameters: {} };
                        _content.queryParameters[_current3.name] = { type: 'string' };
                        if (!_.isEmpty(_content)) {
                          ramlSecuritySchemes[_current3.externalName || 'apiKey'] = {
                            type: this.getApiKeyType(),
                            describedBy: _content,
                            description: _current3.description
                          };
                        }
                      }
                    }
                  }
                  return this.mapSecuritySchemes(ramlSecuritySchemes);
                }
              },
              {
                key: '_mapRequestBody',
                value: function _mapRequestBody(bodyData, mimeType, ramlDef) {
                  var body = {};
                  if (!bodyData.body || mimeType === '')
                    return body;
                  switch (mimeType) {
                  case 'application/json':
                    body[mimeType] = this.mapBody(bodyData, mimeType, ramlDef);
                    this.convertRequiredFromProperties(body[mimeType]);
                    if (bodyData.name) {
                      RAMLExporter._createAnnotation(body[mimeType], 'body-name', bodyData.name, ramlDef);
                    }
                    break;
                  case 'multipart/form-data':
                  case 'application/x-www-form-urlencoded': {
                      var parsedBody = jsonHelper.parse(bodyData.body);
                      body[mimeType] = this.mapRequestBodyForm(this.convertRefFromModel(parsedBody, false, null, ramlDef), ramlDef);
                      break;
                    }
                  default:  //unsuported format
                            //TODO
                  }
                  if (bodyData.description) {
                    body[mimeType].description = bodyData.description;
                  }
                  return body;
                }
              },
              {
                key: '_mapNamedParams',
                value: function _mapNamedParams(params, ramlDef) {
                  if (!params || _.isEmpty(params.properties))
                    return;
                  var newParams = {};
                  var convertedParams = this.convertRefFromModel(params.properties, false, null, ramlDef);
                  for (var key in convertedParams) {
                    if (!convertedParams.hasOwnProperty(key))
                      continue;
                    newParams[key] = ramlHelper.setParameterFields(convertedParams[key], {});
                    if (params.required && params.required.indexOf(key) > -1) {
                      newParams[key].required = true;
                    }
                    newParams[key] = jsonHelper.orderByKeys(newParams[key], [
                      'type',
                      'description'
                    ]);
                  }
                  return RAMLExporter._validateParam(newParams);
                }
              },
              {
                key: '_mapResponseBody',
                value: function _mapResponseBody(responseData, mimeType, ramlDef) {
                  var responses = {};
                  for (var i in responseData) {
                    if (!responseData.hasOwnProperty(i))
                      continue;
                    var resBody = responseData[i];
                    if (!_.isEmpty(resBody.codes)) {
                      var code = resBody.codes[0];
                      if (parseInt(code) == 'NaN' || _.startsWith(code, 'x-')) {
                        continue;
                      }
                      responses[code] = {};
                      var type = mimeType;
                      var body = this.mapBody(resBody, type, ramlDef);
                      this.convertRequiredFromProperties(body);
                      if (!_.isEmpty(body)) {
                        responses[code].body = {};
                        if (type) {
                          responses[code]['body'][type] = body;
                        } else {
                          responses[code]['body'] = body;
                        }
                      }
                      if (resBody.description) {
                        responses[code]['description'] = resBody.description;
                      }
                      if (!jsonHelper.isEmptySchema(resBody.headers)) {
                        responses[code].headers = this._mapNamedParams(resBody.headers, ramlDef);
                      }
                      if (resBody.response_id) {
                        RAMLExporter._createAnnotation(responses[code], 'global-response-definition', resBody.response_id, ramlDef);
                        delete resBody.response_id;
                      }
                    }
                  }
                  return responses;
                }
              },
              {
                key: '_mapURIParams',
                value: function _mapURIParams(pathParamData, ramlDef) {
                  if (!pathParamData.properties || _.isEmpty(pathParamData.properties)) {
                    return;
                  }
                  var pathParams = {};
                  for (var key in pathParamData.properties) {
                    if (!pathParamData.properties.hasOwnProperty(key))
                      continue;
                    var prop = pathParamData.properties[key];
                    RAMLExporter._mapFormats(prop, ramlDef);
                    pathParams[key] = ramlHelper.setParameterFields(prop, {});
                    RAMLExporter.fixEnumValueFormat(prop);
                    if (prop.items) {
                      var items = prop.items;
                      RAMLExporter._mapFormats(items, ramlDef);
                      RAMLExporter.fixEnumValueFormat(items);
                      pathParams[key].items = items;
                    }
                    if (prop.format) {
                      pathParams[key].format = prop.format;
                    }
                    pathParams[key].type = pathParams[key].type || 'string';
                    //facets
                    for (var id in pathParams[key]) {
                      if (!pathParams[key].hasOwnProperty(id))
                        continue;
                      if (id === 'exclusiveMinimum' || id === 'exclusiveMaximum' || id === 'allowEmptyValue' || id === 'collectionFormat') {
                        RAMLExporter._createAnnotation(pathParams[key], id, pathParams[key][id], ramlDef);
                        delete pathParams[key][id];
                      }
                    }
                  }
                  return RAMLExporter._validateParam(pathParams);
                }
              },
              {
                key: '_mapTextSections',
                value: function _mapTextSections(slTexts) {
                  var results = [];
                  if (!slTexts)
                    return resilts;
                  for (var i in slTexts) {
                    if (!slTexts.hasOwnProperty(i))
                      continue;
                    var text = slTexts[i];
                    if (text.divider || _.isEmpty(text.name) || _.isEmpty(text.content)) {
                      continue;
                    }
                    results.push({
                      title: text.name,
                      content: text.content
                    });
                  }
                  return results;
                }  // from ref=type1 to type=type1
                   // from $ref=#/definitions/type1 to type=type1
                   // from $ref=definitions/type1 to !include definitions/type1
              },
              {
                key: 'convertRefFromModel',
                value: function convertRefFromModel(object, isTypeDeclaration, insideProperties, ramlDef) {
                  RAMLExporter._mapFormats(object, ramlDef);
                  for (var id in object) {
                    if (object.hasOwnProperty(id)) {
                      var val = object[id];
                      if (insideProperties)
                        val = RAMLExporter.convertSchemaTitles(val, 'property', ramlDef);
                      if (id == '$ref' && !insideProperties) {
                        if (val.indexOf('#/') == 0) {
                          object.type = val.replace('#/definitions/', '');
                          //check if object.type has invalid characters.
                          object.type = stringHelper.checkAndReplaceInvalidChars(object.type, ramlHelper.getValidCharacters, ramlHelper.getReplacementCharacter);
                        } else {
                          object.type = '!include ' + val.replace('#/', '#');
                        }
                        delete object[id];
                      } else if (id == 'type' && !insideProperties) {
                        if (val === 'null')
                          object.type = 'nil';
                        else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                          for (var key in val) {
                            if (!val.hasOwnProperty(key))
                              continue;
                            if (val[key] === 'null')
                              val[key] = 'nil';
                          }
                        }
                      } else if (typeof val === 'string') {
                        if (id == 'ref') {
                          object.type = val;
                          delete object[id];
                        } else if (id == 'include') {
                          object.type = '!include ' + val;
                          delete object[id];
                        } else if (id === 'collectionFormat') {
                          RAMLExporter._createAnnotation(object, id, object[id], ramlDef);
                        }
                      } else if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && (id !== 'facets' || insideProperties)) {
                        RAMLExporter._mapFormats(val, ramlDef);
                        if (!insideProperties) {
                          if (id === 'example' && object.type === undefined)
                            object['type'] = typeof val === 'undefined' ? 'undefined' : _typeof(val);
                          else if (object.hasOwnProperty('items') && object.type !== 'array')
                            object['type'] = 'array';
                        } else if (val.hasOwnProperty('additionalProperties'))
                          val.type = 'object';
                        if (id === 'readOnly')
                          RAMLExporter._createAnnotation(object, id, object[id], ramlDef);
                        object[id] = this.convertRefFromModel(val, isTypeDeclaration, id === 'properties' && !insideProperties, ramlDef);
                      } else if (id === '$ref') {
                        object.type = val.replace('#/definitions/', '');
                        delete object[id];
                      } else if (id === 'exclusiveMinimum' || id === 'exclusiveMaximum' || id === 'allowEmptyValue' || id === 'collectionFormat') {
                        RAMLExporter._createAnnotation(object, id, object[id], ramlDef);
                        delete object[id];
                      } else if (id === 'readOnly') {
                        RAMLExporter._createAnnotation(object, id, object[id], ramlDef);
                        delete object[id];
                      } else if (!ramlHelper.isNumberType(object.type) && (id === 'maximum' || id === 'minimum')) {
                        RAMLExporter._createAnnotation(object, id, object[id], ramlDef);
                        delete object[id];
                      }
                      if (ramlHelper.isNumberType(object.type) && id === 'example') {
                        object[id] = _.toNumber(object[id]);
                      }
                      if (val !== null && val.hasOwnProperty('readOnly') && id !== 'properties') {
                        RAMLExporter._createAnnotation(val, 'readOnly', val['readOnly'], ramlDef);
                        delete val['readOnly'];
                      }
                    }
                  }
                  return object;
                }
              },
              {
                key: '_mapParametersTraits',
                value: function _mapParametersTraits(slTraits, ramlDef) {
                  var traits = this.initializeTraits();
                  for (var i in slTraits) {
                    if (!slTraits.hasOwnProperty(i))
                      continue;
                    var slTrait = slTraits[i];
                    var trait = {};
                    try {
                      var queryString = jsonHelper.parse(slTrait.request.queryString);
                      if (!jsonHelper.isEmptySchema(queryString)) {
                        trait.queryParameters = this._mapNamedParams(queryString, ramlDef);
                      }
                    } catch (e) {
                    }
                    try {
                      var headers = jsonHelper.parse(slTrait.request.headers);
                      if (!jsonHelper.isEmptySchema(headers)) {
                        trait.headers = this._mapNamedParams(headers);
                      }
                    } catch (e) {
                    }
                    try {
                      var formData = jsonHelper.parse(slTrait.request.formData);
                      if (!jsonHelper.isEmptySchema(formData)) {
                        trait.body = this._mapRequestBody(formData, 'multipart/form-data');
                      }
                    } catch (e) {
                    }
                    try {
                      var body = jsonHelper.parse(slTrait.request.body);
                      if (!jsonHelper.isEmptySchema(body)) {
                        trait.body = this._mapRequestBody(body, 'application/json', ramlDef);
                      }
                    } catch (e) {
                    }
                    if (!_.isEmpty(slTrait.responses)) {
                      //ignore responses as traits
                      continue;
                    }
                    this.addTrait(slTrait.name, trait, traits);
                  }
                  return traits;
                }
              },
              {
                key: '_mapResponsesTraits',
                value: function _mapResponsesTraits(slTraits, mimeType) {
                  var responses = {};
                  for (var i in slTraits) {
                    if (!slTraits.hasOwnProperty(i))
                      continue;
                    var slTrait = slTraits[i];
                    try {
                      if (slTrait.responses && slTrait.responses.length) {
                        var response = this._mapResponseBody(slTrait.responses, mimeType);
                        responses[slTrait.name] = response['200'];
                      }
                    } catch (e) {
                    }
                  }
                  return responses;
                }
              },
              {
                key: '_export',
                value: function _export() {
                  var env = this.project.Environment;
                  var ramlDef = new RAMLDefinition(this.project.Name, env);
                  ramlDef.mediaType = this.mapMediaType(env.Consumes, env.Produces);
                  this.description(ramlDef, this.project);
                  if (this.project.tags) {
                    RAMLExporter._addTags(ramlDef, this.project.tags);
                  }
                  if (this.project.Environment.extensions) {
                    if (!ramlDef['(oas-info)']) {
                      ramlDef['(oas-info)'] = {};
                    }
                    RAMLExporter._createAnnotation(ramlDef, 'info', this.project.Environment.extensions, ramlDef);
                    RAMLExporter._addExtensions(ramlDef, ramlDef['(oas-info)'], this.project.Environment.extensions);
                  }
                  if (this.project.Environment.ExternalDocs) {
                    var value = {
                        'description': this.project.Environment.ExternalDocs.description,
                        'url': this.project.Environment.ExternalDocs.url
                      };
                    RAMLExporter._createAnnotation(ramlDef, 'externalDocs', value, ramlDef);
                    if (this.project.Environment.ExternalDocs.extensions) {
                      RAMLExporter._addExtensions(ramlDef, ramlDef['(oas-externalDocs)'], this.project.Environment.ExternalDocs.extensions);
                    }
                  }
                  if (this.project.Environment.contactInfo) {
                    var contact = { contact: {} };
                    if (this.project.Environment.contactInfo.name) {
                      contact['contact'].name = this.project.Environment.contactInfo.name;
                    }
                    if (this.project.Environment.contactInfo.url) {
                      contact['contact'].url = this.project.Environment.contactInfo.url;
                    }
                    if (this.project.Environment.contactInfo.email) {
                      contact['contact'].email = this.project.Environment.contactInfo.email;
                    }
                    RAMLExporter._createAnnotation(ramlDef, 'info', contact, ramlDef);
                    if (this.project.Environment.contactInfo.extensions) {
                      RAMLExporter._addExtensions(ramlDef, ramlDef['(oas-info)'].contact, this.project.Environment.contactInfo.extensions);
                    }
                  }
                  if (this.project.Environment.termsOfService) {
                    var _value = { termsOfService: this.project.Environment.termsOfService };
                    RAMLExporter._createAnnotation(ramlDef, 'info', _value, ramlDef);
                  }
                  if (this.project.Environment.license) {
                    var _value2 = { license: {} };
                    if (this.project.Environment.license.name) {
                      _value2['license'].name = this.project.Environment.license.name;
                    }
                    if (this.project.Environment.license.url) {
                      _value2['license'].url = this.project.Environment.license.url;
                    }
                    RAMLExporter._createAnnotation(ramlDef, 'info', _value2, ramlDef);
                    if (this.project.Environment.license.extensions) {
                      RAMLExporter._addExtensions(ramlDef, ramlDef['(oas-info)'].license, this.project.Environment.license.extensions);
                    }
                  }
                  var docs = this._mapTextSections(this.project.Texts);
                  if (docs.length) {
                    ramlDef.documentation = ramlDef.documentation || [];
                    ramlDef.documentation = ramlDef.documentation.concat(docs);
                  }
                  var slSecuritySchemes = this.project.Environment.SecuritySchemes;
                  var securitySchemes = this._mapSecurityScheme(slSecuritySchemes);
                  if (!_.isEmpty(securitySchemes)) {
                    ramlDef.securitySchemes = securitySchemes;
                  }
                  if (!_.isEmpty(this.project.endpointExtensions)) {
                    if (!ramlDef['(oas-paths)']) {
                      ramlDef['(oas-paths)'] = {};
                    }
                    RAMLExporter._addExtensions(ramlDef, ramlDef['(oas-paths)'], this.project.endpointExtensions);
                    ramlDef.annotationTypes['oas-paths'] = {
                      type: 'any',
                      allowedTargets: 'API'
                    };
                  }
                  var endpoints = this.project.Endpoints;
                  // Collect endpoints ids from environment resourcesOrder
                  var orderedIds = env.resourcesOrder.docs.reduce(function (ids, group) {
                      return ids.concat(_.map(_.filter(group.items, { type: 'endpoints' }), '_id'));
                    }, []);
                  // Sort endpoints similar to resourcesOrder items order
                  endpoints.sort(function (a, b) {
                    return orderedIds.indexOf(a._id) < orderedIds.indexOf(b._id) ? -1 : 1;
                  });
                  for (var i in endpoints) {
                    if (!endpoints.hasOwnProperty(i))
                      continue;
                    var endpoint = endpoints[i];
                    var method = {};
                    if (endpoint.extensions) {
                      RAMLExporter._addExtensions(ramlDef, method, endpoint.extensions);
                    }
                    this.setMethodDisplayName(method, endpoint.operationId || endpoint.Name);
                    if (endpoint.Description) {
                      method.description = endpoint.Description;
                    }
                    if (endpoint.Summary) {
                      RAMLExporter._createAnnotation(method, 'summary', endpoint.Summary, ramlDef);
                    }
                    var protocols = RAMLExporter.mapProtocols(endpoint.protocols);
                    if (!_.isEmpty(protocols)) {
                      method.protocols = protocols;
                    }
                    var is = RAMLExporter._mapEndpointTraits(this.project.Traits, endpoint);
                    if (is.length) {
                      method.is = is;
                    }
                    if (_.toLower(endpoint.Method) === 'post' || _.toLower(endpoint.Method) === 'put' || _.toLower(endpoint.Method) === 'patch') {
                      var _mimeType = RAMLExporter.getDefaultMimeType(endpoint.Consumes, ramlDef.mediaType);
                      if (_.isArray(endpoint.Body) && endpoint.Body.length > 0) {
                        var body = this._mapRequestBody(endpoint.Body[0], _mimeType, ramlDef);
                        if (!_.isEmpty(body)) {
                          method.body = body;
                        }
                      }
                    }
                    method.headers = this._mapNamedParams(endpoint.Headers, ramlDef);
                    var mimeType = RAMLExporter.getDefaultMimeType(endpoint.Produces, ramlDef.mediaType);
                    var responses = this._mapResponseBody(endpoint.Responses, mimeType, ramlDef);
                    if (!_.isEmpty(responses)) {
                      if (responses.default) {
                        RAMLExporter._createAnnotation(method, 'responses-default', responses.default, ramlDef);
                        delete responses.default;
                      }
                      if (!_.isEmpty(responses)) {
                        method.responses = responses;
                      }
                    }
                    method.queryParameters = this._mapURIParams(endpoint.QueryString, ramlDef);
                    method.uriParameters = this._mapURIParams(endpoint.PathParams, ramlDef);
                    if (endpoint.securedBy) {
                      var rsecuredBy = [];
                      if (endpoint.securedBy.oauth2) {
                        for (var index in slSecuritySchemes.oauth2) {
                          if (!slSecuritySchemes.oauth2.hasOwnProperty(index))
                            continue;
                          var current = slSecuritySchemes.oauth2[index];
                          if (current.name === endpoint.securedBy.oauth2.name) {
                            var securedName = current.name || 'oauth2';
                            if (!_.isEmpty(endpoint.securedBy.oauth2.scope)) {
                              var scopes = {};
                              scopes[securedName] = { scopes: endpoint.securedBy.oauth2.scope };
                              rsecuredBy.push(scopes);
                            } else {
                              rsecuredBy.push(securedName);
                            }
                          }
                        }
                      }
                      if (endpoint.securedBy.basic && slSecuritySchemes.basic) {
                        for (var _index5 in slSecuritySchemes.basic) {
                          if (!slSecuritySchemes.basic.hasOwnProperty(_index5))
                            continue;
                          var _current4 = slSecuritySchemes.basic[_index5];
                          if (endpoint.securedBy.basic.name === _current4.name) {
                            rsecuredBy.push(_current4.name);
                          }
                        }
                      }
                      if (endpoint.securedBy.apiKey) {
                        if (slSecuritySchemes.apiKey) {
                          if (!_.isEmpty(slSecuritySchemes.apiKey.headers)) {
                            for (var _index6 in slSecuritySchemes.apiKey.headers) {
                              if (!slSecuritySchemes.apiKey.headers.hasOwnProperty(_index6))
                                continue;
                              var _current5 = slSecuritySchemes.apiKey.headers[_index6];
                              if (_current5.externalName === endpoint.securedBy.apiKey.name) {
                                rsecuredBy.push(_current5.externalName);
                              }
                            }
                          }
                          if (!_.isEmpty(slSecuritySchemes.apiKey.queryString)) {
                            for (var _index7 in slSecuritySchemes.apiKey.queryString) {
                              if (!slSecuritySchemes.apiKey.queryString.hasOwnProperty(_index7))
                                continue;
                              var _current6 = slSecuritySchemes.apiKey.queryString[_index7];
                              if (_current6.externalName === endpoint.securedBy.apiKey.name) {
                                rsecuredBy.push(_current6.externalName);
                              }
                            }
                          }
                        }
                      }
                      if (rsecuredBy.length > 0) {
                        method.securedBy = rsecuredBy;
                      }
                    }
                    var uriParts = endpoint.Path.split('/');
                    uriParts.splice(0, 1);
                    ramlDef.addMethod(ramlDef, uriParts, endpoint.Method, method, this.project.getPathParamRef(endpoint.Path));
                    if (endpoint.Tags && !_.isEmpty(endpoint.Tags)) {
                      RAMLExporter._createAnnotation(method, 'tags', endpoint.Tags, ramlDef);
                    }
                    if (endpoint.Deprecated) {
                      RAMLExporter._createAnnotation(method, 'deprecated', endpoint.Deprecated, ramlDef);
                    }
                    if (endpoint.ExternalDocs) {
                      var _value3 = {
                          'description': endpoint.ExternalDocs.description,
                          'url': endpoint.ExternalDocs.url
                        };
                      RAMLExporter._createAnnotation(method, 'externalDocs', _value3, ramlDef);
                    }
                    if (endpoint.responses.extensions) {
                      RAMLExporter._addExtensions(ramlDef, method.responses, endpoint.responses.extensions);
                    }
                    for (var _i in method) {
                      if (!method.hasOwnProperty(_i))
                        continue;
                      var _value4 = method[_i];
                      if ((typeof _value4 === 'undefined' ? 'undefined' : _typeof(_value4)) === 'object')
                        RAMLExporter._addInnerExtensions(ramlDef, _value4);
                    }
                    for (var _i2 in method.responses) {
                      if (!method.responses.hasOwnProperty(_i2))
                        continue;
                      var response = method.responses[_i2];
                      RAMLExporter._addExampleExtensions(ramlDef, response.body);
                    }
                  }
                  RAMLExporter.removeDisplayName(ramlDef);
                  var schemas = this.project.Schemas;
                  if (schemas && schemas.length > 0) {
                    this.addSchema(ramlDef, this.mapSchema(schemas, ramlDef));
                  }
                  for (var _i3 in schemas) {
                    if (!schemas.hasOwnProperty(_i3))
                      continue;
                    var schema = schemas[_i3];
                    if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object') {
                      var object = schema.definition;
                      RAMLExporter._addInnerExtensions(ramlDef, object);
                      RAMLExporter._addInnerExternalDocs(ramlDef, object);
                    }
                  }
                  if (this.project.Traits && this.project.Traits.length > 0) {
                    var traits = this._mapParametersTraits(this.project.Traits, ramlDef);
                    if (!_.isEmpty(traits)) {
                      ramlDef.traits = traits;
                    }
                  }
                  //export responses
                  if (this.project.Traits && this.project.Traits.length > 0) {
                    var _responses = this._mapResponsesTraits(this.project.Traits);
                    if (!_.isEmpty(_responses)) {
                      RAMLExporter._createAnnotation(ramlDef, 'responses', _responses, ramlDef);
                    }
                  }
                  // Clean empty field in definition
                  for (var field in ramlDef) {
                    if (ramlDef.hasOwnProperty(field) && !ramlDef[field]) {
                      delete ramlDef[field];
                    }
                  }
                  RAMLExporter._addExtensions(ramlDef, ramlDef, this.project.extensions);
                  this.data = ramlHelper.removeEmptyValueNodes(ramlDef);
                }
              },
              {
                key: '_unescapeYamlIncludes',
                value: function _unescapeYamlIncludes(yaml) {
                  var start = yaml.indexOf('\'!include ');
                  if (start == -1)
                    return yaml;
                  var end = yaml.indexOf('\'', start + 1);
                  if (end == -1)
                    return yaml;
                  return yaml.substring(0, start) + yaml.substring(start + 1, end) + this._unescapeYamlIncludes(yaml.substring(end + 1));
                }
              },
              {
                key: '_getData',
                value: function _getData(format) {
                  switch (format) {
                  case 'yaml': {
                      var yaml = this._unescapeYamlIncludes(YAML.dump(jsonHelper.parse(JSON.stringify(this.Data)), { lineWidth: -1 }));
                      return '#%RAML ' + this.version() + '\n' + yaml;
                    }
                  default:
                    throw Error('RAML doesn not support ' + format + ' format');
                  }
                }
              },
              {
                key: 'convertRequiredFromProperties',
                value: function convertRequiredFromProperties(object, insideProperties) {
                  for (var id in object) {
                    if (!object.hasOwnProperty(id))
                      continue;
                    var val = object[id];
                    if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && id !== 'required') {
                      this.convertRequiredFromProperties(val, id === 'properties' && !insideProperties);
                    }
                    if (id === 'properties' && !insideProperties) {
                      for (var propId in object.properties) {
                        if (!object.properties.hasOwnProperty(propId) || propId === '//')
                          continue;
                        var property = object.properties[propId];
                        if (!RAMLExporter.checkRequiredProperty(object, propId) && (typeof property === 'undefined' ? 'undefined' : _typeof(property)) === 'object') {
                          property.required = false;
                        }
                      }
                      delete object.required;
                    }
                  }
                }
              },
              {
                key: 'description',
                value: function description() {
                  throw new Error('description method not implemented');
                }
              },
              {
                key: 'version',
                value: function version() {
                  throw new Error('version method not implemented');
                }
              },
              {
                key: 'mapAuthorizationGrants',
                value: function mapAuthorizationGrants() {
                  throw new Error('mapAuthorizationGrants method not implemented');
                }
              },
              {
                key: 'mapBody',
                value: function mapBody() {
                  throw new Error('mapBody method not implemented');
                }
              },
              {
                key: 'mapRequestBodyForm',
                value: function mapRequestBodyForm() {
                  throw new Error('mapRequestBodyForm method not implemented');
                }
              },
              {
                key: 'addSchema',
                value: function addSchema() {
                  throw new Error('addSchema method not implemented');
                }
              },
              {
                key: 'mapSchema',
                value: function mapSchema() {
                  throw new Error('mapSchema method not implemented');
                }
              },
              {
                key: 'getApiKeyType',
                value: function getApiKeyType() {
                  throw new Error('getApiType method not implemented');
                }
              },
              {
                key: 'mapSecuritySchemes',
                value: function mapSecuritySchemes() {
                  throw new Error('mapSecuritySchemes method not implemented');
                }
              },
              {
                key: 'setMethodDisplayName',
                value: function setMethodDisplayName() {
                  throw new Error('setMethodDisplayName method not implemented');
                }
              },
              {
                key: 'initializeTraits',
                value: function initializeTraits() {
                  throw new Error('initializeTraits method not implemented');
                }
              },
              {
                key: 'addTrait',
                value: function addTrait() {
                  throw new Error('addTrait method not implemented');
                }
              },
              {
                key: 'mapMediaType',
                value: function mapMediaType() {
                  throw new Error('mapMediaType method not implemented');
                }
              }
            ], [
              {
                key: '_validateParam',
                value: function _validateParam(params) {
                  var acceptedTypes = [
                      'string',
                      'number',
                      'integer',
                      'date',
                      'boolean',
                      'file',
                      'array',
                      'datetime'
                    ];
                  for (var key in params) {
                    if (!params.hasOwnProperty(key))
                      continue;
                    var param = params[key];
                    for (var prop in param) {
                      if (!param.hasOwnProperty(prop))
                        continue;
                      switch (prop) {
                      case 'type': {
                          var type = params[key].type;
                          if (acceptedTypes.indexOf(type) < 0) {
                            //not supported type, delete param
                            delete params[key];
                            continue;
                          }
                          break;
                        }
                      case 'enum':
                      case 'pattern':
                      case 'minLength':
                      case 'maxLength':
                        if (params[key].type !== 'string') {
                          delete params[key][prop];
                        }
                        break;
                      case 'minimum':
                      case 'maximum': {
                          var typeLowercase = _.toLower(params[key].type);
                          if (typeLowercase !== 'integer' && typeLowercase !== 'number') {
                            delete params[key][prop];
                          }
                          break;
                        }
                      case 'required':
                      case 'displayName':
                      case 'description':
                      case 'example':
                      case 'repeat':
                      case 'default':
                      case 'items':
                      case 'format':
                      case 'maxItems':
                      case 'minItems':
                      case 'uniqueItems':
                      case 'facets':
                      case '(oas-format)':
                      case '(oas-allowEmptyValue)':
                      case '(oas-collectionFormat)':
                      case '(oas-exclusiveMaximum)':
                      case '(oas-exclusiveMinimum)':
                        break;
                      default:
                        //not supported types
                        if (params[key]) {
                          delete params[key][prop];
                        }
                      }
                    }
                  }
                  return params;
                }
              },
              {
                key: 'fixEnumValueFormat',
                value: function fixEnumValueFormat(object) {
                  if (object.hasOwnProperty('enum')) {
                    if (object.type === 'date-only') {
                      for (var index in object.enum) {
                        if (!object.enum.hasOwnProperty(index))
                          continue;
                        var val = object.enum[index];
                        if (ramlHelper.getDateOnlyFormat.test(val)) {
                          val = val.replace(/_/g, '-');
                          val = val.replace(new RegExp('/', 'g'), '-');
                          object['enum'][index] = val;
                        }
                      }
                    }
                  }
                }
              },
              {
                key: 'mapProtocols',
                value: function mapProtocols(protocols) {
                  var validProtocols = [];
                  for (var i in protocols) {
                    if (!protocols.hasOwnProperty(i) || _.toLower(protocols[i]) != 'http' && _.toLower(protocols[i]) != 'https') {
                      //RAML incompatible formats( 'ws' etc)
                      continue;
                    }
                    validProtocols.push(_.toUpper(protocols[i]));
                  }
                  return validProtocols;
                }
              },
              {
                key: '_createAnnotation',
                value: function _createAnnotation(object, id, value, ramlDef) {
                  var definition = void 0;
                  var found = true;
                  switch (id) {
                  case 'allowEmptyValue':
                    definition = { type: 'boolean' };
                    break;
                  case 'tags':
                    definition = {
                      type: 'string[]',
                      allowedTargets: 'Method'
                    };
                    break;
                  case 'deprecated':
                    definition = {
                      type: 'boolean',
                      allowedTargets: 'Method'
                    };
                    break;
                  case 'summary':
                    definition = {
                      type: 'string',
                      allowedTargets: 'Method'
                    };
                    break;
                  case 'externalDocs':
                    definition = {
                      properties: {
                        'description?': 'string',
                        'url': 'string'
                      },
                      allowedTargets: [
                        'API',
                        'Method',
                        'TypeDeclaration'
                      ]
                    };
                    break;
                  case 'info':
                    definition = {
                      properties: {
                        'termsOfService?': 'string',
                        'contact?': {
                          properties: {
                            'name?': 'string',
                            'url?': 'string',
                            'email?': 'string'
                          }
                        },
                        'license?': {
                          properties: {
                            'name?': 'string',
                            'url?': 'string'
                          }
                        }
                      },
                      allowedTargets: 'API'
                    };
                    break;
                  case 'schema-title':
                    definition = {
                      type: 'string',
                      allowedTargets: 'TypeDeclaration'
                    };
                    break;
                  case 'property-title':
                    definition = {
                      type: 'string',
                      allowedTargets: 'TypeDeclaration'
                    };
                    break;
                  case 'body-name':
                    definition = {
                      type: 'string',
                      allowedTargets: 'TypeDeclaration'
                    };
                    break;
                  case 'responses-default':
                    definition = {
                      type: 'any',
                      allowedTargets: 'Method'
                    };
                    break;
                  case 'global-response-definition':
                    definition = {
                      type: 'any',
                      allowedTargets: 'Response'
                    };
                    break;
                  case 'definition-name':
                    definition = {
                      type: 'string',
                      allowedTargets: 'TypeDeclaration'
                    };
                    break;
                  case 'collectionFormat':
                    definition = { type: 'string' };
                    break;
                  case 'format':
                    definition = {
                      type: 'string',
                      allowedTargets: 'TypeDeclaration'
                    };
                    break;
                  case 'readOnly':
                    definition = {
                      type: 'boolean',
                      allowedTargets: 'TypeDeclaration'
                    };
                    break;
                  case 'responses':
                    definition = 'any';
                    break;
                  case 'exclusiveMaximum':
                  case 'exclusiveMinimum':
                    definition = { type: 'boolean' };
                    break;
                  case 'maximum':
                  case 'minimum':
                    definition = {
                      allowedTargets: 'TypeDeclaration',
                      type: 'number'
                    };
                    break;
                  default:
                    found = false;
                    break;
                  }
                  if (!found)
                    return false;
                  if (!ramlDef.annotationTypes) {
                    ramlDef.annotationTypes = {};
                  }
                  var annotationDefId = 'oas-' + id;
                  if (!ramlDef.annotationTypes.hasOwnProperty(annotationDefId)) {
                    ramlDef.annotationTypes[annotationDefId] = definition;
                  }
                  var annotationUsageId = '(' + annotationDefId + ')';
                  if (object.hasOwnProperty(annotationUsageId))
                    _.merge(object[annotationUsageId], value);
                  else
                    object[annotationUsageId] = value;
                  return true;
                }
              },
              {
                key: '_mapFormats',
                value: function _mapFormats(object, ramlDef) {
                  var intValidFormats = [
                      'int',
                      'int8',
                      'int16',
                      'int32',
                      'int64'
                    ];
                  if (object && !object.hasOwnProperty('type') && object.format == 'string') {
                    object['type'] = 'string';
                    delete object.format;
                  } else if (object && object.type == 'string') {
                    if (object.format == 'byte' || object.format == 'binary' || object.format == 'password' || object.format == 'uuid') {
                      RAMLExporter._createAnnotation(object, 'format', object.format, ramlDef);
                      delete object.format;
                    } else if (object.format == 'date') {
                      object['type'] = 'date-only';
                      delete object.format;
                    } else if (object.format == 'date-time') {
                      object['type'] = 'datetime';
                      object['format'] = 'rfc3339';
                    } else {
                      if (object.format && ramlHelper.getValidFormat.indexOf(object.format) < 0) {
                        RAMLExporter._createAnnotation(object, 'format', object.format, ramlDef);
                        delete object.format;
                      }
                    }
                  } else if (object && object.type == 'integer') {
                    if (intValidFormats.indexOf(object.format) < 0)
                      delete object.format;
                  } else if (object && object.type == 'number') {
                    if (intValidFormats.concat([
                        'long',
                        'float',
                        'double'
                      ]).indexOf(object.format) < 0) {
                      if (object.format == 'integer')
                        object['type'] = 'integer';
                      delete object.format;
                    }
                  }
                }
              },
              {
                key: 'convertSchemaTitles',
                value: function convertSchemaTitles(object, objectType, ramlDef) {
                  for (var id in object) {
                    if (!object.hasOwnProperty(id))
                      continue;
                    var val = object[id];
                    if (id === 'title' && typeof val === 'string') {
                      if (objectType === 'schema')
                        RAMLExporter._createAnnotation(object, 'schema-title', val, ramlDef);
                      else if (objectType === 'property')
                        RAMLExporter._createAnnotation(object, 'property-title', val, ramlDef);
                      delete object[id];
                    }
                  }
                  return object;
                }
              },
              {
                key: '_mapEndpointTraits',
                value: function _mapEndpointTraits(slTraits, endpoint) {
                  var is = [];
                  for (var i in endpoint.traits) {
                    if (!endpoint.traits.hasOwnProperty(i))
                      continue;
                    var trait = _.find(slTraits, [
                        '_id',
                        endpoint.traits[i]
                      ]);
                    if (!trait) {
                      continue;
                    }
                    is.push(_.camelCase(trait.name));
                  }
                  return is;
                }
              },
              {
                key: 'getDefaultMimeType',
                value: function getDefaultMimeType(mimeType, defMimeType) {
                  var mt = mimeType && mimeType.length > 0 ? mimeType[0] : null;
                  if (!mt) {
                    if (_.isArray(defMimeType) && defMimeType.length) {
                      mt = defMimeType[0];
                    } else if (_.isString(defMimeType) && defMimeType !== '') {
                      mt = defMimeType;
                    }
                  }
                  if (!mt) {
                    mt = 'application/json';  //default mime Type isn't present
                  }
                  return mt;
                }
              },
              {
                key: 'removeDisplayName',
                value: function removeDisplayName(resource) {
                  delete resource.displayName;
                  for (var id in resource) {
                    if (!resource.hasOwnProperty(id) || !id.startsWith('/'))
                      continue;
                    var value = resource[id];
                    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
                      RAMLExporter.removeDisplayName(value);
                    }
                  }
                }
              },
              {
                key: '_addTags',
                value: function _addTags(ramlDef, tags) {
                  if (_.isEmpty(tags))
                    return;
                  ramlDef['(oas-tags-definition)'] = [];
                  if (!ramlDef.annotationTypes) {
                    ramlDef.annotationTypes = {};
                  }
                  ramlDef.annotationTypes['oas-tags-definition'] = {
                    type: 'array',
                    items: {
                      properties: {
                        name: 'string',
                        'description?': 'string',
                        'externalDocs?': {
                          properties: {
                            url: 'string',
                            'description?': 'string'
                          }
                        }
                      }
                    },
                    allowedTargets: 'API'
                  };
                  for (var key in tags) {
                    if (!tags.hasOwnProperty(key))
                      continue;
                    ramlDef['(oas-tags-definition)'].push(tags[key]);
                  }
                }  // allowedTargets?
              },
              {
                key: '_addExtensions',
                value: function _addExtensions(ramlDef, ramlObject, extensions) {
                  for (var key in extensions) {
                    if (!extensions.hasOwnProperty(key))
                      continue;
                    if (ramlObject.hasOwnProperty(key))
                      delete ramlObject[key];
                    var annotationKey = key === 'example' ? 'responses-'.concat(key) : key;
                    ramlObject['(oas-' + annotationKey + ')'] = extensions[key];
                    if (!ramlDef.annotationTypes)
                      ramlDef.annotationTypes = {};
                    if (!ramlDef.annotationTypes.hasOwnProperty('oas-' + annotationKey)) {
                      switch (key) {
                      case 'example':
                        ramlDef.annotationTypes['oas-' + annotationKey] = {
                          type: 'string',
                          allowedTargets: 'TypeDeclaration'
                        };
                        break;
                      case 'externalDocs':
                        ramlDef.annotationTypes['oas-' + annotationKey] = {
                          properties: {
                            'description?': 'string',
                            'url': 'string'
                          },
                          allowedTargets: [
                            'API',
                            'Method',
                            'TypeDeclaration'
                          ]
                        };
                        break;
                      default:
                        ramlDef.annotationTypes['oas-' + key] = 'any';
                        break;
                      }
                    }
                  }
                }
              },
              {
                key: '_addExampleExtensions',
                value: function _addExampleExtensions(ramlDef, object) {
                  for (var key in object) {
                    if (!object.hasOwnProperty(key))
                      continue;
                    var type = object[key];
                    if (!type.hasOwnProperty('example'))
                      continue;
                    var value = type['example'];
                    if (typeof value === 'string')
                      RAMLExporter._addExtensions(ramlDef, type, { 'example': value });
                  }
                }
              },
              {
                key: '_addInnerExtensions',
                value: function _addInnerExtensions(ramlDef, object) {
                  var extensions = {};
                  var innerObjects = {};
                  for (var key in object) {
                    if (!object.hasOwnProperty(key))
                      continue;
                    var value = object[key];
                    if (_.startsWith(key, 'x-')) {
                      extensions[key] = value;
                    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
                      innerObjects[key] = value;
                    }
                  }
                  if (!_.isEmpty(extensions))
                    RAMLExporter._addExtensions(ramlDef, object, extensions);
                  for (var _key in innerObjects) {
                    if (!innerObjects.hasOwnProperty(_key))
                      continue;
                    var obj = innerObjects[_key];
                    RAMLExporter._addInnerExtensions(ramlDef, obj);
                  }
                }
              },
              {
                key: '_addInnerExternalDocs',
                value: function _addInnerExternalDocs(ramlDef, object) {
                  var innerObjects = {};
                  for (var key in object) {
                    if (!object.hasOwnProperty(key))
                      continue;
                    var value = object[key];
                    if (key === 'externalDocs')
                      RAMLExporter._addExtensions(ramlDef, object, { 'externalDocs': value });
                    else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')
                      innerObjects[key] = value;
                  }
                  for (var _key2 in innerObjects) {
                    if (!innerObjects.hasOwnProperty(_key2))
                      continue;
                    var obj = innerObjects[_key2];
                    RAMLExporter._addInnerExternalDocs(ramlDef, obj);
                  }
                }
              },
              {
                key: 'checkRequiredProperty',
                value: function checkRequiredProperty(object, paramName) {
                  if (!object.required)
                    return false;
                  if (object.required && object.required.length > 0) {
                    for (var j in object.required) {
                      if (!object.required.hasOwnProperty(j))
                        continue;
                      var requiredParam = object.required[j];
                      if (requiredParam === paramName) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
              }
            ]);
            return RAMLExporter;
          }(Exporter);
        module.exports = RAMLExporter;
      },
      {
        '../helpers/raml': 97,
        '../utils/json': 107,
        '../utils/strings': 108,
        './exporter': 91,
        'js-yaml': 111,
        'lodash': 79
      }
    ],
    91: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var YAML = require('js-yaml'), Importer = require('../importers/index'), _ = require('lodash'), Formats = require('../formats');
        var Exporter = function () {
            function Exporter() {
              _classCallCheck(this, Exporter);
              this.data = null;
              this.project = null;
              this.options = null;
            }
            _createClass(Exporter, [
              {
                key: 'loadProject',
                value: function loadProject(project) {
                  this.project = _.cloneDeep(project);
                }
              },
              {
                key: '_export',
                value: function _export() {
                  throw new Error('_export method not implemented');
                }  //noinspection ReservedWordAsName
              },
              {
                key: 'export',
                value: function _export(format, options) {
                  var _this = this;
                  return new Promise(function (resolve, reject) {
                    try {
                      _this.options = options;
                      _this._export();
                      var exportedData = _this._getData(format);
                      if (options && (options.validate === true || options.validateExport === true)) {
                        var formattedData = (typeof exportedData === 'undefined' ? 'undefined' : _typeof(exportedData)) === 'object' ? JSON.stringify(exportedData) : exportedData;
                        var importer = Importer.factory(Formats.AUTO);
                        importer.loadData(formattedData, options).then(function () {
                          try {
                            importer.import();
                            resolve(exportedData);
                          } catch (err) {
                            err.exportedData = exportedData;
                            reject(err);
                          }
                        }).catch(function (err) {
                          err.exportedData = exportedData;
                          reject(err);
                        });
                      } else {
                        resolve(exportedData);
                      }
                    } catch (err) {
                      reject(err);
                    }
                  });
                }
              },
              {
                key: '_getData',
                value: function _getData(format) {
                  switch (format) {
                  case 'yaml':
                    return YAML.dump(JSON.parse(JSON.stringify(this.Data)), { lineWidth: -1 });
                  default:
                    return this.Data;
                  }
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: '_mapEndpoint',
                value: function _mapEndpoint() {
                  throw new Error('_mapEndpoint method not implemented');
                }
              },
              {
                key: '_mapSchema',
                value: function _mapSchema() {
                  throw new Error('_mapSchema method not implemented');
                }
              },
              {
                key: '_mapQueryString',
                value: function _mapQueryString() {
                  throw new Error('_mapQueryString method not implemented');
                }
              },
              {
                key: '_mapURIParams',
                value: function _mapURIParams() {
                  throw new Error('_mapURIParams method not implemented');
                }
              },
              {
                key: '_mapRequestBody',
                value: function _mapRequestBody() {
                  throw new Error('_mapRequestBody method not implemented');
                }
              },
              {
                key: '_mapResponseBody',
                value: function _mapResponseBody() {
                  throw new Error('_mapResponseBody method not implemented');
                }
              },
              {
                key: '_mapRequestHeaders',
                value: function _mapRequestHeaders() {
                  throw new Error('_mapRequestHeaders method not implemented');
                }
              },
              {
                key: 'Data',
                get: function get() {
                  //noinspection JSConstructorReturnsPrimitive
                  return this.data;
                }
              }
            ]);
            return Exporter;
          }();
        module.exports = Exporter;
      },
      {
        '../formats': 96,
        '../importers/index': 102,
        'js-yaml': 111,
        'lodash': 79
      }
    ],
    92: [
      function (require, module, exports) {
        'use strict';
        var exporters = {
            Swagger: require('./swagger'),
            RAML08: require('./raml08'),
            RAML10: require('./raml10')
          };
        function hasFormatSupport(format) {
          return !(!format || !format.name || !exporters.hasOwnProperty(format.className));
        }
        module.exports = {
          hasSupport: hasFormatSupport,
          factory: function factory(format) {
            if (!hasFormatSupport(format)) {
              return null;
            }
            return new exporters[format.className]();
          }
        };
      },
      {
        './raml08': 93,
        './raml10': 94,
        './swagger': 95
      }
    ],
    93: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var _ = require('lodash'), RAMLExporter = require('./baseraml'), jsonHelper = require('../utils/json');
        var RAML08Exporter = function (_RAMLExporter) {
            _inherits(RAML08Exporter, _RAMLExporter);
            function RAML08Exporter() {
              _classCallCheck(this, RAML08Exporter);
              return _possibleConstructorReturn(this, (RAML08Exporter.__proto__ || Object.getPrototypeOf(RAML08Exporter)).call(this));
            }
            _createClass(RAML08Exporter, [
              {
                key: 'version',
                value: function version() {
                  return '0.8';
                }
              },
              {
                key: 'mapMediaType',
                value: function mapMediaType(consumes, produces) {
                  var mediaTypes = [];
                  if (consumes && consumes.length > 0) {
                    mediaTypes = consumes;
                  }
                  if (_.isArray(produces)) {
                    mediaTypes = mediaTypes.concat(produces);
                  }
                  mediaTypes = _.uniq(mediaTypes);
                  return mediaTypes.length ? mediaTypes[0] : null;
                }
              },
              {
                key: 'mapAuthorizationGrants',
                value: function mapAuthorizationGrants(flow) {
                  var ag = [];
                  switch (flow) {
                  case 'implicit':
                    ag = ['token'];
                    break;
                  case 'password':
                    ag = ['credentials'];
                    break;
                  case 'application':
                    ag = ['owner'];
                    break;
                  case 'accessCode':
                    ag = ['code'];
                    break;
                  }
                  return ag;
                }
              },
              {
                key: 'mapRequestBodyForm',
                value: function mapRequestBodyForm(bodyData) {
                  var body = { formParameters: bodyData.properties };
                  if (bodyData.required && bodyData.required.length > 0) {
                    for (var i in bodyData.required) {
                      if (!bodyData.required.hasOwnProperty(i))
                        continue;
                      var requiredParam = bodyData.required[i];
                      if (body['formParameters'][requiredParam]) {
                        body['formParameters'][requiredParam].required = true;
                      }
                    }
                  }
                  return body;
                }
              },
              {
                key: 'mapBody',
                value: function mapBody(bodyData, ramlDef) {
                  var body = { schema: jsonHelper.format(this.convertRefFromModel(jsonHelper.parse(bodyData.body), false, null, ramlDef)) };
                  var example = jsonHelper.format(bodyData.example);
                  if (!_.isEmpty(example)) {
                    body.example = example;
                  }
                  return body;
                }
              },
              {
                key: 'addSchema',
                value: function addSchema(ramlDef, schema) {
                  ramlDef.schemas = schema;
                }
              },
              {
                key: 'mapSchema',
                value: function mapSchema(slSchemas) {
                  var results = [];
                  for (var i in slSchemas) {
                    if (!slSchemas.hasOwnProperty(i))
                      continue;
                    var schema = slSchemas[i];
                    var resultSchema = {};
                    resultSchema[schema.NameSpace] = jsonHelper.format(schema.Definition);
                    results.push(resultSchema);
                  }
                  return results;
                }
              },
              {
                key: 'description',
                value: function description(ramlDef, project) {
                  ramlDef.documentation = [{
                      title: project.Name,
                      content: project.Description
                    }];
                }
              },
              {
                key: 'getApiKeyType',
                value: function getApiKeyType() {
                  return 'x-api-key';
                }
              },
              {
                key: 'mapSecuritySchemes',
                value: function mapSecuritySchemes(securitySchemes) {
                  return _.map(securitySchemes, function (v, k) {
                    var m = {};
                    m[k] = v;
                    return m;
                  });
                }
              },
              {
                key: 'setMethodDisplayName',
                value: function setMethodDisplayName() {
                }
              },
              {
                key: 'initializeTraits',
                value: function initializeTraits() {
                  return [];
                }
              },
              {
                key: 'addTrait',
                value: function addTrait(id, trait, traits) {
                  var newTrait = {};
                  newTrait[_.camelCase(id)] = trait;
                  traits.push(newTrait);
                }
              }
            ]);
            return RAML08Exporter;
          }(RAMLExporter);
        module.exports = RAML08Exporter;
      },
      {
        '../utils/json': 107,
        './baseraml': 90,
        'lodash': 79
      }
    ],
    94: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var _ = require('lodash'), RAMLExporter = require('./baseraml'), stringHelper = require('../utils/strings'), ramlHelper = require('../helpers/raml'), jsonHelper = require('../utils/json');
        var RAML10Exporter = function (_RAMLExporter) {
            _inherits(RAML10Exporter, _RAMLExporter);
            function RAML10Exporter() {
              _classCallCheck(this, RAML10Exporter);
              return _possibleConstructorReturn(this, (RAML10Exporter.__proto__ || Object.getPrototypeOf(RAML10Exporter)).call(this));
            }
            _createClass(RAML10Exporter, [
              {
                key: 'version',
                value: function version() {
                  return '1.0';
                }
              },
              {
                key: 'mapMediaType',
                value: function mapMediaType(consumes, produces) {
                  var mediaTypes = [];
                  if (consumes && consumes.length > 0) {
                    mediaTypes = consumes;
                  }
                  if (_.isArray(produces)) {
                    mediaTypes = mediaTypes.concat(produces);
                  }
                  mediaTypes = _.uniq(mediaTypes);
                  if (mediaTypes.length === 1) {
                    return mediaTypes[0];
                  }
                  return mediaTypes.length ? mediaTypes : null;
                }
              },
              {
                key: 'mapAuthorizationGrants',
                value: function mapAuthorizationGrants(flow) {
                  var ag = [];
                  switch (flow) {
                  case 'implicit':
                    ag = ['implicit'];
                    break;
                  case 'password':
                    ag = ['password'];
                    break;
                  case 'application':
                    ag = ['client_credentials'];
                    break;
                  case 'accessCode':
                    ag = ['authorization_code'];
                    break;
                  }
                  return ag;
                }
              },
              {
                key: 'mapBody',
                value: function mapBody(bodyData, type, ramlDef) {
                  var body = jsonHelper.parse(bodyData.body);
                  var result = this.convertAllOfToModel(this.convertRefFromModel(body, false, null, ramlDef));
                  result = RAMLExporter.convertSchemaTitles(result, 'schema', ramlDef);
                  result = this.mapAdditionalProperties(result);
                  if (bodyData.example) {
                    result.example = jsonHelper.parse(bodyData.example);
                    if (type && result.example[type]) {
                      result.example = jsonHelper.parse(result.example[type]);
                      if (result.example.hasOwnProperty('value')) {
                        var value = {};
                        value.value = result.example.value;
                        result.example.value = value;
                      }
                      if (_typeof(result.example) === 'object')
                        result.example = this.fixValuesFormat(result.example);
                    }
                  }
                  return result;
                }
              },
              {
                key: 'fixValuesFormat',
                value: function fixValuesFormat(object) {
                  for (var id in object) {
                    if (object.hasOwnProperty(id)) {
                      var val = object[id];
                      object[id] = RAML10Exporter.fixDateFormat(val);
                      if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object')
                        object[id] = this.fixValuesFormat(val);
                    }
                  }
                  return object;
                }
              },
              {
                key: 'mapRequestBodyForm',
                value: function mapRequestBodyForm(bodyData, ramlDef) {
                  var body = { properties: bodyData.properties };
                  /**
    * Two different approaches to declare an optional parameter.
    * source https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#property-declarations
    * a) appending '?' to property name (without declaring required parameter).
    * b) set required = false
    */
                  for (var i in body.properties) {
                    if (!body.properties.hasOwnProperty(i))
                      continue;
                    var property = body.properties[i];
                    property.required = false;
                    //facets
                    //todo add annotation
                    for (var id in property) {
                      if (!property.hasOwnProperty(id))
                        continue;
                      var found = RAMLExporter._createAnnotation(property, id, property[id], ramlDef);
                      if (found)
                        delete property[id];
                    }
                  }
                  if (bodyData.required && bodyData.required.length > 0) {
                    for (var j in bodyData.required) {
                      if (!bodyData.required.hasOwnProperty(j))
                        continue;
                      var requiredParam = bodyData.required[j];
                      if (body['properties'][requiredParam]) {
                        body['properties'][requiredParam].required = true;
                      }
                    }
                  }
                  return body;
                }
              },
              {
                key: 'addSchema',
                value: function addSchema(ramlDef, schema) {
                  ramlDef.types = schema;
                }
              },
              {
                key: 'convertAllOfToModel',
                value: function convertAllOfToModel(object) {
                  for (var id in object) {
                    if (!object.hasOwnProperty(id))
                      continue;
                    var val = object[id];
                    if (!val)
                      continue;
                    if (id == 'allOf') {
                      object = this.convertAllOfAttribute(object);
                    } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                      object[id] = this.convertAllOfToModel(val);
                    }
                  }
                  return object;
                }
              },
              {
                key: 'convertAllOfAttribute',
                value: function convertAllOfAttribute(definition) {
                  var result = {};
                  var allOfTypes = [];
                  if (!definition.allOf)
                    return definition;
                  for (var j in definition.allOf) {
                    if (!definition.allOf.hasOwnProperty(j))
                      continue;
                    var allOf = definition.allOf[j];
                    if (allOf.properties) {
                      result = this.mapSchemaProperties(allOf);
                    } else if (allOf.type) {
                      allOfTypes.push(allOf.type);
                    }
                  }
                  result.type = allOfTypes.length > 1 ? allOfTypes : allOfTypes[0];
                  delete result.allOf;
                  return result;
                }
              },
              {
                key: 'mapSchema',
                value: function mapSchema(slSchemas, ramlDef) {
                  var results = {};
                  for (var i in slSchemas) {
                    if (!slSchemas.hasOwnProperty(i))
                      continue;
                    var schema = slSchemas[i];
                    var definition = this.convertRefFromModel(jsonHelper.parse(schema.Definition), true, null, ramlDef);
                    definition = RAML10Exporter.convertSchemaTitles(definition, 'schema', ramlDef);
                    if (definition.allOf) {
                      definition = this.convertAllOfToModel(definition);
                    } else {
                      if (definition.properties) {
                        definition = this.mapSchemaProperties(definition);
                      }
                    }
                    definition = this.mapAdditionalProperties(definition);
                    if (definition.externalDocs) {
                      RAMLExporter._createAnnotation(definition, 'externalDocs', definition.externalDocs, ramlDef);
                      delete definition.externalDocs;
                    }
                    if (definition.additionalProperties) {
                      if (!definition.properties) {
                        definition.properties = {};
                      }
                      definition.properties['//'] = definition.additionalProperties;
                      delete definition.additionalProperties;
                    }
                    if (schema.example) {
                      definition.example = jsonHelper.parse(schema.example);  // const example = jsonHelper.parse(schema.example);
                                                                              // if (!_.isEmpty(example)) {
                                                                              // 	definition.example = example;
                    }
                    //check if schemaId contains invalid characters.
                    var schemaId = stringHelper.checkAndReplaceInvalidChars(schema.NameSpace, ramlHelper.getValidCharacters, ramlHelper.getReplacementCharacter);
                    if (schemaId !== schema.NameSpace) {
                      RAMLExporter._createAnnotation(definition, 'definition-name', schema.NameSpace, ramlDef);
                    }
                    results[schemaId] = definition;
                  }
                  return results;
                }
              },
              {
                key: 'mapSchemaProperties',
                value: function mapSchemaProperties(definition) {
                  this.convertRequiredFromProperties(definition);
                  if (definition.properties && definition.type == 'object') {
                    delete definition.type;
                  }
                  return definition;
                }
              },
              {
                key: 'mapAdditionalProperties',
                value: function mapAdditionalProperties(definition, insideProperties) {
                  for (var key in definition) {
                    if (!definition.hasOwnProperty(key))
                      continue;
                    var val = definition[key];
                    if (key === 'additionalProperties' && !insideProperties) {
                      var hasObjectType = definition.type === 'object';
                      var hasProperties = definition.hasOwnProperty('properties');
                      if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object' && val || !val && !hasObjectType && !hasProperties) {
                        delete definition.additionalProperties;
                      } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                        if (!hasProperties)
                          definition.properties = {};
                        definition.properties['//'] = this.mapAdditionalProperties(val, key === 'properties' && !insideProperties);
                        delete definition.additionalProperties;
                      }
                    } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                      val = this.mapAdditionalProperties(val, key === 'properties' && !insideProperties);
                    }
                  }
                  return definition;
                }
              },
              {
                key: 'description',
                value: function description(ramlDef, project) {
                  ramlDef.description = project.Description;
                }
              },
              {
                key: 'getApiKeyType',
                value: function getApiKeyType() {
                  return 'Pass Through';
                }
              },
              {
                key: 'mapSecuritySchemes',
                value: function mapSecuritySchemes(securitySchemes) {
                  return securitySchemes;
                }
              },
              {
                key: 'setMethodDisplayName',
                value: function setMethodDisplayName(method, displayName) {
                  if (displayName) {
                    method.displayName = displayName;
                  }
                }
              },
              {
                key: 'initializeTraits',
                value: function initializeTraits() {
                  return {};
                }
              },
              {
                key: 'addTrait',
                value: function addTrait(id, trait, traits) {
                  traits[_.camelCase(id)] = trait;
                }
              }
            ], [{
                key: 'fixDateFormat',
                value: function fixDateFormat(val) {
                  if (typeof val === 'string' && ramlHelper.getRFC3339Format.test(val)) {
                    if (val.match(/\d*Z/)[0].length > 3)
                      return val.replace(/\d*Z/, val.match(/\d*Z/)[0].slice(0, 3) + 'Z');
                  }
                  return val;
                }
              }]);
            return RAML10Exporter;
          }(RAMLExporter);
        module.exports = RAML10Exporter;
      },
      {
        '../helpers/raml': 97,
        '../utils/json': 107,
        '../utils/strings': 108,
        './baseraml': 90,
        'lodash': 79
      }
    ],
    95: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Exporter = require('./exporter'), jsonHelper = require('../utils/json.js'), stringHelper = require('../utils/strings.js'), urlHelper = require('../utils/url'), SwaggerDefinition = require('../entities/swagger/definition'), swaggerHelper = require('../helpers/swagger'), xmlHelper = require('../utils/xml.js'), _ = require('lodash'), arrayHelper = require('../utils/array.js'), url = require('url');
        var Swagger = function (_Exporter) {
            _inherits(Swagger, _Exporter);
            function Swagger() {
              _classCallCheck(this, Swagger);
              return _possibleConstructorReturn(this, (Swagger.__proto__ || Object.getPrototypeOf(Swagger)).call(this));
            }
            _createClass(Swagger, [
              {
                key: '_getResponseTypes',
                value: function _getResponseTypes(endpoint, defaultResponseType) {
                  var defRespType = defaultResponseType || [], produces = endpoint.Produces || [];
                  return produces.reduce(function (result, mimeType) {
                    if (result.indexOf(mimeType) === -1 && defRespType.indexOf(mimeType) === -1) {
                      result.push(mimeType);
                    }
                    return result;
                  }, []);
                }
              },
              {
                key: '_getRequestTypes',
                value: function _getRequestTypes(endpoint, parameters, defaultRequestType) {
                  var result = [], typesToInclude = [
                      'multipart/form-data',
                      'application/x-www-form-urlencoded'
                    ], consumes = endpoint.Consumes || [], defReqType = defaultRequestType || [];
                  for (var i in parameters) {
                    if (!parameters.hasOwnProperty(i))
                      continue;
                    if (parameters[i].type && parameters[i].type === 'file') {
                      //consumes must have 'multipart/form-data' or 'application/x-www-form-urlencoded'
                      typesToInclude.forEach(function (mimeType) {
                        if (!result.length) {
                          if (consumes.indexOf(mimeType) >= 0) {
                            result.push(mimeType);
                          } else if (defReqType.indexOf(mimeType) >= 0) {
                            result.push(mimeType);
                          }
                        }
                      });
                      if (!result.length) {
                        //as swagger spec validation must want one of these, add one
                        result.push(typesToInclude[0]);
                      }
                      //no need for the further iterations
                      break;
                    }
                  }
                  if (!_.isEmpty(consumes)) {
                    consumes.forEach(function (mimeType) {
                      if (defReqType.indexOf(mimeType) === -1) {
                        result.push(mimeType);
                      }
                    });
                  }
                  return _.uniq(result);
                }
              },
              {
                key: '_constructTags',
                value: function _constructTags(endpoint, env) {
                  var tags = endpoint.tags || [];
                  var group = _.find(env.GroupsOrder.docs, function (g) {
                      return _.find(g.items, [
                        '_id',
                        endpoint._id
                      ]);
                    });
                  if (group) {
                    tags.push(group.name);
                  }
                  return _.uniq(tags);
                }
              },
              {
                key: '_constructSwaggerMethod',
                value: function _constructSwaggerMethod(endpoint, parameters, responses, env) {
                  var consumes = this._getRequestTypes(endpoint, parameters, env.Consumes);
                  var produces = this._getResponseTypes(endpoint, env.Produces);
                  endpoint.SetOperationId(endpoint.operationId);
                  var resultSwaggerMethod = {};
                  if (!_.isEmpty(endpoint.operationId)) {
                    resultSwaggerMethod.operationId = endpoint.operationId;
                  }
                  if (!_.isEmpty(endpoint.Name)) {
                    resultSwaggerMethod.summary = endpoint.Name;
                  }
                  var tags = this._constructTags(endpoint, env);
                  if (!_.isEmpty(tags)) {
                    resultSwaggerMethod.tags = tags;
                  }
                  if (!_.isEmpty(endpoint.Description)) {
                    resultSwaggerMethod.description = endpoint.Description;
                  }
                  if (_.isArray(consumes) && endpoint.Consumes && !_.isEqual(env.Consumes, consumes) && !_.isEmpty(consumes)) {
                    resultSwaggerMethod.consumes = consumes.filter(_.isString);
                  }
                  if (_.isArray(produces) && endpoint.Produces && !_.isEqual(env.Produces, produces) && !_.isEmpty(produces)) {
                    resultSwaggerMethod.produces = produces.filter(_.isString);
                  }
                  if (!_.isEmpty(parameters)) {
                    resultSwaggerMethod.parameters = parameters;
                  }
                  resultSwaggerMethod.responses = responses;
                  return resultSwaggerMethod;
                }
              },
              {
                key: '_mapURIParams',
                value: function _mapURIParams(pathParams) {
                  var parameters = [];
                  if (!pathParams.properties || _.isEmpty(pathParams)) {
                    return parameters;
                  }
                  for (var paramName in pathParams.properties) {
                    if (!pathParams.properties.hasOwnProperty(paramName))
                      continue;
                    var prop = pathParams.properties[paramName];
                    var param = swaggerHelper.setParameterFields(prop, {});
                    param.name = paramName;
                    param.in = 'path';
                    param.required = true;
                    param.type = param.type || 'string';
                    if (!_.isEmpty(prop.description)) {
                      param.description = prop.description;
                    }
                    Swagger._addPatternedObjects(prop, param);
                    parameters.push(param);
                  }
                  return parameters;
                }
              },
              {
                key: '_mapQueryString',
                value: function _mapQueryString(queryStringParams) {
                  var parameters = [];
                  if (queryStringParams.name && queryStringParams.name === 'queryString' && !queryStringParams.properties) {
                    queryStringParams.in = 'query';
                    return queryStringParams;
                  }
                  if (!queryStringParams.properties) {
                    return parameters;
                  }
                  for (var paramName in queryStringParams.properties) {
                    if (!queryStringParams.properties.hasOwnProperty(paramName))
                      continue;
                    var param = this._convertExamples(queryStringParams.properties[paramName], false);
                    param = swaggerHelper.setParameterFields(param, {});
                    param.name = paramName;
                    param.in = 'query';
                    param.required = queryStringParams.hasOwnProperty('required') && queryStringParams.required.indexOf(param.name) >= 0;
                    parameters.push(param);
                  }
                  return parameters;
                }
              },
              {
                key: 'mapResponseBody',
                value: function mapResponseBody(res, mimeType) {
                  var item = {};
                  item.description = res.description || '';
                  // if response body mimeType is null, do not include schema in swagger export
                  // TODO: Figure out how to set example for mimeType properly.
                  // if (!mimeType) {
                  //   return item;
                  // }
                  var body = jsonHelper.parse(res.body);
                  if (body && !_.isEmpty(body)) {
                    if (body.hasOwnProperty('$schema'))
                      delete body['$schema'];
                    item.schema = this.convertRefFromModel(body, false);
                  }
                  if (mimeType && mimeType !== '' && res.example && res.example !== '{}' && res.example.length > 2) {
                    item.examples = {};
                    item.examples[mimeType] = jsonHelper.parse(res.example);
                  }
                  if (res.headers) {
                    this.mapHeaderProperties(res.headers);
                    item.headers = res.headers;
                    var headers = item.headers;
                    for (var id in headers) {
                      if (!headers.hasOwnProperty(id))
                        continue;
                      headers[id] = this._convertExamples(headers[id], false);
                    }
                  }
                  Swagger._addPatternedObjects(res, item);
                  return item;
                }
              },
              {
                key: 'mapHeaderProperties',
                value: function mapHeaderProperties(headers) {
                  for (var i in headers) {
                    if (!headers.hasOwnProperty(i))
                      continue;
                    var header = headers[i];
                    if (header.hasOwnProperty('description') && header.description == null)
                      header.description = '';
                    if (header.hasOwnProperty('required')) {
                      this.addExtension(header, 'x-raml-required', header['required']);
                      delete header.required;
                    }
                    if (header.hasOwnProperty('repeat')) {
                      this.addExtension(header, 'x-raml-repeat', header['repeat']);
                      delete header.repeat;
                    }
                  }
                }
              },
              {
                key: 'addExtension',
                value: function addExtension(object, id, value) {
                  if (_.isEmpty(this.options) || !this.options.hasOwnProperty('noExtension') || this.options.noExtension === true)
                    return;
                  // if (!_.isEmpty(this.options) && this.options.hasOwnProperty('noExtension') && this.options['noExtension'] === true) return;
                  object[id] = value;
                }
              },
              {
                key: '_mapResponseBody',
                value: function _mapResponseBody(endpoint) {
                  var slResponses = endpoint.Responses;
                  var result = {};
                  for (var i in slResponses) {
                    if (!slResponses.hasOwnProperty(i))
                      continue;
                    var res = slResponses[i];
                    var mimeType = endpoint.Produces && endpoint.Produces.length ? endpoint.Produces[0] : null;
                    // if (!mimeType && env.Produces && env.Produces.length) {
                    //   mimeType = env.Produces[0];
                    // }
                    var code = res.codes && res.codes.length > 0 && parseInt(res.codes[0]) ? res.codes[0] : 'default';
                    result[code] = this.mapResponseBody(res, mimeType);
                  }
                  return result;
                }
              },
              {
                key: '_mapRequestBodies',
                value: function _mapRequestBodies(slRequestBodies, mimeTypes) {
                  var result = {};
                  for (var id in slRequestBodies) {
                    if (!slRequestBodies.hasOwnProperty(id))
                      continue;
                    var requestBody = slRequestBodies[id];
                    this.addExtension(result, 'x-raml-body-' + requestBody.mimeType, this._mapRequestBody(requestBody, mimeTypes, false));
                  }
                  return result;
                }
              },
              {
                key: '_mapRequestBody',
                value: function _mapRequestBody(slRequestBody, requestTypes, multipleBodies) {
                  var result = [];
                  if (_.isEmpty(slRequestBody.body)) {
                    return result;
                  }
                  var body = jsonHelper.parse(slRequestBody.body) || {};
                  var param = {};
                  if (!_.isEmpty(slRequestBody.description)) {
                    param.description = slRequestBody.description;
                  }
                  if (!jsonHelper.isEmptySchema(body)) {
                    //make sure body isn't empty
                    var regex = /\"type\":[ ]*\"file\"|\"type\":[ ]*\"binary\"/;
                    //export as formData only if schema includes file type property
                    if (jsonHelper.stringify(slRequestBody.body, 4).match(regex) || !_.isEmpty(requestTypes) && [
                        'multipart/form-data',
                        'application/x-www-form-urlencoded'
                      ].indexOf(requestTypes[0]) !== -1) {
                      if (body.properties) {
                        for (var prop in body.properties) {
                          if (!body.properties.hasOwnProperty(prop))
                            continue;
                          param = body.properties[prop];
                          param.in = 'formData';
                          param.name = prop;
                          if (body.required && body.required.indexOf(prop) >= 0) {
                            param.required = true;
                          }
                          // if (param.hasOwnProperty('type')) {
                          // 	param.type = multipleBodies ? {type: 'object'} : param.type;
                          // }
                          result.push(param);
                        }
                      } else {
                        param.in = 'formData';
                        param.name = 'formData';
                        if (body.ref) {
                          this.addExtension(param, 'x-raml-type', body.ref);
                        }
                        if (param.hasOwnProperty('type')) {
                          param.type = multipleBodies ? { type: 'object' } : param.type;
                        }
                        if (body.hasOwnProperty('type') && body.type === 'file')
                          param.type = body.type;
                        result.push(param);
                      }
                    } else {
                      if (body.required && body.required.length <= 0) {
                        delete body.required;
                      }
                      param.name = 'body';
                      param.in = 'body';
                      param.schema = multipleBodies ? { type: 'object' } : this.convertRefFromModel(body, false);
                      if (!_.isEmpty(slRequestBody.example)) {
                        if (!xmlHelper.isXml(slRequestBody.example))
                          param.schema.example = jsonHelper.parse(slRequestBody.example);
                        else
                          param.schema.example = slRequestBody.example;
                      }
                      result.push(param);
                    }
                  }
                  return result;
                }
              },
              {
                key: '_mapRequestHeaders',
                value: function _mapRequestHeaders(slHeaders) {
                  var result = [];
                  if (slHeaders) {
                    for (var property in slHeaders.properties) {
                      if (!slHeaders.properties.hasOwnProperty(property))
                        continue;
                      var param = this._convertExamples(slHeaders.properties[property], false);
                      param = swaggerHelper.setParameterFields(param, {});
                      param.name = property;
                      param.in = 'header';
                      param.required = slHeaders.required && slHeaders.required.indexOf(property) >= 0;
                      var desc = slHeaders.properties[property].description;
                      if (!_.isEmpty(desc)) {
                        param.description = slHeaders.properties[property].description;
                      }
                      //check if parameter contains pattern or example attributes.
                      param = this._hasAttributes(param, [
                        'example',
                        'pattern'
                      ]);
                      result.push(param);
                    }
                  }
                  return result;
                }
              },
              {
                key: '_hasAttributes',
                value: function _hasAttributes(object, atts) {
                  for (var id in object) {
                    if (!object.hasOwnProperty(id))
                      continue;
                    var val = object[id];
                    if (atts.indexOf(id) >= 0) {
                      this.addExtension(object, 'x-raml-' + id, val);
                      delete object[id];
                    } else {
                      if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                        object[id] = this._hasAttributes(val, atts);
                      }
                    }
                  }
                  return object;
                }
              },
              {
                key: '_mapSchema',
                value: function _mapSchema(slSchemas) {
                  var result = {};
                  for (var i in slSchemas) {
                    if (!slSchemas.hasOwnProperty(i))
                      continue;
                    var schema = slSchemas[i];
                    var definition = jsonHelper.parse(schema.Definition);
                    if (definition.hasOwnProperty('$schema')) {
                      delete definition['$schema'];
                      delete definition['id'];
                    }
                    definition = this.convertRefFromModel(definition, true);
                    if (definition.hasOwnProperty('description') && _.isEmpty(definition.description)) {
                      delete definition.description;
                    }
                    result[schema.NameSpace] = definition;
                  }
                  return result;
                }
              },
              {
                key: 'replaceCustomProperties',
                value: function replaceCustomProperties(object) {
                  var oldId = '__custom-';
                  var newId = 'x-raml-';
                  for (var id in object) {
                    if (!object.hasOwnProperty(id))
                      continue;
                    if (_typeof(object[id]) === 'object') {
                      this.replaceCustomProperties(object[id]);
                    }
                    if (_.startsWith(id, oldId)) {
                      var replaceId = _.replace(id, new RegExp(oldId, 'g'), newId);
                      this.addExtension(object, replaceId, object[id]);
                      delete object[id];
                    }
                  }
                }  // from ref=type1 to $ref=#/definitions/type1
              },
              {
                key: 'convertRefFromModel',
                value: function convertRefFromModel(object, isSchema, isProperty) {
                  if (xmlHelper.isXml(object)) {
                    var o = object;
                    object = { type: 'object' };
                    this.addExtension(object, 'x-raml-xsd-definition', o);
                  }
                  if (object.hasOwnProperty('definitions') && object.hasOwnProperty('items') && object.type == 'array') {
                    object = Swagger.convertDefinitions(object);
                  }
                  for (var id in object) {
                    if (!object.hasOwnProperty(id) || swaggerHelper.isExtension(id))
                      continue;
                    var val = object[id];
                    if (id == 'type') {
                      object.type = Swagger.convertTypes(val);
                    }
                    if (id == 'allOf') {
                      var allOf = object.allOf;
                      for (var key in allOf) {
                        if (!allOf.hasOwnProperty(key))
                          continue;
                        var obj = allOf[key];
                        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object')
                          allOf[key] = this.convertRefFromModel(obj, isSchema);
                        else
                          allOf[key] = { '$ref': '#/definitions/' + obj };
                      }
                      //check if all elements from allOf are the same.
                      //if yes, remove allOf attribute.
                      if (arrayHelper.allEqual(allOf)) {
                        _.merge(object, object.allOf[0]);
                        delete object.allOf;
                      }
                    } else if ((id === 'oneOf' || id === 'anyOf') && !isProperty) {
                      delete object[id];
                      object.type = 'object';
                    } else if (id === 'schemaPath') {
                      this.addExtension(object, 'x-raml-xsd-definition', val);
                      delete object[id];
                    } else if (typeof val === 'string') {
                      if (id == 'ref') {
                        object.$ref = '#/definitions/' + val;
                        delete object[id];
                        id = '$ref';
                      } else if (id == 'include') {
                        object.$ref = val;
                        delete object[id];
                        id = '$ref';
                      }
                    } else if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                      if (id === 'example' || id === 'examples') {
                        object = this._convertExamples(object, isSchema);
                        id = 'example';
                      } else if (id !== 'xml') {
                        object[id] = this.convertRefFromModel(val, isSchema, id == 'properties' && !isProperty);
                      }
                    }
                    if (!_.isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && !isProperty && swaggerHelper.getSupportedSchemaFields.indexOf(id) < 0 && !_.startsWith(id, 'x-raml')) {
                      this.addExtension(object, 'x-raml-' + id, val);
                      delete object[id];
                    }
                  }
                  return object;
                }
              },
              {
                key: '_convertExamples',
                value: function _convertExamples(object, isSchema) {
                  if (isSchema) {
                    if (object.hasOwnProperty('examples')) {
                      var val = object.examples;
                      if (!_.isArray(val))
                        return val;
                      object.example = val[0];
                      if (val.length > 1) {
                        var additionalExamples = [];
                        for (var i = 1; i < val.length; i++) {
                          additionalExamples.push(val[i]);
                        }
                        this.addExtension(object, 'x-raml-additional-examples', additionalExamples);
                      }
                      delete object.examples;
                    }
                  } else if (object.hasOwnProperty('example')) {
                    this.addExtension(object, 'x-raml-example', object.example);
                    delete object.example;
                  } else if (object.hasOwnProperty('examples')) {
                    var _val = object.examples;
                    if (!_.isArray(_val))
                      return _val;
                    var examples = [];
                    for (var _i = 0; _i < _val.length; _i++) {
                      examples.push(_val[_i]);
                    }
                    this.addExtension(object, 'x-raml-example', examples);
                    delete object.examples;
                  }
                  return object;
                }
              },
              {
                key: '_mapEndpointTraitParameters',
                value: function _mapEndpointTraitParameters(endpoint, existingParams) {
                  if (!endpoint.traits || !endpoint.traits.length) {
                    return [];
                  }
                  var params = [];
                  for (var i in endpoint.traits) {
                    if (!endpoint.traits.hasOwnProperty(i))
                      continue;
                    var traitName = endpoint.traits[i];
                    if (_.isObject(traitName) && !_.isEmpty(traitName)) {
                      traitName = Object.keys(traitName)[0];
                    }
                    var trait = _.find(this.project.Traits, [
                        '_id',
                        traitName
                      ]);
                    if (!trait) {
                      continue;
                    }
                    //if trait has parameters, copy to method and declare it as x-raml-traits
                    try {
                      var schema = jsonHelper.parse(trait.request.queryString);
                      for (var p in schema.properties) {
                        if (!schema.properties.hasOwnProperty(p))
                          continue;
                        // only add it if we didn't already explicitly define it in the operation
                        if (!_.find(existingParams, {
                            name: p,
                            in: 'query'
                          })) {
                          //check if trait is parametric.
                          params.push({ $ref: '#/parameters/' + stringHelper.computeTraitName(trait.name, p) });
                        }
                      }
                    } catch (e) {
                    }
                    try {
                      var _schema = jsonHelper.parse(trait.request.headers);
                      for (var _p in _schema.properties) {
                        if (!_schema.properties.hasOwnProperty(_p))
                          continue;
                        // only add it if we didn't already explicitly define it in the operation
                        if (!_.find(existingParams, {
                            name: _p,
                            in: 'header'
                          })) {
                          params.push({ $ref: '#/parameters/' + stringHelper.computeTraitName(trait.name, _p) });
                        }
                      }
                    } catch (e) {
                    }
                  }
                  return params;
                }
              },
              {
                key: '_mapEndpointTraitResponses',
                value: function _mapEndpointTraitResponses(endpoint) {
                  if (!endpoint.traits || !endpoint.traits.length) {
                    return [];
                  }
                  var result = {};
                  for (var i in endpoint.traits) {
                    if (!endpoint.traits.hasOwnProperty(i))
                      continue;
                    var traitName = endpoint.traits[i];
                    if (_.isObject(traitName) && !_.isEmpty(traitName)) {
                      traitName = Object.keys(traitName)[0];
                    }
                    var trait = _.find(this.project.Traits, [
                        '_id',
                        traitName
                      ]);
                    if (!trait) {
                      continue;
                    }
                    for (var _i2 in trait.responses) {
                      var res = trait.responses[_i2], code = res.codes && res.codes.length > 0 && parseInt(res.codes[0]) ? res.codes[0] : 'default';
                      result[code] = { $ref: '#/responses/' + stringHelper.computeTraitName(trait.name, code) };
                    }
                  }
                  return result;
                }
              },
              {
                key: '_mapResources',
                value: function _mapResources(swaggerDef, env) {
                  var resources = this.project.Resources;
                  if (!_.isEmpty(resources)) {
                    for (var index in resources) {
                      if (!resources.hasOwnProperty(index))
                        continue;
                      var resource = resources[index];
                      this._mapEndpoints(swaggerDef, env, resource.endpoints);
                      if (resource.hasOwnProperty('is')) {
                        this.addExtension(swaggerDef.paths[resource.path], 'x-raml-is', resource.is);
                      }
                      if (!_.isEmpty(resource.annotations) || resource.displayName || resource.description) {
                        if (!swaggerDef.paths[resource.path]) {
                          swaggerDef.paths[resource.path] = {};
                        }
                      }
                      for (var id in resource.annotations) {
                        if (!resource.annotations.hasOwnProperty(id))
                          continue;
                        var annotation = resource.annotations[id];
                        swaggerDef.paths[resource.path][id] = annotation || '';
                      }
                      if (resource.displayName) {
                        this.addExtension(swaggerDef.paths[resource.path], 'x-raml-resource-displayName', resource.displayName);
                      }
                      if (resource.description) {
                        this.addExtension(swaggerDef.paths[resource.path], 'x-raml-resource-description', resource.description);
                      }
                    }
                  } else {
                    this._mapEndpoints(swaggerDef, env, this.project.Endpoints);
                  }
                }
              },
              {
                key: '_mapEndpoints',
                value: function _mapEndpoints(swaggerDef, env, endpoints) {
                  // Collect endpoints ids from environment resourcesOrder
                  var orderedIds = env.resourcesOrder.docs.reduce(function (ids, group) {
                      return ids.concat(_.map(_.filter(group.items, { type: 'endpoints' }), '_id'));
                    }, []);
                  // Sort endpoints similar to resourcesOrder items order
                  endpoints.sort(function (a, b) {
                    return orderedIds.indexOf(a._id) < orderedIds.indexOf(b._id) ? -1 : 1;
                  });
                  for (var i in endpoints) {
                    if (!endpoints.hasOwnProperty(i))
                      continue;
                    var endpoint = endpoints[i];
                    var parameters = [];
                    var requestTypes = this._getRequestTypes(endpoint, parameters, env.Consumes);
                    // To build parameters we need to grab data from body for supported mimeTypes
                    requestTypes = _.isEmpty(requestTypes) ? env.Consumes : requestTypes;
                    if (!swaggerDef.paths[endpoint.Path]) {
                      var params = Swagger._validateParameters(this._mapURIParams(endpoint.PathParams));
                      swaggerDef.paths[endpoint.Path] = params.length ? { parameters: params } : {};
                    }
                    parameters = parameters.concat(this._mapQueryString(endpoint.QueryString));
                    var requestBodySize = _.size(endpoint.Body);
                    if (requestBodySize > 1) {
                      parameters = parameters.concat(this._mapRequestBody(endpoint.Body[0], requestTypes, true));
                    } else {
                      if (!_.isEmpty(endpoint.Body)) {
                        parameters = parameters.concat(this._mapRequestBody(endpoint.Body[0], requestTypes, false));
                      }
                    }
                    parameters = parameters.concat(this._mapRequestHeaders(endpoint.Headers));
                    parameters = parameters.concat(this._mapEndpointTraitParameters(endpoint, parameters));
                    parameters = Swagger._validateParameters(parameters);
                    var responses = _.assign({}, this._mapResponseBody(endpoint, env), this._mapEndpointTraitResponses(endpoint));
                    if (_.isEmpty(responses)) {
                      // empty schema for swagger spec validation
                      responses['default'] = {
                        description: '',
                        schema: {}
                      };
                    }
                    // if (_.isEmpty(endpoint.Produces)) {
                    //   for (const statusCode in responses) {
                    //     const response = responses[statusCode];
                    //     delete response.schema;
                    //   }
                    // }
                    swaggerDef.paths[endpoint.Path][endpoint.Method] = this._constructSwaggerMethod(endpoint, parameters, responses, env);
                    if (requestBodySize > 1) {
                      var bodies = this._mapRequestBodies(endpoint.Body, requestTypes);
                      _.merge(swaggerDef.paths[endpoint.Path][endpoint.Method], bodies);
                    }
                    //Is it OK to include produces/consumes in all cases?
                    if (endpoint.hasOwnProperty('is')) {
                      this.addExtension(swaggerDef.paths[endpoint.Path][endpoint.Method], 'x-raml-is', endpoint.is);
                    }
                    if (endpoint.SecuredBy) {
                      var security = Swagger._mapEndpointSecurity(endpoint.SecuredBy, this.project.Environment.SecuritySchemes);
                      if (!_.isEmpty(security)) {
                        swaggerDef.paths[endpoint.Path][endpoint.Method]['security'] = security;
                      }
                    }
                    Swagger._addPatternedObjects(endpoint, swaggerDef.paths[endpoint.Path][endpoint.Method]);
                  }
                }
              },
              {
                key: '_mapTraitParameters',
                value: function _mapTraitParameters(traits) {
                  var parameters = {};
                  for (var i in traits) {
                    if (!traits.hasOwnProperty(i))
                      continue;
                    var trait = traits[i];
                    var params = [];
                    try {
                      var schema = jsonHelper.parse(trait.request.queryString);
                      if (!jsonHelper.isEmptySchema(schema)) {
                        params = params.concat(Swagger._validateParameters(this._mapQueryString(schema)));
                      }
                    } catch (e) {
                    }
                    try {
                      var _schema2 = jsonHelper.parse(trait.request.headers);
                      if (!jsonHelper.isEmptySchema(_schema2)) {
                        params = params.concat(Swagger._validateParameters(this._mapRequestHeaders(_schema2)));
                      }
                    } catch (e) {
                    }
                    for (var p in params) {
                      var param = params[p];
                      parameters[stringHelper.computeTraitName(trait.name, param.name)] = param;
                    }
                  }
                  return parameters;
                }
              },
              {
                key: '_mapTraitResponses',
                value: function _mapTraitResponses(traits) {
                  var responses = {};
                  for (var i in traits) {
                    if (!traits.hasOwnProperty(i))
                      continue;
                    var trait = traits[i];
                    for (var _i3 in trait.responses) {
                      var res = trait.responses[_i3];
                      var responseName = stringHelper.computeTraitName(trait.name, res.codes && res.codes.length > 0 && parseInt(res.codes[0]) ? res.codes[0] : 'default');
                      var response = this.mapResponseBody(res);
                      if (response.hasOwnProperty('schema') && response['schema'].hasOwnProperty('$ref') && _.includes(response['schema']['$ref'], '<<')) {
                        this.addExtension(response['schema'], 'x-raml-type', response['schema']['$ref']);
                        delete response['schema']['$ref'];
                      }
                      responses[responseName] = response;
                    }
                  }
                  return responses;
                }
              },
              {
                key: '_mapHostAndProtocol',
                value: function _mapHostAndProtocol(env, swaggerDef) {
                  var acceptedSchemes = [
                      'http',
                      'https',
                      'ws',
                      'wss'
                    ];
                  var hostUrl = url.parse(env.Host || '');
                  var swaggerHost = hostUrl.hostname || '';
                  if (swaggerHost && hostUrl.port) {
                    swaggerHost = swaggerHost + ':' + hostUrl.port;
                  }
                  swaggerDef.Host = swaggerHost;
                  // If host has path on it, prepend to base path
                  swaggerDef.BasePath = env.BasePath;
                  if (hostUrl.path && hostUrl.path !== '/') {
                    swaggerDef.BasePath = urlHelper.join(hostUrl.path, env.BasePath);
                  }
                  if (Swagger._isTemplateUri(swaggerDef.basePath)) {
                    Swagger._convertToTemplateUri(swaggerDef);
                  }
                  if (Array.isArray(env.Protocols) && !_.isEmpty(env.Protocols)) {
                    var filteredSchemes = [];
                    env.Protocols.map(function (p) {
                      if (acceptedSchemes.indexOf(p.toLowerCase()) >= 0) {
                        filteredSchemes.push(p.toLowerCase());
                      }
                    });
                    swaggerDef.schemes = filteredSchemes;
                  } else if (hostUrl.protocol) {
                    var scheme = hostUrl.protocol.split(':')[0];
                    if (acceptedSchemes.includes(scheme))
                      swaggerDef.schemes = [scheme];
                  } else {
                    delete swaggerDef.schemes;
                  }
                }
              },
              {
                key: '_mapHostAnnotations',
                value: function _mapHostAnnotations(env, swaggerDef) {
                  for (var id in env) {
                    if (!env.hasOwnProperty(id))
                      continue;
                    if (id.startsWith('x-annotation-'))
                      swaggerDef[id] = env[id];
                  }
                }
              },
              {
                key: '_export',
                value: function _export() {
                  //TODO
                  var swaggerDef = new SwaggerDefinition(this.project.Name, this.project.Description);
                  this.replaceCustomProperties(this.project);
                  var env = this.project.Environment;
                  swaggerDef.info.version = env.Version;
                  swaggerDef.BasePath = env.BasePath || '';
                  this._mapHostAnnotations(env, swaggerDef);
                  this._mapHostAndProtocol(env, swaggerDef);
                  if (env.Produces && env.Produces.length > 0) {
                    swaggerDef.produces = env.Produces;
                  } else {
                    delete swaggerDef.produces;
                  }
                  if (env.Consumes && env.Consumes.length > 0) {
                    swaggerDef.consumes = env.Consumes;
                  } else {
                    delete swaggerDef.consumes;
                  }
                  var definitions = this._mapSchema(this.project.Schemas);
                  if (!_.isEmpty(definitions)) {
                    swaggerDef.definitions = definitions;
                  }
                  var parameters = this._mapTraitParameters(this.project.Traits);
                  if (!_.isEmpty(parameters)) {
                    swaggerDef.parameters = parameters;
                  } else {
                    delete swaggerDef.parameters;
                  }
                  var parametricParameters = this._mapTraitParameters(this.project.parametricTraits);
                  if (!_.isEmpty(parametricParameters)) {
                    this.addExtension(swaggerDef, 'x-raml-traits', parametricParameters);
                  } else {
                    delete swaggerDef['x-raml-traits'];
                  }
                  var responses = this._mapTraitResponses(this.project.Traits);
                  if (!_.isEmpty(responses)) {
                    swaggerDef.responses = responses;
                  } else {
                    delete swaggerDef.responses;
                  }
                  swaggerDef.securityDefinitions = Swagger._mapSecurityDefinitions(this.project.Environment.SecuritySchemes);
                  this._mapResources(swaggerDef, env);
                  //if not security definition added, then don't keep the field anymore
                  if (swaggerDef.securityDefinitions && _.isEmpty(swaggerDef.securityDefinitions)) {
                    delete swaggerDef.securityDefinitions;
                  }
                  this.addExtension(swaggerDef, 'x-raml-uses', this.project.uses);
                  Swagger._addPatternedObjects(this.project, swaggerDef);
                  this.data = jsonHelper.toJSON(swaggerDef);
                }
              }
            ], [
              {
                key: '_validateParameters',
                value: function _validateParameters(parameters) {
                  parameters = jsonHelper.orderByKeys(parameters, [
                    '$ref',
                    'name',
                    'in',
                    'description',
                    'required',
                    'schema',
                    'type'
                  ]);
                  var validTypes = [
                      'string',
                      'number',
                      'integer',
                      'boolean',
                      'array',
                      'file'
                    ], defaultType = 'string';
                  for (var i in parameters) {
                    if (!parameters.hasOwnProperty(i))
                      continue;
                    if (parameters[i].in && parameters[i].in != 'body') {
                      if (Array.isArray(parameters[i].type)) {
                        if (parameters[i].type.length > 0) {
                          parameters[i].type = parameters[i].type[0];
                        } else {
                          parameters[i].type = defaultType;
                        }
                      }
                      if (validTypes.indexOf(parameters[i].type) < 0) {
                        //type not valid
                        parameters[i].type = defaultType;
                      }
                    }
                  }
                  return parameters;
                }
              },
              {
                key: '_mapEndpointSecurity',
                value: function _mapEndpointSecurity(securedByTypes, slSecuritySchemes) {
                  var rsecuredBy = [];
                  for (var index in securedByTypes) {
                    if (!securedByTypes.hasOwnProperty(index))
                      continue;
                    var securedName = void 0;
                    var scope = void 0;
                    if (typeof securedByTypes[index] === 'string') {
                      securedName = securedByTypes[index];
                      scope = [];
                    } else {
                      securedName = Object.keys(securedByTypes[index])[0];
                      scope = securedByTypes[index][securedName];
                    }
                    for (var _index in slSecuritySchemes.oauth2) {
                      if (!slSecuritySchemes.oauth2.hasOwnProperty(_index))
                        continue;
                      var current = slSecuritySchemes.oauth2[_index];
                      if (current.name === securedName) {
                        var _securedName = current.name || 'oauth2';
                        var scopes = {};
                        scopes[_securedName] = scope;
                        rsecuredBy.push(scopes);
                      }
                    }
                    for (var _index2 in slSecuritySchemes.basic) {
                      if (!slSecuritySchemes.basic.hasOwnProperty(_index2))
                        continue;
                      var _current = slSecuritySchemes.basic[_index2];
                      if (securedName === _current.name) {
                        var _scopes = {};
                        _scopes[_current.name] = scope;
                        rsecuredBy.push(_scopes);
                      }
                    }
                    if (slSecuritySchemes.apiKey) {
                      for (var _index3 in slSecuritySchemes.apiKey) {
                        if (!slSecuritySchemes.apiKey.hasOwnProperty(_index3))
                          continue;
                        var _current2 = slSecuritySchemes.apiKey[_index3];
                        if (securedName === _current2.name) {
                          var _scopes2 = {};
                          _scopes2[_current2.name] = scope;
                          rsecuredBy.push(_scopes2);
                        }
                      }
                    }
                  }
                  return rsecuredBy;
                }
              },
              {
                key: '_mapSecurityDefinitions',
                value: function _mapSecurityDefinitions(securityDefinitions) {
                  var result = {};
                  for (var type in securityDefinitions) {
                    if (!securityDefinitions.hasOwnProperty(type))
                      continue;
                    var sd = securityDefinitions[type];
                    switch (type) {
                    case 'apiKey':
                      for (var index in sd) {
                        if (!sd.hasOwnProperty(index))
                          continue;
                        var current = sd[index];
                        if (current.hasOwnProperty('headers') && current.headers.length > 0) {
                          for (var i in current.headers) {
                            if (!current.headers.hasOwnProperty(i))
                              continue;
                            var header = current.headers[i];
                            result[current.name] = {
                              name: header.name,
                              type: type,
                              in: 'header'
                            };
                            if (current.description) {
                              result[current.name]['description'] = current.description;
                            }
                          }
                        }
                        if (current.hasOwnProperty('queryString') && current.queryString.length > 0) {
                          for (var _i4 in current.queryString) {
                            if (!current.queryString.hasOwnProperty(_i4))
                              continue;
                            var _header = current.queryString[_i4];
                            result[current.name] = {
                              name: _header.name,
                              type: type,
                              in: 'query'
                            };
                            if (current.description) {
                              result[current.name]['description'] = current.description;
                            }
                          }
                        }
                      }
                      break;
                    case 'oauth2': {
                        for (var _index4 in sd) {
                          if (!sd.hasOwnProperty(_index4))
                            continue;
                          var _current3 = sd[_index4];
                          var slScopes = _current3.scopes;
                          var swaggerScopes = {};
                          for (var _i5 in slScopes) {
                            if (!slScopes.hasOwnProperty(_i5))
                              continue;
                            var scope = slScopes[_i5];
                            swaggerScopes[scope.name] = scope.value;
                          }
                          var oauth2 = {
                              type: type,
                              flow: _current3.flow,
                              scopes: swaggerScopes
                            };
                          if (_current3.description) {
                            oauth2.description = _current3.description;
                          }
                          if ([
                              'implicit',
                              'accessCode'
                            ].indexOf(_current3.flow) >= 0) {
                            oauth2['authorizationUrl'] = _current3.authorizationUrl;
                          }
                          if ([
                              'password',
                              'application',
                              'accessCode'
                            ].indexOf(_current3.flow) >= 0) {
                            oauth2['tokenUrl'] = _current3.tokenUrl;
                          }
                          result[_current3.name] = oauth2;
                        }
                        break;
                      }
                    case 'basic':
                      for (var _index5 in sd) {
                        if (!sd.hasOwnProperty(_index5))
                          continue;
                        var _current4 = sd[_index5];
                        var basic = { type: type };
                        if (!_.isEmpty(_current4.description)) {
                          basic.description = _current4.description;
                        }
                        result[_current4.name] = basic;
                      }
                      break;
                    }
                  }
                  return result;
                }
              },
              {
                key: 'convertTypes',
                value: function convertTypes(object) {
                  if (_.isArray(object)) {
                    for (var id in object) {
                      if (!object.hasOwnProperty(id))
                        continue;
                      var val = object[id];
                      if (val === 'null' || val === null) {
                        if (!object.includes('string'))
                          object[id] = 'string';
                        object.splice(id, 1);
                      }
                    }
                  }
                  return object.length == 1 ? object[0] : object;
                }
              },
              {
                key: 'convertDefinitions',
                value: function convertDefinitions(object) {
                  if (object.items.hasOwnProperty('$ref')) {
                    var ref = object.items.$ref.split('/');
                    var item = ref[ref.length - 1];
                    var definitions = object.definitions;
                    for (var id in definitions) {
                      if (!definitions.hasOwnProperty(id))
                        continue;
                      if (id === item) {
                        object['items'] = definitions[id];
                        delete definitions[id];
                        if (_.isEmpty(object.definitions))
                          delete object['definitions'];
                        break;
                      }
                    }
                  }
                  return object;
                }
              },
              {
                key: '_addPatternedObjects',
                value: function _addPatternedObjects(source, target) {
                  for (var key in source) {
                    if (!source.hasOwnProperty(key))
                      continue;
                    var value = source[key];
                    if (_.startsWith(key, 'x-')) {
                      target[key] = value;
                    }
                  }
                }
              },
              {
                key: '_isTemplateUri',
                value: function _isTemplateUri(uri) {
                  var decodeUri = decodeURI(uri);
                  return decodeUri.indexOf('{') !== -1 || decodeUri.indexOf('}') !== -1;
                }
              },
              {
                key: '_convertToTemplateUri',
                value: function _convertToTemplateUri(swaggerDef) {
                  swaggerDef['x-basePath'] = decodeURI(swaggerDef.basePath);
                  delete swaggerDef.basePath;
                }
              }
            ]);
            return Swagger;
          }(Exporter);
        module.exports = Swagger;
      },
      {
        '../entities/swagger/definition': 87,
        '../helpers/swagger': 98,
        '../utils/array.js': 106,
        '../utils/json.js': 107,
        '../utils/strings.js': 108,
        '../utils/url': 109,
        '../utils/xml.js': 110,
        './exporter': 91,
        'lodash': 79,
        'url': 183
      }
    ],
    96: [
      function (require, module, exports) {
        'use strict';
        var supportedFormats = {
            'AUTO': {
              name: 'Auto',
              className: 'Auto',
              formats: ['json'],
              import: true,
              export: false
            },
            'OAS': {
              name: 'OAS 2.0',
              className: 'Swagger',
              formats: [
                'json',
                'yaml'
              ],
              import: true,
              export: true
            },
            'RAML08': {
              name: 'RAML 0.8',
              className: 'RAML08',
              formats: ['yaml'],
              import: true,
              export: false
            },
            'RAML10': {
              name: 'RAML 1.0',
              className: 'RAML10',
              formats: ['yaml'],
              import: true,
              export: true
            }
          };
        module.exports = supportedFormats;
      },
      {}
    ],
    97: [
      function (require, module, exports) {
        'use strict';
        var _ = require('lodash');
        module.exports = {
          getValidCharacters: [
            'A',
            'B',
            'C',
            'D',
            'E',
            'F',
            'G',
            'H',
            'I',
            'J',
            'K',
            'L',
            'M',
            'N',
            'O',
            'P',
            'Q',
            'R',
            'S',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z',
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g',
            'h',
            'i',
            'j',
            'k',
            'l',
            'm',
            'n',
            'o',
            'p',
            'q',
            'r',
            's',
            't',
            'u',
            'v',
            'w',
            'x',
            'y',
            'z',
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            '.',
            '-',
            '_'
          ],
          getReplacementCharacter: '_',
          getRAML10ScalarTypes: [
            'string',
            'number',
            'integer',
            'boolean',
            'datetime',
            'date-only',
            'file',
            'array',
            'nil',
            'time-only',
            'datetime-only'
          ],
          getRAML08ScalarTypes: [
            'string',
            'number',
            'integer',
            'boolean',
            'datetime',
            'date-only',
            'file',
            'array',
            'null',
            'time-only',
            'datetime-only'
          ],
          getNumberTypes: [
            'number',
            'integer'
          ],
          getValidFormat: [
            'byte',
            'binary',
            'password',
            'date',
            'date-time'
          ],
          parameterMappings: {},
          getSupportedParameterFields: [
            'displayName',
            'type',
            'description',
            'default',
            'maximum',
            'minimum',
            'maxLength',
            'minLength',
            'pattern',
            'enum',
            'format',
            'collectionFormat',
            'allowEmptyValue',
            'exclusiveMaximum',
            'exclusiveMinimum',
            'maxItems',
            'minItems',
            'uniqueItems',
            'required',
            'facets',
            'items',
            'example',
            'examples',
            '(oas-allowEmptyValue)',
            '(oas-collectionFormat)',
            '(oas-exclusiveMaximum)',
            '(oas-exclusiveMinimum)'
          ],
          getRFC3339Format: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.(\d*)Z$/,
          getDateOnlyFormat: /^\d{4}[^-]\d{2}[^-]\d{2}$/,
          isNumberType: function isNumberType(type) {
            return this.getNumberTypes.indexOf(type) >= 0;
          },
          setParameterFields: function setParameterFields(source, target) {
            for (var prop in source) {
              if (!source.hasOwnProperty(prop))
                continue;
              if (this.getSupportedParameterFields.indexOf(prop) >= 0) {
                target[this.parameterMappings[prop] ? this.parameterMappings[prop] : prop] = typeof source[prop] === 'function' ? source[prop]() : source[prop];
                // call function if needed
                if (typeof target[prop] === 'function') {
                  target[prop] = target[prop]();
                }
                // transform Text nodes
                if (typeof target[prop] !== 'string' && target[prop] && target[prop].value) {
                  target[prop] = target[prop].value();
                }  // enums must be arrays
                else if (prop === 'enum' && typeof target[prop] === 'string') {
                  try {
                    target[prop] = JSON.parse(target[prop].replace(/\'/g, '"'));
                  } catch (e) {
                  }
                }
                if (!target.hasOwnProperty(prop) || _.isArray(target[prop]) && _.isEmpty(target[prop])) {
                  delete target[prop];
                }
              }
            }
            return target;
          },
          removeEmptyValueNodes: function removeEmptyValueNodes(object) {
            var result = {};
            for (var id in object) {
              if (!object.hasOwnProperty(id))
                continue;
              var value = object[id];
              if (_.isArray(value) && id !== 'example' && id !== 'examples') {
                var newArray = [];
                for (var index in value) {
                  if (!value.hasOwnProperty(index))
                    continue;
                  newArray.push(_.isObject(value[index]) ? this.removeEmptyValueNodes(value[index]) : value[index]);
                }
                result[id] = newArray;
              } else if (_.isObject(value) && !_.isDate(value) && id !== 'example' && id !== 'examples') {
                result[id] = this.removeEmptyValueNodes(value);
              } else {
                if (id === 'accessTokenUri' || id === 'content' || id === 'default' || !(value === null || value === ''))
                  result[id] = value;
              }
            }
            return result;
          }
        };
      },
      { 'lodash': 79 }
    ],
    98: [
      function (require, module, exports) {
        'use strict';
        module.exports = {
          parameterMappings: {},
          getSupportedParameterFields: [
            'type',
            'description',
            'default',
            'maximum',
            'exclusiveMaximum',
            'minimum',
            'exclusiveMinimum',
            'maxLength',
            'minLength',
            'pattern',
            'maxItems',
            'minItems',
            'uniqueItems',
            'enum',
            'multipleOf',
            'items',
            'format',
            'collectionFormat',
            'allowEmptyValue',
            'required',
            'x-raml-example'
          ],
          getSupportedSchemaFields: [
            '$ref',
            'format',
            'title',
            'description',
            'default',
            'multipleOf',
            'maximum',
            'exclusiveMaximum',
            'minimum',
            'exclusiveMinimum',
            'maxLength',
            'minLength',
            'pattern',
            'maxItems',
            'minItems',
            'uniqueItems',
            'maxProperties',
            'minProperties',
            'required',
            'enum',
            'type',
            'items',
            'allOf',
            'properties',
            'additionalProperties',
            'example',
            'discriminator',
            'xml',
            'schemaPath'
          ],
          setParameterFields: function setParameterFields(source, target) {
            for (var prop in source) {
              if (!source.hasOwnProperty(prop))
                continue;
              if (this.getSupportedParameterFields.indexOf(prop) >= 0) {
                if (this.parameterMappings[prop]) {
                  target[this.parameterMappings[prop]] = source[prop];
                } else {
                  target[prop] = source[prop];
                }
                // description must be a string
                if (prop === 'description') {
                  target[prop] = String(target[prop]);
                }
                // enums must be arrays
                if (prop === 'enum' && typeof target[prop] === 'string') {
                  try {
                    target[prop] = JSON.parse(target[prop].replace(/\'/g, '"'));
                  } catch (e) {
                  }
                }
              }
            }
            return target;
          },
          isExtension: function isExtension(id) {
            return id.substring(0, 2) === 'x-';
          }
        };
      },
      {}
    ],
    99: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var fs = require('fs'), _ = require('lodash'), Formats = require('../formats'), Importer = require('./importer'), urlHelper = require('../utils/url');
        var importers = {
            RAML08: require('./raml08'),
            RAML10: require('./raml10'),
            Swagger: require('./swagger')
          };
        var Auto = function (_Importer) {
            _inherits(Auto, _Importer);
            // Detect input format automatically
            function Auto() {
              _classCallCheck(this, Auto);
              var _this = _possibleConstructorReturn(this, (Auto.__proto__ || Object.getPrototypeOf(Auto)).call(this));
              _this.importer = null;
              return _this;
            }
            _createClass(Auto, [
              {
                key: 'loadData',
                value: function loadData(data, options, url) {
                  var _this2 = this;
                  return new Promise(function (resolve, reject) {
                    if (!data) {
                      return reject(new Error('No data provided'));
                    }
                    var detectedFormat = Auto.detectFormat(data);
                    if (!detectedFormat) {
                      return reject(new Error('Unable to parse file. Invalid or unsupported syntax.'));
                    }
                    return _this2._parse(detectedFormat, data, url, resolve, reject, options);
                  });
                }
              },
              {
                key: 'loadFile',
                value: function loadFile(filePath, options) {
                  var _this3 = this;
                  if (urlHelper.isURL(filePath)) {
                    // Remote file
                    return urlHelper.get(filePath).then(function (body) {
                      return _this3.loadData(body, options, filePath);
                    });
                  } else {
                    if (options && options.fsResolver) {
                      return options.fsResolver.contentAsync(filePath).then(function (fileContent) {
                        return _this3.loadData(fileContent, options, filePath);
                      });
                    } else {
                      // Local file
                      var fileContent = fs.readFileSync(filePath, 'utf8');
                      return this.loadData(fileContent, options);
                    }
                  }
                }
              },
              {
                key: '_import',
                value: function _import() {
                  return this.importer._import();
                }
              },
              {
                key: '_parse',
                value: function _parse(detectedFormat, data, url, resolve, reject, options) {
                  var _this4 = this;
                  var importer = new importers[detectedFormat.className]();
                  var promise = url ? importer.loadFile(url, options) : importer.loadData(data, options);
                  promise.then(function () {
                    _this4.data = importer.data;
                    _this4.importer = importer;
                    resolve();
                  }).catch(reject);
                }
              }
            ], [{
                key: 'detectFormat',
                value: function detectFormat(data) {
                  if (!data)
                    return;
                  data = _.trim(data);
                  if (/#%RAML[\s]*1\.?0?/.test(data))
                    return Formats.RAML10;
                  if (/#%RAML[\s]*0\.?8?/.test(data))
                    return Formats.RAML08;
                  if (/swagger:[\s'"]*\d\.?\d?/.test(data) || /{"swagger":[\s'"]*\d\.?\d?/.test(data))
                    return Formats.OAS;
                }
              }]);
            return Auto;
          }(Importer);
        module.exports = Auto;
      },
      {
        '../formats': 96,
        '../utils/url': 109,
        './importer': 101,
        './raml08': 103,
        './raml10': 104,
        './swagger': 105,
        'fs': 4,
        'lodash': 79
      }
    ],
    100: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Endpoint = require('../entities/endpoint'), Importer = require('./importer'), Project = require('../entities/project'), jsonHelper = require('../utils/json'), xmlHelper = require('../utils/xml'), ramlHelper = require('../helpers/raml'), Schema = require('../entities/schema'), url = require('url'), _ = require('lodash');
        var toJSONOptions = { serializeMetadata: false };
        //TODO multi file support isn't justified
        var RAMLImporter = function (_Importer) {
            _inherits(RAMLImporter, _Importer);
            function RAMLImporter() {
              _classCallCheck(this, RAMLImporter);
              var _this = _possibleConstructorReturn(this, (RAMLImporter.__proto__ || Object.getPrototypeOf(RAMLImporter)).call(this));
              _this.schemas = [];
              return _this;
            }
            _createClass(RAMLImporter, [
              {
                key: '_mapSecuritySchemes',
                value: function _mapSecuritySchemes(securitySchemes) {
                  var slSecurityScheme = {};
                  for (var i in securitySchemes) {
                    if (!securitySchemes.hasOwnProperty(i))
                      continue;
                    var securityScheme = securitySchemes[i];
                    for (var name in securityScheme) {
                      if (!securityScheme.hasOwnProperty(name))
                        continue;
                      var scheme = securityScheme[name];
                      switch (scheme.type) {
                      case 'Pass Through': {
                          if (!slSecurityScheme['apiKey']) {
                            slSecurityScheme['apiKey'] = [];
                          }
                          var apiKey = { name: name };
                          if (scheme.describedBy) {
                            if (scheme.describedBy.headers) {
                              for (var index in scheme.describedBy.headers) {
                                if (!scheme.describedBy.headers.hasOwnProperty(index))
                                  continue;
                                var current = scheme.describedBy.headers[index];
                                apiKey.headers = [];
                                apiKey.headers.push({ name: current.name });
                              }
                            }
                            if (scheme.describedBy.queryParameters) {
                              for (var _index in scheme.describedBy.queryParameters) {
                                if (!scheme.describedBy.queryParameters.hasOwnProperty(_index))
                                  continue;
                                var _current = scheme.describedBy.queryParameters[_index];
                                apiKey.queryString = [];
                                apiKey.queryString.push({ name: _current.name });
                              }
                            }
                          }
                          if (scheme.description) {
                            apiKey.description = scheme.description;
                          }
                          slSecurityScheme['apiKey'].push(apiKey);
                          break;
                        }
                      case 'OAuth 2.0': {
                          if (!slSecurityScheme['oauth2']) {
                            slSecurityScheme['oauth2'] = [];
                          }
                          var oauth = {
                              name: name,
                              authorizationUrl: scheme.settings.authorizationUri || '',
                              tokenUrl: scheme.settings.accessTokenUri || '',
                              scopes: []
                            };
                          if (Array.isArray(scheme.settings.scopes)) {
                            for (var scopeIndex in scheme.settings.scopes) {
                              if (!scheme.settings.scopes.hasOwnProperty(scopeIndex))
                                continue;
                              oauth.scopes.push({
                                name: scheme.settings.scopes[scopeIndex],
                                value: ''
                              });
                            }
                          }
                          //authorizationGrants are flow, only one supported in stoplight
                          var flow = !_.isEmpty(scheme.settings.authorizationGrants) ? scheme.settings.authorizationGrants[0] : 'code';
                          oauth = this.mapAuthorizationGrants(oauth, flow);
                          if (scheme.description) {
                            oauth.description = scheme.description;
                          }
                          slSecurityScheme['oauth2'].push(oauth);
                          break;
                        }
                      case 'Basic Authentication':
                        if (!slSecurityScheme['basic']) {
                          slSecurityScheme['basic'] = [];
                        }
                        slSecurityScheme['basic'].push({
                          name: name,
                          value: '',
                          description: scheme.description || ''
                        });
                        break;
                      default:  //TODO not supported
                      }
                    }
                  }
                  return slSecurityScheme;
                }
              },
              {
                key: '_mapRequestBody',
                value: function _mapRequestBody(methodBody, checkEmptyType) {
                  return this.mapRequestBody(methodBody, checkEmptyType);
                }
              },
              {
                key: '_mapHeadersParameters',
                value: function _mapHeadersParameters(queryParameters, traits) {
                  return this._mapParameters(queryParameters, traits, 'headers');
                }
              },
              {
                key: '_mapQueryParameters',
                value: function _mapQueryParameters(queryParameters, traits) {
                  return this._mapParameters(queryParameters, traits, 'queryParameters');
                }
              },
              {
                key: '_mapParameters',
                value: function _mapParameters(queryParameters, traits, parameterName) {
                  //avoid queryParameters from expand option.
                  if (traits) {
                    RAMLImporter._filterPropertiesFromTraits(queryParameters, traits, parameterName);
                  }
                  var queryString = {
                      type: 'object',
                      properties: {},
                      required: []
                    };
                  for (var key in queryParameters) {
                    if (!queryParameters.hasOwnProperty(key))
                      continue;
                    var qp = queryParameters[key];
                    var parameterFields = ramlHelper.setParameterFields(qp, {});
                    queryString.properties[key] = this.convertRefToModel(parameterFields, false);
                    RAMLImporter._convertRequiredToArray(qp, key, queryString.required);
                  }
                  return queryString;
                }
              },
              {
                key: '_mapQueryString',
                value: function _mapQueryString(queryString) {
                  var result = queryString;
                  delete result.typePropertyKind;
                  RAMLImporter._mapTypesFormats(queryString, false);
                  if (queryString.properties) {
                    queryString.required = [];
                  }
                  for (var paramId in queryString.properties) {
                    if (!queryString.properties.hasOwnProperty(paramId))
                      continue;
                    var param = queryString.properties[paramId];
                    RAMLImporter._convertRequiredToArray(param, paramId, queryString.required);
                  }
                  return result;
                }
              },
              {
                key: '_mapRequestHeaders',
                value: function _mapRequestHeaders(data, traits) {
                  return this._mapHeadersParameters(data, traits);
                }
              },
              {
                key: '_mapURIParams',
                value: function _mapURIParams(uriParams, path) {
                  var pathParams = {
                      type: 'object',
                      properties: {},
                      required: []
                    };
                  for (var i in uriParams) {
                    if (!uriParams.hasOwnProperty(i))
                      continue;
                    var key = uriParams[i];
                    if (!_.includes(path, key.name))
                      continue;
                    pathParams.properties[key.name] = { type: key.type || 'string' };
                    var description = key.displayName || key.description;
                    if (description) {
                      pathParams.properties[key.name]['description'] = description;
                    }
                    RAMLImporter._convertRequiredToArray(key, key.name, pathParams.required);
                    RAMLImporter._addAnnotations(key, pathParams.properties[key.name]);
                  }
                  return pathParams;
                }
              },
              {
                key: '_mapResponseBody',
                value: function _mapResponseBody(responses) {
                  var data = [];
                  for (var code in responses) {
                    if (!responses.hasOwnProperty(code))
                      continue;
                    var response = responses[code];
                    var result = {};
                    if (response.hasOwnProperty('body') && !_.isEmpty(response.body)) {
                      var mimeType = Object.keys(response.body)[0];
                      if (response.body[mimeType].hasOwnProperty('displayName')) {
                        //unnecessary property added after change to expand(true).
                        delete response.body[mimeType]['displayName'];
                      }
                      result = this.mapRequestBody(response.body[mimeType], false, mimeType);
                    }
                    result.codes = [response.code];
                    if (result.body) {
                      result.body = jsonHelper.parse(jsonHelper.cleanSchema(result.body));
                    }
                    if (response.headers) {
                      var r = {};
                      for (var index in response.headers) {
                        if (!response.headers.hasOwnProperty(index))
                          continue;
                        var header = response.headers[index];
                        if (!header.hasOwnProperty('type'))
                          header.type = 'string';
                        else
                          RAMLImporter._mapTypesFormats(header, false);
                        r[header.name] = this._mapQueryString(header);
                        delete r[header.name]['name'];
                        header = RAMLImporter._mapExamples(header);
                        if (header.description && _.isEmpty(header.description))
                          header.description = '';
                      }
                      result.headers = r;
                    }
                    if (response.description) {
                      result.description = _.isEmpty(response.description) ? '' : jsonHelper.stringify(response.description);
                    }
                    RAMLImporter._addAnnotations(response, result);
                    data.push(result);
                  }
                  return data;
                }
              },
              {
                key: '_mapSchemas',
                value: function _mapSchemas(schemData) {
                  //check if type attribute is abscent and fill with default value (type: string).
                  RAMLImporter._checkForDefaultType(schemData);
                  var schemas = [];
                  var newSchemas = [];
                  for (var index in schemData) {
                    if (!schemData.hasOwnProperty(index))
                      continue;
                    for (var schemaName in schemData[index]) {
                      if (!schemData[index].hasOwnProperty(schemaName))
                        continue;
                      var sd = new Schema(schemaName);
                      sd.Name = schemaName;
                      var schema = jsonHelper.parse(schemData[index][schemaName]);
                      if (schema.hasOwnProperty('definitions')) {
                        newSchemas = this.addDefinitions(schema, newSchemas);
                      }
                      sd.Definition = this._mapSchema(schemData[index][schemaName], true, false);
                      schemas.push(sd);
                    }
                  }
                  if (!_.isEmpty(newSchemas)) {
                    schemas = _.concat(schemas, this._mapSchemas(newSchemas));
                  }
                  return schemas;
                }
              },
              {
                key: 'addDefinitions',
                value: function addDefinitions(schema, schemas) {
                  var definitions = schema.definitions;
                  if (!schemas)
                    schemas = [];
                  for (var def in definitions) {
                    if (!definitions.hasOwnProperty(def))
                      continue;
                    var newSchema = {};
                    newSchema[def] = jsonHelper.stringify(definitions[def]);
                    var schemaNames = schemas.map(function (a) {
                        return Object.keys(a)[0];
                      });
                    if (!_.includes(schemaNames, def))
                      schemas.push(newSchema);
                  }
                  delete schema.definitions;
                  return schemas;
                }
              },
              {
                key: 'isValidRefValues',
                value: function isValidRefValues(values) {
                  if (!_.isArray(values)) {
                    return this.isValidRefValue(values);
                  }
                  var result = true;
                  for (var index = 0; index < values.length && result == true; index++) {
                    result = this.isValidRefValue(values[index]);
                  }
                  return result;
                }
              },
              {
                key: 'isValidRefValue',
                value: function isValidRefValue(value) {
                  return typeof value === 'string' && this.isDefinedAsSchema(this.getSchemas(this.data), value);
                }  // from type=type1 & schema=type1 to ref=type1
              },
              {
                key: 'convertRefToModel',
                value: function convertRefToModel(object, isSchema, isProperty) {
                  if (jsonHelper.isJson(object)) {
                    return object;
                  }
                  // if the object is a string, that means it's a direct ref/type
                  if (typeof object === 'string') {
                    if (this.isValidRefValue(object)) {
                      return { $ref: '#/definitions/' + object };
                    } else {
                      return object;
                    }
                  }
                  delete object.typePropertyKind;
                  for (var id in object) {
                    if (!object.hasOwnProperty(id))
                      continue;
                    var val = object[id];
                    if (!val)
                      continue;
                    if (id === 'type') {
                      if (_.isArray(object[id]) && object[id].length == 1)
                        object[id] = object[id][0];
                      val = object[id];
                      if (val !== 'object' && typeof val === 'string' && !xmlHelper.isXml(val)) {
                        object[id] = RAMLImporter._modifyUnionType(val);
                        val = object[id];
                      }
                      if (jsonHelper.isJson(val)) {
                        object = val;
                        delete object[id];
                      } else if (xmlHelper.isXml(val)) {
                        object.type = 'object';
                      } else if (this.isValidRefValues(val)) {
                        object.ref = val;
                        delete object[id];
                      }
                      if (!isProperty) {
                        RAMLImporter._mapTypesFormats(object, isSchema);
                      }
                    }
                    if (id === 'example' || id === 'examples') {
                      object = RAMLImporter._mapExamples(object);
                    } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                      if (id === 'items' && !val.hasOwnProperty('type') && !val.hasOwnProperty('properties')) {
                        if (!_.isArray(val))
                          val.type = 'string';
                        else {
                          object.items = { ref: val[0] };
                          return object;
                        }
                      }
                      if (id == 'fixedFacets') {
                        //delete garbage
                        delete object[id];
                      } else {
                        if (id == 'xml') {
                          //no process xml object
                          object[id] = val;
                        } else {
                          object[id] = this.convertRefToModel(val, isSchema, id === 'properties' && !isProperty);
                        }
                      }
                    } else if (id == 'name') {
                      //delete garbage
                      delete object[id];
                    }
                  }
                  return object;
                }
              },
              {
                key: '_mapEndpoint',
                value: function _mapEndpoint(project, resource, baseURI, pathParams) {
                  var resultParams = JSON.parse(JSON.stringify(pathParams));
                  var path = baseURI + resource.relativeUri;
                  if (resource.uriParameters) {
                    if (_.isEmpty(resultParams))
                      resultParams = this._mapURIParams(resource.uriParameters, path);
                    else {
                      var newParams = this._mapURIParams(resource.uriParameters, path);
                      _.merge(resultParams.properties, newParams.properties);
                      resultParams.required = _.concat(resultParams.required, newParams.required);
                    }
                  }
                  var mResource = {
                      path: path,
                      endpoints: [],
                      annotations: {}
                    };
                  if (resource.hasOwnProperty('is')) {
                    mResource.is = resource.is;
                  }
                  if (resource.displayName) {
                    mResource.displayName = resource.displayName;
                  }
                  if (resource.description) {
                    mResource.description = resource.description;
                  }
                  RAMLImporter._addAnnotations(resource, mResource.annotations);
                  var methods = resource.methods;
                  for (var i in methods) {
                    if (!methods.hasOwnProperty(i))
                      continue;
                    var method = methods[i];
                    var summary = method.summary ? method.summary : '';
                    var endpoint = new Endpoint(summary);
                    endpoint.Method = method.method;
                    endpoint.Path = baseURI + resource.relativeUri;
                    endpoint.Description = method.description ? jsonHelper.stringify(method.description) : '';
                    endpoint.SetOperationId(method.displayName);
                    if (method.body) {
                      var c = RAMLImporter.mapMimeTypes(method.body, this.data.mediaType);
                      endpoint.Consumes = c.length > 0 ? c : null;
                      this.mapRequestBodies(endpoint, method.body, true);
                    }
                    if (method.queryParameters) {
                      endpoint.QueryString = this._mapQueryParameters(method.queryParameters, this.data.traits);
                    } else if (method.queryString) {
                      endpoint.QueryString = this._mapQueryString(method.queryString);
                    }
                    if (method.headers) {
                      endpoint.Headers = this._mapRequestHeaders(method.headers, this.data.traits);
                    }
                    if (method.responses) {
                      var produces = [];
                      for (var code in method.responses) {
                        if (!method.responses.hasOwnProperty(code))
                          continue;
                        if (!method.responses[code] || !method.responses[code].body) {
                          continue;
                        }
                        produces = produces.concat(RAMLImporter.mapMimeTypes(method.responses[code].body, this.data.mediaType));
                      }
                      var p = _.uniq(produces);
                      endpoint.Produces = p.length > 0 ? p : null;
                      endpoint.Responses = this._mapResponseBody(method.responses);
                    }
                    endpoint.traits = [];
                    var isMethod = _.union(resource.is, method.is);
                    if (isMethod) {
                      if (isMethod instanceof Array) {
                        endpoint.traits = isMethod;
                      } else if (isMethod instanceof Object) {
                        endpoint.traits = Object.keys(isMethod);
                      }
                    }
                    if (method.hasOwnProperty('is')) {
                      endpoint.is = method.is;
                    }
                    endpoint.PathParams = resultParams;
                    //endpoint security
                    var securedBy = method.securedBy;
                    if (Array.isArray(securedBy)) {
                      endpoint.securedBy = [];
                      for (var si in securedBy) {
                        if (!securedBy.hasOwnProperty(si))
                          continue;
                        if (typeof securedBy[si] === 'string') {
                          endpoint.securedBy.push(securedBy[si]);
                        } else {
                          for (var index in securedBy[si]) {
                            if (!securedBy[si].hasOwnProperty(index))
                              continue;
                            var current = securedBy[si][index];
                            if (current.scopes) {
                              var elem = {};
                              elem[index] = current.scopes;
                              endpoint.securedBy.push(elem);
                            } else {
                              endpoint.securedBy.push(index);
                            }
                          }
                        }
                      }
                    }
                    //add annotations
                    RAMLImporter._addAnnotations(method, endpoint);
                    //TODO endpoint security
                    mResource.endpoints.push(endpoint);
                  }
                  project.addResource(mResource);
                  var resources = resource.resources;
                  if (resources && resources.length > 0) {
                    for (var j = 0; j < resources.length; j++) {
                      this._mapEndpoint(project, resources[j], baseURI + resource.relativeUri, resultParams);
                    }
                  }
                }
              },
              {
                key: 'loadFile',
                value: function loadFile(filePath, options) {
                  var _this2 = this;
                  return new Promise(function (resolve, reject) {
                    var parser = window.RAML.Parser;
                    parser.loadApi(filePath, RAMLImporter._options(options)).then(function (api) {
                      try {
                        _this2.data = api.expand(true).toJSON(toJSONOptions);
                        resolve();
                      } catch (e) {
                        reject(e);
                      }
                    }).catch(reject);
                  });
                }
              },
              {
                key: 'loadData',
                value: function loadData(data, options) {
                  var _this3 = this;
                  return new Promise(function (resolve, reject) {
                    try {
                      var parser = window.RAML.Parser;
                      var parsedData = parser.parseRAMLSync(data, RAMLImporter._options(options));
                      if (parsedData.name === 'Error') {
                        reject(error);
                      } else {
                        _this3.data = parsedData.expand(true).toJSON(toJSONOptions);
                        resolve();
                      }
                    } catch (e) {
                      reject(e);
                    }
                  });
                }
              },
              {
                key: '_mapHost',
                value: function _mapHost(project) {
                  var parsedURL = url.parse(this.data.baseUri || '');
                  project.Environment.Host = parsedURL.protocol && parsedURL.host ? parsedURL.protocol + '//' + parsedURL.host : null;
                  project.Environment.BasePath = parsedURL.path;
                  if (this.data.hasOwnProperty('scalarsAnnotations') && this.data.scalarsAnnotations.hasOwnProperty('baseUri')) {
                    var annotations = _.reduce(this.data.scalarsAnnotations.baseUri, function (obj, param) {
                        obj[param.name] = { structuredValue: param.structuredValue };
                        return obj;
                      }, {});
                    RAMLImporter._addAnnotations({ annotations: annotations }, project.Environment);
                  }
                }
              },
              {
                key: '_mapTraits',
                value: function _mapTraits(traitGroups, parametric) {
                  var slTraits = [];
                  for (var i in traitGroups) {
                    if (!traitGroups.hasOwnProperty(i))
                      continue;
                    var traitGroup = traitGroups[i];
                    for (var k in traitGroup) {
                      if (!traitGroup.hasOwnProperty(k))
                        continue;
                      var trait = traitGroup[k];
                      var slTrait = {
                          _id: k,
                          name: k,
                          description: '',
                          request: {},
                          responses: []
                        };
                      if (!_.isEmpty(trait.usage)) {
                        slTrait.description = jsonHelper.stringify(trait.usage);
                      } else {
                        delete slTrait.description;
                      }
                      if (trait.queryParameters) {
                        var queryString = RAMLImporter._filterParametricTraits(this._mapQueryParameters(trait.queryParameters), parametric);
                        if (!_.isEmpty(queryString.properties))
                          slTrait.request.queryString = queryString;
                      }
                      if (trait.headers) {
                        var headers = RAMLImporter._filterParametricTraits(this._mapRequestHeaders(trait.headers), parametric);
                        if (!_.isEmpty(headers.properties))
                          slTrait.request.headers = headers;
                      }
                      if (trait.responses) {
                        slTrait.responses = this._mapResponseBody(trait.responses);
                      } else {
                        delete slTrait.responses;
                      }
                      slTraits.push(slTrait);
                    }
                  }
                  return slTraits;
                }
              },
              {
                key: '_import',
                value: function _import() {
                  try {
                    var project = new Project(this.data.title);
                    project.Environment.Version = this.data.version;
                    if (!project.Environment.Version) {
                      delete project.Environment.Version;
                    }
                    // TODO set project description from documentation
                    // How to know which documentation describes the project briefly?
                    this.description(project, this.data);
                    this._mapHost(project);
                    if (!_.isEmpty(this.data.protocols)) {
                      project.Environment.Protocols = this.data.protocols;
                      for (var i in project.Environment.Protocols) {
                        if (!project.Environment.Protocols.hasOwnProperty(i))
                          continue;
                        project.Environment.Protocols[i] = project.Environment.Protocols[i].toLowerCase();
                      }
                    }
                    var mimeTypes = [];
                    var mediaType = this.data.mediaType;
                    if (mediaType) {
                      if (!_.isArray(mediaType)) {
                        mediaType = [mediaType];
                      }
                      for (var _i in mediaType) {
                        if (!mediaType.hasOwnProperty(_i))
                          continue;
                        if (mediaType[_i]) {
                          mimeTypes.push(mediaType[_i]);
                        }
                      }
                    }
                    if (mimeTypes.length) {
                      project.Environment.Produces = mimeTypes;
                      project.Environment.Consumes = mimeTypes;
                    }
                    project.Environment.SecuritySchemes = this._mapSecuritySchemes(this.data.securitySchemes);
                    var resources = this.data.resources;
                    if (!_.isEmpty(resources)) {
                      for (var _i2 = 0; _i2 < resources.length; _i2++) {
                        this._mapEndpoint(project, resources[_i2], '', {});
                      }
                    }
                    var schemas = this._mapSchemas(this.getSchemas(this.data));
                    for (var s in schemas) {
                      if (!schemas.hasOwnProperty(s))
                        continue;
                      project.addSchema(schemas[s]);
                    }
                    project.traits = this._mapTraits(this.data.traits, false);
                    project.parametricTraits = this._mapTraits(this.data.traits, true);
                    project.uses = this.data.uses;
                    RAMLImporter._addAnnotations(this.data, project);
                    return project;
                  } catch (e) {
                    console.error('raml#import', e);
                    throw e;
                  }
                }
              },
              {
                key: 'mapRequestBodies',
                value: function mapRequestBodies(endpoint, methodBodies, checkEmptyType) {
                  for (var mimeType in methodBodies) {
                    if (!methodBodies.hasOwnProperty(mimeType))
                      continue;
                    var methodBody = methodBodies[mimeType];
                    endpoint.Body = this.mapRequestBody(methodBody, checkEmptyType, mimeType);
                  }
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: 'description',
                value: function description() {
                  throw new Error('description method not implemented');
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: 'mapRequestBody',
                value: function mapRequestBody() {
                  throw new Error('mapRequestBody method not implemented');
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: '_mapSchema',
                value: function _mapSchema() {
                  throw new Error('mapSchema method not implemented');
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: 'getSchemas',
                value: function getSchemas() {
                  throw new Error('getSchema method not implemented');
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: 'mapAuthorizationGrants',
                value: function mapAuthorizationGrants() {
                  throw new Error('convertAuthorizationGrants method not implemented');
                }
              },
              {
                key: 'isDefinedAsSchema',
                value: function isDefinedAsSchema() {
                  throw new Error('isDefinedAsSchema method not implemented');
                }
              }
            ], [
              {
                key: 'getCustomProperty',
                value: function getCustomProperty(propName) {
                  return '__custom-' + propName;
                }
              },
              {
                key: '_filterPropertiesFromTraits',
                value: function _filterPropertiesFromTraits(params, traits, propertyName) {
                  for (var i in traits) {
                    if (!traits.hasOwnProperty(i))
                      continue;
                    for (var j in traits[i]) {
                      if (!traits[i].hasOwnProperty(j))
                        continue;
                      var param = traits[i][j];
                      if (param.hasOwnProperty(propertyName)) {
                        for (var k in param[propertyName]) {
                          if (!param[propertyName].hasOwnProperty(k))
                            continue;
                          var p = param[propertyName][k];
                          var isParametricTrait = RAMLImporter._isParametricTrait(p);
                          var found = _.find(params, { name: p.name });
                          if (found && !isParametricTrait) {
                            delete params[k];
                          }
                        }
                      }
                    }
                  }
                }
              },
              {
                key: '_isParametricTrait',
                value: function _isParametricTrait(trait) {
                  var result = false;
                  for (var id in trait) {
                    if (!trait.hasOwnProperty(id))
                      continue;
                    var prop = trait[id];
                    if ((typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object' && id !== 'required') {
                      result = this._isParametricTrait(prop);
                    } else {
                      if (_.includes(prop, '<<') && _.includes(prop, '>>'))
                        result = true;
                      else if (typeof prop === 'number' && _.isNaN(prop))
                        result = true;
                    }
                  }
                  return result;
                }
              },
              {
                key: '_convertRequiredToArray',
                value: function _convertRequiredToArray(object, key, required) {
                  if (!object.hasOwnProperty('required') || object.required === true) {
                    required.push(key);
                  }
                  delete object.required;
                }
              },
              {
                key: '_mapTypesFormats',
                value: function _mapTypesFormats(object, isSchema) {
                  if (!object.hasOwnProperty('type') || object.type === 'object')
                    return object;
                  var type = _.isArray(object.type) && object.type.length == 1 ? object.type[0] : object.type;
                  object.type = type;
                  switch (type) {
                  case 'date-only':
                    object.type = 'string';
                    object.format = 'date';
                    break;
                  case 'time-only':
                    object.type = 'string';
                    object[RAMLImporter.getCustomProperty('format')] = 'time-only';
                    break;
                  case 'datetime-only':
                    object.type = 'string';
                    object[RAMLImporter.getCustomProperty('format')] = 'datetime-only';
                    break;
                  case 'datetime':
                    object.type = 'string';
                    if (object.format == 'rfc3339' || !object.hasOwnProperty('format')) {
                      object.format = 'date-time';
                    } else {
                      object[RAMLImporter.getCustomProperty('format')] = object.format;
                      delete object.format;
                    }
                    break;
                  case 'file':
                    if (isSchema) {
                      object.type = 'string';
                      object[RAMLImporter.getCustomProperty('type')] = 'file';
                    }
                    if (object.hasOwnProperty('fileTypes')) {
                      object[RAMLImporter.getCustomProperty('fileTypes')] = object['fileTypes'];
                      delete object['fileTypes'];
                    }
                    break;
                  default:
                    if (typeof type === 'string' && (type.includes('|') || type.includes('?'))) {
                      object.type = 'object';
                    } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) !== 'object' && ramlHelper.getRAML10ScalarTypes.indexOf(type) < 0) {
                      object[RAMLImporter.getCustomProperty('type')] = type;
                      object.type = 'string';
                    }
                    break;
                  }
                }
              },
              {
                key: '_checkForDefaultType',
                value: function _checkForDefaultType(schemas) {
                  for (var index in schemas) {
                    if (!schemas.hasOwnProperty(index))
                      continue;
                    for (var id in schemas[index]) {
                      if (!schemas[index].hasOwnProperty(id))
                        continue;
                      var schema = schemas[index][id];
                      RAMLImporter._fillDefaultType(schema);
                    }
                  }
                }
              },
              {
                key: '_fillDefaultType',
                value: function _fillDefaultType(object) {
                  if (object.properties) {
                    for (var id in object.properties) {
                      if (!object.properties.hasOwnProperty(id))
                        continue;
                      var current = object.properties[id];
                      RAMLImporter._fillDefaultType(current);
                    }
                  } else {
                    if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !object.hasOwnProperty('type') && !object.hasOwnProperty('schema')) {
                      object.type = ['string'];
                    }
                  }
                }
              },
              {
                key: '_modifyUnionType',
                value: function _modifyUnionType(type) {
                  if (type.includes('|') || type.includes('?'))
                    type = 'object';
                  return type;
                }
              },
              {
                key: 'mapMimeTypes',
                value: function mapMimeTypes(body, skip) {
                  var result = [];
                  var skipMimeTypes = [];
                  for (var i in skip) {
                    if (!skip.hasOwnProperty(i))
                      continue;
                    if (skip[i].value) {
                      skipMimeTypes.push(skip[i].value);
                    }
                  }
                  for (var _i3 in body) {
                    if (!body.hasOwnProperty(_i3))
                      continue;
                    var b = body[_i3];
                    if (b.name) {
                      var mimeType = b.name;
                      if (skipMimeTypes.indexOf(mimeType) === -1) {
                        result.push(mimeType);
                      }
                    }
                  }
                  return _.uniq(result);
                }
              },
              {
                key: '_options',
                value: function _options(options) {
                  var validate = options && (options.validate === true || options.validateImport === true);
                  var parseOptions = {
                      attributeDefaults: false,
                      rejectOnErrors: validate
                    };
                  return !options ? parseOptions : _.merge(parseOptions, options);
                }
              },
              {
                key: '_filterParametricTraits',
                value: function _filterParametricTraits(traits, parametric) {
                  var result = {
                      properties: {},
                      required: []
                    };
                  for (var id in traits.properties) {
                    if (!traits.properties.hasOwnProperty(id))
                      continue;
                    var trait = traits.properties[id];
                    var isParametric = RAMLImporter._isParametricTrait(trait);
                    if (isParametric && !parametric)
                      continue;
                    if (!isParametric && parametric)
                      continue;
                    result.properties[id] = trait;
                    if (_.indexOf(traits.required, id) >= 0) {
                      result.required.push(id);
                    }
                  }
                  return result;
                }
              },
              {
                key: '_addAnnotations',
                value: function _addAnnotations(source, target) {
                  if (!source.annotations)
                    return;
                  var annotations = source.annotations;
                  for (var i in annotations) {
                    if (!annotations.hasOwnProperty(i))
                      continue;
                    if (_.startsWith(i, 'oas-'))
                      continue;
                    var value = annotations[i];
                    var key = 'x-annotation-' + i;
                    target[key] = value.structuredValue || '';
                  }
                  if (target.annotations)
                    delete target.annotations;
                }
              },
              {
                key: '_mapExamples',
                value: function _mapExamples(object) {
                  if (object.hasOwnProperty('example')) {
                    var example = object.example;
                    if (object.hasOwnProperty('structuredExample')) {
                      example = object.structuredExample;
                      delete object.structuredExample;
                    }
                    if (example.hasOwnProperty('structuredValue')) {
                      object.example = example.structuredValue;
                    } else if (example.hasOwnProperty('value')) {
                      object.example = JSON.parse(example.value);
                    }
                    if (example.hasOwnProperty('strict') && !example.strict) {
                      object.example.strict = false;
                    }
                    if (example.hasOwnProperty('name') && example.name) {
                      object.example[RAMLImporter.getCustomProperty('example-name')] = example.name;
                    }
                  } else if (object.hasOwnProperty('examples')) {
                    var examples = object.examples;
                    for (var id in examples) {
                      if (!examples.hasOwnProperty(id))
                        continue;
                      var _example = examples[id];
                      if (_example.hasOwnProperty('structuredValue')) {
                        object.examples[id] = _example.structuredValue;
                      } else if (_example.hasOwnProperty('value')) {
                        object.examples[id] = JSON.parse(_example.value);
                      }
                      if (_example.hasOwnProperty('strict') && !_example.strict) {
                        object.examples[id].strict = false;
                      }
                      if (_example.hasOwnProperty('name') && _example.name) {
                        object.examples[id][RAMLImporter.getCustomProperty('example-name')] = _example.name;
                      }
                    }
                  }
                  return object;
                }
              }
            ]);
            return RAMLImporter;
          }(Importer);
        module.exports = RAMLImporter;
      },
      {
        '../entities/endpoint': 83,
        '../entities/project': 85,
        '../entities/schema': 86,
        '../helpers/raml': 97,
        '../utils/json': 107,
        '../utils/xml': 110,
        './importer': 101,
        'lodash': 79,
        'url': 183
      }
    ],
    101: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Importer = function () {
            function Importer() {
              _classCallCheck(this, Importer);
              this.data = null;
            }
            _createClass(Importer, [
              {
                key: 'loadFile',
                value: function loadFile() {
                  throw new Error('loadFile method not implemented');
                }
              },
              {
                key: 'loadData',
                value: function loadData(data) {
                  // TODO validation of the data
                  this.data = data;
                  return new Promise(function (resolve) {
                    resolve();
                  });
                }
              },
              {
                key: '_import',
                value: function _import() {
                  throw new Error('_import method not implemented');
                }  //noinspection ReservedWordAsName
              },
              {
                key: 'import',
                value: function _import() {
                  if (!this.IsDataLoaded) {
                    throw new Error('data not loaded for ' + this.constructor.name.toString());
                  }
                  return this._import();
                }
              },
              {
                key: '_mapEndpoint',
                value: function _mapEndpoint() {
                  throw new Error('_mapEndpoint method not implemented');
                }
              },
              {
                key: '_mapSchema',
                value: function _mapSchema() {
                  throw new Error('_mapSchema method not implemented');
                }
              },
              {
                key: '_mapQueryString',
                value: function _mapQueryString() {
                  throw new Error('_mapQueryString method not implemented');
                }
              },
              {
                key: '_mapURIParams',
                value: function _mapURIParams() {
                  throw new Error('_mapURIParams method not implemented');
                }
              },
              {
                key: '_mapRequestBody',
                value: function _mapRequestBody() {
                  throw new Error('_mapRequestBody method not implemented');
                }
              },
              {
                key: '_mapResponseBody',
                value: function _mapResponseBody() {
                  throw new Error('_mapResponseBody method not implemented');
                }
              },
              {
                key: '_mapRequestHeaders',
                value: function _mapRequestHeaders() {
                  throw new Error('_mapRequestHeaders method not implemented');
                }
              },
              {
                key: 'IsDataLoaded',
                get: function get() {
                  //noinspection JSConstructorReturnsPrimitive
                  return this.data !== null;
                }
              }
            ]);
            return Importer;
          }();
        module.exports = Importer;
      },
      {}
    ],
    102: [
      function (require, module, exports) {
        'use strict';
        var importers = {
            RAML08: require('./raml08'),
            RAML10: require('./raml10'),
            Swagger: require('./swagger'),
            Auto: require('./auto')
          };
        function doesSupportFormat(format) {
          return !(!format || !format.name || !importers.hasOwnProperty(format.className));
        }
        module.exports = {
          hasSupport: doesSupportFormat,
          factory: function factory(format) {
            if (!doesSupportFormat(format)) {
              return null;
            }
            return new importers[format.className]();
          }
        };
      },
      {
        './auto': 99,
        './raml08': 103,
        './raml10': 104,
        './swagger': 105
      }
    ],
    103: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var RAMLImporter = require('./baseraml'), jsonHelper = require('../utils/json'), ramlHelper = require('../helpers/raml'), Text = require('../entities/text'), _ = require('lodash');
        var RAML08Importer = function (_RAMLImporter) {
            _inherits(RAML08Importer, _RAMLImporter);
            function RAML08Importer() {
              _classCallCheck(this, RAML08Importer);
              return _possibleConstructorReturn(this, (RAML08Importer.__proto__ || Object.getPrototypeOf(RAML08Importer)).call(this));
            }
            _createClass(RAML08Importer, [
              {
                key: 'mapRequestBody',
                value: function mapRequestBody(methodBody, checkEmptyType, mimeType) {
                  var data = {
                      mimeType: '',
                      body: {},
                      example: ''
                    };
                  data.mimeType = mimeType;
                  if (methodBody.example) {
                    data.example = methodBody.example;
                  }
                  if (methodBody.schema) {
                    var schema = jsonHelper.parse(methodBody.schema);
                    if (schema.hasOwnProperty('definitions')) {
                      this.data.schemas = this.addDefinitions(schema, this.data.schemas);
                      methodBody.schema = jsonHelper.stringify(schema);
                    }
                    data.body = this._mapSchema(this.convertRefToModel(jsonHelper.parse(methodBody.schema), false));
                  } else if (methodBody.formParameters) {
                    data.body = {
                      type: 'object',
                      'properties': {},
                      'required': []
                    };
                    var formParams = methodBody.formParameters;
                    for (var j in formParams) {
                      if (!formParams.hasOwnProperty(j))
                        continue;
                      var param = formParams[j];
                      data.body.properties[param.name] = { type: param.type };
                      if (param.description) {
                        data.body.properties[param.name].description = param.description;
                      }
                      if (param.required) {
                        data.body.required.push(param.name);
                      }
                    }
                  }
                  return data;
                }
              },
              {
                key: 'isDefinedAsSchema',
                value: function isDefinedAsSchema(schemas, schemaId) {
                  for (var i in schemas) {
                    if (!schemas.hasOwnProperty(i))
                      continue;
                    for (var schemaName in schemas[i]) {
                      if (!schemas[i].hasOwnProperty(schemaName))
                        continue;
                      if (schemaName === schemaId)
                        return true;
                    }
                  }
                  return false;
                }
              },
              {
                key: '_mapSchema',
                value: function _mapSchema(definition, isSchema, isProperty) {
                  if (typeof definition === 'string')
                    definition = jsonHelper.parse(definition);
                  if (typeof definition === 'string')
                    return definition;
                  if (!isProperty)
                    definition.required = definition.hasOwnProperty('required') && _.isArray(definition.required) ? definition.required : [];
                  for (var id in definition.properties) {
                    if (!definition.properties.hasOwnProperty(id))
                      continue;
                    var property = definition.properties[id];
                    property = _.isArray(property) ? property[0] : property;
                    definition.properties[id] = property;
                    if (property.hasOwnProperty('required') && typeof property.required === 'boolean' && !isProperty) {
                      if (property.required && !definition.required.includes(id)) {
                        definition.required.push(id);
                      }
                      delete property.required;
                    }
                  }
                  for (var _id in definition) {
                    if (!definition.hasOwnProperty(_id))
                      continue;
                    var val = definition[_id];
                    if (!isProperty) {
                      if (_id === 'items') {
                        if (_.isArray(val) && val.length == 0) {
                          definition[_id] = { type: 'string' };
                        } else if (_.isArray(val) || val.hasOwnProperty('0')) {
                          for (var key in val) {
                            if (!val.hasOwnProperty(key))
                              continue;
                            definition[_id][key] = this._mapSchema(val[key], isSchema, false);
                          }
                        } else {
                          definition[_id] = this._mapSchema(val, isSchema, false);
                        }
                      } else if (_id === 'type') {
                        if (_.isArray(val)) {
                          if (val.length == 1)
                            val = val[0];
                          else if (val.length == 0) {
                            definition[_id] = 'array';
                            definition['items'] = { type: 'string' };
                            val = 'array';
                          }
                        }
                        if (typeof val === 'string' && val != 'object' && ramlHelper.getRAML08ScalarTypes.indexOf(val) < 0) {
                          definition[RAMLImporter.getCustomProperty('type')] = val;
                          definition.type = 'string';
                        }
                        if (typeof val === 'string' && val === 'array' && !definition.hasOwnProperty('items')) {
                          if (definition.hasOwnProperty('properties')) {
                            definition.items = {
                              type: 'object',
                              properties: this._mapSchema(definition.properties, isSchema, !isProperty)
                            };
                            if (definition.hasOwnProperty('required') && !_.isEmpty(definition.required)) {
                              definition.items.required = definition.required;
                              delete definition.required;
                            }
                            delete definition.properties;
                          } else {
                            definition.items = { type: 'string' };
                          }
                        }
                      } else if (_id === 'properties') {
                        definition[_id] = this._mapSchema(val, isSchema, !isProperty);
                      }
                    } else {
                      definition[_id] = this._mapSchema(val, isSchema, false);
                    }
                  }
                  if (definition.required && definition.required.length == 0) {
                    delete definition.required;
                  }
                  return definition;
                }  //noinspection JSMethodCanBeStatic
              },
              {
                key: 'getSchemas',
                value: function getSchemas(data) {
                  return data.schemas;
                }
              },
              {
                key: 'mapAuthorizationGrants',
                value: function mapAuthorizationGrants(oauth, flow) {
                  switch (flow) {
                  case 'code':
                    oauth.flow = 'accessCode';
                    break;
                  case 'token':
                    oauth.flow = 'implicit';
                    break;
                  case 'credentials':
                    oauth.flow = 'application';
                    break;
                  case 'owner':
                    oauth.flow = 'password';
                    break;
                  }
                  return oauth;
                }
              },
              {
                key: 'description',
                value: function description(project, data) {
                  var documentation = data.documentation;
                  if (documentation && documentation.length > 0) {
                    project.Description = documentation[0].content;
                    project.Environment.summary = documentation[0].content;
                  }
                  // text sections
                  if (documentation) {
                    for (var i in documentation) {
                      if (!documentation.hasOwnProperty(i))
                        continue;
                      var doc = documentation[i];
                      var txt = new Text(doc.title);
                      txt.Public = true;
                      txt.Content = doc.content;
                      project.addText(txt);
                    }
                  }
                }
              }
            ]);
            return RAML08Importer;
          }(RAMLImporter);
        module.exports = RAML08Importer;
      },
      {
        '../entities/text': 89,
        '../helpers/raml': 97,
        '../utils/json': 107,
        './baseraml': 100,
        'lodash': 79
      }
    ],
    104: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var RAMLImporter = require('./baseraml'), jsonHelper = require('../utils/json'), _ = require('lodash');
        var RAML10Importer = function (_RAMLImporter) {
            _inherits(RAML10Importer, _RAMLImporter);
            function RAML10Importer() {
              _classCallCheck(this, RAML10Importer);
              return _possibleConstructorReturn(this, (RAML10Importer.__proto__ || Object.getPrototypeOf(RAML10Importer)).call(this));
            }
            _createClass(RAML10Importer, [
              {
                key: 'mapRequestBody',
                value: function mapRequestBody(methodBody, checkEmptyType, mimeType) {
                  var data = { mimeType: '' };
                  if (checkEmptyType) {
                    RAMLImporter._fillDefaultType(methodBody);
                  }
                  data.mimeType = mimeType;
                  if (methodBody.description) {
                    data.description = methodBody.description;
                    delete methodBody.description;
                  }
                  if (methodBody.properties && !_.isEmpty(methodBody.properties)) {
                    switch (data.mimeType) {
                    case 'application/json':
                      data.body = this._mapSchema(methodBody, true, false);
                      // data.body = RAML10Importer.convertObjectProperty(mimeType);
                      delete data.body.description;
                      // delete data.body.type;
                      break;
                    case 'multipart/form-data':
                    case 'application/x-www-form-urlencoded': {
                        data.body = {
                          type: 'object',
                          'properties': {},
                          'required': []
                        };
                        var formParams = methodBody.properties;
                        for (var j in formParams) {
                          if (!formParams.hasOwnProperty(j))
                            continue;
                          var param = formParams[j];
                          var bodyType = !_.isEmpty(param.type) ? param.type[0] : param.type;
                          data.body.properties[param.name] = { type: bodyType };
                          if (param.description) {
                            data.body.properties[param.name].description = param.description;
                          }
                          if (param.format) {
                            data.body.properties[param.name].format = param.format;
                          }
                          RAMLImporter._convertRequiredToArray(param, param.name, data.body.required);
                        }
                        break;
                      }
                    default:
                    }
                  } else if (RAML10Importer.isArray(methodBody)) {
                    data.body = this.convertRefToModel(this.convertArray(methodBody), false, false);
                  } else if (methodBody.schema && !_.isEmpty(methodBody.schema)) {
                    var schema = _.isArray(methodBody.schema) ? methodBody.schema[0] : methodBody.schema;
                    if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) !== 'object')
                      schema = jsonHelper.parse(schema);
                    if (schema.hasOwnProperty('definitions')) {
                      this.data.types = this.addDefinitions(schema, this.data.types);
                    }
                    data.body = this._mapSchema(this.convertRefToModel({ type: schema }, false), false, false);
                  } else if (methodBody.type && !_.isEmpty(methodBody.type) && methodBody.type[0] !== 'object') {
                    data.body = this._mapSchema(methodBody, false, false);  // data.body = RAMLImporter.convertRefToModel({
                                                                            // 	type: mimeType.type[0]
                                                                            // });
                  }
                  return data;
                }
              },
              {
                key: 'convertArrayTypeExpression',
                value: function convertArrayTypeExpression(param) {
                  var valid = true;
                  var result = {};
                  var types = [];
                  for (var i = 0; i < param.length; i++) {
                    var key = param[i];
                    if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                      if (key.hasOwnProperty('type') && typeof key.type[0] === 'string' && this.isValidRefValue(key.type[0])) {
                        types.push(key.type[0]);
                      } else {
                        valid = false;
                        break;
                      }
                    }
                  }
                  if (valid) {
                    result['name'] = param[0].name;
                    result['type'] = types;
                    result['typePropertyKind'] = 'TYPE_EXPRESSION';
                    return result;
                  }
                  return param;
                }
              },
              {
                key: 'convertObjectProperty',
                value: function convertObjectProperty(source) {
                  var _this2 = this;
                  var target = Object.assign({}, source);
                  target.properties = {};
                  if (source.type !== 'array')
                    target.type = 'object';
                  target.required = [];
                  if (source.hasOwnProperty('description') && !_.isEmpty(source.description)) {
                    target.description = jsonHelper.stringify(source.description);
                  }
                  var _loop = function _loop(paramName) {
                    var skipRequired = false;
                    if (!source.properties.hasOwnProperty(paramName))
                      return 'continue';
                    var parameter = source.properties[paramName];
                    var param = _.isArray(parameter) ? _this2.convertArrayTypeExpression(parameter) : parameter;
                    if (RAML10Importer.isArray(param)) {
                      target.properties[paramName] = _this2.convertArray(param);
                    } else if (RAML10Importer.isFacet(param)) {
                      //check for facets
                      target.properties[paramName] = RAML10Importer.convertFacet(param);
                    } else if (RAML10Importer.isAdditionalProperties(param)) {
                      RAML10Importer.convertAdditionalProperties(target, param);
                      skipRequired = true;
                    } else {
                      if (_.isArray(param.type) && param.type.length > 1) {
                        RAML10Importer._removeHarmlessChars(param.type);
                        RAML10Importer._modifyUnionTypeDef(param);
                        param.allOf = param.type;
                        delete param.type;
                      }
                      if (!_.isArray(param.type) && _typeof(param.type) === 'object') {
                        param.type = _this2._mapSchema(param.type, false, false);
                        param = _this2.mapNestedType(param);
                      }
                      target.properties[paramName] = param;
                    }
                    if (skipRequired)
                      return 'continue';
                    //add annotations
                    RAMLImporter._addAnnotations(param, target.properties[paramName]);
                    //required
                    RAMLImporter._convertRequiredToArray(param, paramName, target['required']);
                    if (param.hasOwnProperty('scalarsAnnotations') && param.scalarsAnnotations.hasOwnProperty('required')) {
                      var annotations = _.reduce(param.scalarsAnnotations.required, function (obj, prop) {
                          obj[param.name + '-' + prop.name] = { structuredValue: prop.structuredValue };
                          return obj;
                        }, {});
                      RAMLImporter._addAnnotations({ annotations: annotations }, target);
                    }
                    if (param.properties && !_.isEmpty(param.properties))
                      target.properties[paramName] = _this2.convertObjectProperty(param);
                  };
                  for (var paramName in source.properties) {
                    var _ret = _loop(paramName);
                    if (_ret === 'continue')
                      continue;
                  }
                  if (target.required && target.required.length == 0) {
                    delete target.required;
                  }
                  if (target.properties && _.isEmpty(target.properties)) {
                    delete target.properties;
                  }
                  // RAMLImporter.convertRefToModel(target);
                  return target;
                }
              },
              {
                key: 'mapNestedType',
                value: function mapNestedType(param) {
                  var type = param.type;
                  var mergeFacets = [
                      'properties',
                      'required'
                    ];
                  for (var id in type) {
                    if (!type.hasOwnProperty(id))
                      continue;
                    var val = type[id];
                    param[id] = mergeFacets.indexOf(id) > -1 && param.hasOwnProperty(id) ? _.merge(param[id], val) : val;
                  }
                  return param;
                }
              },
              {
                key: '_mapSchema',
                value: function _mapSchema(definition, isSchema, isProperty) {
                  if (typeof definition === 'string')
                    definition = jsonHelper.parse(definition);
                  var properties = null;
                  var result = definition;
                  if (definition.properties && !_.isEmpty(definition.properties)) {
                    properties = this.convertObjectProperty(definition);
                  }
                  if (definition.hasOwnProperty('type') && definition.type != 'object') {
                    //type
                    if (_.isArray(definition.type)) {
                      RAML10Importer._removeHarmlessChars(definition.type);
                      //remove ( and )
                      RAML10Importer._modifyUnionTypeDef(definition);
                    }
                    if (properties) {
                      //type and properties
                      result.allOf = definition.type;
                      result.allOf.push(properties);
                      delete result.type;
                      delete result.properties;
                    } else {
                      result = this._convertCustomTypes(definition);
                      if (_.isArray(definition.type) && definition.type.length > 1) {
                        result.allOf = definition.type;
                        delete result.type;
                      } else {
                        //definition.type is json string value. or type=object
                        var jsonObject = jsonHelper.parse(_.isArray(definition.type) ? definition.type[0] : definition.type);
                        if ((typeof jsonObject === 'undefined' ? 'undefined' : _typeof(jsonObject)) === 'object') {
                          jsonObject = this.convertObjectProperty(jsonObject);
                          result = jsonObject;
                        }
                      }
                    }
                  } else {
                    //only properties
                    if (!properties) {
                      if (definition.hasOwnProperty('schema')) {
                        definition = jsonHelper.parse(_.isArray(definition.schema) ? definition.schema[0] : definition.schema);
                        result = this.convertObjectProperty(definition);
                      } else if (definition.type == 'object') {
                        result = definition;
                      }
                    } else {
                      //type = object with properties
                      result = properties;
                    }
                  }
                  //add annotations
                  RAMLImporter._addAnnotations(definition, result);
                  result = this._convertCustomTypes(result);
                  return this.convertRefToModel(result, isSchema, isProperty);
                }
              },
              {
                key: 'isDefinedAsSchema',
                value: function isDefinedAsSchema(schemas, schemaId) {
                  for (var index in schemas) {
                    if (!schemas.hasOwnProperty(index))
                      continue;
                    for (var schemaName in schemas[index]) {
                      if (!schemas[index].hasOwnProperty(schemaName))
                        continue;
                      if (schemaName === schemaId)
                        return true;
                    }
                  }
                  return false;
                }
              },
              {
                key: '_convertCustomTypes',
                value: function _convertCustomTypes(result) {
                  if (RAML10Importer.isArray(result)) {
                    //check for array
                    //convert array
                    result = this.convertArray(result);
                  } else if (RAML10Importer.isFacet(result)) {
                    //check for facets
                    result = RAML10Importer.convertFacet(result);
                  } else if (RAML10Importer.isFixedFacet(result)) {
                    result = RAML10Importer.convertFixedFacet(result);
                  }
                  return result;
                }
              },
              {
                key: 'convertArray',
                value: function convertArray(definition) {
                  if (definition.hasOwnProperty('items')) {
                    if (definition.items.hasOwnProperty('type')) {
                      definition.items.type = _.isArray(definition.items.type) ? definition.items.type[0] : definition.items.type;
                      if (definition.items.type === 'object' && definition.items.hasOwnProperty('properties'))
                        definition['items'] = this.convertObjectProperty(definition.items);
                    } else {
                      var items = definition.items;
                      if (RAML10Importer.isRamlArray(items)) {
                        definition.items = this.convertArray(RAML10Importer.convertRamlArray(definition.items));
                      } else {
                        if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) !== 'object' || _.isArray(items)) {
                          definition.items = { type: items };
                        }
                      }
                    }
                  } else {
                    var type = _.isArray(definition.type) ? definition.type[0] : definition.type;
                    definition = RAML10Importer.convertRamlArray(type);
                  }
                  definition.type = 'array';
                  return definition;
                }
              },
              {
                key: 'getSchemas',
                value: function getSchemas(data) {
                  return data.types || data.schemas;
                }
              },
              {
                key: 'mapAuthorizationGrants',
                value: function mapAuthorizationGrants(oauth, flow) {
                  switch (flow) {
                  case 'authorization_code':
                    oauth.flow = 'accessCode';
                    break;
                  case 'implicit':
                    oauth.flow = 'implicit';
                    break;
                  case 'client_credentials':
                    oauth.flow = 'application';
                    break;
                  case 'password':
                    oauth.flow = 'password';
                    break;
                  }
                  return oauth;
                }
              },
              {
                key: 'description',
                value: function description(project, data) {
                  if (data.description) {
                    project.Description = data.description;
                  }
                }
              }
            ], [
              {
                key: '_modifyUnionTypeDef',
                value: function _modifyUnionTypeDef(definition) {
                  var type = definition.type;
                  if (type.length > 1) {
                    definition[RAMLImporter.getCustomProperty('union-type-definition')] = '[' + _.join(type, ',') + ']';
                  }
                  for (var index in type) {
                    if (!type.hasOwnProperty(index))
                      continue;
                    if (type[index].includes('|')) {
                      type[index] = { type: 'object' };
                    }
                  }
                  return definition;
                }
              },
              {
                key: '_removeHarmlessChars',
                value: function _removeHarmlessChars(type) {
                  for (var index in type) {
                    if (!type.hasOwnProperty(index))
                      continue;
                    type[index] = _.replace(_.replace(type[index], ')', ''), '(', '');
                  }
                  return type;
                }
              },
              {
                key: 'isArray',
                value: function isArray(definition) {
                  var type = _.isArray(definition.type) ? definition.type[0] : definition.type;
                  return type === 'array' && definition.items || !definition.hasOwnProperty('items') && _.endsWith(type, '[]');
                }
              },
              {
                key: 'isFacet',
                value: function isFacet(definition) {
                  return definition.facets;
                }
              },
              {
                key: 'isAdditionalProperties',
                value: function isAdditionalProperties(definition) {
                  return _.startsWith(definition.name, '/') && _.endsWith(definition.name, '/');
                }
              },
              {
                key: 'isFixedFacet',
                value: function isFixedFacet(definition) {
                  return definition.fixedFacets;
                }
              },
              {
                key: 'isRamlArray',
                value: function isRamlArray(object) {
                  return _.endsWith(object, '[]');
                }
              },
              {
                key: 'convertRamlArray',
                value: function convertRamlArray(object) {
                  return {
                    type: 'array',
                    items: { type: _.replace(object, '[]', '') }
                  };
                }
              },
              {
                key: 'convertAdditionalProperties',
                value: function convertAdditionalProperties(target, definition) {
                  var type = definition.type;
                  var pattern = definition.name;
                  var info = {};
                  if (_.isArray(type) && type.length == 1) {
                    info.type = type[0];
                  }
                  if (pattern !== '//') {
                    info.pattern = pattern;
                  }
                  if (info.hasOwnProperty('pattern')) {
                    if (!target.hasOwnProperty('additionalProperties')) {
                      target.additionalProperties = {};
                      target.additionalProperties[RAMLImporter.getCustomProperty('additional-properties-info')] = [];
                    }
                    if (!target.additionalProperties.type)
                      target.additionalProperties.type = info.type;
                    else
                      target.additionalProperties.type = 'object';
                    target.additionalProperties[RAMLImporter.getCustomProperty('additional-properties-info')].push(info);
                  } else {
                    target.additionalProperties = {};
                    target.additionalProperties.type = info.type;
                  }
                }
              },
              {
                key: 'convertFacet',
                value: function convertFacet(definition) {
                  var facets = definition.facets;
                  var result = [];
                  for (var key in facets) {
                    if (!facets.hasOwnProperty(key))
                      continue;
                    var facet = facets[key];
                    facet[key] = _.isArray(facet.type) ? facet.type[0] : facet.type;
                    delete facet.name;
                    delete facet.type;
                    delete facet.typePropertyKind;
                    result.push(facet);
                  }
                  definition[RAMLImporter.getCustomProperty('facets')] = result;
                  delete definition.facets;
                  return definition;
                }
              },
              {
                key: 'convertFixedFacet',
                value: function convertFixedFacet(definition) {
                  var fixedFacets = definition.fixedFacets;
                  for (var key in fixedFacets) {
                    if (!fixedFacets.hasOwnProperty(key))
                      continue;
                    if (definition.hasOwnProperty(key)) {
                      definition[key] = fixedFacets[key];
                    } else {
                      definition[RAMLImporter.getCustomProperty('facets-' + key)] = fixedFacets[key];
                    }
                  }
                  delete definition.fixedFacets;
                  return definition;
                }
              }
            ]);
            return RAML10Importer;
          }(RAMLImporter);
        module.exports = RAML10Importer;
      },
      {
        '../utils/json': 107,
        './baseraml': 100,
        'lodash': 79
      }
    ],
    105: [
      function (require, module, exports) {
        'use strict';
        var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
          }
          return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var parser = require('swagger-parser'), Method = require('../entities/swagger/method'), Endpoint = require('../entities/endpoint'), Schema = require('../entities/schema'), Importer = require('./importer'), Project = require('../entities/project'), jsonHelper = require('../utils/json'), swaggerHelper = require('../helpers/swagger'), YAML = require('js-yaml'), _ = require('lodash');
        var referenceRegex = /\/(parameters|responses)\/(.+)/i;
        var Swagger = function (_Importer) {
            _inherits(Swagger, _Importer);
            function Swagger() {
              _classCallCheck(this, Swagger);
              var _this = _possibleConstructorReturn(this, (Swagger.__proto__ || Object.getPrototypeOf(Swagger)).call(this));
              _this.dereferencedAPI = null;
              return _this;
            }
            _createClass(Swagger, [
              {
                key: '_mapSchema',
                value: function _mapSchema(schemaDefinitions) {
                  var result = [];
                  for (var schemaName in schemaDefinitions) {
                    if (!schemaDefinitions.hasOwnProperty(schemaName))
                      continue;
                    var sd = new Schema(schemaName);
                    sd.Name = schemaName;
                    //create a clone to remove extension properties
                    var schemaDataClone = _.clone(schemaDefinitions[schemaName]);
                    var re = /^x-/;
                    //properties to avoid
                    for (var prop in schemaDataClone) {
                      if (schemaDataClone.hasOwnProperty(prop) && prop.match(re)) {
                        delete schemaDataClone[prop];
                      }
                    }
                    Swagger.mapExample(schemaDataClone, sd);
                    sd.Definition = schemaDataClone;
                    result.push(sd);
                  }
                  return result;
                }
              },
              {
                key: '_mapQueryString',
                value: function _mapQueryString(params, skipParameterRefs) {
                  var queryString = {
                      type: 'object',
                      properties: {},
                      required: []
                    };
                  for (var i in params) {
                    if (!params.hasOwnProperty(i))
                      continue;
                    var param = params[i];
                    if (skipParameterRefs && Swagger.needDeReferenced(param)) {
                      continue;
                    }
                    if (param.in && param.in !== 'query') {
                      //skip other type of params
                      continue;
                    }
                    queryString.properties[param.name] = swaggerHelper.setParameterFields(param, {});
                    if (param.required) {
                      queryString.required.push(param.name);
                    }
                  }
                  return queryString;
                }
              },
              {
                key: '_mapURIParams',
                value: function _mapURIParams(params, resolvedParameters) {
                  var pathParams = {
                      type: 'object',
                      properties: {},
                      required: []
                    };
                  for (var i in params) {
                    if (!params.hasOwnProperty(i))
                      continue;
                    var param = params[i];
                    if ((Swagger.needDeReferenced(param) || param.hasOwnProperty('$ref')) && resolvedParameters) {
                      param = resolvedParameters[i];
                    }
                    if (param.in && param.in !== 'path') {
                      //skip other type of params
                      continue;
                    }
                    pathParams.properties[param.name] = swaggerHelper.setParameterFields(param, {});
                    pathParams.required.push(param.name);
                  }
                  return pathParams;
                }
              },
              {
                key: '_mapRequestBody',
                value: function _mapRequestBody(params, resolvedParams) {
                  if (_.isEmpty(params) || !_.some(params, { 'in': 'body' }) && !_.some(params, { 'in': 'formData' })) {
                    return;
                  }
                  var data = {
                      body: {
                        properties: {},
                        required: []
                      },
                      example: ''
                    };
                  for (var i in params) {
                    if (!params.hasOwnProperty(i))
                      continue;
                    var param = params[i];
                    if (Swagger.needDeReferenced(param)) {
                      param = resolvedParams[i];
                    }
                    if (param.in && param.in !== 'body' && param.in !== 'formData') {
                      continue;
                    }
                    switch (param.in) {
                    case 'body':
                      Swagger.mapExample(param.schema, data);
                      data.body = param.schema;
                      if (param.name) {
                        data.name = param.name;
                      }
                      if (param.description) {
                        data.description = jsonHelper.stringify(param.description);
                      }
                      break;
                    default: {
                        var prop = {};
                        prop = swaggerHelper.setParameterFields(param, prop);
                        if (param.required) {
                          data.body.required.push(param.name);
                        }
                        data.body.properties[param.name] = prop;
                      }
                    }
                  }
                  //remove required field if doesn't have anything inside it
                  if (data.body.required && data.body.required.length == 0) {
                    delete data.body.required;
                  }
                  return data;
                }
              },
              {
                key: '_mapResponseBody',
                value: function _mapResponseBody(responses, skipParameterRefs, resolvedResponses, $refs) {
                  var data = [];
                  for (var code in responses) {
                    if (!responses.hasOwnProperty(code))
                      continue;
                    var res = {
                        body: {},
                        example: '',
                        codes: []
                      };
                    var description = '';
                    var response = responses[code];
                    if (skipParameterRefs && Swagger.needDeReferenced(response) && (response.$ref.match(/trait/) || _.includes($refs, response.$ref))) {
                      continue;
                    }
                    var needBeReferenced = Swagger.needDeReferenced(response);
                    if (needBeReferenced && resolvedResponses) {
                      var resolvedResponse = this._getResponses(response, resolvedResponses[code]);
                      var schema = resolvedResponse.schema;
                      description = jsonHelper.stringify(resolvedResponse.description || '');
                      res.body = schema;
                    } else if (response.schema) {
                      var _schema = response.schema;
                      if (Swagger.needDeReferenced(response.schema)) {
                        description = jsonHelper.stringify(resolvedResponses[code].description || '');
                        _schema = resolvedResponses[code].schema;
                      }
                      res.body = _schema;
                    }
                    this._mapResponseExample(needBeReferenced ? resolvedResponses[code] : response, res);
                    Swagger._mapResponseHeaders(needBeReferenced ? resolvedResponses[code] : response, res);
                    Swagger._mapResponseDescription(needBeReferenced ? resolvedResponses[code] : response, description, res);
                    if (needBeReferenced) {
                      res.response_id = needBeReferenced[needBeReferenced.length - 1];
                    }
                    res.codes.push(String(code));
                    data.push(res);
                  }
                  var extensions = Swagger._getExtensionsFrom(responses);
                  if (!_.isEmpty(extensions)) {
                    data.extensions = extensions;
                  }
                  return data;
                }
              },
              {
                key: '_mapResponseExample',
                value: function _mapResponseExample(responseBody, res) {
                  if (responseBody.hasOwnProperty('examples') && !_.isEmpty(responseBody.examples)) {
                    var examples = responseBody.examples;
                    if (_.isArray(examples)) {
                      for (var t in examples) {
                        if (!examples.hasOwnProperty(t))
                          continue;
                        if (t === resType) {
                          res.example = jsonHelper.stringify(examples[t], 4);
                        }
                      }
                    } else {
                      res.example = jsonHelper.stringify(examples, 4);
                    }
                  }
                }
              },
              {
                key: '_mapRequestHeaders',
                value: function _mapRequestHeaders(params, skipParameterRefs) {
                  var data = {
                      type: 'object',
                      properties: {},
                      required: []
                    };
                  for (var i in params) {
                    if (!params.hasOwnProperty(i))
                      continue;
                    var param = params[i];
                    if (skipParameterRefs && Swagger.needDeReferenced(param)) {
                      continue;
                    }
                    if (param.in !== 'header') {
                      //skip other type of params
                      continue;
                    }
                    data.properties[param.name] = swaggerHelper.setParameterFields(param, {});
                    if (param.required) {
                      data.required.push(param.name);
                    }
                  }
                  return data;
                }
              },
              {
                key: '_parseData',
                value: function _parseData(dataOrPath, options) {
                  var _this2 = this;
                  return new Promise(function (resolve, reject) {
                    var validateOptions = _.cloneDeep(options || {});
                    var validate = options && (options.validate === true || options.validateImport === true);
                    validateOptions.validate = {
                      schema: validate,
                      spec: validate
                    };
                    // with validation
                    //in case of data, if not cloned, referenced to resolved data
                    var dataCopy = _.cloneDeep(dataOrPath);
                    parser.validate(dataCopy, validateOptions).then(function () {
                      _this2._doParseData(dataOrPath, options || {}, resolve, reject);
                    }).catch(reject);
                  });
                }
              },
              {
                key: '_doParseData',
                value: function _doParseData(dataOrPath, options, resolve, reject) {
                  var _this3 = this;
                  // without validation
                  parser.parse(dataOrPath, options).then(function (api) {
                    JSON.parse(JSON.stringify(api));
                    _this3.data = api;
                    var parseFn = void 0;
                    if (typeof dataOrPath === 'string') {
                      parseFn = parser.dereference(dataOrPath, JSON.parse(JSON.stringify(api)), options);
                    } else {
                      parseFn = parser.dereference(JSON.parse(JSON.stringify(api)), options);
                    }
                    parseFn.then(function (dereferencedAPI) {
                      if (options && options.expand) {
                        _this3.data = dereferencedAPI;
                      } else {
                        _this3.dereferencedAPI = dereferencedAPI;
                      }
                      resolve();
                    }).catch(reject);
                  }).catch(reject);
                }  // Load a swagger spec by local or remote file path
              },
              {
                key: 'loadFile',
                value: function loadFile(path, options) {
                  return this._parseData(path, options);
                }  // Load a swagger spec by string data
              },
              {
                key: 'loadData',
                value: function loadData(data, options) {
                  var _this4 = this;
                  return new Promise(function (resolve, reject) {
                    var parsedData = void 0;
                    try {
                      parsedData = JSON.parse(data);
                    } catch (err) {
                      // Possibly YAML Data
                      try {
                        parsedData = YAML.safeLoad(data, { json: true });
                      } catch (err) {
                        return reject(err);
                      }
                    }
                    _this4._parseData(parsedData, options).then(resolve).catch(reject);
                  });
                }  //for now, if 'application/json' exist in supported type, use that
              },
              {
                key: '_getResponses',
                value: function _getResponses(response, resolvedResponse) {
                  var result = void 0;
                  var deReferenced = Swagger.needDeReferenced(response);
                  var isFilePath = Swagger._isFilePath(response);
                  if ((deReferenced || isFilePath) && resolvedResponse) {
                    if (isFilePath) {
                      result = resolvedResponse;
                    } else {
                      var responseName = deReferenced[deReferenced.length - 1];
                      result = this.data.responses[responseName];
                      if (result.$ref) {
                        result = resolvedResponse;
                      }
                    }
                  }
                  return result;
                }
              },
              {
                key: '_mapEndpoints',
                value: function _mapEndpoints(project, consumes, produces) {
                  var _this5 = this;
                  for (var path in this.data.paths) {
                    if (!this.data.paths.hasOwnProperty(path))
                      continue;
                    if (_.startsWith(path, 'x-'))
                      continue;
                    //avoid custom extensions
                    var methods = this.data.paths[path].hasOwnProperty('$ref') ? this.dereferencedAPI.paths[path] : this.data.paths[path];
                    var resolvedPathParames = {};
                    var globalParamsURI = {};
                    var pathParamRef = [];
                    var globalParamsNonURI = [];
                    if (methods.parameters) {
                      resolvedPathParames = this.dereferencedAPI ? this.dereferencedAPI.paths[path].parameters : methods.parameters;
                      globalParamsURI = this._mapURIParams(methods.parameters, resolvedPathParames);
                      pathParamRef = Swagger._mapEndpointTrait(methods.parameters, this.dereferencedAPI.parameters);
                      if (!_.isEmpty(pathParamRef)) {
                        project.addPathParamRef(path, pathParamRef);
                      }
                      globalParamsNonURI = Swagger._getParams(methods.parameters, resolvedPathParames, function (param) {
                        return !(param.in && param.in == 'path');
                      });
                    }
                    var _loop = function _loop(method) {
                      if (!methods.hasOwnProperty(method))
                        return 'continue';
                      if (method === 'parameters')
                        return 'continue';
                      var currentMethod = new Method(methods[method], _this5.dereferencedAPI ? _this5.dereferencedAPI.paths[path][method] : methods[method]);
                      var currentMethodResolved = _this5.dereferencedAPI ? _this5.dereferencedAPI.paths[path][method] : methods[method];
                      var endpoint = new Endpoint(currentMethod.summary || '');
                      var extensions = Swagger._getExtensionsFrom(currentMethodResolved);
                      if (!_.isEmpty(extensions)) {
                        endpoint.extensions = extensions;
                      }
                      endpoint.Method = method;
                      endpoint.Path = path;
                      endpoint.Tags = currentMethod.tags || [];
                      endpoint.Summary = (currentMethod.summary || '').substring(0, 139);
                      endpoint.Description = jsonHelper.stringify(currentMethod.description);
                      endpoint.Deprecated = currentMethod.deprecated;
                      endpoint.SetOperationId(currentMethod.operationId);
                      endpoint.ExternalDocs = currentMethod.externalDocs;
                      if (currentMethod.schemes) {
                        endpoint.protocols = currentMethod.schemes;
                      }
                      //map request body
                      // if (_.isArray(currentMethod.consumes)) {
                      //   if (_.isEmpty(currentMethod.consumes)) {
                      //     reqType = null;
                      //   } else {
                      //     reqType = this.findDefaultMimeType(currentMethod.consumes);
                      //   }
                      // }
                      var params = _.union(globalParamsNonURI, Swagger._getParams(currentMethod.parameters, currentMethodResolved.parameters));
                      var c = [];
                      if (_.some(params, { 'in': 'body' })) {
                        c.push('application/json');
                      }
                      if (_.some(params, { 'in': 'formData' })) {
                        c.push('multipart/form-data');
                      }
                      if (consumes && _.isArray(consumes) && c.length) {
                        consumes.forEach(function (mimeType) {
                          return c = _.without(c, mimeType);
                        });
                      }
                      if (c.length) {
                        endpoint.Consumes = c;
                      }
                      if (currentMethod.consumes && _.isArray(currentMethod.consumes)) {
                        c = _.uniq(endpoint.Consumes && _.isArray(endpoint.Consumes) ? endpoint.Consumes.concat(currentMethod.consumes) : currentMethod.consumes);
                        if (consumes && _.isArray(consumes) && c.length) {
                          consumes.forEach(function (mimeType) {
                            return c = _.without(c, mimeType);
                          });
                        }
                        if (endpoint.Consumes || c.length) {
                          endpoint.Consumes = c;
                        }
                      }
                      if (endpoint.Method.toLowerCase() !== 'get' && endpoint.Method.toLowerCase() !== 'head') {
                        var body = _this5._mapRequestBody(params, currentMethodResolved.parameters);
                        if (body) {
                          endpoint.Body = body;
                        }
                      }
                      // this needs to happen before the mappings below, because param/response $refs will be removed after those mappings
                      endpoint.traits = Swagger._mapEndpointTraits(currentMethod.parameters, currentMethod.responses);
                      //if path params are defined in this level
                      //map path params
                      var mapURIParams = _this5._mapURIParams(currentMethod.parameters, currentMethodResolved.parameters);
                      var pathParams = {};
                      _.merge(pathParams, globalParamsURI);
                      _.merge(pathParams, mapURIParams);
                      endpoint.PathParams = pathParams;
                      //map headers
                      endpoint.Headers = _this5._mapRequestHeaders(params, true);
                      //map query string
                      // endpoint.QueryString = this._mapQueryString(currentMethod.parameters, true);
                      endpoint.QueryString = _this5._mapQueryString(params, true);
                      //map response body
                      // if (_.isArray(currentMethod.produces)) {
                      //   if (_.isEmpty(currentMethod.produces)) {
                      //     resType = null;
                      //   } else {
                      //     resType = this.findDefaultMimeType(currentMethod.produces);
                      //   }
                      // }
                      if (currentMethod.produces && _.isArray(currentMethod.produces)) {
                        var p = _.uniq(endpoint.Produces && _.isArray(endpoint.Produces) ? endpoint.Produces.concat(currentMethod.produces) : currentMethod.produces);
                        if (produces && _.isArray(produces) && p.length) {
                          produces.forEach(function (mimeType) {
                            return p = _.without(p, mimeType);
                          });
                        }
                        if (endpoint.Produces || p.length) {
                          endpoint.Produces = p;
                        }
                      }
                      var responses = _this5._mapResponseBody(currentMethod.responses, true, currentMethodResolved.responses, _this5.$refs);
                      if (responses) {
                        endpoint.Responses = responses;
                      }
                      //map security
                      if (currentMethod.security) {
                        var securities = currentMethod.security;
                        for (var securityIndex in securities) {
                          if (!securities.hasOwnProperty(securityIndex))
                            continue;
                          var keys = Object.keys(securities[securityIndex]);
                          var securityName = keys[0];
                          var scheme = _.get(_this5, [
                              'data',
                              'securityDefinitions',
                              securityName
                            ]);
                          if (!scheme) {
                            //definition error
                            continue;
                          }
                          switch (scheme.type) {
                          case 'apiKey':
                          case 'basic':
                            if (!endpoint.SecuredBy) {
                              endpoint.SecuredBy = {};
                            }
                            endpoint.SecuredBy[scheme.type] = { name: securityName };
                            break;
                          case 'oauth2':
                            if (!endpoint.SecuredBy) {
                              endpoint.SecuredBy = {};
                            }
                            endpoint.SecuredBy[scheme.type] = {
                              name: securityName,
                              scope: securities[securityIndex][securityName]
                            };
                            break;
                          }
                        }
                      }
                      project.addEndpoint(endpoint);
                    };
                    for (var method in methods) {
                      var _ret = _loop(method);
                      if (_ret === 'continue')
                        continue;
                    }
                  }
                }
              },
              {
                key: '_mapTraits',
                value: function _mapTraits(parameters, responses, resolvedParameters) {
                  var traits = {}, queryParams = {}, headerParams = {}, formDataParams = {}, bodyParams = {}, traitResponses = {};
                  for (var k in parameters) {
                    if (!parameters.hasOwnProperty(k))
                      continue;
                    var param = parameters[k];
                    var parts = k.split(':');
                    var name = k;
                    if (parts[0] === 'trait') {
                      name = parts[1];
                    }
                    if (Swagger._isFilePath(param)) {
                      param = resolvedParameters[k];
                    }
                    switch (param.in) {
                    case 'query':
                      queryParams[name] = queryParams[name] || [];
                      queryParams[name].push(param);
                      break;
                    case 'header':
                      headerParams[name] = headerParams[name] || [];
                      headerParams[name].push(param);
                      break;
                    case 'formData':
                      formDataParams[name] = formDataParams[name] || [];
                      formDataParams[name].push(param);
                      break;
                    case 'body':
                      bodyParams[name] = bodyParams[name] || [];
                      bodyParams[name].push(param);
                      break;
                    }
                  }
                  for (var r in responses) {
                    if (!responses.hasOwnProperty(r))
                      continue;
                    var response = responses[r];
                    var resName = r;
                    var resCode = 200;
                    var resNameParts = r.split(':');
                    // Support for StopLight Swagger traits
                    if (resNameParts.length === 3 && resNameParts[0] === 'trait') {
                      resName = resNameParts[1];
                      resCode = resNameParts[2];
                    }
                    traitResponses[resName] = traitResponses[resName] || {};
                    traitResponses[resName][resCode] = response;
                  }
                  for (var _k in queryParams) {
                    if (!queryParams.hasOwnProperty(_k))
                      continue;
                    var trait = traits[_k] || {
                        _id: _k,
                        name: _k,
                        request: {},
                        responses: []
                      };
                    trait.request.queryString = this._mapQueryString(queryParams[_k]);
                    traits[_k] = trait;
                  }
                  for (var _k2 in headerParams) {
                    if (!headerParams.hasOwnProperty(_k2))
                      continue;
                    var _trait = traits[_k2] || {
                        _id: _k2,
                        name: _k2,
                        request: {},
                        responses: []
                      };
                    _trait.request.headers = this._mapRequestHeaders(headerParams[_k2]);
                    traits[_k2] = _trait;
                  }
                  for (var _k3 in formDataParams) {
                    if (!formDataParams.hasOwnProperty(_k3))
                      continue;
                    var _trait2 = traits[_k3] || {
                        _id: _k3,
                        name: _k3,
                        request: {},
                        responses: []
                      };
                    _trait2.request.formData = this._mapRequestBody(formDataParams[_k3]);
                    traits[_k3] = _trait2;
                  }
                  for (var _k4 in bodyParams) {
                    if (!bodyParams.hasOwnProperty(_k4))
                      continue;
                    var _trait3 = traits[_k4] || {
                        _id: _k4,
                        name: _k4,
                        request: {},
                        responses: []
                      };
                    _trait3.request.body = this._mapRequestBody(bodyParams[_k4]);
                    traits[_k4] = _trait3;
                  }
                  for (var _k5 in traitResponses) {
                    if (!traitResponses.hasOwnProperty(_k5))
                      continue;
                    var _trait4 = traits[_k5] || {
                        _id: _k5,
                        name: _k5,
                        request: {},
                        responses: []
                      };
                    _trait4.responses = this._mapResponseBody(traitResponses[_k5]);
                    traits[_k5] = _trait4;
                  }
                  return _.values(traits);
                }
              },
              {
                key: '_createExtensions',
                value: function _createExtensions(project) {
                  project.extensions = Swagger._getExtensionsFrom(this.data);
                  if (this.data.info) {
                    var infoExtensions = Swagger._getExtensionsFrom(this.data.info);
                    if (!_.isEmpty(infoExtensions)) {
                      project.Environment.extensions = infoExtensions;
                    }
                  }
                  if (this.data.info.contact) {
                    var contactExtensions = Swagger._getExtensionsFrom(this.data.info.contact);
                    if (!_.isEmpty(contactExtensions)) {
                      project.Environment.contactInfo.extensions = contactExtensions;
                    }
                  }
                  if (this.data.info.license) {
                    var licenseExtensions = Swagger._getExtensionsFrom(this.data.info.license);
                    if (!_.isEmpty(licenseExtensions)) {
                      project.Environment.license.extensions = licenseExtensions;
                    }
                  }
                  if (this.data.externalDocs) {
                    var externalDocsExtensions = Swagger._getExtensionsFrom(this.data.externalDocs);
                    if (!_.isEmpty(externalDocsExtensions)) {
                      project.Environment.ExternalDocs.extensions = externalDocsExtensions;
                    }
                  }
                  if (this.data.paths) {
                    var endpointExtensions = Swagger._getExtensionsFrom(this.data.paths);
                    if (!_.isEmpty(endpointExtensions)) {
                      project.endpointExtensions = {};
                      project.endpointExtensions = endpointExtensions;
                    }
                  }
                }
              },
              {
                key: '_import',
                value: function _import() {
                  var project = new Project(this.data.info.title);
                  project.Description = this.data.info.description || '';
                  project.tags = this.data.tags;
                  var protocol = 'http';
                  if (this.data.schemes && this.data.schemes.length > 0) {
                    project.Environment.Protocols = this.data.schemes;
                    protocol = this.data.schemes[0];
                  }
                  this._mapEndpoints(project, this.data.consumes, this.data.produces);
                  project.Environment.summary = this.data.info.description || '';
                  project.Environment.BasePath = this.data.basePath || '';
                  project.Environment.Host = this.data.host ? protocol + '://' + this.data.host : '';
                  project.Environment.Version = this.data.info.version;
                  if (this.data.externalDocs) {
                    project.Environment.ExternalDocs = {
                      description: this.data.externalDocs.description,
                      url: this.data.externalDocs.url
                    };
                  }
                  if (this.data.info.contact) {
                    project.Environment.contactInfo = {};
                    if (this.data.info.contact.name) {
                      project.Environment.contactInfo.name = this.data.info.contact.name;
                    }
                    if (this.data.info.contact.url) {
                      project.Environment.contactInfo.url = this.data.info.contact.url;
                    }
                    if (this.data.info.contact.email) {
                      project.Environment.contactInfo.email = this.data.info.contact.email;
                    }
                  }
                  if (this.data.info.termsOfService) {
                    project.Environment.termsOfService = this.data.info.termsOfService;
                  }
                  if (this.data.info.license) {
                    project.Environment.license = {};
                    if (this.data.info.license.name) {
                      project.Environment.license.name = this.data.info.license.name;
                    }
                    if (this.data.info.license.url) {
                      project.Environment.license.url = this.data.info.license.url;
                    }
                  }
                  if (this.data.produces) {
                    //taking the first as default one
                    project.Environment.Produces = this.data.produces;
                  }
                  if (this.data.consumes) {
                    //taking the first as default one
                    project.Environment.Consumes = this.data.consumes;
                  }
                  if (this.data.securityDefinitions) {
                    project.Environment.SecuritySchemes = Swagger._mapSecurityDefinitions(this.data.securityDefinitions, this.dereferencedAPI.securityDefinitions);
                  }
                  project.traits = this._mapTraits(this.data.parameters, this.data.responses, this.dereferencedAPI.parameters);
                  var schemas = this._mapSchema(this.data.definitions);
                  for (var i in schemas) {
                    if (!schemas.hasOwnProperty(i))
                      continue;
                    project.addSchema(schemas[i]);
                  }
                  this._createExtensions(project);
                  return project;
                }
              }
            ], [
              {
                key: 'needDeReferenced',
                value: function needDeReferenced(param) {
                  if (!param || !param.$ref) {
                    return false;
                  }
                  return param.$ref.match(referenceRegex);
                }
              },
              {
                key: 'mapExample',
                value: function mapExample(data, target) {
                  if (data.example) {
                    target.example = jsonHelper.stringify(data.example, 4);
                    delete data.example;
                  }
                }
              },
              {
                key: '_mapSecurityDefinitions',
                value: function _mapSecurityDefinitions(securityDefinitions, dereferenceSecurityDefinitions) {
                  if (securityDefinitions.hasOwnProperty('$ref')) {
                    securityDefinitions = dereferenceSecurityDefinitions;
                  }
                  var result = {};
                  for (var name in securityDefinitions) {
                    if (!securityDefinitions.hasOwnProperty(name))
                      continue;
                    var type = securityDefinitions[name].type;
                    var sd = securityDefinitions[name];
                    switch (type) {
                    case 'apiKey': {
                        if (!result.hasOwnProperty(type)) {
                          result[type] = {};
                        }
                        var current = {
                            externalName: name,
                            name: sd.name,
                            value: '',
                            description: sd.description
                          };
                        var keyPlaceHolder = sd.in === 'header' ? 'headers' : 'queryString';
                        if (!result[type].hasOwnProperty(keyPlaceHolder)) {
                          result[type][keyPlaceHolder] = [];
                        }
                        result[type][keyPlaceHolder].push(current);
                        break;
                      }
                    case 'oauth2': {
                        if (!result.hasOwnProperty(type)) {
                          result[type] = [];
                        }
                        var _current = {
                            name: name,
                            authorizationUrl: sd.authorizationUrl || '',
                            tokenUrl: sd.tokenUrl || ''
                          };
                        var slScopes = [], swaggerScopes = sd.scopes;
                        if (swaggerScopes) {
                          for (var key in swaggerScopes) {
                            if (!swaggerScopes.hasOwnProperty(key))
                              continue;
                            var scope = {};
                            scope['name'] = key;
                            scope['value'] = swaggerScopes[key];
                            slScopes.push(scope);
                          }
                        }
                        if (sd.flow) {
                          _current['flow'] = sd.flow;
                        }
                        if (sd.description) {
                          _current['description'] = sd.description;
                        }
                        if (!_.isEmpty(slScopes)) {
                          _current['scopes'] = slScopes;
                        }
                        result[type].push(_current);
                        break;
                      }
                    case 'basic': {
                        if (!result.hasOwnProperty(type)) {
                          result[type] = [];
                        }
                        var _current2 = {
                            name: name,
                            value: '',
                            description: sd.description || ''
                          };
                        result[type].push(_current2);
                        break;
                      }
                    }
                  }
                  return result;
                }
              },
              {
                key: '_mapResponseDescription',
                value: function _mapResponseDescription(responseBody, description, res) {
                  res.description = jsonHelper.stringify(description || responseBody.description || '');
                }
              },
              {
                key: '_mapResponseHeaders',
                value: function _mapResponseHeaders(responseBody, res) {
                  if (responseBody.hasOwnProperty('headers') && !_.isEmpty(responseBody.headers)) {
                    res.headers = { properties: responseBody.headers };
                  }
                }
              },
              {
                key: 'findDefaultMimeType',
                value: function findDefaultMimeType(mimeTypes) {
                  if (!mimeTypes || mimeTypes.length <= 0) {
                    return null;
                  }
                  for (var i in mimeTypes) {
                    if (!mimeTypes.hasOwnProperty(i))
                      continue;
                    if (mimeTypes[i] === 'application/json') {
                      return mimeTypes[i];
                    }
                  }
                  return mimeTypes[0];
                }
              },
              {
                key: '_mapEndpointTrait',
                value: function _mapEndpointTrait(params, resolvedParameters) {
                  var traits = [];
                  for (var i in params) {
                    if (!params.hasOwnProperty(i))
                      continue;
                    var param = params[i];
                    if (!Swagger.needDeReferenced(param) || Swagger._isFilePath(param)) {
                      continue;
                    }
                    var parts = param.$ref.split('/');
                    var traitParts = parts[parts.length - 1].split(':');
                    var name = traitParts[0];
                    if (traitParts[0] === 'trait') {
                      name = traitParts[1];
                    }
                    if (resolvedParameters && resolvedParameters[name] && resolvedParameters[name].in && resolvedParameters[name].in === 'path') {
                      continue;
                    }
                    traits.push(name);
                  }
                  return traits;
                }
              },
              {
                key: '_mapEndpointTraits',
                value: function _mapEndpointTraits(params) {
                  var traits = [];
                  traits = traits.concat(Swagger._mapEndpointTrait(params));
                  // traits = traits.concat(this._mapEndpointTrait(responses));
                  return _.uniq(traits);
                }
              },
              {
                key: '_getParams',
                value: function _getParams(params, resolvedParameters, condition) {
                  if (_.isEmpty(params))
                    return params;
                  var result = [];
                  for (var id in params) {
                    if (!params.hasOwnProperty(id))
                      continue;
                    var param = params[id];
                    if (condition && !condition(param)) {
                      continue;
                    }
                    var deReferenced = Swagger.needDeReferenced(param);
                    var isFilePath = Swagger._isFilePath(param);
                    if (deReferenced && !isFilePath && deReferenced.length)
                      continue;
                    if (isFilePath && resolvedParameters) {
                      param = resolvedParameters[id];
                    }
                    result.push(param);
                  }
                  return result;
                }
              },
              {
                key: '_isFilePath',
                value: function _isFilePath(param) {
                  if (!param || !param.$ref) {
                    return false;
                  }
                  var filePath = param.$ref.split('#')[0];
                  return filePath.split('.').length > 1;
                }
              },
              {
                key: '_getExtensionsFrom',
                value: function _getExtensionsFrom(object) {
                  var result = {};
                  for (var key in object) {
                    if (!object.hasOwnProperty(key))
                      continue;
                    if (_.startsWith(key, 'x-'))
                      result[key] = object[key];
                  }
                  return result;
                }
              }
            ]);
            return Swagger;
          }(Importer);
        module.exports = Swagger;
      },
      {
        '../entities/endpoint': 83,
        '../entities/project': 85,
        '../entities/schema': 86,
        '../entities/swagger/method': 88,
        '../helpers/swagger': 98,
        '../utils/json': 107,
        './importer': 101,
        'js-yaml': 111,
        'lodash': 79,
        'swagger-parser': 174
      }
    ],
    106: [
      function (require, module, exports) {
        'use strict';
        var _ = require('lodash');
        module.exports = {
          allEqual: function allEqual(array) {
            return !!array.reduce(function (a, b) {
              return _.isEqual(a, b) ? a : NaN;
            });
          }
        };
      },
      { 'lodash': 79 }
    ],
    107: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var _ = require('lodash'), jsonSchemaConverter = require('json-schema-compatibility');
        module.exports = {
          parse: function parse(data) {
            if (typeof data !== 'string') {
              return data;
            }
            try {
              var result = JSON.parse(data);
              if (typeof result === 'string') {
                return this.parse(result);
              }
              return result;
            } catch (err) {
              //can't parse, use as it is
              return data;
            }
          },
          stringify: function stringify(jsonObj, spacing) {
            if (typeof jsonObj === 'string') {
              return jsonObj;
            }
            if (!spacing) {
              spacing = 0;
            }
            return JSON.stringify(jsonObj, null, spacing);
          },
          format: function format(data) {
            if (typeof data !== 'string') {
              if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
                return this.stringify(data, 4);
              }
              return data;
            }
            //try parse
            var result = this.parse(data);
            if (typeof result === 'string') {
              //not parsable, no formatting possible
              return data;
            }
            return this.stringify(result, 4);
          },
          toJSON: function toJSON(obj) {
            var def = {};
            for (var property in obj) {
              if (!obj.hasOwnProperty(property))
                continue;
              var propType = _typeof(obj[property]);
              if (propType !== 'function' && propType !== 'undefined') {
                def[property] = obj[property];
              }
            }
            return def;
          },
          orderByKeys: function orderByKeys(obj, propertiesOrder) {
            //if array recursive call to all items
            if (Array.isArray(obj)) {
              var me = this;
              return obj.map(function (item) {
                return me.orderByKeys(item, propertiesOrder);
              });
            }
            var orderedObj = {};
            //place the ordered key items first
            for (var i in propertiesOrder) {
              if (!propertiesOrder.hasOwnProperty(i))
                continue;
              var key = propertiesOrder[i];
              if (obj.hasOwnProperty(key)) {
                orderedObj[key] = obj[key];
              }
            }
            //add if something missing from the given orders
            for (var _key in obj) {
              if (!obj.hasOwnProperty(_key))
                continue;
              if (!orderedObj.hasOwnProperty(_key)) {
                orderedObj[_key] = obj[_key];
              }
            }
            return orderedObj;
          },
          isEmptySchema: function isEmptySchema(schema) {
            if (_.isEmpty(schema)) {
              return true;
            }
            var parsed = schema;
            if (typeof parsed === 'string') {
              try {
                parsed = JSON.parse(parsed);
              } catch (e) {
                return true;
              }
            }
            if (!parsed || !Object.keys(parsed).length || parsed.properties && !Object.keys(parsed.properties).length) {
              return true;
            }
            return parsed.type === 'array' && _.isEmpty(parsed.items);
          },
          cleanSchema: function cleanSchema(schema) {
            var parsed = this.parse(schema);
            try {
              jsonSchemaConverter.v4(parsed);
            } catch (e) {
            }
            return this.stringify(parsed, 4);
          },
          isJson: function isJson(str) {
            try {
              if (!_.startsWith(str, '{') || !_.endsWith(str, '}'))
                return false;
              JSON.parse(str);
            } catch (e) {
              return false;
            }
            return true;
          }
        };
      },
      {
        'json-schema-compatibility': 21,
        'lodash': 79
      }
    ],
    108: [
      function (require, module, exports) {
        'use strict';
        var _ = require('lodash');
        module.exports = {
          computeOperationId: function computeOperationId(method, path) {
            method = _.trim(method).toUpperCase();
            path = _.trim(path);
            if (path === '/' || path === '') {
              return method + '_root';
            }
            return method + '_' + _.trim(path, '/').replace(/\{|\}/g, '').replace(/\/|\./g, '-');
          },
          computeTraitName: function computeTraitName(name, key) {
            var traitName = 'trait:' + _.camelCase(name);
            if (key) {
              traitName += ':' + key;
            }
            return traitName;
          },
          checkAndReplaceInvalidChars: function checkAndReplaceInvalidChars(object, validChars, replacement) {
            for (var index in object) {
              if (!object.hasOwnProperty(index))
                continue;
              if (!validChars.includes(object[index]))
                object = _.replace(object, object[index], replacement);
            }
            return object;
          }
        };
      },
      { 'lodash': 79 }
    ],
    109: [
      function (require, module, exports) {
        'use strict';
        var request = require('request');
        var _ = require('lodash');
        module.exports = {
          isURL: function isURL(path) {
            if (!path) {
              throw new Error('Invalid path/url string given.');
            }
            var expression = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%_\+.~#?&\/\/=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&\/\/=]*)?/gi;
            var regexp = new RegExp(expression);
            return path.match(regexp);
          },
          get: function get(url) {
            return new Promise(function (resolve, reject) {
              request(url, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                  resolve(body);
                } else {
                  reject(error || new Error('Could not fetch remote URL.'));
                }
              });
            });
          },
          join: function join(a, b) {
            return _.trimEnd(a, '/') + '/' + _.trimStart(b, '/');
          }
        };
      },
      {
        'lodash': 79,
        'request': 2
      }
    ],
    110: [
      function (require, module, exports) {
        'use strict';
        var parseString = require('xml2js').parseString;
        module.exports = {
          isXml: function isXml(data) {
            var result = false;
            parseString(data, function (err, r) {
              if (r)
                result = true;
            });
            return result;
          }
        };
      },
      { 'xml2js': 264 }
    ],
    111: [
      function (require, module, exports) {
        arguments[4][45][0].apply(exports, arguments);
      },
      {
        './lib/js-yaml.js': 112,
        'dup': 45
      }
    ],
    112: [
      function (require, module, exports) {
        arguments[4][46][0].apply(exports, arguments);
      },
      {
        './js-yaml/dumper': 114,
        './js-yaml/exception': 115,
        './js-yaml/loader': 116,
        './js-yaml/schema': 118,
        './js-yaml/schema/core': 119,
        './js-yaml/schema/default_full': 120,
        './js-yaml/schema/default_safe': 121,
        './js-yaml/schema/failsafe': 122,
        './js-yaml/schema/json': 123,
        './js-yaml/type': 124,
        'dup': 46
      }
    ],
    113: [
      function (require, module, exports) {
        arguments[4][47][0].apply(exports, arguments);
      },
      { 'dup': 47 }
    ],
    114: [
      function (require, module, exports) {
        arguments[4][48][0].apply(exports, arguments);
      },
      {
        './common': 113,
        './exception': 115,
        './schema/default_full': 120,
        './schema/default_safe': 121,
        'dup': 48
      }
    ],
    115: [
      function (require, module, exports) {
        arguments[4][49][0].apply(exports, arguments);
      },
      { 'dup': 49 }
    ],
    116: [
      function (require, module, exports) {
        arguments[4][50][0].apply(exports, arguments);
      },
      {
        './common': 113,
        './exception': 115,
        './mark': 117,
        './schema/default_full': 120,
        './schema/default_safe': 121,
        'dup': 50
      }
    ],
    117: [
      function (require, module, exports) {
        arguments[4][51][0].apply(exports, arguments);
      },
      {
        './common': 113,
        'dup': 51
      }
    ],
    118: [
      function (require, module, exports) {
        arguments[4][52][0].apply(exports, arguments);
      },
      {
        './common': 113,
        './exception': 115,
        './type': 124,
        'dup': 52
      }
    ],
    119: [
      function (require, module, exports) {
        arguments[4][53][0].apply(exports, arguments);
      },
      {
        '../schema': 118,
        './json': 123,
        'dup': 53
      }
    ],
    120: [
      function (require, module, exports) {
        arguments[4][54][0].apply(exports, arguments);
      },
      {
        '../schema': 118,
        '../type/js/function': 129,
        '../type/js/regexp': 130,
        '../type/js/undefined': 131,
        './default_safe': 121,
        'dup': 54
      }
    ],
    121: [
      function (require, module, exports) {
        arguments[4][55][0].apply(exports, arguments);
      },
      {
        '../schema': 118,
        '../type/binary': 125,
        '../type/merge': 133,
        '../type/omap': 135,
        '../type/pairs': 136,
        '../type/set': 138,
        '../type/timestamp': 140,
        './core': 119,
        'dup': 55
      }
    ],
    122: [
      function (require, module, exports) {
        arguments[4][56][0].apply(exports, arguments);
      },
      {
        '../schema': 118,
        '../type/map': 132,
        '../type/seq': 137,
        '../type/str': 139,
        'dup': 56
      }
    ],
    123: [
      function (require, module, exports) {
        arguments[4][57][0].apply(exports, arguments);
      },
      {
        '../schema': 118,
        '../type/bool': 126,
        '../type/float': 127,
        '../type/int': 128,
        '../type/null': 134,
        './failsafe': 122,
        'dup': 57
      }
    ],
    124: [
      function (require, module, exports) {
        arguments[4][58][0].apply(exports, arguments);
      },
      {
        './exception': 115,
        'dup': 58
      }
    ],
    125: [
      function (require, module, exports) {
        arguments[4][59][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 59
      }
    ],
    126: [
      function (require, module, exports) {
        arguments[4][60][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 60
      }
    ],
    127: [
      function (require, module, exports) {
        arguments[4][61][0].apply(exports, arguments);
      },
      {
        '../common': 113,
        '../type': 124,
        'dup': 61
      }
    ],
    128: [
      function (require, module, exports) {
        arguments[4][62][0].apply(exports, arguments);
      },
      {
        '../common': 113,
        '../type': 124,
        'dup': 62
      }
    ],
    129: [
      function (require, module, exports) {
        arguments[4][63][0].apply(exports, arguments);
      },
      {
        '../../type': 124,
        'dup': 63
      }
    ],
    130: [
      function (require, module, exports) {
        arguments[4][64][0].apply(exports, arguments);
      },
      {
        '../../type': 124,
        'dup': 64
      }
    ],
    131: [
      function (require, module, exports) {
        arguments[4][65][0].apply(exports, arguments);
      },
      {
        '../../type': 124,
        'dup': 65
      }
    ],
    132: [
      function (require, module, exports) {
        arguments[4][66][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 66
      }
    ],
    133: [
      function (require, module, exports) {
        arguments[4][67][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 67
      }
    ],
    134: [
      function (require, module, exports) {
        arguments[4][68][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 68
      }
    ],
    135: [
      function (require, module, exports) {
        arguments[4][69][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 69
      }
    ],
    136: [
      function (require, module, exports) {
        arguments[4][70][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 70
      }
    ],
    137: [
      function (require, module, exports) {
        arguments[4][71][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 71
      }
    ],
    138: [
      function (require, module, exports) {
        arguments[4][72][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 72
      }
    ],
    139: [
      function (require, module, exports) {
        arguments[4][73][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 73
      }
    ],
    140: [
      function (require, module, exports) {
        arguments[4][74][0].apply(exports, arguments);
      },
      {
        '../type': 124,
        'dup': 74
      }
    ],
    141: [
      function (require, module, exports) {
        'use strict';
        // modified from https://github.com/es-shims/es5-shim
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var has = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var slice = Array.prototype.slice;
        var isArgs = require('./isArguments');
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
        var hasProtoEnumBug = isEnumerable.call(function () {
          }, 'prototype');
        var dontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
          ];
        var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        var excludedKeys = {
            $console: true,
            $external: true,
            $frame: true,
            $frameElement: true,
            $frames: true,
            $innerHeight: true,
            $innerWidth: true,
            $outerHeight: true,
            $outerWidth: true,
            $pageXOffset: true,
            $pageYOffset: true,
            $parent: true,
            $scrollLeft: true,
            $scrollTop: true,
            $scrollX: true,
            $scrollY: true,
            $self: true,
            $webkitIndexedDB: true,
            $webkitStorageInfo: true,
            $window: true
          };
        var hasAutomationEqualityBug = function () {
            /* global window */
            if (typeof window === 'undefined') {
              return false;
            }
            for (var k in window) {
              try {
                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
                  try {
                    equalsConstructorPrototype(window[k]);
                  } catch (e) {
                    return true;
                  }
                }
              } catch (e) {
                return true;
              }
            }
            return false;
          }();
        var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
          /* global window */
          if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        var keysShim = function keys(object) {
          var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
          var isFunction = toStr.call(object) === '[object Function]';
          var isArguments = isArgs(object);
          var isString = isObject && toStr.call(object) === '[object String]';
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError('Object.keys called on a non-object');
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
        keysShim.shim = function shimObjectKeys() {
          if (Object.keys) {
            var keysWorksWithArguments = function () {
                // Safari 5.0 bug
                return (Object.keys(arguments) || '').length === 2;
              }(1, 2);
            if (!keysWorksWithArguments) {
              var originalKeys = Object.keys;
              Object.keys = function keys(object) {
                if (isArgs(object)) {
                  return originalKeys(slice.call(object));
                } else {
                  return originalKeys(object);
                }
              };
            }
          } else {
            Object.keys = keysShim;
          }
          return Object.keys || keysShim;
        };
        module.exports = keysShim;
      },
      { './isArguments': 142 }
    ],
    142: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var toStr = Object.prototype.toString;
        module.exports = function isArguments(value) {
          var str = toStr.call(value);
          var isArgs = str === '[object Arguments]';
          if (!isArgs) {
            isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
          }
          return isArgs;
        };
      },
      {}
    ],
    143: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var util = require('util'), slice = Array.prototype.slice, vendorSpecificErrorProperties = [
            'name',
            'message',
            'description',
            'number',
            'fileName',
            'lineNumber',
            'columnNumber',
            'sourceURL',
            'line',
            'column',
            'stack'
          ];
        module.exports = create(Error);
        module.exports.error = create(Error);
        module.exports.eval = create(EvalError);
        module.exports.range = create(RangeError);
        module.exports.reference = create(ReferenceError);
        module.exports.syntax = create(SyntaxError);
        module.exports.type = create(TypeError);
        module.exports.uri = create(URIError);
        module.exports.formatter = util.format;
        /**
 * Creates a new {@link ono} function that creates the given Error class.
 *
 * @param {Class} Klass - The Error subclass to create
 * @returns {ono}
 */
        function create(Klass) {
          /**
   * @param {Error}   [err]     - The original error, if any
   * @param {object}  [props]   - An object whose properties will be added to the error object
   * @param {string}  [message] - The error message. May contain {@link util#format} placeholders
   * @param {...*}    [params]  - Parameters that map to the `message` placeholders
   * @returns {Error}
   */
          return function ono(err, props, message, params) {
            // eslint-disable-line no-unused-vars
            var formattedMessage;
            var formatter = module.exports.formatter;
            if (typeof err === 'string') {
              formattedMessage = formatter.apply(null, arguments);
              err = props = undefined;
            } else if (typeof props === 'string') {
              formattedMessage = formatter.apply(null, slice.call(arguments, 1));
            } else {
              formattedMessage = formatter.apply(null, slice.call(arguments, 2));
            }
            if (!(err instanceof Error)) {
              props = err;
              err = undefined;
            }
            if (err) {
              // The inner-error's message will be added to the new message
              formattedMessage += (formattedMessage ? ' \n' : '') + err.message;
            }
            // Create the new error
            // NOTE: DON'T move this to a separate function! We don't want to pollute the stack trace
            var newError = new Klass(formattedMessage);
            // Extend the new error with the additional properties
            extendError(newError, err);
            // Copy properties of the original error
            extendToJSON(newError);
            // Replace the original toJSON method
            extend(newError, props);
            // Copy custom properties, possibly including a custom toJSON method
            return newError;
          };
        }
        /**
 * Extends the targetError with the properties of the source error.
 *
 * @param {Error}   targetError - The error object to extend
 * @param {?Error}  sourceError - The source error object, if any
 */
        function extendError(targetError, sourceError) {
          if (sourceError) {
            extendStack(targetError, sourceError);
            extend(targetError, sourceError, true);
          }
        }
        /**
 * JavaScript engines differ in how errors are serialized to JSON - especially when it comes
 * to custom error properties and stack traces.  So we add our own toJSON method that ALWAYS
 * outputs every property of the error.
 */
        function extendToJSON(error) {
          error.toJSON = errorToJSON;
          // Also add an inspect() method, for compatibility with Node.js' `util.inspect()` method
          error.inspect = errorToString;
        }
        /**
 * Extends the target object with the properties of the source object.
 *
 * @param {object}  target - The object to extend
 * @param {?source} source - The object whose properties are copied
 * @param {boolean} omitVendorSpecificProperties - Skip vendor-specific Error properties
 */
        function extend(target, source, omitVendorSpecificProperties) {
          if (source && (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object') {
            var keys = Object.keys(source);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              // Don't bother trying to copy read-only vendor-specific Error properties
              if (omitVendorSpecificProperties && vendorSpecificErrorProperties.indexOf(key) >= 0) {
                continue;
              }
              try {
                target[key] = source[key];
              } catch (e) {
              }
            }
          }
        }
        /**
 * Custom JSON serializer for Error objects.
 * Returns all built-in error properties, as well as extended properties.
 *
 * @returns {object}
 */
        function errorToJSON() {
          var json = {};
          // Get all the properties of this error
          var keys = Object.keys(this);
          // Also include vendor-specific properties from the prototype
          keys = keys.concat(vendorSpecificErrorProperties);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this[key];
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            if (type !== 'undefined' && type !== 'function') {
              json[key] = value;
            }
          }
          return json;
        }
        /**
 * Serializes Error objects as human-readable JSON strings for debugging/logging purposes.
 *
 * @returns {string}
 */
        function errorToString() {
          return JSON.stringify(this, null, 2).replace(/\\n/g, '\n');
        }
        /**
 * Extend the error stack to include its cause
 */
        function extendStack(targetError, sourceError) {
          if (hasLazyStack(sourceError)) {
            extendStackProperty(targetError, sourceError);
          } else {
            var stack = sourceError.stack;
            if (stack) {
              targetError.stack += ' \n\n' + sourceError.stack;
            }
          }
        }
        /**
 * Does a one-time determination of whether this JavaScript engine
 * supports lazy `Error.stack` properties.
 */
        var supportsLazyStack = function () {
            return !!(Object.getOwnPropertyDescriptor && Object.defineProperty && (typeof navigator === 'undefined' || !/Android/.test(navigator.userAgent)));
          }();
        /**
 * Does this error have a lazy stack property?
 *
 * @returns {boolean}
 */
        function hasLazyStack(err) {
          if (!supportsLazyStack) {
            return false;
          }
          var descriptor = Object.getOwnPropertyDescriptor(err, 'stack');
          if (!descriptor) {
            return false;
          }
          return typeof descriptor.get === 'function';
        }
        /**
 * Extend the error stack to include its cause, lazily
 */
        function extendStackProperty(targetError, sourceError) {
          var sourceStack = Object.getOwnPropertyDescriptor(sourceError, 'stack');
          if (sourceStack) {
            var targetStack = Object.getOwnPropertyDescriptor(targetError, 'stack');
            Object.defineProperty(targetError, 'stack', {
              get: function get() {
                return targetStack.get.apply(targetError) + ' \n\n' + sourceError.stack;
              },
              enumerable: false,
              configurable: true
            });
          }
        }
      },
      { 'util': 187 }
    ],
    144: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
            module.exports = nextTick;
          } else {
            module.exports = process.nextTick;
          }
          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== 'function') {
              throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
            case 0:
            case 1:
              return process.nextTick(fn);
            case 2:
              return process.nextTick(function afterTickOne() {
                fn.call(null, arg1);
              });
            case 3:
              return process.nextTick(function afterTickTwo() {
                fn.call(null, arg1, arg2);
              });
            case 4:
              return process.nextTick(function afterTickThree() {
                fn.call(null, arg1, arg2, arg3);
              });
            default:
              args = new Array(len - 1);
              i = 0;
              while (i < args.length) {
                args[i++] = arguments[i];
              }
              return process.nextTick(function afterTick() {
                fn.apply(null, args);
              });
            }
          }
        }.call(this, require('_process')));
      },
      { '_process': 145 }
    ],
    145: [
      function (require, module, exports) {
        // shim for using process in browser
        var process = module.exports = {};
        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout() {
          throw new Error('clearTimeout has not been defined');
        }
        (function () {
          try {
            if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        }());
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = '';
        // empty string to avoid regexp issues
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function (name) {
          return [];
        };
        process.binding = function (name) {
          throw new Error('process.binding is not supported');
        };
        process.cwd = function () {
          return '/';
        };
        process.chdir = function (dir) {
          throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
          return 0;
        };
      },
      {}
    ],
    146: [
      function (require, module, exports) {
        (function (global) {
          /*! https://mths.be/punycode v1.4.1 by @mathias */
          ;
          (function (root) {
            /** Detect free variables */
            var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
            var freeModule = typeof module == 'object' && module && !module.nodeType && module;
            var freeGlobal = typeof global == 'object' && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
              root = freeGlobal;
            }
            /**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
            var punycode,
              /** Highest positive signed 32-bit float value */
              maxInt = 2147483647,
              // aka. 0x7FFFFFFF or 2^31-1
              /** Bootstring parameters */
              base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128,
              // 0x80
              delimiter = '-',
              // '\x2D'
              /** Regular expressions */
              regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/,
              // unprintable ASCII chars + non-ASCII chars
              regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
              // RFC 3490 separators
              /** Error messages */
              errors = {
                'overflow': 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input'
              },
              /** Convenience shortcuts */
              baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode,
              /** Temporary variable */
              key;
            /*--------------------------------------------------------------------------*/
            /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
            function error(type) {
              throw new RangeError(errors[type]);
            }
            /**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
            function map(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }
            /**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
            function mapDomain(string, fn) {
              var parts = string.split('@');
              var result = '';
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '.');
              var labels = string.split('.');
              var encoded = map(labels, fn).join('.');
              return result + encoded;
            }
            /**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
            function ucs2decode(string) {
              var output = [], counter = 0, length = string.length, value, extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 64512) == 56320) {
                    // low surrogate
                    output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }
            /**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = '';
                if (value > 65535) {
                  value -= 65536;
                  output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                  value = 56320 | value & 1023;
                }
                output += stringFromCharCode(value);
                return output;
              }).join('');
            }
            /**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }
            /**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            /**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            /**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
            function decode(input) {
              // Don't use UCS-2
              var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t,
                /** Cached calculation results */
                baseMinusT;
              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.
              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }
              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 128) {
                  error('not-basic');
                }
                output.push(input.charCodeAt(j));
              }
              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.
              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; k += base) {
                  if (index >= inputLength) {
                    error('invalid-input');
                  }
                  digit = basicToDigit(input.charCodeAt(index++));
                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                  }
                  i += digit * w;
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (digit < t) {
                    break;
                  }
                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                  }
                  w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow');
                }
                n += floor(i / out);
                i %= out;
                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
              }
              return ucs2encode(output);
            }
            /**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
            function encode(input) {
              var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne, baseMinusT, qMinusT;
              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input);
              // Cache the length
              inputLength = input.length;
              // Initialize the state
              n = initialN;
              delta = 0;
              bias = initialBias;
              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 128) {
                  output.push(stringFromCharCode(currentValue));
                }
              }
              handledCPCount = basicLength = output.length;
              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.
              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter);
              }
              // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }
                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }
                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base;; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                      q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }
                ++delta;
                ++n;
              }
              return output.join('');
            }
            /**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
              });
            }
            /**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
              });
            }
            /*--------------------------------------------------------------------------*/
            /** Define the public API */
            punycode = {
              'version': '1.4.1',
              'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
              },
              'decode': decode,
              'encode': encode,
              'toASCII': toASCII,
              'toUnicode': toUnicode
            };
            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
              define('punycode', function () {
                return punycode;
              });
            } else if (freeExports && freeModule) {
              if (module.exports == freeExports) {
                // in Node.js, io.js, or RingoJS v0.8.0+
                freeModule.exports = punycode;
              } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              // in Rhino or a web browser
              root.punycode = punycode;
            }
          }(this));
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    147: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        'use strict';
        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function (qs, sep, eq, options) {
          sep = sep || '&';
          eq = eq || '=';
          var obj = {};
          if (typeof qs !== 'string' || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1000;
          if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'), idx = x.indexOf(eq), kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = '';
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [
                obj[k],
                v
              ];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
          };
      },
      {}
    ],
    148: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var stringifyPrimitive = function stringifyPrimitive(v) {
          switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
          case 'string':
            return v;
          case 'boolean':
            return v ? 'true' : 'false';
          case 'number':
            return isFinite(v) ? v : '';
          default:
            return '';
          }
        };
        module.exports = function (obj, sep, eq, name) {
          sep = sep || '&';
          eq = eq || '=';
          if (obj === null) {
            obj = undefined;
          }
          if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
            return map(objectKeys(obj), function (k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function (v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name)
            return '';
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
          };
        function map(xs, f) {
          if (xs.map)
            return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function (obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                res.push(key);
            }
            return res;
          };
      },
      {}
    ],
    149: [
      function (require, module, exports) {
        'use strict';
        exports.decode = exports.parse = require('./decode');
        exports.encode = exports.stringify = require('./encode');
      },
      {
        './decode': 147,
        './encode': 148
      }
    ],
    150: [
      function (require, module, exports) {
        'use strict';
        /* eslint-disable node/no-deprecated-api */
        var buffer = require('buffer');
        var Buffer = buffer.Buffer;
        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module.exports = buffer;
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports);
          exports.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function (arg, encodingOrOffset, length) {
          if (typeof arg === 'number') {
            throw new TypeError('Argument must not be a number');
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function (size, fill, encoding) {
          if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number');
          }
          var buf = Buffer(size);
          if (fill !== undefined) {
            if (typeof encoding === 'string') {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function (size) {
          if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number');
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function (size) {
          if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number');
          }
          return buffer.SlowBuffer(size);
        };
      },
      { 'buffer': 5 }
    ],
    151: [
      function (require, module, exports) {
        (function (Buffer) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          ;
          (function (sax) {
            // wrapper for non-node envs
            sax.parser = function (strict, opt) {
              return new SAXParser(strict, opt);
            };
            sax.SAXParser = SAXParser;
            sax.SAXStream = SAXStream;
            sax.createStream = createStream;
            // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
            // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
            // since that's the earliest that a buffer overrun could occur.  This way, checks are
            // as rare as required, but as often as necessary to ensure never crossing this bound.
            // Furthermore, buffers are only tested at most once per write(), so passing a very
            // large string into write() might have undesirable effects, but this is manageable by
            // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
            // edge case, result in creating at most one complete copy of the string passed in.
            // Set to Infinity to have unlimited buffers.
            sax.MAX_BUFFER_LENGTH = 64 * 1024;
            var buffers = [
                'comment',
                'sgmlDecl',
                'textNode',
                'tagName',
                'doctype',
                'procInstName',
                'procInstBody',
                'entity',
                'attribName',
                'attribValue',
                'cdata',
                'script'
              ];
            sax.EVENTS = [
              'text',
              'processinginstruction',
              'sgmldeclaration',
              'doctype',
              'comment',
              'opentagstart',
              'attribute',
              'opentag',
              'closetag',
              'opencdata',
              'cdata',
              'closecdata',
              'error',
              'end',
              'ready',
              'script',
              'opennamespace',
              'closenamespace'
            ];
            function SAXParser(strict, opt) {
              if (!(this instanceof SAXParser)) {
                return new SAXParser(strict, opt);
              }
              var parser = this;
              clearBuffers(parser);
              parser.q = parser.c = '';
              parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
              parser.opt = opt || {};
              parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
              parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
              parser.tags = [];
              parser.closed = parser.closedRoot = parser.sawRoot = false;
              parser.tag = parser.error = null;
              parser.strict = !!strict;
              parser.noscript = !!(strict || parser.opt.noscript);
              parser.state = S.BEGIN;
              parser.strictEntities = parser.opt.strictEntities;
              parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
              parser.attribList = [];
              // namespaces form a prototype chain.
              // it always points at the current tag,
              // which protos to its parent tag.
              if (parser.opt.xmlns) {
                parser.ns = Object.create(rootNS);
              }
              // mostly just for error reporting
              parser.trackPosition = parser.opt.position !== false;
              if (parser.trackPosition) {
                parser.position = parser.line = parser.column = 0;
              }
              emit(parser, 'onready');
            }
            if (!Object.create) {
              Object.create = function (o) {
                function F() {
                }
                F.prototype = o;
                var newf = new F();
                return newf;
              };
            }
            if (!Object.keys) {
              Object.keys = function (o) {
                var a = [];
                for (var i in o) {
                  if (o.hasOwnProperty(i))
                    a.push(i);
                }
                return a;
              };
            }
            function checkBufferLength(parser) {
              var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
              var maxActual = 0;
              for (var i = 0, l = buffers.length; i < l; i++) {
                var len = parser[buffers[i]].length;
                if (len > maxAllowed) {
                  // Text/cdata nodes can get big, and since they're buffered,
                  // we can get here under normal conditions.
                  // Avoid issues by emitting the text node now,
                  // so at least it won't get any bigger.
                  switch (buffers[i]) {
                  case 'textNode':
                    closeText(parser);
                    break;
                  case 'cdata':
                    emitNode(parser, 'oncdata', parser.cdata);
                    parser.cdata = '';
                    break;
                  case 'script':
                    emitNode(parser, 'onscript', parser.script);
                    parser.script = '';
                    break;
                  default:
                    error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                  }
                }
                maxActual = Math.max(maxActual, len);
              }
              // schedule the next check for the earliest possible buffer overrun.
              var m = sax.MAX_BUFFER_LENGTH - maxActual;
              parser.bufferCheckPosition = m + parser.position;
            }
            function clearBuffers(parser) {
              for (var i = 0, l = buffers.length; i < l; i++) {
                parser[buffers[i]] = '';
              }
            }
            function flushBuffers(parser) {
              closeText(parser);
              if (parser.cdata !== '') {
                emitNode(parser, 'oncdata', parser.cdata);
                parser.cdata = '';
              }
              if (parser.script !== '') {
                emitNode(parser, 'onscript', parser.script);
                parser.script = '';
              }
            }
            SAXParser.prototype = {
              end: function end() {
                _end(this);
              },
              write: write,
              resume: function resume() {
                this.error = null;
                return this;
              },
              close: function close() {
                return this.write(null);
              },
              flush: function flush() {
                flushBuffers(this);
              }
            };
            var Stream;
            try {
              Stream = require('stream').Stream;
            } catch (ex) {
              Stream = function Stream() {
              };
            }
            var streamWraps = sax.EVENTS.filter(function (ev) {
                return ev !== 'error' && ev !== 'end';
              });
            function createStream(strict, opt) {
              return new SAXStream(strict, opt);
            }
            function SAXStream(strict, opt) {
              if (!(this instanceof SAXStream)) {
                return new SAXStream(strict, opt);
              }
              Stream.apply(this);
              this._parser = new SAXParser(strict, opt);
              this.writable = true;
              this.readable = true;
              var me = this;
              this._parser.onend = function () {
                me.emit('end');
              };
              this._parser.onerror = function (er) {
                me.emit('error', er);
                // if didn't throw, then means error was handled.
                // go ahead and clear error, so we can write again.
                me._parser.error = null;
              };
              this._decoder = null;
              streamWraps.forEach(function (ev) {
                Object.defineProperty(me, 'on' + ev, {
                  get: function get() {
                    return me._parser['on' + ev];
                  },
                  set: function set(h) {
                    if (!h) {
                      me.removeAllListeners(ev);
                      me._parser['on' + ev] = h;
                      return h;
                    }
                    me.on(ev, h);
                  },
                  enumerable: true,
                  configurable: false
                });
              });
            }
            SAXStream.prototype = Object.create(Stream.prototype, { constructor: { value: SAXStream } });
            SAXStream.prototype.write = function (data) {
              if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
                if (!this._decoder) {
                  var SD = require('string_decoder').StringDecoder;
                  this._decoder = new SD('utf8');
                }
                data = this._decoder.write(data);
              }
              this._parser.write(data.toString());
              this.emit('data', data);
              return true;
            };
            SAXStream.prototype.end = function (chunk) {
              if (chunk && chunk.length) {
                this.write(chunk);
              }
              this._parser.end();
              return true;
            };
            SAXStream.prototype.on = function (ev, handler) {
              var me = this;
              if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
                me._parser['on' + ev] = function () {
                  var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                  args.splice(0, 0, ev);
                  me.emit.apply(me, args);
                };
              }
              return Stream.prototype.on.call(me, ev, handler);
            };
            // this really needs to be replaced with character classes.
            // XML allows all manner of ridiculous numbers and digits.
            var CDATA = '[CDATA[';
            var DOCTYPE = 'DOCTYPE';
            var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
            var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
            var rootNS = {
                xml: XML_NAMESPACE,
                xmlns: XMLNS_NAMESPACE
              };
            var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
            var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
            function isWhitespace(c) {
              return c === ' ' || c === '\n' || c === '\r' || c === '\t';
            }
            function isQuote(c) {
              return c === '"' || c === '\'';
            }
            function isAttribEnd(c) {
              return c === '>' || isWhitespace(c);
            }
            function isMatch(regex, c) {
              return regex.test(c);
            }
            function notMatch(regex, c) {
              return !isMatch(regex, c);
            }
            var S = 0;
            sax.STATE = {
              BEGIN: S++,
              BEGIN_WHITESPACE: S++,
              TEXT: S++,
              TEXT_ENTITY: S++,
              OPEN_WAKA: S++,
              SGML_DECL: S++,
              SGML_DECL_QUOTED: S++,
              DOCTYPE: S++,
              DOCTYPE_QUOTED: S++,
              DOCTYPE_DTD: S++,
              DOCTYPE_DTD_QUOTED: S++,
              COMMENT_STARTING: S++,
              COMMENT: S++,
              COMMENT_ENDING: S++,
              COMMENT_ENDED: S++,
              CDATA: S++,
              CDATA_ENDING: S++,
              CDATA_ENDING_2: S++,
              PROC_INST: S++,
              PROC_INST_BODY: S++,
              PROC_INST_ENDING: S++,
              OPEN_TAG: S++,
              OPEN_TAG_SLASH: S++,
              ATTRIB: S++,
              ATTRIB_NAME: S++,
              ATTRIB_NAME_SAW_WHITE: S++,
              ATTRIB_VALUE: S++,
              ATTRIB_VALUE_QUOTED: S++,
              ATTRIB_VALUE_CLOSED: S++,
              ATTRIB_VALUE_UNQUOTED: S++,
              ATTRIB_VALUE_ENTITY_Q: S++,
              ATTRIB_VALUE_ENTITY_U: S++,
              CLOSE_TAG: S++,
              CLOSE_TAG_SAW_WHITE: S++,
              SCRIPT: S++,
              SCRIPT_ENDING: S++
            };
            sax.XML_ENTITIES = {
              'amp': '&',
              'gt': '>',
              'lt': '<',
              'quot': '"',
              'apos': '\''
            };
            sax.ENTITIES = {
              'amp': '&',
              'gt': '>',
              'lt': '<',
              'quot': '"',
              'apos': '\'',
              'AElig': 198,
              'Aacute': 193,
              'Acirc': 194,
              'Agrave': 192,
              'Aring': 197,
              'Atilde': 195,
              'Auml': 196,
              'Ccedil': 199,
              'ETH': 208,
              'Eacute': 201,
              'Ecirc': 202,
              'Egrave': 200,
              'Euml': 203,
              'Iacute': 205,
              'Icirc': 206,
              'Igrave': 204,
              'Iuml': 207,
              'Ntilde': 209,
              'Oacute': 211,
              'Ocirc': 212,
              'Ograve': 210,
              'Oslash': 216,
              'Otilde': 213,
              'Ouml': 214,
              'THORN': 222,
              'Uacute': 218,
              'Ucirc': 219,
              'Ugrave': 217,
              'Uuml': 220,
              'Yacute': 221,
              'aacute': 225,
              'acirc': 226,
              'aelig': 230,
              'agrave': 224,
              'aring': 229,
              'atilde': 227,
              'auml': 228,
              'ccedil': 231,
              'eacute': 233,
              'ecirc': 234,
              'egrave': 232,
              'eth': 240,
              'euml': 235,
              'iacute': 237,
              'icirc': 238,
              'igrave': 236,
              'iuml': 239,
              'ntilde': 241,
              'oacute': 243,
              'ocirc': 244,
              'ograve': 242,
              'oslash': 248,
              'otilde': 245,
              'ouml': 246,
              'szlig': 223,
              'thorn': 254,
              'uacute': 250,
              'ucirc': 251,
              'ugrave': 249,
              'uuml': 252,
              'yacute': 253,
              'yuml': 255,
              'copy': 169,
              'reg': 174,
              'nbsp': 160,
              'iexcl': 161,
              'cent': 162,
              'pound': 163,
              'curren': 164,
              'yen': 165,
              'brvbar': 166,
              'sect': 167,
              'uml': 168,
              'ordf': 170,
              'laquo': 171,
              'not': 172,
              'shy': 173,
              'macr': 175,
              'deg': 176,
              'plusmn': 177,
              'sup1': 185,
              'sup2': 178,
              'sup3': 179,
              'acute': 180,
              'micro': 181,
              'para': 182,
              'middot': 183,
              'cedil': 184,
              'ordm': 186,
              'raquo': 187,
              'frac14': 188,
              'frac12': 189,
              'frac34': 190,
              'iquest': 191,
              'times': 215,
              'divide': 247,
              'OElig': 338,
              'oelig': 339,
              'Scaron': 352,
              'scaron': 353,
              'Yuml': 376,
              'fnof': 402,
              'circ': 710,
              'tilde': 732,
              'Alpha': 913,
              'Beta': 914,
              'Gamma': 915,
              'Delta': 916,
              'Epsilon': 917,
              'Zeta': 918,
              'Eta': 919,
              'Theta': 920,
              'Iota': 921,
              'Kappa': 922,
              'Lambda': 923,
              'Mu': 924,
              'Nu': 925,
              'Xi': 926,
              'Omicron': 927,
              'Pi': 928,
              'Rho': 929,
              'Sigma': 931,
              'Tau': 932,
              'Upsilon': 933,
              'Phi': 934,
              'Chi': 935,
              'Psi': 936,
              'Omega': 937,
              'alpha': 945,
              'beta': 946,
              'gamma': 947,
              'delta': 948,
              'epsilon': 949,
              'zeta': 950,
              'eta': 951,
              'theta': 952,
              'iota': 953,
              'kappa': 954,
              'lambda': 955,
              'mu': 956,
              'nu': 957,
              'xi': 958,
              'omicron': 959,
              'pi': 960,
              'rho': 961,
              'sigmaf': 962,
              'sigma': 963,
              'tau': 964,
              'upsilon': 965,
              'phi': 966,
              'chi': 967,
              'psi': 968,
              'omega': 969,
              'thetasym': 977,
              'upsih': 978,
              'piv': 982,
              'ensp': 8194,
              'emsp': 8195,
              'thinsp': 8201,
              'zwnj': 8204,
              'zwj': 8205,
              'lrm': 8206,
              'rlm': 8207,
              'ndash': 8211,
              'mdash': 8212,
              'lsquo': 8216,
              'rsquo': 8217,
              'sbquo': 8218,
              'ldquo': 8220,
              'rdquo': 8221,
              'bdquo': 8222,
              'dagger': 8224,
              'Dagger': 8225,
              'bull': 8226,
              'hellip': 8230,
              'permil': 8240,
              'prime': 8242,
              'Prime': 8243,
              'lsaquo': 8249,
              'rsaquo': 8250,
              'oline': 8254,
              'frasl': 8260,
              'euro': 8364,
              'image': 8465,
              'weierp': 8472,
              'real': 8476,
              'trade': 8482,
              'alefsym': 8501,
              'larr': 8592,
              'uarr': 8593,
              'rarr': 8594,
              'darr': 8595,
              'harr': 8596,
              'crarr': 8629,
              'lArr': 8656,
              'uArr': 8657,
              'rArr': 8658,
              'dArr': 8659,
              'hArr': 8660,
              'forall': 8704,
              'part': 8706,
              'exist': 8707,
              'empty': 8709,
              'nabla': 8711,
              'isin': 8712,
              'notin': 8713,
              'ni': 8715,
              'prod': 8719,
              'sum': 8721,
              'minus': 8722,
              'lowast': 8727,
              'radic': 8730,
              'prop': 8733,
              'infin': 8734,
              'ang': 8736,
              'and': 8743,
              'or': 8744,
              'cap': 8745,
              'cup': 8746,
              'int': 8747,
              'there4': 8756,
              'sim': 8764,
              'cong': 8773,
              'asymp': 8776,
              'ne': 8800,
              'equiv': 8801,
              'le': 8804,
              'ge': 8805,
              'sub': 8834,
              'sup': 8835,
              'nsub': 8836,
              'sube': 8838,
              'supe': 8839,
              'oplus': 8853,
              'otimes': 8855,
              'perp': 8869,
              'sdot': 8901,
              'lceil': 8968,
              'rceil': 8969,
              'lfloor': 8970,
              'rfloor': 8971,
              'lang': 9001,
              'rang': 9002,
              'loz': 9674,
              'spades': 9824,
              'clubs': 9827,
              'hearts': 9829,
              'diams': 9830
            };
            Object.keys(sax.ENTITIES).forEach(function (key) {
              var e = sax.ENTITIES[key];
              var s = typeof e === 'number' ? String.fromCharCode(e) : e;
              sax.ENTITIES[key] = s;
            });
            for (var s in sax.STATE) {
              sax.STATE[sax.STATE[s]] = s;
            }
            // shorthand
            S = sax.STATE;
            function emit(parser, event, data) {
              parser[event] && parser[event](data);
            }
            function emitNode(parser, nodeType, data) {
              if (parser.textNode)
                closeText(parser);
              emit(parser, nodeType, data);
            }
            function closeText(parser) {
              parser.textNode = textopts(parser.opt, parser.textNode);
              if (parser.textNode)
                emit(parser, 'ontext', parser.textNode);
              parser.textNode = '';
            }
            function textopts(opt, text) {
              if (opt.trim)
                text = text.trim();
              if (opt.normalize)
                text = text.replace(/\s+/g, ' ');
              return text;
            }
            function error(parser, er) {
              closeText(parser);
              if (parser.trackPosition) {
                er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
              }
              er = new Error(er);
              parser.error = er;
              emit(parser, 'onerror', er);
              return parser;
            }
            function _end(parser) {
              if (parser.sawRoot && !parser.closedRoot)
                strictFail(parser, 'Unclosed root tag');
              if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
                error(parser, 'Unexpected end');
              }
              closeText(parser);
              parser.c = '';
              parser.closed = true;
              emit(parser, 'onend');
              SAXParser.call(parser, parser.strict, parser.opt);
              return parser;
            }
            function strictFail(parser, message) {
              if ((typeof parser === 'undefined' ? 'undefined' : _typeof(parser)) !== 'object' || !(parser instanceof SAXParser)) {
                throw new Error('bad call to strictFail');
              }
              if (parser.strict) {
                error(parser, message);
              }
            }
            function newTag(parser) {
              if (!parser.strict)
                parser.tagName = parser.tagName[parser.looseCase]();
              var parent = parser.tags[parser.tags.length - 1] || parser;
              var tag = parser.tag = {
                  name: parser.tagName,
                  attributes: {}
                };
              if (parser.opt.xmlns) {
                tag.ns = parent.ns;
              }
              parser.attribList.length = 0;
              emitNode(parser, 'onopentagstart', tag);
            }
            function qname(name, attribute) {
              var i = name.indexOf(':');
              var qualName = i < 0 ? [
                  '',
                  name
                ] : name.split(':');
              var prefix = qualName[0];
              var local = qualName[1];
              // <x "xmlns"="http://foo">
              if (attribute && name === 'xmlns') {
                prefix = 'xmlns';
                local = '';
              }
              return {
                prefix: prefix,
                local: local
              };
            }
            function attrib(parser) {
              if (!parser.strict) {
                parser.attribName = parser.attribName[parser.looseCase]();
              }
              if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                parser.attribName = parser.attribValue = '';
                return;
              }
              if (parser.opt.xmlns) {
                var qn = qname(parser.attribName, true);
                var prefix = qn.prefix;
                var local = qn.local;
                if (prefix === 'xmlns') {
                  // namespace binding attribute. push the binding into scope
                  if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                    strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                  } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                    strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                  } else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) {
                      tag.ns = Object.create(parent.ns);
                    }
                    tag.ns[local] = parser.attribValue;
                  }
                }
                // defer onattribute events until all attributes have been seen
                // so any new bindings can take effect. preserve attribute order
                // so deferred events can be emitted in document order
                parser.attribList.push([
                  parser.attribName,
                  parser.attribValue
                ]);
              } else {
                // in non-xmlns mode, we can emit the event right away
                parser.tag.attributes[parser.attribName] = parser.attribValue;
                emitNode(parser, 'onattribute', {
                  name: parser.attribName,
                  value: parser.attribValue
                });
              }
              parser.attribName = parser.attribValue = '';
            }
            function openTag(parser, selfClosing) {
              if (parser.opt.xmlns) {
                // emit namespace binding events
                var tag = parser.tag;
                // add namespace info to tag
                var qn = qname(parser.tagName);
                tag.prefix = qn.prefix;
                tag.local = qn.local;
                tag.uri = tag.ns[qn.prefix] || '';
                if (tag.prefix && !tag.uri) {
                  strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                  tag.uri = qn.prefix;
                }
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns && parent.ns !== tag.ns) {
                  Object.keys(tag.ns).forEach(function (p) {
                    emitNode(parser, 'onopennamespace', {
                      prefix: p,
                      uri: tag.ns[p]
                    });
                  });
                }
                // handle deferred onattribute events
                // Note: do not apply default ns to attributes:
                //   http://www.w3.org/TR/REC-xml-names/#defaulting
                for (var i = 0, l = parser.attribList.length; i < l; i++) {
                  var nv = parser.attribList[i];
                  var name = nv[0];
                  var value = nv[1];
                  var qualName = qname(name, true);
                  var prefix = qualName.prefix;
                  var local = qualName.local;
                  var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                  var a = {
                      name: name,
                      value: value,
                      prefix: prefix,
                      local: local,
                      uri: uri
                    };
                  if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                  }
                  parser.tag.attributes[name] = a;
                  emitNode(parser, 'onattribute', a);
                }
                parser.attribList.length = 0;
              }
              parser.tag.isSelfClosing = !!selfClosing;
              // process the tag
              parser.sawRoot = true;
              parser.tags.push(parser.tag);
              emitNode(parser, 'onopentag', parser.tag);
              if (!selfClosing) {
                // special case for <script> in non-strict mode.
                if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                  parser.state = S.SCRIPT;
                } else {
                  parser.state = S.TEXT;
                }
                parser.tag = null;
                parser.tagName = '';
              }
              parser.attribName = parser.attribValue = '';
              parser.attribList.length = 0;
            }
            function closeTag(parser) {
              if (!parser.tagName) {
                strictFail(parser, 'Weird empty close tag.');
                parser.textNode += '</>';
                parser.state = S.TEXT;
                return;
              }
              if (parser.script) {
                if (parser.tagName !== 'script') {
                  parser.script += '</' + parser.tagName + '>';
                  parser.tagName = '';
                  parser.state = S.SCRIPT;
                  return;
                }
                emitNode(parser, 'onscript', parser.script);
                parser.script = '';
              }
              // first make sure that the closing tag actually exists.
              // <a><b></c></b></a> will close everything, otherwise.
              var t = parser.tags.length;
              var tagName = parser.tagName;
              if (!parser.strict) {
                tagName = tagName[parser.looseCase]();
              }
              var closeTo = tagName;
              while (t--) {
                var close = parser.tags[t];
                if (close.name !== closeTo) {
                  // fail the first time in strict mode
                  strictFail(parser, 'Unexpected close tag');
                } else {
                  break;
                }
              }
              // didn't find it.  we already failed for strict, so just abort.
              if (t < 0) {
                strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
                parser.textNode += '</' + parser.tagName + '>';
                parser.state = S.TEXT;
                return;
              }
              parser.tagName = tagName;
              var s = parser.tags.length;
              while (s-- > t) {
                var tag = parser.tag = parser.tags.pop();
                parser.tagName = parser.tag.name;
                emitNode(parser, 'onclosetag', parser.tagName);
                var x = {};
                for (var i in tag.ns) {
                  x[i] = tag.ns[i];
                }
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (parser.opt.xmlns && tag.ns !== parent.ns) {
                  // remove namespace bindings introduced by tag
                  Object.keys(tag.ns).forEach(function (p) {
                    var n = tag.ns[p];
                    emitNode(parser, 'onclosenamespace', {
                      prefix: p,
                      uri: n
                    });
                  });
                }
              }
              if (t === 0)
                parser.closedRoot = true;
              parser.tagName = parser.attribValue = parser.attribName = '';
              parser.attribList.length = 0;
              parser.state = S.TEXT;
            }
            function parseEntity(parser) {
              var entity = parser.entity;
              var entityLC = entity.toLowerCase();
              var num;
              var numStr = '';
              if (parser.ENTITIES[entity]) {
                return parser.ENTITIES[entity];
              }
              if (parser.ENTITIES[entityLC]) {
                return parser.ENTITIES[entityLC];
              }
              entity = entityLC;
              if (entity.charAt(0) === '#') {
                if (entity.charAt(1) === 'x') {
                  entity = entity.slice(2);
                  num = parseInt(entity, 16);
                  numStr = num.toString(16);
                } else {
                  entity = entity.slice(1);
                  num = parseInt(entity, 10);
                  numStr = num.toString(10);
                }
              }
              entity = entity.replace(/^0+/, '');
              if (isNaN(num) || numStr.toLowerCase() !== entity) {
                strictFail(parser, 'Invalid character entity');
                return '&' + parser.entity + ';';
              }
              return String.fromCodePoint(num);
            }
            function beginWhiteSpace(parser, c) {
              if (c === '<') {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (!isWhitespace(c)) {
                // have to process this as a text node.
                // weird, but happens.
                strictFail(parser, 'Non-whitespace before first tag.');
                parser.textNode = c;
                parser.state = S.TEXT;
              }
            }
            function charAt(chunk, i) {
              var result = '';
              if (i < chunk.length) {
                result = chunk.charAt(i);
              }
              return result;
            }
            function write(chunk) {
              var parser = this;
              if (this.error) {
                throw this.error;
              }
              if (parser.closed) {
                return error(parser, 'Cannot write after close. Assign an onready handler.');
              }
              if (chunk === null) {
                return _end(parser);
              }
              if ((typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) === 'object') {
                chunk = chunk.toString();
              }
              var i = 0;
              var c = '';
              while (true) {
                c = charAt(chunk, i++);
                parser.c = c;
                if (!c) {
                  break;
                }
                if (parser.trackPosition) {
                  parser.position++;
                  if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
                switch (parser.state) {
                case S.BEGIN:
                  parser.state = S.BEGIN_WHITESPACE;
                  if (c === '\ufeff') {
                    continue;
                  }
                  beginWhiteSpace(parser, c);
                  continue;
                case S.BEGIN_WHITESPACE:
                  beginWhiteSpace(parser, c);
                  continue;
                case S.TEXT:
                  if (parser.sawRoot && !parser.closedRoot) {
                    var starti = i - 1;
                    while (c && c !== '<' && c !== '&') {
                      c = charAt(chunk, i++);
                      if (c && parser.trackPosition) {
                        parser.position++;
                        if (c === '\n') {
                          parser.line++;
                          parser.column = 0;
                        } else {
                          parser.column++;
                        }
                      }
                    }
                    parser.textNode += chunk.substring(starti, i - 1);
                  }
                  if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                    parser.state = S.OPEN_WAKA;
                    parser.startTagPosition = parser.position;
                  } else {
                    if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                      strictFail(parser, 'Text data outside of root node.');
                    }
                    if (c === '&') {
                      parser.state = S.TEXT_ENTITY;
                    } else {
                      parser.textNode += c;
                    }
                  }
                  continue;
                case S.SCRIPT:
                  // only non-strict
                  if (c === '<') {
                    parser.state = S.SCRIPT_ENDING;
                  } else {
                    parser.script += c;
                  }
                  continue;
                case S.SCRIPT_ENDING:
                  if (c === '/') {
                    parser.state = S.CLOSE_TAG;
                  } else {
                    parser.script += '<' + c;
                    parser.state = S.SCRIPT;
                  }
                  continue;
                case S.OPEN_WAKA:
                  // either a /, ?, !, or text is coming next.
                  if (c === '!') {
                    parser.state = S.SGML_DECL;
                    parser.sgmlDecl = '';
                  } else if (isWhitespace(c)) {
                  } else if (isMatch(nameStart, c)) {
                    parser.state = S.OPEN_TAG;
                    parser.tagName = c;
                  } else if (c === '/') {
                    parser.state = S.CLOSE_TAG;
                    parser.tagName = '';
                  } else if (c === '?') {
                    parser.state = S.PROC_INST;
                    parser.procInstName = parser.procInstBody = '';
                  } else {
                    strictFail(parser, 'Unencoded <');
                    // if there was some whitespace, then add that in.
                    if (parser.startTagPosition + 1 < parser.position) {
                      var pad = parser.position - parser.startTagPosition;
                      c = new Array(pad).join(' ') + c;
                    }
                    parser.textNode += '<' + c;
                    parser.state = S.TEXT;
                  }
                  continue;
                case S.SGML_DECL:
                  if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                    emitNode(parser, 'onopencdata');
                    parser.state = S.CDATA;
                    parser.sgmlDecl = '';
                    parser.cdata = '';
                  } else if (parser.sgmlDecl + c === '--') {
                    parser.state = S.COMMENT;
                    parser.comment = '';
                    parser.sgmlDecl = '';
                  } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                    parser.state = S.DOCTYPE;
                    if (parser.doctype || parser.sawRoot) {
                      strictFail(parser, 'Inappropriately located doctype declaration');
                    }
                    parser.doctype = '';
                    parser.sgmlDecl = '';
                  } else if (c === '>') {
                    emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                    parser.sgmlDecl = '';
                    parser.state = S.TEXT;
                  } else if (isQuote(c)) {
                    parser.state = S.SGML_DECL_QUOTED;
                    parser.sgmlDecl += c;
                  } else {
                    parser.sgmlDecl += c;
                  }
                  continue;
                case S.SGML_DECL_QUOTED:
                  if (c === parser.q) {
                    parser.state = S.SGML_DECL;
                    parser.q = '';
                  }
                  parser.sgmlDecl += c;
                  continue;
                case S.DOCTYPE:
                  if (c === '>') {
                    parser.state = S.TEXT;
                    emitNode(parser, 'ondoctype', parser.doctype);
                    parser.doctype = true;  // just remember that we saw it.
                  } else {
                    parser.doctype += c;
                    if (c === '[') {
                      parser.state = S.DOCTYPE_DTD;
                    } else if (isQuote(c)) {
                      parser.state = S.DOCTYPE_QUOTED;
                      parser.q = c;
                    }
                  }
                  continue;
                case S.DOCTYPE_QUOTED:
                  parser.doctype += c;
                  if (c === parser.q) {
                    parser.q = '';
                    parser.state = S.DOCTYPE;
                  }
                  continue;
                case S.DOCTYPE_DTD:
                  parser.doctype += c;
                  if (c === ']') {
                    parser.state = S.DOCTYPE;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_DTD_QUOTED;
                    parser.q = c;
                  }
                  continue;
                case S.DOCTYPE_DTD_QUOTED:
                  parser.doctype += c;
                  if (c === parser.q) {
                    parser.state = S.DOCTYPE_DTD;
                    parser.q = '';
                  }
                  continue;
                case S.COMMENT:
                  if (c === '-') {
                    parser.state = S.COMMENT_ENDING;
                  } else {
                    parser.comment += c;
                  }
                  continue;
                case S.COMMENT_ENDING:
                  if (c === '-') {
                    parser.state = S.COMMENT_ENDED;
                    parser.comment = textopts(parser.opt, parser.comment);
                    if (parser.comment) {
                      emitNode(parser, 'oncomment', parser.comment);
                    }
                    parser.comment = '';
                  } else {
                    parser.comment += '-' + c;
                    parser.state = S.COMMENT;
                  }
                  continue;
                case S.COMMENT_ENDED:
                  if (c !== '>') {
                    strictFail(parser, 'Malformed comment');
                    // allow <!-- blah -- bloo --> in non-strict mode,
                    // which is a comment of " blah -- bloo "
                    parser.comment += '--' + c;
                    parser.state = S.COMMENT;
                  } else {
                    parser.state = S.TEXT;
                  }
                  continue;
                case S.CDATA:
                  if (c === ']') {
                    parser.state = S.CDATA_ENDING;
                  } else {
                    parser.cdata += c;
                  }
                  continue;
                case S.CDATA_ENDING:
                  if (c === ']') {
                    parser.state = S.CDATA_ENDING_2;
                  } else {
                    parser.cdata += ']' + c;
                    parser.state = S.CDATA;
                  }
                  continue;
                case S.CDATA_ENDING_2:
                  if (c === '>') {
                    if (parser.cdata) {
                      emitNode(parser, 'oncdata', parser.cdata);
                    }
                    emitNode(parser, 'onclosecdata');
                    parser.cdata = '';
                    parser.state = S.TEXT;
                  } else if (c === ']') {
                    parser.cdata += ']';
                  } else {
                    parser.cdata += ']]' + c;
                    parser.state = S.CDATA;
                  }
                  continue;
                case S.PROC_INST:
                  if (c === '?') {
                    parser.state = S.PROC_INST_ENDING;
                  } else if (isWhitespace(c)) {
                    parser.state = S.PROC_INST_BODY;
                  } else {
                    parser.procInstName += c;
                  }
                  continue;
                case S.PROC_INST_BODY:
                  if (!parser.procInstBody && isWhitespace(c)) {
                    continue;
                  } else if (c === '?') {
                    parser.state = S.PROC_INST_ENDING;
                  } else {
                    parser.procInstBody += c;
                  }
                  continue;
                case S.PROC_INST_ENDING:
                  if (c === '>') {
                    emitNode(parser, 'onprocessinginstruction', {
                      name: parser.procInstName,
                      body: parser.procInstBody
                    });
                    parser.procInstName = parser.procInstBody = '';
                    parser.state = S.TEXT;
                  } else {
                    parser.procInstBody += '?' + c;
                    parser.state = S.PROC_INST_BODY;
                  }
                  continue;
                case S.OPEN_TAG:
                  if (isMatch(nameBody, c)) {
                    parser.tagName += c;
                  } else {
                    newTag(parser);
                    if (c === '>') {
                      openTag(parser);
                    } else if (c === '/') {
                      parser.state = S.OPEN_TAG_SLASH;
                    } else {
                      if (!isWhitespace(c)) {
                        strictFail(parser, 'Invalid character in tag name');
                      }
                      parser.state = S.ATTRIB;
                    }
                  }
                  continue;
                case S.OPEN_TAG_SLASH:
                  if (c === '>') {
                    openTag(parser, true);
                    closeTag(parser);
                  } else {
                    strictFail(parser, 'Forward-slash in opening tag not followed by >');
                    parser.state = S.ATTRIB;
                  }
                  continue;
                case S.ATTRIB:
                  // haven't read the attribute name yet.
                  if (isWhitespace(c)) {
                    continue;
                  } else if (c === '>') {
                    openTag(parser);
                  } else if (c === '/') {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.attribValue = '';
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, 'Invalid attribute name');
                  }
                  continue;
                case S.ATTRIB_NAME:
                  if (c === '=') {
                    parser.state = S.ATTRIB_VALUE;
                  } else if (c === '>') {
                    strictFail(parser, 'Attribute without value');
                    parser.attribValue = parser.attribName;
                    attrib(parser);
                    openTag(parser);
                  } else if (isWhitespace(c)) {
                    parser.state = S.ATTRIB_NAME_SAW_WHITE;
                  } else if (isMatch(nameBody, c)) {
                    parser.attribName += c;
                  } else {
                    strictFail(parser, 'Invalid attribute name');
                  }
                  continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                  if (c === '=') {
                    parser.state = S.ATTRIB_VALUE;
                  } else if (isWhitespace(c)) {
                    continue;
                  } else {
                    strictFail(parser, 'Attribute without value');
                    parser.tag.attributes[parser.attribName] = '';
                    parser.attribValue = '';
                    emitNode(parser, 'onattribute', {
                      name: parser.attribName,
                      value: ''
                    });
                    parser.attribName = '';
                    if (c === '>') {
                      openTag(parser);
                    } else if (isMatch(nameStart, c)) {
                      parser.attribName = c;
                      parser.state = S.ATTRIB_NAME;
                    } else {
                      strictFail(parser, 'Invalid attribute name');
                      parser.state = S.ATTRIB;
                    }
                  }
                  continue;
                case S.ATTRIB_VALUE:
                  if (isWhitespace(c)) {
                    continue;
                  } else if (isQuote(c)) {
                    parser.q = c;
                    parser.state = S.ATTRIB_VALUE_QUOTED;
                  } else {
                    strictFail(parser, 'Unquoted attribute value');
                    parser.state = S.ATTRIB_VALUE_UNQUOTED;
                    parser.attribValue = c;
                  }
                  continue;
                case S.ATTRIB_VALUE_QUOTED:
                  if (c !== parser.q) {
                    if (c === '&') {
                      parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                    } else {
                      parser.attribValue += c;
                    }
                    continue;
                  }
                  attrib(parser);
                  parser.q = '';
                  parser.state = S.ATTRIB_VALUE_CLOSED;
                  continue;
                case S.ATTRIB_VALUE_CLOSED:
                  if (isWhitespace(c)) {
                    parser.state = S.ATTRIB;
                  } else if (c === '>') {
                    openTag(parser);
                  } else if (c === '/') {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else if (isMatch(nameStart, c)) {
                    strictFail(parser, 'No whitespace between attributes');
                    parser.attribName = c;
                    parser.attribValue = '';
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, 'Invalid attribute name');
                  }
                  continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                  if (!isAttribEnd(c)) {
                    if (c === '&') {
                      parser.state = S.ATTRIB_VALUE_ENTITY_U;
                    } else {
                      parser.attribValue += c;
                    }
                    continue;
                  }
                  attrib(parser);
                  if (c === '>') {
                    openTag(parser);
                  } else {
                    parser.state = S.ATTRIB;
                  }
                  continue;
                case S.CLOSE_TAG:
                  if (!parser.tagName) {
                    if (isWhitespace(c)) {
                      continue;
                    } else if (notMatch(nameStart, c)) {
                      if (parser.script) {
                        parser.script += '</' + c;
                        parser.state = S.SCRIPT;
                      } else {
                        strictFail(parser, 'Invalid tagname in closing tag.');
                      }
                    } else {
                      parser.tagName = c;
                    }
                  } else if (c === '>') {
                    closeTag(parser);
                  } else if (isMatch(nameBody, c)) {
                    parser.tagName += c;
                  } else if (parser.script) {
                    parser.script += '</' + parser.tagName;
                    parser.tagName = '';
                    parser.state = S.SCRIPT;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, 'Invalid tagname in closing tag');
                    }
                    parser.state = S.CLOSE_TAG_SAW_WHITE;
                  }
                  continue;
                case S.CLOSE_TAG_SAW_WHITE:
                  if (isWhitespace(c)) {
                    continue;
                  }
                  if (c === '>') {
                    closeTag(parser);
                  } else {
                    strictFail(parser, 'Invalid characters in closing tag');
                  }
                  continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                  var returnState;
                  var buffer;
                  switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = 'textNode';
                    break;
                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = 'attribValue';
                    break;
                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = 'attribValue';
                    break;
                  }
                  if (c === ';') {
                    parser[buffer] += parseEntity(parser);
                    parser.entity = '';
                    parser.state = returnState;
                  } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                    parser.entity += c;
                  } else {
                    strictFail(parser, 'Invalid character in entity name');
                    parser[buffer] += '&' + parser.entity + c;
                    parser.entity = '';
                    parser.state = returnState;
                  }
                  continue;
                default:
                  throw new Error(parser, 'Unknown state: ' + parser.state);
                }
              }
              // while
              if (parser.position >= parser.bufferCheckPosition) {
                checkBufferLength(parser);
              }
              return parser;
            }
            /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
            /* istanbul ignore next */
            if (!String.fromCodePoint) {
              (function () {
                var stringFromCharCode = String.fromCharCode;
                var floor = Math.floor;
                var fromCodePoint = function fromCodePoint() {
                  var MAX_SIZE = 16384;
                  var codeUnits = [];
                  var highSurrogate;
                  var lowSurrogate;
                  var index = -1;
                  var length = arguments.length;
                  if (!length) {
                    return '';
                  }
                  var result = '';
                  while (++index < length) {
                    var codePoint = Number(arguments[index]);
                    if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                      throw RangeError('Invalid code point: ' + codePoint);
                    }
                    if (codePoint <= 65535) {
                      // BMP code point
                      codeUnits.push(codePoint);
                    } else {
                      // Astral code point; split in surrogate halves
                      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                      codePoint -= 65536;
                      highSurrogate = (codePoint >> 10) + 55296;
                      lowSurrogate = codePoint % 1024 + 56320;
                      codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                      result += stringFromCharCode.apply(null, codeUnits);
                      codeUnits.length = 0;
                    }
                  }
                  return result;
                };
                /* istanbul ignore next */
                if (Object.defineProperty) {
                  Object.defineProperty(String, 'fromCodePoint', {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                  });
                } else {
                  String.fromCodePoint = fromCodePoint;
                }
              }());
            }
          }(typeof exports === 'undefined' ? undefined.sax = {} : exports));
        }.call(this, require('buffer').Buffer));
      },
      {
        'buffer': 5,
        'stream': 152,
        'string_decoder': 172
      }
    ],
    152: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        module.exports = Stream;
        var EE = require('events').EventEmitter;
        var inherits = require('inherits');
        inherits(Stream, EE);
        Stream.Readable = require('readable-stream/readable.js');
        Stream.Writable = require('readable-stream/writable.js');
        Stream.Duplex = require('readable-stream/duplex.js');
        Stream.Transform = require('readable-stream/transform.js');
        Stream.PassThrough = require('readable-stream/passthrough.js');
        // Backwards-compat with node 0.4.x
        Stream.Stream = Stream;
        // old-style streams.  Note that the pipe method (the only relevant
        // part of this class) is overridden in the Readable class.
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function (dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on('data', ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on('drain', ondrain);
          // If the 'end' option is not supplied, dest.end() will be called when
          // source gets the 'end' or 'close' events.  Only dest.end() once.
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on('end', onend);
            source.on('close', onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === 'function')
              dest.destroy();
          }
          // don't leave dangling pipes when there are errors.
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, 'error') === 0) {
              throw er;  // Unhandled stream error in pipe.
            }
          }
          source.on('error', onerror);
          dest.on('error', onerror);
          // remove all the event listeners that were added.
          function cleanup() {
            source.removeListener('data', ondata);
            dest.removeListener('drain', ondrain);
            source.removeListener('end', onend);
            source.removeListener('close', onclose);
            source.removeListener('error', onerror);
            dest.removeListener('error', onerror);
            source.removeListener('end', cleanup);
            source.removeListener('close', cleanup);
            dest.removeListener('close', cleanup);
          }
          source.on('end', cleanup);
          source.on('close', cleanup);
          dest.on('close', cleanup);
          dest.emit('pipe', source);
          // Allow for unix-like usage: A.pipe(B).pipe(C)
          return dest;
        };
      },
      {
        'events': 13,
        'inherits': 19,
        'readable-stream/duplex.js': 154,
        'readable-stream/passthrough.js': 163,
        'readable-stream/readable.js': 164,
        'readable-stream/transform.js': 165,
        'readable-stream/writable.js': 166
      }
    ],
    153: [
      function (require, module, exports) {
        arguments[4][6][0].apply(exports, arguments);
      },
      { 'dup': 6 }
    ],
    154: [
      function (require, module, exports) {
        module.exports = require('./lib/_stream_duplex.js');
      },
      { './lib/_stream_duplex.js': 155 }
    ],
    155: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.
        'use strict';
        /*<replacement>*/
        var processNextTick = require('process-nextick-args');
        /*</replacement>*/
        /*<replacement>*/
        var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) {
              keys.push(key);
            }
            return keys;
          };
        /*</replacement>*/
        module.exports = Duplex;
        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/
        var Readable = require('./_stream_readable');
        var Writable = require('./_stream_writable');
        util.inherits(Duplex, Readable);
        var keys = objectKeys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false)
            this.readable = false;
          if (options && options.writable === false)
            this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;
          this.once('end', onend);
        }
        // the no-half-open enforcer
        function onend() {
          // if we allow half-open state, or if the writable side ended,
          // then we're ok.
          if (this.allowHalfOpen || this._writableState.ended)
            return;
          // no more data can be written.
          // But allow more writes to happen in this tick.
          processNextTick(onEndNT, this);
        }
        function onEndNT(self) {
          self.end();
        }
        Object.defineProperty(Duplex.prototype, 'destroyed', {
          get: function () {
            if (this._readableState === undefined || this._writableState === undefined) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function (value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (this._readableState === undefined || this._writableState === undefined) {
              return;
            }
            // backward compatibility, the user is explicitly
            // managing destroyed
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        });
        Duplex.prototype._destroy = function (err, cb) {
          this.push(null);
          this.end();
          processNextTick(cb, err);
        };
        function forEach(xs, f) {
          for (var i = 0, l = xs.length; i < l; i++) {
            f(xs[i], i);
          }
        }
      },
      {
        './_stream_readable': 157,
        './_stream_writable': 159,
        'core-util-is': 9,
        'inherits': 19,
        'process-nextick-args': 144
      }
    ],
    156: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.
        'use strict';
        module.exports = PassThrough;
        var Transform = require('./_stream_transform');
        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function (chunk, encoding, cb) {
          cb(null, chunk);
        };
      },
      {
        './_stream_transform': 158,
        'core-util-is': 9,
        'inherits': 19
      }
    ],
    157: [
      function (require, module, exports) {
        (function (process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          'use strict';
          /*<replacement>*/
          var processNextTick = require('process-nextick-args');
          /*</replacement>*/
          module.exports = Readable;
          /*<replacement>*/
          var isArray = require('isarray');
          /*</replacement>*/
          /*<replacement>*/
          var Duplex;
          /*</replacement>*/
          Readable.ReadableState = ReadableState;
          /*<replacement>*/
          var EE = require('events').EventEmitter;
          var EElistenerCount = function (emitter, type) {
            return emitter.listeners(type).length;
          };
          /*</replacement>*/
          /*<replacement>*/
          var Stream = require('./internal/streams/stream');
          /*</replacement>*/
          // TODO(bmeurer): Change this back to const once hole checks are
          // properly optimized away early in Ignition+TurboFan.
          /*<replacement>*/
          var Buffer = require('safe-buffer').Buffer;
          var OurUint8Array = global.Uint8Array || function () {
            };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          /*</replacement>*/
          /*<replacement>*/
          var util = require('core-util-is');
          util.inherits = require('inherits');
          /*</replacement>*/
          /*<replacement>*/
          var debugUtil = require('util');
          var debug = void 0;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream');
          } else {
            debug = function () {
            };
          }
          /*</replacement>*/
          var BufferList = require('./internal/streams/BufferList');
          var destroyImpl = require('./internal/streams/destroy');
          var StringDecoder;
          util.inherits(Readable, Stream);
          var kProxyEvents = [
              'error',
              'close',
              'destroy',
              'pause',
              'resume'
            ];
          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === 'function') {
              return emitter.prependListener(event, fn);
            } else {
              // This is a hack to make sure that our error handler is attached before any
              // userland ones.  NEVER DO THIS. This is here only because this code needs
              // to continue to work with older versions of Node.js that do not include
              // the prependListener() method. The goal is to eventually remove this hack.
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [
                  fn,
                  emitter._events[event]
                ];
            }
          }
          function ReadableState(options, stream) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {};
            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark);
            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.
            this.sync = true;
            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            // has it been destroyed
            this.destroyed = false;
            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0;
            // if true, a maybeReadMore has been scheduled
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require('./_stream_duplex');
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            // legacy
            this.readable = true;
            if (options) {
              if (typeof options.read === 'function')
                this._read = options.read;
              if (typeof options.destroy === 'function')
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, 'destroyed', {
            get: function () {
              if (this._readableState === undefined) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return;
              }
              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function (err, cb) {
            this.push(null);
            cb(err);
          };
          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = '';
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function (chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit('error', er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit('error', new Error('stream.unshift() after end event'));
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit('error', new Error('stream.push() after EOF'));
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
              }
            }
            return needMoreData(state);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
          }
          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false;
          };
          // backwards compatibility.
          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder)
              StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          };
          // Don't raise the hwm > 8MB
          var MAX_HWM = 8388608;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function (n) {
            debug('read', n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              debug('read: emitReadable', state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.
            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable;
            debug('need readable', doRead);
            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug('length less than watermark', doRead);
            }
            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false;
              debug('reading or ended', doRead);
            } else if (doRead) {
              debug('do read');
              state.reading = true;
              state.sync = true;
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0)
                state.needReadable = true;
              // call internal read method
              this._read(state.highWaterMark);
              state.sync = false;
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }
            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended)
                state.needReadable = true;
              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit('data', ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream);
          }
          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug('emitReadable', state.flowing);
              state.emittedReadable = true;
              if (state.sync)
                processNextTick(emitReadable_, stream);
              else
                emitReadable_(stream);
            }
          }
          function emitReadable_(stream) {
            debug('emit readable');
            stream.emit('readable');
            flow(stream);
          }
          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              processNextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              debug('maybeReadMore read 0');
              stream.read(0);
              if (len === state.length)
                // didn't get any data, stop spinning.
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function (n) {
            this.emit('error', new Error('_read() is not implemented'));
          };
          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [
                state.pipes,
                dest
              ];
              break;
            default:
              state.pipes.push(dest);
              break;
            }
            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              processNextTick(endFn);
            else
              src.once('end', endFn);
            dest.on('unpipe', onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug('onunpipe');
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug('onend');
              dest.end();
            }
            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug('cleanup');
              // cleanup event handlers once the pipe is broken
              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', unpipe);
              src.removeListener('data', ondata);
              cleanedUp = true;
              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false;
            src.on('data', ondata);
            function ondata(chunk) {
              debug('ondata');
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug('false write response, pause', src._readableState.awaitDrain);
                  src._readableState.awaitDrain++;
                  increasedAwaitDrain = true;
                }
                src.pause();
              }
            }
            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug('onerror', er);
              unpipe();
              dest.removeListener('error', onerror);
              if (EElistenerCount(dest, 'error') === 0)
                dest.emit('error', er);
            }
            // Make sure our error handler is attached before userland ones.
            prependListener(dest, 'error', onerror);
            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
              debug('onfinish');
              dest.removeListener('close', onclose);
              unpipe();
            }
            dest.once('finish', onfinish);
            function unpipe() {
              debug('unpipe');
              src.unpipe(dest);
            }
            // tell the dest that it's being piped to
            dest.emit('pipe', src);
            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug('pipe resume');
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function () {
              var state = src._readableState;
              debug('pipeOnDrain', state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState;
            var unpipeInfo = { hasUnpiped: false };
            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0)
              return this;
            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              // got a match.
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit('unpipe', this, unpipeInfo);
              return this;
            }
            // slow case. multiple pipe destinations.
            if (!dest) {
              // remove all.
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit('unpipe', this, unpipeInfo);
              }
              return this;
            }
            // try to find the right one.
            var index = indexOf(state.pipes, dest);
            if (index === -1)
              return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit('unpipe', this, unpipeInfo);
            return this;
          };
          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === 'data') {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false)
                this.resume();
            } else if (ev === 'readable') {
              var state = this._readableState;
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;
                if (!state.reading) {
                  processNextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          function nReadingNextTick(self) {
            debug('readable nexttick read 0');
            self.read(0);
          }
          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function () {
            var state = this._readableState;
            if (!state.flowing) {
              debug('resume');
              state.flowing = true;
              resume(this, state);
            }
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              processNextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            if (!state.reading) {
              debug('resume read 0');
              stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function () {
            debug('call pause flowing=%j', this._readableState.flowing);
            if (false !== this._readableState.flowing) {
              debug('pause');
              this._readableState.flowing = false;
              this.emit('pause');
            }
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);
            while (state.flowing && stream.read() !== null) {
            }
          }
          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function (stream) {
            var state = this._readableState;
            var paused = false;
            var self = this;
            stream.on('end', function () {
              debug('wrapped end');
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  self.push(chunk);
              }
              self.push(null);
            });
            stream.on('data', function (chunk) {
              debug('wrapped data');
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = self.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === 'function') {
                this[i] = function (method) {
                  return function () {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            // proxy certain important events.
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
            }
            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            self._read = function (n) {
              debug('wrapped _read', n);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return self;
          };
          // exposed for testing purposes only.
          Readable._fromList = fromList;
          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder)
                ret = state.buffer.join('');
              else if (state.buffer.length === 1)
                ret = state.buffer.head.data;
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
          }
          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift();
            } else {
              // result spans more than one buffer
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }
            return ret;
          }
          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
              state.ended = true;
              processNextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit('end');
            }
          }
          function forEach(xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {
        './_stream_duplex': 155,
        './internal/streams/BufferList': 160,
        './internal/streams/destroy': 161,
        './internal/streams/stream': 162,
        '_process': 145,
        'core-util-is': 9,
        'events': 13,
        'inherits': 19,
        'isarray': 153,
        'process-nextick-args': 144,
        'safe-buffer': 150,
        'string_decoder/': 167,
        'util': 3
      }
    ],
    158: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.
        'use strict';
        module.exports = Transform;
        var Duplex = require('./_stream_duplex');
        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/
        util.inherits(Transform, Duplex);
        function TransformState(stream) {
          this.afterTransform = function (er, data) {
            return afterTransform(stream, er, data);
          };
          this.needTransform = false;
          this.transforming = false;
          this.writecb = null;
          this.writechunk = null;
          this.writeencoding = null;
        }
        function afterTransform(stream, er, data) {
          var ts = stream._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb) {
            return stream.emit('error', new Error('write callback called multiple times'));
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data !== null && data !== undefined)
            stream.push(data);
          cb(er);
          var rs = stream._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = new TransformState(this);
          var stream = this;
          // start out asking for a readable event once data is transformed.
          this._readableState.needReadable = true;
          // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === 'function')
              this._transform = options.transform;
            if (typeof options.flush === 'function')
              this._flush = options.flush;
          }
          // When the writable side finishes, then flush out anything remaining.
          this.once('prefinish', function () {
            if (typeof this._flush === 'function')
              this._flush(function (er, data) {
                done(stream, er, data);
              });
            else
              done(stream);
          });
        }
        Transform.prototype.push = function (chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function (chunk, encoding, cb) {
          throw new Error('_transform() is not implemented');
        };
        Transform.prototype._write = function (chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function (n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function (err, cb) {
          var _this = this;
          Duplex.prototype._destroy.call(this, err, function (err2) {
            cb(err2);
            _this.emit('close');
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit('error', er);
          if (data !== null && data !== undefined)
            stream.push(data);
          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided
          var ws = stream._writableState;
          var ts = stream._transformState;
          if (ws.length)
            throw new Error('Calling transform done when ws.length != 0');
          if (ts.transforming)
            throw new Error('Calling transform done when still transforming');
          return stream.push(null);
        }
      },
      {
        './_stream_duplex': 155,
        'core-util-is': 9,
        'inherits': 19
      }
    ],
    159: [
      function (require, module, exports) {
        (function (process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.
          'use strict';
          /*<replacement>*/
          var processNextTick = require('process-nextick-args');
          /*</replacement>*/
          module.exports = Writable;
          /* <replacement> */
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          }
          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function () {
              onCorkedFinish(_this, state);
            };
          }
          /* </replacement> */
          /*<replacement>*/
          var asyncWrite = !process.browser && [
              'v0.10',
              'v0.9.'
            ].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
          /*</replacement>*/
          /*<replacement>*/
          var Duplex;
          /*</replacement>*/
          Writable.WritableState = WritableState;
          /*<replacement>*/
          var util = require('core-util-is');
          util.inherits = require('inherits');
          /*</replacement>*/
          /*<replacement>*/
          var internalUtil = { deprecate: require('util-deprecate') };
          /*</replacement>*/
          /*<replacement>*/
          var Stream = require('./internal/streams/stream');
          /*</replacement>*/
          /*<replacement>*/
          var Buffer = require('safe-buffer').Buffer;
          var OurUint8Array = global.Uint8Array || function () {
            };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          /*</replacement>*/
          var destroyImpl = require('./internal/streams/destroy');
          util.inherits(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {};
            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark);
            // if _final has been called
            this.finalCalled = false;
            // drain event flag.
            this.needDrain = false;
            // at the start of calling end()
            this.ending = false;
            // when end() has been called, and returned
            this.ended = false;
            // when 'finish' is emitted
            this.finished = false;
            // has it been destroyed
            this.destroyed = false;
            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';
            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0;
            // a flag to see when we're in the middle of a write.
            this.writing = false;
            // when true all writes will be buffered until .uncork() call
            this.corked = 0;
            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;
            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false;
            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function (er) {
              onwrite(stream, er);
            };
            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null;
            // the amount that is being written when _write is called.
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0;
            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false;
            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false;
            // count buffered requests
            this.bufferedRequestCount = 0;
            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function () {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {
                get: internalUtil.deprecate(function () {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
              });
            } catch (_) {
            }
          }());
          // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.
          var realHasInstance;
          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function (object) {
                if (realHasInstance.call(this, object))
                  return true;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function (object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require('./_stream_duplex');
            // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.
            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
              return new Writable(options);
            }
            this._writableState = new WritableState(options, this);
            // legacy.
            this.writable = true;
            if (options) {
              if (typeof options.write === 'function')
                this._write = options.write;
              if (typeof options.writev === 'function')
                this._writev = options.writev;
              if (typeof options.destroy === 'function')
                this._destroy = options.destroy;
              if (typeof options.final === 'function')
                this._final = options.final;
            }
            Stream.call(this);
          }
          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function () {
            this.emit('error', new Error('Cannot pipe, not readable'));
          };
          function writeAfterEnd(stream, cb) {
            var er = new Error('write after end');
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit('error', er);
            processNextTick(cb, er);
          }
          // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            if (chunk === null) {
              er = new TypeError('May not write null values to stream');
            } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }
            if (er) {
              stream.emit('error', er);
              processNextTick(cb, er);
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = _isUint8Array(chunk) && !state.objectMode;
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = 'buffer';
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== 'function')
              cb = nop;
            if (state.ended)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function () {
            var state = this._writableState;
            state.corked++;
          };
          Writable.prototype.uncork = function () {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === 'string')
              encoding = encoding.toLowerCase();
            if (!([
                'hex',
                'utf8',
                'utf-8',
                'ascii',
                'binary',
                'base64',
                'ucs2',
                'ucs-2',
                'utf16le',
                'utf-16le',
                'raw'
              ].indexOf((encoding + '').toLowerCase()) > -1))
              throw new TypeError('Unknown encoding: ' + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = 'buffer';
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              processNextTick(cb, er);
              // this can emit finish, and it will always happen
              // after error
              processNextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit('error', er);
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit('error', er);
              // this can emit finish, but finish must
              // always follow error
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state);
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb);  /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          }
          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, '', holder.finish);
              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequestCount = 0;
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new Error('_write() is not implemented'));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding);
            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function (err) {
              state.pendingcb--;
              if (err) {
                stream.emit('error', err);
              }
              state.prefinished = true;
              stream.emit('prefinish');
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === 'function') {
                state.pendingcb++;
                state.finalCalled = true;
                processNextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit('prefinish');
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit('finish');
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                processNextTick(cb);
              else
                stream.once('finish', cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq;
            } else {
              state.corkedRequestsFree = corkReq;
            }
          }
          Object.defineProperty(Writable.prototype, 'destroyed', {
            get: function () {
              if (this._writableState === undefined) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function (value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return;
              }
              // backward compatibility, the user is explicitly
              // managing destroyed
              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function (err, cb) {
            this.end();
            cb(err);
          };
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {
        './_stream_duplex': 155,
        './internal/streams/destroy': 161,
        './internal/streams/stream': 162,
        '_process': 145,
        'core-util-is': 9,
        'inherits': 19,
        'process-nextick-args': 144,
        'safe-buffer': 150,
        'util-deprecate': 184
      }
    ],
    160: [
      function (require, module, exports) {
        'use strict';
        /*<replacement>*/
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var Buffer = require('safe-buffer').Buffer;
        /*</replacement>*/
        function copyBuffer(src, target, offset) {
          src.copy(target, offset);
        }
        module.exports = function () {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          BufferList.prototype.push = function push(v) {
            var entry = {
                data: v,
                next: null
              };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          };
          BufferList.prototype.unshift = function unshift(v) {
            var entry = {
                data: v,
                next: this.head
              };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          };
          BufferList.prototype.shift = function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          };
          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
          };
          BufferList.prototype.join = function join(s) {
            if (this.length === 0)
              return '';
            var p = this.head;
            var ret = '' + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          };
          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0)
              return Buffer.alloc(0);
            if (this.length === 1)
              return this.head.data;
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          };
          return BufferList;
        }();
      },
      { 'safe-buffer': 150 }
    ],
    161: [
      function (require, module, exports) {
        'use strict';
        /*<replacement>*/
        var processNextTick = require('process-nextick-args');
        /*</replacement>*/
        // undocumented cb() API, needed for core, not for public API
        function destroy(err, cb) {
          var _this = this;
          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;
          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
              processNextTick(emitErrorNT, this, err);
            }
            return;
          }
          // we set destroyed to true before firing error callbacks in order
          // to make it re-entrance safe in case destroy() is called within callbacks
          if (this._readableState) {
            this._readableState.destroyed = true;
          }
          // if this is a duplex stream mark the writable part as destroyed as well
          if (this._writableState) {
            this._writableState.destroyed = true;
          }
          this._destroy(err || null, function (err) {
            if (!cb && err) {
              processNextTick(emitErrorNT, _this, err);
              if (_this._writableState) {
                _this._writableState.errorEmitted = true;
              }
            } else if (cb) {
              cb(err);
            }
          });
        }
        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }
          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }
        function emitErrorNT(self, err) {
          self.emit('error', err);
        }
        module.exports = {
          destroy: destroy,
          undestroy: undestroy
        };
      },
      { 'process-nextick-args': 144 }
    ],
    162: [
      function (require, module, exports) {
        module.exports = require('events').EventEmitter;
      },
      { 'events': 13 }
    ],
    163: [
      function (require, module, exports) {
        module.exports = require('./readable').PassThrough;
      },
      { './readable': 164 }
    ],
    164: [
      function (require, module, exports) {
        exports = module.exports = require('./lib/_stream_readable.js');
        exports.Stream = exports;
        exports.Readable = exports;
        exports.Writable = require('./lib/_stream_writable.js');
        exports.Duplex = require('./lib/_stream_duplex.js');
        exports.Transform = require('./lib/_stream_transform.js');
        exports.PassThrough = require('./lib/_stream_passthrough.js');
      },
      {
        './lib/_stream_duplex.js': 155,
        './lib/_stream_passthrough.js': 156,
        './lib/_stream_readable.js': 157,
        './lib/_stream_transform.js': 158,
        './lib/_stream_writable.js': 159
      }
    ],
    165: [
      function (require, module, exports) {
        module.exports = require('./readable').Transform;
      },
      { './readable': 164 }
    ],
    166: [
      function (require, module, exports) {
        module.exports = require('./lib/_stream_writable.js');
      },
      { './lib/_stream_writable.js': 159 }
    ],
    167: [
      function (require, module, exports) {
        'use strict';
        var Buffer = require('safe-buffer').Buffer;
        var isEncoding = Buffer.isEncoding || function (encoding) {
            encoding = '' + encoding;
            switch (encoding && encoding.toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
            case 'raw':
              return true;
            default:
              return false;
            }
          };
        function _normalizeEncoding(enc) {
          if (!enc)
            return 'utf8';
          var retried;
          while (true) {
            switch (enc) {
            case 'utf8':
            case 'utf-8':
              return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 'utf16le';
            case 'latin1':
            case 'binary':
              return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
              return enc;
            default:
              if (retried)
                return;
              // undefined
              enc = ('' + enc).toLowerCase();
              retried = true;
            }
          }
        }
        ;
        // Do not cache `Buffer.isEncoding` when checking encoding names as some
        // modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error('Unknown encoding: ' + enc);
          return nenc || enc;
        }
        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters.
        exports.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
          case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function (buf) {
          if (buf.length === 0)
            return '';
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === undefined)
              return '';
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || '';
        };
        StringDecoder.prototype.end = utf8End;
        // Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text;
        // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function (buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
        // continuation byte.
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return -1;
        }
        // Checks at most 3 bytes at the end of a Buffer in order to detect an
        // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
        // needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        // Validates as many continuation bytes for a multi-byte UTF-8 character as
        // needed or are available. If we see a non-continuation byte where we expect
        // one, we "replace" the validated continuation bytes we've seen so far with
        // UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
        // behavior. The continuation byte check is included three times in the case
        // where all of the continuation bytes for a character exist in the same buffer.
        // It is also done this way as a slight performance increase instead of using a
        // loop.
        function utf8CheckExtraBytes(self, buf, p) {
          if ((buf[0] & 192) !== 128) {
            self.lastNeed = 0;
            return '\ufffd'.repeat(p);
          }
          if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self.lastNeed = 1;
              return '\ufffd'.repeat(p + 1);
            }
            if (self.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self.lastNeed = 2;
                return '\ufffd'.repeat(p + 2);
              }
            }
          }
        }
        // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf, p);
          if (r !== undefined)
            return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
        // partial character, the character's bytes are buffered until the required
        // number of bytes are available.
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString('utf8', i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString('utf8', i, end);
        }
        // For UTF-8, a replacement character for each buffered byte of a (partial)
        // character needs to be added to the output.
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : '';
          if (this.lastNeed)
            return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
          return r;
        }
        // UTF-16LE typically needs two bytes per character, but even if we have an even
        // number of bytes available, we need to check if we end on a leading/high
        // surrogate. In that case, we need to wait for the next two bytes in order to
        // decode the last character properly.
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString('utf16le', i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString('utf16le', i, buf.length - 1);
        }
        // For UTF-16LE we do not explicitly append special replacement characters if we
        // end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : '';
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString('utf16le', 0, end);
          }
          return r;
        }
        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0)
            return buf.toString('base64', i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString('base64', i, buf.length - n);
        }
        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : '';
          if (this.lastNeed)
            return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
          return r;
        }
        // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : '';
        }
      },
      { 'safe-buffer': 150 }
    ],
    168: [
      function (require, module, exports) {
        var ClientRequest = require('./lib/request');
        var extend = require('xtend');
        var statusCodes = require('builtin-status-codes');
        var url = require('url');
        var http = exports;
        http.request = function (opts, cb) {
          if (typeof opts === 'string')
            opts = url.parse(opts);
          else
            opts = extend(opts);
          var protocol = opts.protocol || '';
          var host = opts.hostname || opts.host;
          var port = opts.port;
          var path = opts.path || '/';
          // Necessary for IPv6 addresses
          if (host && host.indexOf(':') !== -1)
            host = '[' + host + ']';
          // This may be a relative url. The browser should always be able to interpret it correctly.
          opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
          opts.method = (opts.method || 'GET').toUpperCase();
          opts.headers = opts.headers || {};
          // Also valid opts.auth, opts.mode
          var req = new ClientRequest(opts);
          if (cb)
            req.on('response', cb);
          return req;
        };
        http.get = function get(opts, cb) {
          var req = http.request(opts, cb);
          req.end();
          return req;
        };
        http.Agent = function () {
        };
        http.Agent.defaultMaxSockets = 4;
        http.STATUS_CODES = statusCodes;
        http.METHODS = [
          'CHECKOUT',
          'CONNECT',
          'COPY',
          'DELETE',
          'GET',
          'HEAD',
          'LOCK',
          'M-SEARCH',
          'MERGE',
          'MKACTIVITY',
          'MKCOL',
          'MOVE',
          'NOTIFY',
          'OPTIONS',
          'PATCH',
          'POST',
          'PROPFIND',
          'PROPPATCH',
          'PURGE',
          'PUT',
          'REPORT',
          'SEARCH',
          'SUBSCRIBE',
          'TRACE',
          'UNLOCK',
          'UNSUBSCRIBE'
        ];
      },
      {
        './lib/request': 170,
        'builtin-status-codes': 7,
        'url': 183,
        'xtend': 287
      }
    ],
    169: [
      function (require, module, exports) {
        (function (global) {
          'use strict';
          exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream);
          exports.blobConstructor = false;
          try {
            new Blob([new ArrayBuffer(1)]);
            exports.blobConstructor = true;
          } catch (e) {
          }
          var xhr = new global.XMLHttpRequest();
          // If location.host is empty, e.g. if this page/worker was loaded
          // from a Blob, then use example.com to avoid an error
          xhr.open('GET', global.location.host ? '/' : 'https://example.com');
          function checkTypeSupport(type) {
            try {
              xhr.responseType = type;
              return xhr.responseType === type;
            } catch (e) {
            }
            return false;
          }
          // For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
          // Safari 7.1 appears to have fixed this bug.
          var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
          var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);
          exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer');
          // These next two tests unavoidably show warnings in Chrome. Since fetch will always
          // be used if it's available, just return false for these to avoid the warnings.
          exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
          exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer');
          exports.overrideMimeType = isFunction(xhr.overrideMimeType);
          exports.vbArray = isFunction(global.VBArray);
          function isFunction(value) {
            return typeof value === 'function';
          }
          xhr = null;  // Help gc
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    170: [
      function (require, module, exports) {
        (function (process, global, Buffer) {
          'use strict';
          // var Base64 = require('Base64')
          var capability = require('./capability');
          var foreach = require('foreach');
          var indexOf = require('indexof');
          var inherits = require('inherits');
          var keys = require('object-keys');
          var response = require('./response');
          var stream = require('stream');
          var IncomingMessage = response.IncomingMessage;
          var rStates = response.readyStates;
          function decideMode(preferBinary) {
            if (capability.fetch) {
              return 'fetch';
            } else if (capability.mozchunkedarraybuffer) {
              return 'moz-chunked-arraybuffer';
            } else if (capability.msstream) {
              return 'ms-stream';
            } else if (capability.arraybuffer && preferBinary) {
              return 'arraybuffer';
            } else if (capability.vbArray && preferBinary) {
              return 'text:vbarray';
            } else {
              return 'text';
            }
          }
          var ClientRequest = module.exports = function (opts) {
              var self = this;
              stream.Writable.call(self);
              self._opts = opts;
              self._body = [];
              self._headers = {};
              if (opts.auth)
                self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
              foreach(keys(opts.headers), function (name) {
                self.setHeader(name, opts.headers[name]);
              });
              var preferBinary;
              if (opts.mode === 'prefer-streaming') {
                // If streaming is a high priority but binary compatibility and
                // the accuracy of the 'content-type' header aren't
                preferBinary = false;
              } else if (opts.mode === 'allow-wrong-content-type') {
                // If streaming is more important than preserving the 'content-type' header
                preferBinary = !capability.overrideMimeType;
              } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
                // Use binary if text streaming may corrupt data or the content-type header, or for speed
                preferBinary = true;
              } else {
                throw new Error('Invalid value for opts.mode');
              }
              self._mode = decideMode(preferBinary);
              self.on('finish', function () {
                self._onFinish();
              });
            };
          inherits(ClientRequest, stream.Writable);
          ClientRequest.prototype.setHeader = function (name, value) {
            var self = this;
            var lowerName = name.toLowerCase();
            // This check is not necessary, but it prevents warnings from browsers about setting unsafe
            // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
            // http-browserify did it, so I will too.
            if (indexOf(unsafeHeaders, lowerName) !== -1)
              return;
            self._headers[lowerName] = {
              name: name,
              value: value
            };
          };
          ClientRequest.prototype.getHeader = function (name) {
            var self = this;
            return self._headers[name.toLowerCase()].value;
          };
          ClientRequest.prototype.removeHeader = function (name) {
            var self = this;
            delete self._headers[name.toLowerCase()];
          };
          ClientRequest.prototype._onFinish = function () {
            var self = this;
            if (self._destroyed)
              return;
            var opts = self._opts;
            var headersObj = self._headers;
            var body;
            if (opts.method === 'POST' || opts.method === 'PUT') {
              if (capability.blobConstructor) {
                body = new global.Blob(self._body.map(function (buffer) {
                  return buffer.toArrayBuffer();
                }), { type: (headersObj['content-type'] || {}).value || '' });
              } else {
                // get utf8 string
                body = Buffer.concat(self._body).toString();
              }
            }
            if (self._mode === 'fetch') {
              var headers = keys(headersObj).map(function (name) {
                  return [
                    headersObj[name].name,
                    headersObj[name].value
                  ];
                });
              global.fetch(self._opts.url, {
                method: self._opts.method,
                headers: headers,
                body: body,
                mode: 'cors',
                credentials: opts.withCredentials ? 'include' : 'same-origin'
              }).then(function (response) {
                self._fetchResponse = response;
                self._connect();
              }).then(undefined, function (reason) {
                self.emit('error', reason);
              });
            } else {
              var xhr = self._xhr = new global.XMLHttpRequest();
              try {
                xhr.open(self._opts.method, self._opts.url, true);
              } catch (err) {
                process.nextTick(function () {
                  self.emit('error', err);
                });
                return;
              }
              // Can't set responseType on really old browsers
              if ('responseType' in xhr)
                xhr.responseType = self._mode.split(':')[0];
              if ('withCredentials' in xhr)
                xhr.withCredentials = !!opts.withCredentials;
              if (self._mode === 'text' && 'overrideMimeType' in xhr)
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              foreach(keys(headersObj), function (name) {
                xhr.setRequestHeader(headersObj[name].name, headersObj[name].value);
              });
              self._response = null;
              xhr.onreadystatechange = function () {
                switch (xhr.readyState) {
                case rStates.LOADING:
                case rStates.DONE:
                  self._onXHRProgress();
                  break;
                }
              };
              // Necessary for streaming in Firefox, since xhr.response is ONLY defined
              // in onprogress, not in onreadystatechange with xhr.readyState = 3
              if (self._mode === 'moz-chunked-arraybuffer') {
                xhr.onprogress = function () {
                  self._onXHRProgress();
                };
              }
              xhr.onerror = function () {
                if (self._destroyed)
                  return;
                self.emit('error', new Error('XHR error'));
              };
              try {
                xhr.send(body);
              } catch (err) {
                process.nextTick(function () {
                  self.emit('error', err);
                });
                return;
              }
            }
          };
          /**
 * Checks if xhr.status is readable. Even though the spec says it should
 * be available in readyState 3, accessing it throws an exception in IE8
 */
          function statusValid(xhr) {
            try {
              return xhr.status !== null;
            } catch (e) {
              return false;
            }
          }
          ClientRequest.prototype._onXHRProgress = function () {
            var self = this;
            if (!statusValid(self._xhr) || self._destroyed)
              return;
            if (!self._response)
              self._connect();
            self._response._onXHRProgress();
          };
          ClientRequest.prototype._connect = function () {
            var self = this;
            if (self._destroyed)
              return;
            self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode);
            self.emit('response', self._response);
          };
          ClientRequest.prototype._write = function (chunk, encoding, cb) {
            var self = this;
            self._body.push(chunk);
            cb();
          };
          ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
            var self = this;
            self._destroyed = true;
            if (self._response)
              self._response._destroyed = true;
            if (self._xhr)
              self._xhr.abort();  // Currently, there isn't a way to truly abort a fetch.
                                  // If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
          };
          ClientRequest.prototype.end = function (data, encoding, cb) {
            var self = this;
            if (typeof data === 'function') {
              cb = data;
              data = undefined;
            }
            stream.Writable.prototype.end.call(self, data, encoding, cb);
          };
          ClientRequest.prototype.flushHeaders = function () {
          };
          ClientRequest.prototype.setTimeout = function () {
          };
          ClientRequest.prototype.setNoDelay = function () {
          };
          ClientRequest.prototype.setSocketKeepAlive = function () {
          };
          // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
          var unsafeHeaders = [
              'accept-charset',
              'accept-encoding',
              'access-control-request-headers',
              'access-control-request-method',
              'connection',
              'content-length',
              'cookie',
              'cookie2',
              'date',
              'dnt',
              'expect',
              'host',
              'keep-alive',
              'origin',
              'referer',
              'te',
              'trailer',
              'transfer-encoding',
              'upgrade',
              'user-agent',
              'via'
            ];
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('buffer').Buffer));
      },
      {
        './capability': 169,
        './response': 171,
        '_process': 145,
        'buffer': 5,
        'foreach': 14,
        'indexof': 18,
        'inherits': 19,
        'object-keys': 141,
        'stream': 152
      }
    ],
    171: [
      function (require, module, exports) {
        (function (process, global, Buffer) {
          'use strict';
          var capability = require('./capability');
          var foreach = require('foreach');
          var inherits = require('inherits');
          var stream = require('stream');
          var rStates = exports.readyStates = {
              UNSENT: 0,
              OPENED: 1,
              HEADERS_RECEIVED: 2,
              LOADING: 3,
              DONE: 4
            };
          var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
              var self = this;
              stream.Readable.call(self);
              self._mode = mode;
              self.headers = {};
              self.rawHeaders = [];
              self.trailers = {};
              self.rawTrailers = [];
              // Fake the 'close' event, but only once 'end' fires
              self.on('end', function () {
                // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
                process.nextTick(function () {
                  self.emit('close');
                });
              });
              if (mode === 'fetch') {
                var read = function read() {
                  reader.read().then(function (result) {
                    if (self._destroyed)
                      return;
                    if (result.done) {
                      self.push(null);
                      return;
                    }
                    self.push(new Buffer(result.value));
                    read();
                  });
                };
                self._fetchResponse = response;
                self.statusCode = response.status;
                self.statusMessage = response.statusText;
                // backwards compatible version of for (<item> of <iterable>):
                // for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
                for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
                  self.headers[header[0].toLowerCase()] = header[1];
                  self.rawHeaders.push(header[0], header[1]);
                }
                // TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
                var reader = response.body.getReader();
                read();
              } else {
                self._xhr = xhr;
                self._pos = 0;
                self.statusCode = xhr.status;
                self.statusMessage = xhr.statusText;
                var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                foreach(headers, function (header) {
                  var matches = header.match(/^([^:]+):\s*(.*)/);
                  if (matches) {
                    var key = matches[1].toLowerCase();
                    if (self.headers[key] !== undefined)
                      self.headers[key] += ', ' + matches[2];
                    else
                      self.headers[key] = matches[2];
                    self.rawHeaders.push(matches[1], matches[2]);
                  }
                });
                self._charset = 'x-user-defined';
                if (!capability.overrideMimeType) {
                  var mimeType = self.rawHeaders['mime-type'];
                  if (mimeType) {
                    var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                    if (charsetMatch) {
                      self._charset = charsetMatch[1].toLowerCase();
                    }
                  }
                  if (!self._charset)
                    self._charset = 'utf-8';  // best guess
                }
              }
            };
          inherits(IncomingMessage, stream.Readable);
          IncomingMessage.prototype._read = function () {
          };
          IncomingMessage.prototype._onXHRProgress = function () {
            var self = this;
            var xhr = self._xhr;
            var response = null;
            switch (self._mode) {
            case 'text:vbarray':
              // For IE9
              if (xhr.readyState !== rStates.DONE)
                break;
              try {
                // This fails in IE8
                response = new global.VBArray(xhr.responseBody).toArray();
              } catch (e) {
              }
              if (response !== null) {
                self.push(new Buffer(response));
                break;
              }
            // Falls through in IE8	
            case 'text':
              try {
                // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
                response = xhr.responseText;
              } catch (e) {
                self._mode = 'text:vbarray';
                break;
              }
              if (response.length > self._pos) {
                var newData = response.substr(self._pos);
                if (self._charset === 'x-user-defined') {
                  var buffer = new Buffer(newData.length);
                  for (var i = 0; i < newData.length; i++) {
                    buffer[i] = newData.charCodeAt(i) & 255;
                  }
                  self.push(buffer);
                } else {
                  self.push(newData, self._charset);
                }
                self._pos = response.length;
              }
              break;
            case 'arraybuffer':
              if (xhr.readyState !== rStates.DONE)
                break;
              response = xhr.response;
              self.push(new Buffer(new Uint8Array(response)));
              break;
            case 'moz-chunked-arraybuffer':
              // take whole
              response = xhr.response;
              if (xhr.readyState !== rStates.LOADING || !response)
                break;
              self.push(new Buffer(new Uint8Array(response)));
              break;
            case 'ms-stream':
              response = xhr.response;
              if (xhr.readyState !== rStates.LOADING)
                break;
              var reader = new global.MSStreamReader();
              reader.onprogress = function () {
                if (reader.result.byteLength > self._pos) {
                  self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
                  self._pos = reader.result.byteLength;
                }
              };
              reader.onload = function () {
                self.push(null);
              };
              // reader.onerror = ??? // TODO: this
              reader.readAsArrayBuffer(response);
              break;
            }
            // The ms-stream case handles end separately in reader.onload()
            if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
              self.push(null);
            }
          };
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('buffer').Buffer));
      },
      {
        './capability': 169,
        '_process': 145,
        'buffer': 5,
        'foreach': 14,
        'inherits': 19,
        'stream': 152
      }
    ],
    172: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var Buffer = require('buffer').Buffer;
        var isBufferEncoding = Buffer.isEncoding || function (encoding) {
            switch (encoding && encoding.toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
            case 'raw':
              return true;
            default:
              return false;
            }
          };
        function assertEncoding(encoding) {
          if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
          }
        }
        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters. CESU-8 is handled as part of the UTF-8 encoding.
        //
        // @TODO Handling all encodings inside a single object makes it very difficult
        // to reason about this code, so it should be split up in the future.
        // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
        // points as used by CESU-8.
        var StringDecoder = exports.StringDecoder = function (encoding) {
            this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
            assertEncoding(encoding);
            switch (this.encoding) {
            case 'utf8':
              // CESU-8 represents each of Surrogate Pair by 3-bytes
              this.surrogateSize = 3;
              break;
            case 'ucs2':
            case 'utf16le':
              // UTF-16 represents each of Surrogate Pair by 2-bytes
              this.surrogateSize = 2;
              this.detectIncompleteChar = utf16DetectIncompleteChar;
              break;
            case 'base64':
              // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
              this.surrogateSize = 3;
              this.detectIncompleteChar = base64DetectIncompleteChar;
              break;
            default:
              this.write = passThroughWrite;
              return;
            }
            // Enough space to store all bytes of a single character. UTF-8 needs 4
            // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
            this.charBuffer = new Buffer(6);
            // Number of bytes received for the current incomplete multi-byte character.
            this.charReceived = 0;
            // Number of bytes expected for the current incomplete multi-byte character.
            this.charLength = 0;
          };
        // write decodes the given buffer and returns it as JS string that is
        // guaranteed to not contain any partial multi-byte characters. Any partial
        // character found at the end of the buffer is buffered up, and will be
        // returned when calling write again with the remaining bytes.
        //
        // Note: Converting a Buffer containing an orphan surrogate to a String
        // currently works, but converting a String to a Buffer (via `new Buffer`, or
        // Buffer#write) will replace incomplete surrogates with the unicode
        // replacement character. See https://codereview.chromium.org/121173009/ .
        StringDecoder.prototype.write = function (buffer) {
          var charStr = '';
          // if our last write ended with an incomplete multibyte character
          while (this.charLength) {
            // determine how many remaining bytes this buffer has to offer for this char
            var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
            // add the new bytes to the char buffer
            buffer.copy(this.charBuffer, this.charReceived, 0, available);
            this.charReceived += available;
            if (this.charReceived < this.charLength) {
              // still not enough chars in this buffer? wait for more ...
              return '';
            }
            // remove bytes belonging to the current character from the buffer
            buffer = buffer.slice(available, buffer.length);
            // get the character that was split
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 55296 && charCode <= 56319) {
              this.charLength += this.surrogateSize;
              charStr = '';
              continue;
            }
            this.charReceived = this.charLength = 0;
            // if there are no more bytes in this buffer, just emit our char
            if (buffer.length === 0) {
              return charStr;
            }
            break;
          }
          // determine and set charLength / charReceived
          this.detectIncompleteChar(buffer);
          var end = buffer.length;
          if (this.charLength) {
            // buffer the incomplete character bytes we got
            buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
            end -= this.charReceived;
          }
          charStr += buffer.toString(this.encoding, 0, end);
          var end = charStr.length - 1;
          var charCode = charStr.charCodeAt(end);
          // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
          if (charCode >= 55296 && charCode <= 56319) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            buffer.copy(this.charBuffer, 0, 0, size);
            return charStr.substring(0, end);
          }
          // or just emit the charStr
          return charStr;
        };
        // detectIncompleteChar determines if there is an incomplete UTF-8 character at
        // the end of the given buffer. If so, it sets this.charLength to the byte
        // length that character, and sets this.charReceived to the number of bytes
        // that are available for this character.
        StringDecoder.prototype.detectIncompleteChar = function (buffer) {
          // determine how many bytes we have to check at the end of this buffer
          var i = buffer.length >= 3 ? 3 : buffer.length;
          // Figure out if one of the last i bytes of our buffer announces an
          // incomplete char.
          for (; i > 0; i--) {
            var c = buffer[buffer.length - i];
            // See http://en.wikipedia.org/wiki/UTF-8#Description
            // 110XXXXX
            if (i == 1 && c >> 5 == 6) {
              this.charLength = 2;
              break;
            }
            // 1110XXXX
            if (i <= 2 && c >> 4 == 14) {
              this.charLength = 3;
              break;
            }
            // 11110XXX
            if (i <= 3 && c >> 3 == 30) {
              this.charLength = 4;
              break;
            }
          }
          this.charReceived = i;
        };
        StringDecoder.prototype.end = function (buffer) {
          var res = '';
          if (buffer && buffer.length)
            res = this.write(buffer);
          if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
          }
          return res;
        };
        function passThroughWrite(buffer) {
          return buffer.toString(this.encoding);
        }
        function utf16DetectIncompleteChar(buffer) {
          this.charReceived = buffer.length % 2;
          this.charLength = this.charReceived ? 2 : 0;
        }
        function base64DetectIncompleteChar(buffer) {
          this.charReceived = buffer.length % 3;
          this.charLength = this.charReceived ? 3 : 0;
        }
      },
      { 'buffer': 5 }
    ],
    173: [
      function (require, module, exports) {
        'use strict';
        module.exports = [
          'get',
          'put',
          'post',
          'delete',
          'options',
          'head',
          'patch'
        ];
      },
      {}
    ],
    174: [
      function (require, module, exports) {
        /** !
 * Swagger Parser v4.0.0-beta.2
 *
 * @link https://github.com/BigstickCarpet/swagger-parser
 * @license MIT
 */
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var validateSchema = require('./validate-schema'), validateSpec = require('./validate-spec'), util = require('./util'), Options = require('./options'), Promise = require('./promise'), maybe = require('call-me-maybe'), ono = require('ono'), $RefParser = require('json-schema-ref-parser'), dereference = require('json-schema-ref-parser/lib/dereference');
        module.exports = SwaggerParser;
        /**
 * This class parses a Swagger 2.0 API, resolves its JSON references and their resolved values,
 * and provides methods for traversing, dereferencing, and validating the API.
 *
 * @constructor
 * @extends $RefParser
 */
        function SwaggerParser() {
          $RefParser.apply(this, arguments);
        }
        util.inherits(SwaggerParser, $RefParser);
        SwaggerParser.YAML = $RefParser.YAML;
        SwaggerParser.parse = $RefParser.parse;
        SwaggerParser.resolve = $RefParser.resolve;
        SwaggerParser.bundle = $RefParser.bundle;
        SwaggerParser.dereference = $RefParser.dereference;
        /**
 * Alias {@link $RefParser#schema} as {@link SwaggerParser#api}
 */
        Object.defineProperty(SwaggerParser.prototype, 'api', {
          configurable: true,
          enumerable: true,
          get: function get() {
            return this.schema;
          }
        });
        /**
 * Parses the given Swagger API.
 * This method does not resolve any JSON references.
 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
 *
 * @param {string|object} api - The file path or URL of the Swagger API. Or a Swagger object.
 * @param {ParserOptions} [options] - Options that determine how the API is parsed
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.
 * @returns {Promise} - The returned promise resolves with the parsed API object.
 */
        SwaggerParser.prototype.parse = function (api, options, callback) {
          var args = normalizeArgs(arguments);
          return $RefParser.prototype.parse.call(this, args.path, args.api, args.options).then(function (schema) {
            var supportedSwaggerVersions = ['2.0'];
            // Verify that the parsed object is a Swagger API
            if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {
              throw ono.syntax('%s is not a valid Swagger API definition', args.path || args.api);
            } else if (typeof schema.swagger === 'number') {
              // This is a very common mistake, so give a helpful error message
              throw ono.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
            } else if (typeof schema.info.version === 'number') {
              // This is a very common mistake, so give a helpful error message
              throw ono.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
            } else if (supportedSwaggerVersions.indexOf(schema.swagger) === -1) {
              throw ono.syntax('Unsupported Swagger version: %d. Swagger Parser only supports version %s', schema.swagger, supportedSwaggerVersions.join(', '));
            }
            // Looks good!
            return maybe(args.callback, Promise.resolve(schema));
          }).catch(function (err) {
            return maybe(args.callback, Promise.reject(err));
          });
        };
        /**
 * Parses, dereferences, and validates the given Swagger API.
 * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.
 *
 * @param {string|object} api - The file path or URL of the Swagger API. Or a Swagger object.
 * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.
 * @returns {Promise} - The returned promise resolves with the parsed API object.
 */
        SwaggerParser.validate = function (api, options, callback) {
          var Class = this;
          // eslint-disable-line consistent-this
          var instance = new Class();
          return instance.validate.apply(instance, arguments);
        };
        /**
 * Parses, dereferences, and validates the given Swagger API.
 * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.
 *
 * @param {string|object} api - The file path or URL of the Swagger API. Or a Swagger object.
 * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated
 * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.
 * @returns {Promise} - The returned promise resolves with the parsed API object.
 */
        SwaggerParser.prototype.validate = function (api, options, callback) {
          var me = this;
          var args = normalizeArgs(arguments);
          // ZSchema doesn't support circular objects, so don't dereference circular $refs yet
          // (see https://github.com/zaggino/z-schema/issues/137)
          var circular$RefOption = args.options.dereference.circular;
          args.options.validate.schema && (args.options.dereference.circular = 'ignore');
          return this.dereference(args.path, args.api, args.options).then(function () {
            // Restore the original options, now that we're done dereferencing
            args.options.dereference.circular = circular$RefOption;
            if (args.options.validate.schema) {
              // Validate the API against the Swagger schema
              // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet
              validateSchema(me.api);
              if (me.$refs.circular) {
                if (circular$RefOption === true) {
                  // The API has circular references,
                  // so we need to do a second-pass to fully-dereference it
                  dereference(me, args.options);
                } else if (circular$RefOption === false) {
                  // The API has circular references, and they're not allowed, so throw an error
                  throw ono.reference('The API contains circular references');
                }
              }
            }
            if (args.options.validate.spec) {
              // Validate the API against the Swagger spec
              validateSpec(me.api);
            }
            return maybe(args.callback, Promise.resolve(me.schema));
          }).catch(function (err) {
            return maybe(args.callback, Promise.reject(err));
          });
        };
        /**
 * The Swagger object
 * https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#swagger-object
 *
 * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject
 */
        /**
 * Normalizes the given arguments, accounting for optional args.
 *
 * @param {Arguments} args
 * @returns {object}
 */
        function normalizeArgs(args) {
          var path, api, options, callback;
          args = Array.prototype.slice.call(args);
          if (typeof args[args.length - 1] === 'function') {
            // The last parameter is a callback function
            callback = args.pop();
          }
          if (typeof args[0] === 'string') {
            // The first parameter is the path
            path = args[0];
            if (_typeof(args[2]) === 'object') {
              // The second parameter is the api, and the third parameter is the options
              api = args[1];
              options = args[2];
            } else {
              // The second parameter is the options
              api = undefined;
              options = args[1];
            }
          } else {
            // The first parameter is the api
            path = '';
            api = args[0];
            options = args[1];
          }
          if (!(options instanceof Options)) {
            options = new Options(options);
          }
          return {
            path: path,
            api: api,
            options: options,
            callback: callback
          };
        }
      },
      {
        './options': 175,
        './promise': 176,
        './util': 177,
        './validate-schema': 178,
        './validate-spec': 179,
        'call-me-maybe': 8,
        'json-schema-ref-parser': 24,
        'json-schema-ref-parser/lib/dereference': 23,
        'ono': 143
      }
    ],
    175: [
      function (require, module, exports) {
        'use strict';
        var $RefParserOptions = require('json-schema-ref-parser/lib/options'), util = require('util');
        module.exports = ParserOptions;
        /**
 * Options that determine how Swagger APIs are parsed, resolved, dereferenced, and validated.
 *
 * @param {object|ParserOptions} [options] - Overridden options
 * @constructor
 * @extends $RefParserOptions
 */
        function ParserOptions(options) {
          $RefParserOptions.call(this, ParserOptions.defaults);
          $RefParserOptions.apply(this, arguments);
        }
        ParserOptions.defaults = {
          validate: {
            schema: { order: 1 },
            spec: { order: 2 }
          }
        };
        util.inherits(ParserOptions, $RefParserOptions);
      },
      {
        'json-schema-ref-parser/lib/options': 25,
        'util': 187
      }
    ],
    176: [
      function (require, module, exports) {
        arguments[4][39][0].apply(exports, arguments);
      },
      {
        'dup': 39,
        'es6-promise': 180
      }
    ],
    177: [
      function (require, module, exports) {
        'use strict';
        var debug = require('debug'), util = require('util');
        exports.format = util.format;
        exports.inherits = util.inherits;
        /**
 * Writes messages to stdout.
 * Log messages are suppressed by default, but can be enabled by setting the DEBUG variable.
 * @type {function}
 */
        exports.debug = debug('swagger:parser');
        /**
 * Regular Expression that matches Swagger path params.
 */
        exports.swaggerParamRegExp = /\{([^\/}]+)}/g;
      },
      {
        'debug': 10,
        'util': 187
      }
    ],
    178: [
      function (require, module, exports) {
        'use strict';
        var util = require('./util'), ono = require('ono'), ZSchema = require('z-schema'), swaggerSchema = require('swagger-schema-official/schema');
        module.exports = validateSchema;
        initializeZSchema();
        /**
 * Validates the given Swagger API against the Swagger 2.0 schema.
 *
 * @param {SwaggerObject} api
 */
        function validateSchema(api) {
          util.debug('Validating against the Swagger 2.0 schema');
          // Validate the API against the Swagger schema
          var isValid = ZSchema.validate(api, swaggerSchema);
          if (isValid) {
            util.debug('    Validated successfully');
          } else {
            var err = ZSchema.getLastError();
            var message = 'Swagger schema validation failed. \n' + formatZSchemaError(err.details);
            throw ono.syntax(err, { details: err.details }, message);
          }
        }
        /**
 * Performs one-time initialization logic to prepare for Swagger Schema validation.
 */
        function initializeZSchema() {
          ZSchema = new ZSchema({
            breakOnFirstError: true,
            noExtraKeywords: true,
            ignoreUnknownFormats: false,
            reportPathAsArray: true
          });
        }
        /**
 * Z-Schema validation errors are a nested tree structure.
 * This function crawls that tree and builds an error message string.
 *
 * @param {object[]}  errors     - The Z-Schema error details
 * @param {string}    [indent]   - The whitespace used to indent the error message
 * @returns {string}
 */
        function formatZSchemaError(errors, indent) {
          indent = indent || '  ';
          var message = '';
          errors.forEach(function (error, index) {
            message += util.format('%s%s at #/%s\n', indent, error.message, error.path.join('/'));
            if (error.inner) {
              message += formatZSchemaError(error.inner, indent + '  ');
            }
          });
          return message;
        }
      },
      {
        './util': 177,
        'ono': 143,
        'swagger-schema-official/schema': 181,
        'z-schema': 297
      }
    ],
    179: [
      function (require, module, exports) {
        'use strict';
        var util = require('./util'), ono = require('ono'), swaggerMethods = require('swagger-methods'), primitiveTypes = [
            'array',
            'boolean',
            'integer',
            'number',
            'string'
          ], schemaTypes = [
            'array',
            'boolean',
            'integer',
            'number',
            'string',
            'object',
            'null',
            undefined
          ];
        module.exports = validateSpec;
        /**
 * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.
 *
 * @param {SwaggerObject} api
 */
        function validateSpec(api) {
          util.debug('Validating against the Swagger 2.0 spec');
          var paths = Object.keys(api.paths || {});
          paths.forEach(function (pathName) {
            var path = api.paths[pathName];
            var pathId = '/paths' + pathName;
            if (path && pathName.indexOf('/') === 0) {
              validatePath(api, path, pathId);
            }
          });
          util.debug('    Validated successfully');
        }
        /**
 * Validates the given path.
 *
 * @param {SwaggerObject} api      - The entire Swagger API object
 * @param {object}        path     - A Path object, from the Swagger API
 * @param {string}        pathId   - A value that uniquely identifies the path
 */
        function validatePath(api, path, pathId) {
          swaggerMethods.forEach(function (operationName) {
            var operation = path[operationName];
            var operationId = pathId + '/' + operationName;
            if (operation) {
              validateParameters(api, path, pathId, operation, operationId);
              var responses = Object.keys(operation.responses || {});
              responses.forEach(function (responseName) {
                var response = operation.responses[responseName];
                var responseId = operationId + '/responses/' + responseName;
                validateResponse(responseName, response, responseId);
              });
            }
          });
        }
        /**
 * Validates the parameters for the given operation.
 *
 * @param {SwaggerObject} api           - The entire Swagger API object
 * @param {object}        path          - A Path object, from the Swagger API
 * @param {string}        pathId        - A value that uniquely identifies the path
 * @param {object}        operation     - An Operation object, from the Swagger API
 * @param {string}        operationId   - A value that uniquely identifies the operation
 */
        function validateParameters(api, path, pathId, operation, operationId) {
          var pathParams = path.parameters || [];
          var operationParams = operation.parameters || [];
          // Check for duplicate path parameters
          try {
            checkForDuplicates(pathParams);
          } catch (e) {
            throw ono.syntax(e, 'Validation failed. %s has duplicate parameters', pathId);
          }
          // Check for duplicate operation parameters
          try {
            checkForDuplicates(operationParams);
          } catch (e) {
            throw ono.syntax(e, 'Validation failed. %s has duplicate parameters', operationId);
          }
          // Combine the path and operation parameters,
          // with the operation params taking precedence over the path params
          var params = pathParams.reduce(function (combinedParams, value) {
              var duplicate = combinedParams.some(function (param) {
                  return param.in === value.in && param.name === value.name;
                });
              if (!duplicate) {
                combinedParams.push(value);
              }
              return combinedParams;
            }, operationParams.slice());
          validateBodyParameters(params, operationId);
          validatePathParameters(params, pathId, operationId);
          validateParameterTypes(params, api, operation, operationId);
        }
        /**
 * Validates body and formData parameters for the given operation.
 *
 * @param   {object[]}  params       -  An array of Parameter objects
 * @param   {string}    operationId  -  A value that uniquely identifies the operation
 */
        function validateBodyParameters(params, operationId) {
          var bodyParams = params.filter(function (param) {
              return param.in === 'body';
            });
          var formParams = params.filter(function (param) {
              return param.in === 'formData';
            });
          // There can only be one "body" parameter
          if (bodyParams.length > 1) {
            throw ono.syntax('Validation failed. %s has %d body parameters. Only one is allowed.', operationId, bodyParams.length);
          } else if (bodyParams.length > 0 && formParams.length > 0) {
            // "body" params and "formData" params are mutually exclusive
            throw ono.syntax('Validation failed. %s has body parameters and formData parameters. Only one or the other is allowed.', operationId);
          }
        }
        /**
 * Validates path parameters for the given path.
 *
 * @param   {object[]}  params        - An array of Parameter objects
 * @param   {string}    pathId        - A value that uniquely identifies the path
 * @param   {string}    operationId   - A value that uniquely identifies the operation
 */
        function validatePathParameters(params, pathId, operationId) {
          // Find all {placeholders} in the path string
          var placeholders = pathId.match(util.swaggerParamRegExp) || [];
          // Check for duplicates
          for (var i = 0; i < placeholders.length; i++) {
            for (var j = i + 1; j < placeholders.length; j++) {
              if (placeholders[i] === placeholders[j]) {
                throw ono.syntax('Validation failed. %s has multiple path placeholders named %s', operationId, placeholders[i]);
              }
            }
          }
          params.filter(function (param) {
            return param.in === 'path';
          }).forEach(function (param) {
            if (param.required !== true) {
              throw ono.syntax('Validation failed. Path parameters cannot be optional. Set required=true for the "%s" parameter at %s', param.name, operationId);
            }
            var match = placeholders.indexOf('{' + param.name + '}');
            if (match === -1) {
              throw ono.syntax('Validation failed. %s has a path parameter named "%s", ' + 'but there is no corresponding {%s} in the path string', operationId, param.name, param.name);
            }
            placeholders.splice(match, 1);
          });
          if (placeholders.length > 0) {
            throw ono.syntax('Validation failed. %s is missing path parameter(s) for %s', operationId, placeholders);
          }
        }
        /**
 * Validates data types of parameters for the given operation.
 *
 * @param   {object[]}  params       -  An array of Parameter objects
 * @param   {object}    api          -  The entire Swagger API object
 * @param   {object}    operation    -  An Operation object, from the Swagger API
 * @param   {string}    operationId  -  A value that uniquely identifies the operation
 */
        function validateParameterTypes(params, api, operation, operationId) {
          params.forEach(function (param) {
            var parameterId = operationId + '/parameters/' + param.name;
            var schema, validTypes;
            switch (param.in) {
            case 'body':
              schema = param.schema;
              validTypes = schemaTypes;
              break;
            case 'formData':
              schema = param;
              validTypes = primitiveTypes.concat('file');
              break;
            default:
              schema = param;
              validTypes = primitiveTypes;
            }
            validateSchema(schema, parameterId, validTypes);
            if (schema.type === 'file') {
              // "file" params require specific "consumes" types
              var consumes = operation.consumes || api.consumes || [];
              if (consumes.indexOf('multipart/form-data') === -1 && consumes.indexOf('application/x-www-form-urlencoded') === -1) {
                throw ono.syntax('Validation failed. %s has a file parameter, so it must consume multipart/form-data ' + 'or application/x-www-form-urlencoded', operationId);
              }
            }
          });
        }
        /**
 * Checks the given parameter list for duplicates, and throws an error if found.
 *
 * @param   {object[]}  params  - An array of Parameter objects
 */
        function checkForDuplicates(params) {
          for (var i = 0; i < params.length - 1; i++) {
            var outer = params[i];
            for (var j = i + 1; j < params.length; j++) {
              var inner = params[j];
              if (outer.name === inner.name && outer.in === inner.in) {
                throw ono.syntax('Validation failed. Found multiple %s parameters named "%s"', outer.in, outer.name);
              }
            }
          }
        }
        /**
 * Validates the given response object.
 *
 * @param   {string}    code        -  The HTTP response code (or "default")
 * @param   {object}    response    -  A Response object, from the Swagger API
 * @param   {string}    responseId  -  A value that uniquely identifies the response
 */
        function validateResponse(code, response, responseId) {
          if (code !== 'default' && (code < 100 || code > 599)) {
            throw ono.syntax('Validation failed. %s has an invalid response code (%s)', responseId, code);
          }
          var headers = Object.keys(response.headers || {});
          headers.forEach(function (headerName) {
            var header = response.headers[headerName];
            var headerId = responseId + '/headers/' + headerName;
            validateSchema(header, headerId, primitiveTypes);
          });
          if (response.schema) {
            var validTypes = schemaTypes.concat('file');
            if (validTypes.indexOf(response.schema.type) === -1) {
              throw ono.syntax('Validation failed. %s has an invalid response schema type (%s)', responseId, response.schema.type);
            }
          }
        }
        /**
 * Validates the given Swagger schema object.
 *
 * @param {object}    schema      - A Schema object, from the Swagger API
 * @param {string}    schemaId    - A value that uniquely identifies the schema object
 * @param {string[]}  validTypes  - An array of the allowed schema types
 */
        function validateSchema(schema, schemaId, validTypes) {
          if (validTypes.indexOf(schema.type) === -1) {
            throw ono.syntax('Validation failed. %s has an invalid type (%s)', schemaId, schema.type);
          }
          if (schema.type === 'array' && !schema.items) {
            throw ono.syntax('Validation failed. %s is an array, so it must include an "items" schema', schemaId);
          }
        }
      },
      {
        './util': 177,
        'ono': 143,
        'swagger-methods': 173
      }
    ],
    180: [
      function (require, module, exports) {
        (function (process, global) {
          /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */
          (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ES6Promise = factory();
          }(this, function () {
            'use strict';
            function objectOrFunction(x) {
              return typeof x === 'function' || typeof x === 'object' && x !== null;
            }
            function isFunction(x) {
              return typeof x === 'function';
            }
            var _isArray = undefined;
            if (!Array.isArray) {
              _isArray = function (x) {
                return Object.prototype.toString.call(x) === '[object Array]';
              };
            } else {
              _isArray = Array.isArray;
            }
            var isArray = _isArray;
            var len = 0;
            var vertxNext = undefined;
            var customSchedulerFn = undefined;
            var asap = function asap(callback, arg) {
              queue[len] = callback;
              queue[len + 1] = arg;
              len += 2;
              if (len === 2) {
                // If len is 2, that means that we need to schedule an async flush.
                // If additional callbacks are queued before the queue is flushed, they
                // will be processed by this flush that we are scheduling.
                if (customSchedulerFn) {
                  customSchedulerFn(flush);
                } else {
                  scheduleFlush();
                }
              }
            };
            function setScheduler(scheduleFn) {
              customSchedulerFn = scheduleFn;
            }
            function setAsap(asapFn) {
              asap = asapFn;
            }
            var browserWindow = typeof window !== 'undefined' ? window : undefined;
            var browserGlobal = browserWindow || {};
            var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
            var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
            // test for web worker but not in IE10
            var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
            // node
            function useNextTick() {
              // node version 0.10.x displays a deprecation warning when nextTick is used recursively
              // see https://github.com/cujojs/when/issues/410 for details
              return function () {
                return process.nextTick(flush);
              };
            }
            // vertx
            function useVertxTimer() {
              return function () {
                vertxNext(flush);
              };
            }
            function useMutationObserver() {
              var iterations = 0;
              var observer = new BrowserMutationObserver(flush);
              var node = document.createTextNode('');
              observer.observe(node, { characterData: true });
              return function () {
                node.data = iterations = ++iterations % 2;
              };
            }
            // web worker
            function useMessageChannel() {
              var channel = new MessageChannel();
              channel.port1.onmessage = flush;
              return function () {
                return channel.port2.postMessage(0);
              };
            }
            function useSetTimeout() {
              // Store setTimeout reference so es6-promise will be unaffected by
              // other code modifying setTimeout (like sinon.useFakeTimers())
              var globalSetTimeout = setTimeout;
              return function () {
                return globalSetTimeout(flush, 1);
              };
            }
            var queue = new Array(1000);
            function flush() {
              for (var i = 0; i < len; i += 2) {
                var callback = queue[i];
                var arg = queue[i + 1];
                callback(arg);
                queue[i] = undefined;
                queue[i + 1] = undefined;
              }
              len = 0;
            }
            function attemptVertx() {
              try {
                var r = require;
                var vertx = r('vertx');
                vertxNext = vertx.runOnLoop || vertx.runOnContext;
                return useVertxTimer();
              } catch (e) {
                return useSetTimeout();
              }
            }
            var scheduleFlush = undefined;
            // Decide what async method to use to triggering processing of queued callbacks:
            if (isNode) {
              scheduleFlush = useNextTick();
            } else if (BrowserMutationObserver) {
              scheduleFlush = useMutationObserver();
            } else if (isWorker) {
              scheduleFlush = useMessageChannel();
            } else if (browserWindow === undefined && typeof require === 'function') {
              scheduleFlush = attemptVertx();
            } else {
              scheduleFlush = useSetTimeout();
            }
            function then(onFulfillment, onRejection) {
              var _arguments = arguments;
              var parent = this;
              var child = new this.constructor(noop);
              if (child[PROMISE_ID] === undefined) {
                makePromise(child);
              }
              var _state = parent._state;
              if (_state) {
                (function () {
                  var callback = _arguments[_state - 1];
                  asap(function () {
                    return invokeCallback(_state, child, callback, parent._result);
                  });
                }());
              } else {
                subscribe(parent, child, onFulfillment, onRejection);
              }
              return child;
            }
            /**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
            function resolve(object) {
              /*jshint validthis:true */
              var Constructor = this;
              if (object && typeof object === 'object' && object.constructor === Constructor) {
                return object;
              }
              var promise = new Constructor(noop);
              _resolve(promise, object);
              return promise;
            }
            var PROMISE_ID = Math.random().toString(36).substring(16);
            function noop() {
            }
            var PENDING = void 0;
            var FULFILLED = 1;
            var REJECTED = 2;
            var GET_THEN_ERROR = new ErrorObject();
            function selfFulfillment() {
              return new TypeError('You cannot resolve a promise with itself');
            }
            function cannotReturnOwn() {
              return new TypeError('A promises callback cannot return that same promise.');
            }
            function getThen(promise) {
              try {
                return promise.then;
              } catch (error) {
                GET_THEN_ERROR.error = error;
                return GET_THEN_ERROR;
              }
            }
            function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
              try {
                then.call(value, fulfillmentHandler, rejectionHandler);
              } catch (e) {
                return e;
              }
            }
            function handleForeignThenable(promise, thenable, then) {
              asap(function (promise) {
                var sealed = false;
                var error = tryThen(then, thenable, function (value) {
                    if (sealed) {
                      return;
                    }
                    sealed = true;
                    if (thenable !== value) {
                      _resolve(promise, value);
                    } else {
                      fulfill(promise, value);
                    }
                  }, function (reason) {
                    if (sealed) {
                      return;
                    }
                    sealed = true;
                    _reject(promise, reason);
                  }, 'Settle: ' + (promise._label || ' unknown promise'));
                if (!sealed && error) {
                  sealed = true;
                  _reject(promise, error);
                }
              }, promise);
            }
            function handleOwnThenable(promise, thenable) {
              if (thenable._state === FULFILLED) {
                fulfill(promise, thenable._result);
              } else if (thenable._state === REJECTED) {
                _reject(promise, thenable._result);
              } else {
                subscribe(thenable, undefined, function (value) {
                  return _resolve(promise, value);
                }, function (reason) {
                  return _reject(promise, reason);
                });
              }
            }
            function handleMaybeThenable(promise, maybeThenable, then$$) {
              if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
                handleOwnThenable(promise, maybeThenable);
              } else {
                if (then$$ === GET_THEN_ERROR) {
                  _reject(promise, GET_THEN_ERROR.error);
                } else if (then$$ === undefined) {
                  fulfill(promise, maybeThenable);
                } else if (isFunction(then$$)) {
                  handleForeignThenable(promise, maybeThenable, then$$);
                } else {
                  fulfill(promise, maybeThenable);
                }
              }
            }
            function _resolve(promise, value) {
              if (promise === value) {
                _reject(promise, selfFulfillment());
              } else if (objectOrFunction(value)) {
                handleMaybeThenable(promise, value, getThen(value));
              } else {
                fulfill(promise, value);
              }
            }
            function publishRejection(promise) {
              if (promise._onerror) {
                promise._onerror(promise._result);
              }
              publish(promise);
            }
            function fulfill(promise, value) {
              if (promise._state !== PENDING) {
                return;
              }
              promise._result = value;
              promise._state = FULFILLED;
              if (promise._subscribers.length !== 0) {
                asap(publish, promise);
              }
            }
            function _reject(promise, reason) {
              if (promise._state !== PENDING) {
                return;
              }
              promise._state = REJECTED;
              promise._result = reason;
              asap(publishRejection, promise);
            }
            function subscribe(parent, child, onFulfillment, onRejection) {
              var _subscribers = parent._subscribers;
              var length = _subscribers.length;
              parent._onerror = null;
              _subscribers[length] = child;
              _subscribers[length + FULFILLED] = onFulfillment;
              _subscribers[length + REJECTED] = onRejection;
              if (length === 0 && parent._state) {
                asap(publish, parent);
              }
            }
            function publish(promise) {
              var subscribers = promise._subscribers;
              var settled = promise._state;
              if (subscribers.length === 0) {
                return;
              }
              var child = undefined, callback = undefined, detail = promise._result;
              for (var i = 0; i < subscribers.length; i += 3) {
                child = subscribers[i];
                callback = subscribers[i + settled];
                if (child) {
                  invokeCallback(settled, child, callback, detail);
                } else {
                  callback(detail);
                }
              }
              promise._subscribers.length = 0;
            }
            function ErrorObject() {
              this.error = null;
            }
            var TRY_CATCH_ERROR = new ErrorObject();
            function tryCatch(callback, detail) {
              try {
                return callback(detail);
              } catch (e) {
                TRY_CATCH_ERROR.error = e;
                return TRY_CATCH_ERROR;
              }
            }
            function invokeCallback(settled, promise, callback, detail) {
              var hasCallback = isFunction(callback), value = undefined, error = undefined, succeeded = undefined, failed = undefined;
              if (hasCallback) {
                value = tryCatch(callback, detail);
                if (value === TRY_CATCH_ERROR) {
                  failed = true;
                  error = value.error;
                  value = null;
                } else {
                  succeeded = true;
                }
                if (promise === value) {
                  _reject(promise, cannotReturnOwn());
                  return;
                }
              } else {
                value = detail;
                succeeded = true;
              }
              if (promise._state !== PENDING) {
              } else if (hasCallback && succeeded) {
                _resolve(promise, value);
              } else if (failed) {
                _reject(promise, error);
              } else if (settled === FULFILLED) {
                fulfill(promise, value);
              } else if (settled === REJECTED) {
                _reject(promise, value);
              }
            }
            function initializePromise(promise, resolver) {
              try {
                resolver(function resolvePromise(value) {
                  _resolve(promise, value);
                }, function rejectPromise(reason) {
                  _reject(promise, reason);
                });
              } catch (e) {
                _reject(promise, e);
              }
            }
            var id = 0;
            function nextId() {
              return id++;
            }
            function makePromise(promise) {
              promise[PROMISE_ID] = id++;
              promise._state = undefined;
              promise._result = undefined;
              promise._subscribers = [];
            }
            function Enumerator(Constructor, input) {
              this._instanceConstructor = Constructor;
              this.promise = new Constructor(noop);
              if (!this.promise[PROMISE_ID]) {
                makePromise(this.promise);
              }
              if (isArray(input)) {
                this._input = input;
                this.length = input.length;
                this._remaining = input.length;
                this._result = new Array(this.length);
                if (this.length === 0) {
                  fulfill(this.promise, this._result);
                } else {
                  this.length = this.length || 0;
                  this._enumerate();
                  if (this._remaining === 0) {
                    fulfill(this.promise, this._result);
                  }
                }
              } else {
                _reject(this.promise, validationError());
              }
            }
            function validationError() {
              return new Error('Array Methods must be provided an Array');
            }
            ;
            Enumerator.prototype._enumerate = function () {
              var length = this.length;
              var _input = this._input;
              for (var i = 0; this._state === PENDING && i < length; i++) {
                this._eachEntry(_input[i], i);
              }
            };
            Enumerator.prototype._eachEntry = function (entry, i) {
              var c = this._instanceConstructor;
              var resolve$$ = c.resolve;
              if (resolve$$ === resolve) {
                var _then = getThen(entry);
                if (_then === then && entry._state !== PENDING) {
                  this._settledAt(entry._state, i, entry._result);
                } else if (typeof _then !== 'function') {
                  this._remaining--;
                  this._result[i] = entry;
                } else if (c === Promise) {
                  var promise = new c(noop);
                  handleMaybeThenable(promise, entry, _then);
                  this._willSettleAt(promise, i);
                } else {
                  this._willSettleAt(new c(function (resolve$$) {
                    return resolve$$(entry);
                  }), i);
                }
              } else {
                this._willSettleAt(resolve$$(entry), i);
              }
            };
            Enumerator.prototype._settledAt = function (state, i, value) {
              var promise = this.promise;
              if (promise._state === PENDING) {
                this._remaining--;
                if (state === REJECTED) {
                  _reject(promise, value);
                } else {
                  this._result[i] = value;
                }
              }
              if (this._remaining === 0) {
                fulfill(promise, this._result);
              }
            };
            Enumerator.prototype._willSettleAt = function (promise, i) {
              var enumerator = this;
              subscribe(promise, undefined, function (value) {
                return enumerator._settledAt(FULFILLED, i, value);
              }, function (reason) {
                return enumerator._settledAt(REJECTED, i, reason);
              });
            };
            /**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
            function all(entries) {
              return new Enumerator(this, entries).promise;
            }
            /**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
            function race(entries) {
              /*jshint validthis:true */
              var Constructor = this;
              if (!isArray(entries)) {
                return new Constructor(function (_, reject) {
                  return reject(new TypeError('You must pass an array to race.'));
                });
              } else {
                return new Constructor(function (resolve, reject) {
                  var length = entries.length;
                  for (var i = 0; i < length; i++) {
                    Constructor.resolve(entries[i]).then(resolve, reject);
                  }
                });
              }
            }
            /**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
            function reject(reason) {
              /*jshint validthis:true */
              var Constructor = this;
              var promise = new Constructor(noop);
              _reject(promise, reason);
              return promise;
            }
            function needsResolver() {
              throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
            }
            function needsNew() {
              throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
            }
            /**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
            function Promise(resolver) {
              this[PROMISE_ID] = nextId();
              this._result = this._state = undefined;
              this._subscribers = [];
              if (noop !== resolver) {
                typeof resolver !== 'function' && needsResolver();
                this instanceof Promise ? initializePromise(this, resolver) : needsNew();
              }
            }
            Promise.all = all;
            Promise.race = race;
            Promise.resolve = resolve;
            Promise.reject = reject;
            Promise._setScheduler = setScheduler;
            Promise._setAsap = setAsap;
            Promise._asap = asap;
            Promise.prototype = {
              constructor: Promise,
              then: then,
              'catch': function _catch(onRejection) {
                return this.then(null, onRejection);
              }
            };
            function polyfill() {
              var local = undefined;
              if (typeof global !== 'undefined') {
                local = global;
              } else if (typeof self !== 'undefined') {
                local = self;
              } else {
                try {
                  local = Function('return this')();
                } catch (e) {
                  throw new Error('polyfill failed because global object is unavailable in this environment');
                }
              }
              var P = local.Promise;
              if (P) {
                var promiseToString = null;
                try {
                  promiseToString = Object.prototype.toString.call(P.resolve());
                } catch (e) {
                }
                if (promiseToString === '[object Promise]' && !P.cast) {
                  return;
                }
              }
              local.Promise = Promise;
            }
            polyfill();
            // Strange compat..
            Promise.polyfill = polyfill;
            Promise.Promise = Promise;
            return Promise;
          }));
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      { '_process': 145 }
    ],
    181: [
      function (require, module, exports) {
        module.exports = {
          'title': 'A JSON Schema for Swagger 2.0 API.',
          'id': 'http://swagger.io/v2/schema.json#',
          '$schema': 'http://json-schema.org/draft-04/schema#',
          'type': 'object',
          'required': [
            'swagger',
            'info',
            'paths'
          ],
          'additionalProperties': false,
          'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
          'properties': {
            'swagger': {
              'type': 'string',
              'enum': ['2.0'],
              'description': 'The Swagger version of this document.'
            },
            'info': { '$ref': '#/definitions/info' },
            'host': {
              'type': 'string',
              'pattern': '^[^{}/ :\\\\]+(?::\\d+)?$',
              'description': 'The host (name or ip) of the API. Example: \'swagger.io\''
            },
            'basePath': {
              'type': 'string',
              'pattern': '^/',
              'description': 'The base path to the API. Example: \'/api\'.'
            },
            'schemes': { '$ref': '#/definitions/schemesList' },
            'consumes': {
              'description': 'A list of MIME types accepted by the API.',
              '$ref': '#/definitions/mediaTypeList'
            },
            'produces': {
              'description': 'A list of MIME types the API can produce.',
              '$ref': '#/definitions/mediaTypeList'
            },
            'paths': { '$ref': '#/definitions/paths' },
            'definitions': { '$ref': '#/definitions/definitions' },
            'parameters': { '$ref': '#/definitions/parameterDefinitions' },
            'responses': { '$ref': '#/definitions/responseDefinitions' },
            'security': { '$ref': '#/definitions/security' },
            'securityDefinitions': { '$ref': '#/definitions/securityDefinitions' },
            'tags': {
              'type': 'array',
              'items': { '$ref': '#/definitions/tag' },
              'uniqueItems': true
            },
            'externalDocs': { '$ref': '#/definitions/externalDocs' }
          },
          'definitions': {
            'info': {
              'type': 'object',
              'description': 'General information about the API.',
              'required': [
                'version',
                'title'
              ],
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'title': {
                  'type': 'string',
                  'description': 'A unique and precise title of the API.'
                },
                'version': {
                  'type': 'string',
                  'description': 'A semantic version number of the API.'
                },
                'description': {
                  'type': 'string',
                  'description': 'A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.'
                },
                'termsOfService': {
                  'type': 'string',
                  'description': 'The terms of service for the API.'
                },
                'contact': { '$ref': '#/definitions/contact' },
                'license': { '$ref': '#/definitions/license' }
              }
            },
            'contact': {
              'type': 'object',
              'description': 'Contact information for the owners of the API.',
              'additionalProperties': false,
              'properties': {
                'name': {
                  'type': 'string',
                  'description': 'The identifying name of the contact person/organization.'
                },
                'url': {
                  'type': 'string',
                  'description': 'The URL pointing to the contact information.',
                  'format': 'uri'
                },
                'email': {
                  'type': 'string',
                  'description': 'The email address of the contact person/organization.',
                  'format': 'email'
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'license': {
              'type': 'object',
              'required': ['name'],
              'additionalProperties': false,
              'properties': {
                'name': {
                  'type': 'string',
                  'description': 'The name of the license type. It\'s encouraged to use an OSI compatible license.'
                },
                'url': {
                  'type': 'string',
                  'description': 'The URL pointing to the license.',
                  'format': 'uri'
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'paths': {
              'type': 'object',
              'description': 'Relative paths to the individual endpoints. They must be relative to the \'basePath\'.',
              'patternProperties': {
                '^x-': { '$ref': '#/definitions/vendorExtension' },
                '^/': { '$ref': '#/definitions/pathItem' }
              },
              'additionalProperties': false
            },
            'definitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/schema' },
              'description': 'One or more JSON objects describing the schemas being consumed and produced by the API.'
            },
            'parameterDefinitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/parameter' },
              'description': 'One or more JSON representations for parameters'
            },
            'responseDefinitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/response' },
              'description': 'One or more JSON representations for parameters'
            },
            'externalDocs': {
              'type': 'object',
              'additionalProperties': false,
              'description': 'information about external documentation',
              'required': ['url'],
              'properties': {
                'description': { 'type': 'string' },
                'url': {
                  'type': 'string',
                  'format': 'uri'
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'examples': {
              'type': 'object',
              'additionalProperties': true
            },
            'mimeType': {
              'type': 'string',
              'description': 'The MIME type of the HTTP message.'
            },
            'operation': {
              'type': 'object',
              'required': ['responses'],
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'tags': {
                  'type': 'array',
                  'items': { 'type': 'string' },
                  'uniqueItems': true
                },
                'summary': {
                  'type': 'string',
                  'description': 'A brief summary of the operation.'
                },
                'description': {
                  'type': 'string',
                  'description': 'A longer description of the operation, GitHub Flavored Markdown is allowed.'
                },
                'externalDocs': { '$ref': '#/definitions/externalDocs' },
                'operationId': {
                  'type': 'string',
                  'description': 'A unique identifier of the operation.'
                },
                'produces': {
                  'description': 'A list of MIME types the API can produce.',
                  '$ref': '#/definitions/mediaTypeList'
                },
                'consumes': {
                  'description': 'A list of MIME types the API can consume.',
                  '$ref': '#/definitions/mediaTypeList'
                },
                'parameters': { '$ref': '#/definitions/parametersList' },
                'responses': { '$ref': '#/definitions/responses' },
                'schemes': { '$ref': '#/definitions/schemesList' },
                'deprecated': {
                  'type': 'boolean',
                  'default': false
                },
                'security': { '$ref': '#/definitions/security' }
              }
            },
            'pathItem': {
              'type': 'object',
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                '$ref': { 'type': 'string' },
                'get': { '$ref': '#/definitions/operation' },
                'put': { '$ref': '#/definitions/operation' },
                'post': { '$ref': '#/definitions/operation' },
                'delete': { '$ref': '#/definitions/operation' },
                'options': { '$ref': '#/definitions/operation' },
                'head': { '$ref': '#/definitions/operation' },
                'patch': { '$ref': '#/definitions/operation' },
                'parameters': { '$ref': '#/definitions/parametersList' }
              }
            },
            'responses': {
              'type': 'object',
              'description': 'Response objects names can either be any valid HTTP status code or \'default\'.',
              'minProperties': 1,
              'additionalProperties': false,
              'patternProperties': {
                '^([0-9]{3})$|^(default)$': { '$ref': '#/definitions/responseValue' },
                '^x-': { '$ref': '#/definitions/vendorExtension' }
              },
              'not': {
                'type': 'object',
                'additionalProperties': false,
                'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
              }
            },
            'responseValue': {
              'oneOf': [
                { '$ref': '#/definitions/response' },
                { '$ref': '#/definitions/jsonReference' }
              ]
            },
            'response': {
              'type': 'object',
              'required': ['description'],
              'properties': {
                'description': { 'type': 'string' },
                'schema': {
                  'oneOf': [
                    { '$ref': '#/definitions/schema' },
                    { '$ref': '#/definitions/fileSchema' }
                  ]
                },
                'headers': { '$ref': '#/definitions/headers' },
                'examples': { '$ref': '#/definitions/examples' }
              },
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'headers': {
              'type': 'object',
              'additionalProperties': { '$ref': '#/definitions/header' }
            },
            'header': {
              'type': 'object',
              'additionalProperties': false,
              'required': ['type'],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'integer',
                    'boolean',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'vendorExtension': {
              'description': 'Any property starting with x- is valid.',
              'additionalProperties': true,
              'additionalItems': true
            },
            'bodyParameter': {
              'type': 'object',
              'required': [
                'name',
                'in',
                'schema'
              ],
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['body']
                },
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'schema': { '$ref': '#/definitions/schema' }
              },
              'additionalProperties': false
            },
            'headerParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['header']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'queryParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['query']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'allowEmptyValue': {
                  'type': 'boolean',
                  'default': false,
                  'description': 'allows sending a parameter by name only or with an empty value.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormatWithMulti' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'formDataParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                'required': {
                  'type': 'boolean',
                  'description': 'Determines whether or not this parameter is required or optional.',
                  'default': false
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['formData']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'allowEmptyValue': {
                  'type': 'boolean',
                  'default': false,
                  'description': 'allows sending a parameter by name only or with an empty value.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array',
                    'file'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormatWithMulti' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'pathParameterSubSchema': {
              'additionalProperties': false,
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'required': ['required'],
              'properties': {
                'required': {
                  'type': 'boolean',
                  'enum': [true],
                  'description': 'Determines whether or not this parameter is required or optional.'
                },
                'in': {
                  'type': 'string',
                  'description': 'Determines the location of the parameter.',
                  'enum': ['path']
                },
                'description': {
                  'type': 'string',
                  'description': 'A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.'
                },
                'name': {
                  'type': 'string',
                  'description': 'The name of the parameter.'
                },
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'boolean',
                    'integer',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              }
            },
            'nonBodyParameter': {
              'type': 'object',
              'required': [
                'name',
                'in',
                'type'
              ],
              'oneOf': [
                { '$ref': '#/definitions/headerParameterSubSchema' },
                { '$ref': '#/definitions/formDataParameterSubSchema' },
                { '$ref': '#/definitions/queryParameterSubSchema' },
                { '$ref': '#/definitions/pathParameterSubSchema' }
              ]
            },
            'parameter': {
              'oneOf': [
                { '$ref': '#/definitions/bodyParameter' },
                { '$ref': '#/definitions/nonBodyParameter' }
              ]
            },
            'schema': {
              'type': 'object',
              'description': 'A deterministic version of a JSON Schema object.',
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'properties': {
                '$ref': { 'type': 'string' },
                'format': { 'type': 'string' },
                'title': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/title' },
                'description': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/description' },
                'default': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/default' },
                'multipleOf': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/multipleOf' },
                'maximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/maximum' },
                'exclusiveMaximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum' },
                'minimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/minimum' },
                'exclusiveMinimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum' },
                'maxLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
                'minLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
                'pattern': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/pattern' },
                'maxItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
                'minItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
                'uniqueItems': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/uniqueItems' },
                'maxProperties': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
                'minProperties': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
                'required': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/stringArray' },
                'enum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/enum' },
                'additionalProperties': {
                  'anyOf': [
                    { '$ref': '#/definitions/schema' },
                    { 'type': 'boolean' }
                  ],
                  'default': {}
                },
                'type': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/type' },
                'items': {
                  'anyOf': [
                    { '$ref': '#/definitions/schema' },
                    {
                      'type': 'array',
                      'minItems': 1,
                      'items': { '$ref': '#/definitions/schema' }
                    }
                  ],
                  'default': {}
                },
                'allOf': {
                  'type': 'array',
                  'minItems': 1,
                  'items': { '$ref': '#/definitions/schema' }
                },
                'properties': {
                  'type': 'object',
                  'additionalProperties': { '$ref': '#/definitions/schema' },
                  'default': {}
                },
                'discriminator': { 'type': 'string' },
                'readOnly': {
                  'type': 'boolean',
                  'default': false
                },
                'xml': { '$ref': '#/definitions/xml' },
                'externalDocs': { '$ref': '#/definitions/externalDocs' },
                'example': {}
              },
              'additionalProperties': false
            },
            'fileSchema': {
              'type': 'object',
              'description': 'A deterministic version of a JSON Schema object.',
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } },
              'required': ['type'],
              'properties': {
                'format': { 'type': 'string' },
                'title': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/title' },
                'description': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/description' },
                'default': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/default' },
                'required': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/stringArray' },
                'type': {
                  'type': 'string',
                  'enum': ['file']
                },
                'readOnly': {
                  'type': 'boolean',
                  'default': false
                },
                'externalDocs': { '$ref': '#/definitions/externalDocs' },
                'example': {}
              },
              'additionalProperties': false
            },
            'primitivesItems': {
              'type': 'object',
              'additionalProperties': false,
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': [
                    'string',
                    'number',
                    'integer',
                    'boolean',
                    'array'
                  ]
                },
                'format': { 'type': 'string' },
                'items': { '$ref': '#/definitions/primitivesItems' },
                'collectionFormat': { '$ref': '#/definitions/collectionFormat' },
                'default': { '$ref': '#/definitions/default' },
                'maximum': { '$ref': '#/definitions/maximum' },
                'exclusiveMaximum': { '$ref': '#/definitions/exclusiveMaximum' },
                'minimum': { '$ref': '#/definitions/minimum' },
                'exclusiveMinimum': { '$ref': '#/definitions/exclusiveMinimum' },
                'maxLength': { '$ref': '#/definitions/maxLength' },
                'minLength': { '$ref': '#/definitions/minLength' },
                'pattern': { '$ref': '#/definitions/pattern' },
                'maxItems': { '$ref': '#/definitions/maxItems' },
                'minItems': { '$ref': '#/definitions/minItems' },
                'uniqueItems': { '$ref': '#/definitions/uniqueItems' },
                'enum': { '$ref': '#/definitions/enum' },
                'multipleOf': { '$ref': '#/definitions/multipleOf' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'security': {
              'type': 'array',
              'items': { '$ref': '#/definitions/securityRequirement' },
              'uniqueItems': true
            },
            'securityRequirement': {
              'type': 'object',
              'additionalProperties': {
                'type': 'array',
                'items': { 'type': 'string' },
                'uniqueItems': true
              }
            },
            'xml': {
              'type': 'object',
              'additionalProperties': false,
              'properties': {
                'name': { 'type': 'string' },
                'namespace': { 'type': 'string' },
                'prefix': { 'type': 'string' },
                'attribute': {
                  'type': 'boolean',
                  'default': false
                },
                'wrapped': {
                  'type': 'boolean',
                  'default': false
                }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'tag': {
              'type': 'object',
              'additionalProperties': false,
              'required': ['name'],
              'properties': {
                'name': { 'type': 'string' },
                'description': { 'type': 'string' },
                'externalDocs': { '$ref': '#/definitions/externalDocs' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'securityDefinitions': {
              'type': 'object',
              'additionalProperties': {
                'oneOf': [
                  { '$ref': '#/definitions/basicAuthenticationSecurity' },
                  { '$ref': '#/definitions/apiKeySecurity' },
                  { '$ref': '#/definitions/oauth2ImplicitSecurity' },
                  { '$ref': '#/definitions/oauth2PasswordSecurity' },
                  { '$ref': '#/definitions/oauth2ApplicationSecurity' },
                  { '$ref': '#/definitions/oauth2AccessCodeSecurity' }
                ]
              }
            },
            'basicAuthenticationSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': ['type'],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['basic']
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'apiKeySecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'name',
                'in'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['apiKey']
                },
                'name': { 'type': 'string' },
                'in': {
                  'type': 'string',
                  'enum': [
                    'header',
                    'query'
                  ]
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2ImplicitSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'authorizationUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['implicit']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'authorizationUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2PasswordSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'tokenUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['password']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'tokenUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2ApplicationSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'tokenUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['application']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'tokenUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2AccessCodeSecurity': {
              'type': 'object',
              'additionalProperties': false,
              'required': [
                'type',
                'flow',
                'authorizationUrl',
                'tokenUrl'
              ],
              'properties': {
                'type': {
                  'type': 'string',
                  'enum': ['oauth2']
                },
                'flow': {
                  'type': 'string',
                  'enum': ['accessCode']
                },
                'scopes': { '$ref': '#/definitions/oauth2Scopes' },
                'authorizationUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'tokenUrl': {
                  'type': 'string',
                  'format': 'uri'
                },
                'description': { 'type': 'string' }
              },
              'patternProperties': { '^x-': { '$ref': '#/definitions/vendorExtension' } }
            },
            'oauth2Scopes': {
              'type': 'object',
              'additionalProperties': { 'type': 'string' }
            },
            'mediaTypeList': {
              'type': 'array',
              'items': { '$ref': '#/definitions/mimeType' },
              'uniqueItems': true
            },
            'parametersList': {
              'type': 'array',
              'description': 'The parameters needed to send a valid API call.',
              'additionalItems': false,
              'items': {
                'oneOf': [
                  { '$ref': '#/definitions/parameter' },
                  { '$ref': '#/definitions/jsonReference' }
                ]
              },
              'uniqueItems': true
            },
            'schemesList': {
              'type': 'array',
              'description': 'The transfer protocol of the API.',
              'items': {
                'type': 'string',
                'enum': [
                  'http',
                  'https',
                  'ws',
                  'wss'
                ]
              },
              'uniqueItems': true
            },
            'collectionFormat': {
              'type': 'string',
              'enum': [
                'csv',
                'ssv',
                'tsv',
                'pipes'
              ],
              'default': 'csv'
            },
            'collectionFormatWithMulti': {
              'type': 'string',
              'enum': [
                'csv',
                'ssv',
                'tsv',
                'pipes',
                'multi'
              ],
              'default': 'csv'
            },
            'title': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/title' },
            'description': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/description' },
            'default': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/default' },
            'multipleOf': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/multipleOf' },
            'maximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/maximum' },
            'exclusiveMaximum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum' },
            'minimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/minimum' },
            'exclusiveMinimum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum' },
            'maxLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
            'minLength': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
            'pattern': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/pattern' },
            'maxItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveInteger' },
            'minItems': { '$ref': 'http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0' },
            'uniqueItems': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/uniqueItems' },
            'enum': { '$ref': 'http://json-schema.org/draft-04/schema#/properties/enum' },
            'jsonReference': {
              'type': 'object',
              'required': ['$ref'],
              'additionalProperties': false,
              'properties': { '$ref': { 'type': 'string' } }
            }
          }
        };
      },
      {}
    ],
    182: [
      function (require, module, exports) {
        var nextTick = require('process/browser.js').nextTick;
        var apply = Function.prototype.apply;
        var slice = Array.prototype.slice;
        var immediateIds = {};
        var nextImmediateId = 0;
        // DOM APIs, for completeness
        exports.setTimeout = function () {
          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
        };
        exports.setInterval = function () {
          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
        };
        exports.clearTimeout = exports.clearInterval = function (timeout) {
          timeout.close();
        };
        function Timeout(id, clearFn) {
          this._id = id;
          this._clearFn = clearFn;
        }
        Timeout.prototype.unref = Timeout.prototype.ref = function () {
        };
        Timeout.prototype.close = function () {
          this._clearFn.call(window, this._id);
        };
        // Does not start the time, just sets up the members needed.
        exports.enroll = function (item, msecs) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = msecs;
        };
        exports.unenroll = function (item) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = -1;
        };
        exports._unrefActive = exports.active = function (item) {
          clearTimeout(item._idleTimeoutId);
          var msecs = item._idleTimeout;
          if (msecs >= 0) {
            item._idleTimeoutId = setTimeout(function onTimeout() {
              if (item._onTimeout)
                item._onTimeout();
            }, msecs);
          }
        };
        // That's not how node.js implements it but the exposed api is the same.
        exports.setImmediate = typeof setImmediate === 'function' ? setImmediate : function (fn) {
          var id = nextImmediateId++;
          var args = arguments.length < 2 ? false : slice.call(arguments, 1);
          immediateIds[id] = true;
          nextTick(function onNextTick() {
            if (immediateIds[id]) {
              // fn.call() is faster so we optimize for the common use-case
              // @see http://jsperf.com/call-apply-segu
              if (args) {
                fn.apply(null, args);
              } else {
                fn.call(null);
              }
              // Prevent ids from leaking
              exports.clearImmediate(id);
            }
          });
          return id;
        };
        exports.clearImmediate = typeof clearImmediate === 'function' ? clearImmediate : function (id) {
          delete immediateIds[id];
        };
      },
      { 'process/browser.js': 145 }
    ],
    183: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var punycode = require('punycode');
        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;
        exports.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        // Reference: RFC 3986, RFC 1808, RFC 2396
        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/,
          // RFC 2396: characters reserved for delimiting URLs.
          // We actually just auto-escape these.
          delims = [
            '<',
            '>',
            '"',
            '`',
            ' ',
            '\r',
            '\n',
            '\t'
          ],
          // RFC 2396: characters not allowed for various reasons.
          unwise = [
            '{',
            '}',
            '|',
            '\\',
            '^',
            '`'
          ].concat(delims),
          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
          autoEscape = ['\''].concat(unwise),
          // Characters that are never ever allowed in a hostname.
          // Note that any invalid chars are also handled, but these
          // are the ones that are *expected* to be seen, so we fast-path
          // them.
          nonHostChars = [
            '%',
            '/',
            '?',
            ';',
            '#'
          ].concat(autoEscape), hostEndingChars = [
            '/',
            '?',
            '#'
          ], hostnameMaxLen = 255, hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
          // protocols that can allow "unsafe" and "unwise" chars.
          unsafeProtocol = {
            'javascript': true,
            'javascript:': true
          },
          // protocols that never have a hostname.
          hostlessProtocol = {
            'javascript': true,
            'javascript:': true
          },
          // protocols that always contain a // bit.
          slashedProtocol = {
            'http': true,
            'https': true,
            'ftp': true,
            'gopher': true,
            'file': true,
            'http:': true,
            'https:': true,
            'ftp:': true,
            'gopher:': true,
            'file:': true
          }, querystring = require('querystring');
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && isObject(url) && url instanceof Url)
            return url;
          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
          if (!isString(url)) {
            throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
          }
          var rest = url;
          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim();
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c
            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.
            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf('@');
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf('@', hostEnd);
            }
            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            // pull out port.
            this.parseHost();
            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';
            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = '';
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += 'x';
                    } else {
                      newpart += part[j];
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = '/' + notHost.join('.') + rest;
                    }
                    this.hostname = validParts.join('.');
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = '';
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              // IDNA Support: Returns a puny coded representation of "domain".
              // It only converts the part of the domain name that
              // has non ASCII characters. I.e. it dosent matter if
              // you call it with a domain that already is in ASCII.
              var domainArray = this.hostname.split('.');
              var newOut = [];
              for (var i = 0; i < domainArray.length; ++i) {
                var s = domainArray[i];
                newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
              }
              this.hostname = newOut.join('.');
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== '/') {
                rest = '/' + rest;
              }
            }
          }
          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          // chop off from the tail first.
          var hash = rest.indexOf('#');
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf('?');
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = '/';
          }
          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
          }
          // finally, reconstruct the href based on what has been validated.
          this.href = this.format();
          return this;
        };
        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function () {
          var auth = this.auth || '';
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
          }
          var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
            if (this.port) {
              host += ':' + this.port;
            }
          }
          if (this.query && isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || query && '?' + query || '';
          if (protocol && protocol.substr(-1) !== ':')
            protocol += ':';
          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/')
              pathname = '/' + pathname;
          } else if (!host) {
            host = '';
          }
          if (hash && hash.charAt(0) !== '#')
            hash = '#' + hash;
          if (search && search.charAt(0) !== '?')
            search = '?' + search;
          pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
          });
          search = search.replace('#', '%23');
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function (relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function (relative) {
          if (isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          Object.keys(this).forEach(function (k) {
            result[k] = this[k];
          }, this);
          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash;
          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === '') {
            result.href = result.format();
            return result;
          }
          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            Object.keys(relative).forEach(function (k) {
              if (k !== 'protocol')
                result[k] = relative[k];
            });
            //urlParse appends trailing / to urls like http://www.example.com
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              Object.keys(relative).forEach(function (k) {
                result[k] = relative[k];
              });
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || '').split('/');
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host)
                relative.host = '';
              if (!relative.hostname)
                relative.hostname = '';
              if (relPath[0] !== '')
                relPath.unshift('');
              if (relPath.length < 2)
                relPath.unshift('');
              result.pathname = relPath.join('/');
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || '';
              var s = result.search || '';
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/', isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/', mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
              if (srcPath[0] === '')
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = '';
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === '')
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
          }
          if (isRelAbs) {
            // it's absolute.
            result.host = relative.host || relative.host === '' ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;  // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              //occationaly the auth can get stuck only in host
              //this especialy happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!isNull(result.pathname) || !isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
              result.path = '/' + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === '';
          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last == '.') {
              srcPath.splice(i, 1);
            } else if (last === '..') {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift('..');
            }
          }
          if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
          }
          if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
            srcPath.push('');
          }
          var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';
          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join('/');
          }
          //to support request.http
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function () {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ':') {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
        function isString(arg) {
          return typeof arg === 'string';
        }
        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        function isNull(arg) {
          return arg === null;
        }
        function isNullOrUndefined(arg) {
          return arg == null;
        }
      },
      {
        'punycode': 146,
        'querystring': 149
      }
    ],
    184: [
      function (require, module, exports) {
        (function (global) {
          'use strict';
          /**
 * Module exports.
 */
          module.exports = deprecate;
          /**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */
          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }
          /**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */
          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage)
                return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val)
              return false;
            return String(val).toLowerCase() === 'true';
          }
        }.call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {}
    ],
    185: [
      function (require, module, exports) {
        if (typeof Object.create === 'function') {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      },
      {}
    ],
    186: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        module.exports = function isBuffer(arg) {
          return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
        };
      },
      {}
    ],
    187: [
      function (require, module, exports) {
        (function (process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          var formatRegExp = /%[sdj%]/g;
          exports.format = function (f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function (x) {
                if (x === '%%')
                  return '%';
                if (i >= len)
                  return x;
                switch (x) {
                case '%s':
                  return String(args[i++]);
                case '%d':
                  return Number(args[i++]);
                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }
                default:
                  return x;
                }
              });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };
          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function (fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
              return function () {
                return exports.deprecate(fn, msg).apply(this, arguments);
              };
            }
            if (process.noDeprecation === true) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnviron;
          exports.debuglog = function (set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                var pid = process.pid;
                debugs[set] = function () {
                  var msg = exports.format.apply(exports, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function () {
                };
              }
            }
            return debugs[set];
          };
          /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
          /* legacy: obj, showHidden, depth, colors*/
          function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
            // legacy...
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts;
            } else if (opts) {
              // got an "options" object
              exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports.inspect = inspect;
          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            'bold': [
              1,
              22
            ],
            'italic': [
              3,
              23
            ],
            'underline': [
              4,
              24
            ],
            'inverse': [
              7,
              27
            ],
            'white': [
              37,
              39
            ],
            'grey': [
              90,
              39
            ],
            'black': [
              30,
              39
            ],
            'blue': [
              34,
              39
            ],
            'cyan': [
              36,
              39
            ],
            'green': [
              32,
              39
            ],
            'magenta': [
              35,
              39
            ],
            'red': [
              31,
              39
            ],
            'yellow': [
              33,
              39
            ]
          };
          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            'regexp': 'red'
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return '\x1b[' + inspect.colors[style][0] + 'm' + str + '\x1b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function (val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            }
            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = '', array = false, braces = [
                '{',
                '}'
              ];
            // Make Array say that they are Array
            if (isArray(value)) {
              array = true;
              braces = [
                '[',
                ']'
              ];
            }
            // Make functions say that they are functions
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }
            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }
            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }
            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function (key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, '\\\'').replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
              return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
              return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
              return ctx.stylize('null', 'null');
          }
          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function (line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function (line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, '\\\'').replace(/\\"/g, '"').replace(/(^"|"$)/g, '\'');
                name = ctx.stylize(name, 'string');
              }
            }
            return name + ': ' + str;
          }
          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function (prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0)
                  numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);
            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }
            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }
          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;
          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;
          exports.isBuffer = require('./support/isBuffer');
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }
          var months = [
              'Jan',
              'Feb',
              'Mar',
              'Apr',
              'May',
              'Jun',
              'Jul',
              'Aug',
              'Sep',
              'Oct',
              'Nov',
              'Dec'
            ];
          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date();
            var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())
              ].join(':');
            return [
              d.getDate(),
              months[d.getMonth()],
              time
            ].join(' ');
          }
          // log is just a thin wrapper to console.log that prepends a timestamp
          exports.log = function () {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
          };
          /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
          exports.inherits = require('inherits');
          exports._extend = function (origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }.call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));
      },
      {
        './support/isBuffer': 186,
        '_process': 145,
        'inherits': 185
      }
    ],
    188: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _toDate = require('./lib/toDate');
        var _toDate2 = _interopRequireDefault(_toDate);
        var _toFloat = require('./lib/toFloat');
        var _toFloat2 = _interopRequireDefault(_toFloat);
        var _toInt = require('./lib/toInt');
        var _toInt2 = _interopRequireDefault(_toInt);
        var _toBoolean = require('./lib/toBoolean');
        var _toBoolean2 = _interopRequireDefault(_toBoolean);
        var _equals = require('./lib/equals');
        var _equals2 = _interopRequireDefault(_equals);
        var _contains = require('./lib/contains');
        var _contains2 = _interopRequireDefault(_contains);
        var _matches = require('./lib/matches');
        var _matches2 = _interopRequireDefault(_matches);
        var _isEmail = require('./lib/isEmail');
        var _isEmail2 = _interopRequireDefault(_isEmail);
        var _isURL = require('./lib/isURL');
        var _isURL2 = _interopRequireDefault(_isURL);
        var _isMACAddress = require('./lib/isMACAddress');
        var _isMACAddress2 = _interopRequireDefault(_isMACAddress);
        var _isIP = require('./lib/isIP');
        var _isIP2 = _interopRequireDefault(_isIP);
        var _isFQDN = require('./lib/isFQDN');
        var _isFQDN2 = _interopRequireDefault(_isFQDN);
        var _isBoolean = require('./lib/isBoolean');
        var _isBoolean2 = _interopRequireDefault(_isBoolean);
        var _isAlpha = require('./lib/isAlpha');
        var _isAlpha2 = _interopRequireDefault(_isAlpha);
        var _isAlphanumeric = require('./lib/isAlphanumeric');
        var _isAlphanumeric2 = _interopRequireDefault(_isAlphanumeric);
        var _isNumeric = require('./lib/isNumeric');
        var _isNumeric2 = _interopRequireDefault(_isNumeric);
        var _isPort = require('./lib/isPort');
        var _isPort2 = _interopRequireDefault(_isPort);
        var _isLowercase = require('./lib/isLowercase');
        var _isLowercase2 = _interopRequireDefault(_isLowercase);
        var _isUppercase = require('./lib/isUppercase');
        var _isUppercase2 = _interopRequireDefault(_isUppercase);
        var _isAscii = require('./lib/isAscii');
        var _isAscii2 = _interopRequireDefault(_isAscii);
        var _isFullWidth = require('./lib/isFullWidth');
        var _isFullWidth2 = _interopRequireDefault(_isFullWidth);
        var _isHalfWidth = require('./lib/isHalfWidth');
        var _isHalfWidth2 = _interopRequireDefault(_isHalfWidth);
        var _isVariableWidth = require('./lib/isVariableWidth');
        var _isVariableWidth2 = _interopRequireDefault(_isVariableWidth);
        var _isMultibyte = require('./lib/isMultibyte');
        var _isMultibyte2 = _interopRequireDefault(_isMultibyte);
        var _isSurrogatePair = require('./lib/isSurrogatePair');
        var _isSurrogatePair2 = _interopRequireDefault(_isSurrogatePair);
        var _isInt = require('./lib/isInt');
        var _isInt2 = _interopRequireDefault(_isInt);
        var _isFloat = require('./lib/isFloat');
        var _isFloat2 = _interopRequireDefault(_isFloat);
        var _isDecimal = require('./lib/isDecimal');
        var _isDecimal2 = _interopRequireDefault(_isDecimal);
        var _isHexadecimal = require('./lib/isHexadecimal');
        var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
        var _isDivisibleBy = require('./lib/isDivisibleBy');
        var _isDivisibleBy2 = _interopRequireDefault(_isDivisibleBy);
        var _isHexColor = require('./lib/isHexColor');
        var _isHexColor2 = _interopRequireDefault(_isHexColor);
        var _isISRC = require('./lib/isISRC');
        var _isISRC2 = _interopRequireDefault(_isISRC);
        var _isMD = require('./lib/isMD5');
        var _isMD2 = _interopRequireDefault(_isMD);
        var _isHash = require('./lib/isHash');
        var _isHash2 = _interopRequireDefault(_isHash);
        var _isJSON = require('./lib/isJSON');
        var _isJSON2 = _interopRequireDefault(_isJSON);
        var _isEmpty = require('./lib/isEmpty');
        var _isEmpty2 = _interopRequireDefault(_isEmpty);
        var _isLength = require('./lib/isLength');
        var _isLength2 = _interopRequireDefault(_isLength);
        var _isByteLength = require('./lib/isByteLength');
        var _isByteLength2 = _interopRequireDefault(_isByteLength);
        var _isUUID = require('./lib/isUUID');
        var _isUUID2 = _interopRequireDefault(_isUUID);
        var _isMongoId = require('./lib/isMongoId');
        var _isMongoId2 = _interopRequireDefault(_isMongoId);
        var _isAfter = require('./lib/isAfter');
        var _isAfter2 = _interopRequireDefault(_isAfter);
        var _isBefore = require('./lib/isBefore');
        var _isBefore2 = _interopRequireDefault(_isBefore);
        var _isIn = require('./lib/isIn');
        var _isIn2 = _interopRequireDefault(_isIn);
        var _isCreditCard = require('./lib/isCreditCard');
        var _isCreditCard2 = _interopRequireDefault(_isCreditCard);
        var _isISIN = require('./lib/isISIN');
        var _isISIN2 = _interopRequireDefault(_isISIN);
        var _isISBN = require('./lib/isISBN');
        var _isISBN2 = _interopRequireDefault(_isISBN);
        var _isISSN = require('./lib/isISSN');
        var _isISSN2 = _interopRequireDefault(_isISSN);
        var _isMobilePhone = require('./lib/isMobilePhone');
        var _isMobilePhone2 = _interopRequireDefault(_isMobilePhone);
        var _isCurrency = require('./lib/isCurrency');
        var _isCurrency2 = _interopRequireDefault(_isCurrency);
        var _isISO = require('./lib/isISO8601');
        var _isISO2 = _interopRequireDefault(_isISO);
        var _isISO31661Alpha = require('./lib/isISO31661Alpha2');
        var _isISO31661Alpha2 = _interopRequireDefault(_isISO31661Alpha);
        var _isBase = require('./lib/isBase64');
        var _isBase2 = _interopRequireDefault(_isBase);
        var _isDataURI = require('./lib/isDataURI');
        var _isDataURI2 = _interopRequireDefault(_isDataURI);
        var _isMimeType = require('./lib/isMimeType');
        var _isMimeType2 = _interopRequireDefault(_isMimeType);
        var _isLatLong = require('./lib/isLatLong');
        var _isLatLong2 = _interopRequireDefault(_isLatLong);
        var _isPostalCode = require('./lib/isPostalCode');
        var _isPostalCode2 = _interopRequireDefault(_isPostalCode);
        var _ltrim = require('./lib/ltrim');
        var _ltrim2 = _interopRequireDefault(_ltrim);
        var _rtrim = require('./lib/rtrim');
        var _rtrim2 = _interopRequireDefault(_rtrim);
        var _trim = require('./lib/trim');
        var _trim2 = _interopRequireDefault(_trim);
        var _escape = require('./lib/escape');
        var _escape2 = _interopRequireDefault(_escape);
        var _unescape = require('./lib/unescape');
        var _unescape2 = _interopRequireDefault(_unescape);
        var _stripLow = require('./lib/stripLow');
        var _stripLow2 = _interopRequireDefault(_stripLow);
        var _whitelist = require('./lib/whitelist');
        var _whitelist2 = _interopRequireDefault(_whitelist);
        var _blacklist = require('./lib/blacklist');
        var _blacklist2 = _interopRequireDefault(_blacklist);
        var _isWhitelisted = require('./lib/isWhitelisted');
        var _isWhitelisted2 = _interopRequireDefault(_isWhitelisted);
        var _normalizeEmail = require('./lib/normalizeEmail');
        var _normalizeEmail2 = _interopRequireDefault(_normalizeEmail);
        var _toString = require('./lib/util/toString');
        var _toString2 = _interopRequireDefault(_toString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var version = '9.2.0';
        var validator = {
            version: version,
            toDate: _toDate2.default,
            toFloat: _toFloat2.default,
            toInt: _toInt2.default,
            toBoolean: _toBoolean2.default,
            equals: _equals2.default,
            contains: _contains2.default,
            matches: _matches2.default,
            isEmail: _isEmail2.default,
            isURL: _isURL2.default,
            isMACAddress: _isMACAddress2.default,
            isIP: _isIP2.default,
            isFQDN: _isFQDN2.default,
            isBoolean: _isBoolean2.default,
            isAlpha: _isAlpha2.default,
            isAlphanumeric: _isAlphanumeric2.default,
            isNumeric: _isNumeric2.default,
            isPort: _isPort2.default,
            isLowercase: _isLowercase2.default,
            isUppercase: _isUppercase2.default,
            isAscii: _isAscii2.default,
            isFullWidth: _isFullWidth2.default,
            isHalfWidth: _isHalfWidth2.default,
            isVariableWidth: _isVariableWidth2.default,
            isMultibyte: _isMultibyte2.default,
            isSurrogatePair: _isSurrogatePair2.default,
            isInt: _isInt2.default,
            isFloat: _isFloat2.default,
            isDecimal: _isDecimal2.default,
            isHexadecimal: _isHexadecimal2.default,
            isDivisibleBy: _isDivisibleBy2.default,
            isHexColor: _isHexColor2.default,
            isISRC: _isISRC2.default,
            isMD5: _isMD2.default,
            isHash: _isHash2.default,
            isJSON: _isJSON2.default,
            isEmpty: _isEmpty2.default,
            isLength: _isLength2.default,
            isByteLength: _isByteLength2.default,
            isUUID: _isUUID2.default,
            isMongoId: _isMongoId2.default,
            isAfter: _isAfter2.default,
            isBefore: _isBefore2.default,
            isIn: _isIn2.default,
            isCreditCard: _isCreditCard2.default,
            isISIN: _isISIN2.default,
            isISBN: _isISBN2.default,
            isISSN: _isISSN2.default,
            isMobilePhone: _isMobilePhone2.default,
            isPostalCode: _isPostalCode2.default,
            isCurrency: _isCurrency2.default,
            isISO8601: _isISO2.default,
            isISO31661Alpha2: _isISO31661Alpha2.default,
            isBase64: _isBase2.default,
            isDataURI: _isDataURI2.default,
            isMimeType: _isMimeType2.default,
            isLatLong: _isLatLong2.default,
            ltrim: _ltrim2.default,
            rtrim: _rtrim2.default,
            trim: _trim2.default,
            escape: _escape2.default,
            unescape: _unescape2.default,
            stripLow: _stripLow2.default,
            whitelist: _whitelist2.default,
            blacklist: _blacklist2.default,
            isWhitelisted: _isWhitelisted2.default,
            normalizeEmail: _normalizeEmail2.default,
            toString: _toString2.default
          };
        exports.default = validator;
        module.exports = exports['default'];
      },
      {
        './lib/blacklist': 190,
        './lib/contains': 191,
        './lib/equals': 192,
        './lib/escape': 193,
        './lib/isAfter': 194,
        './lib/isAlpha': 195,
        './lib/isAlphanumeric': 196,
        './lib/isAscii': 197,
        './lib/isBase64': 198,
        './lib/isBefore': 199,
        './lib/isBoolean': 200,
        './lib/isByteLength': 201,
        './lib/isCreditCard': 202,
        './lib/isCurrency': 203,
        './lib/isDataURI': 204,
        './lib/isDecimal': 205,
        './lib/isDivisibleBy': 206,
        './lib/isEmail': 207,
        './lib/isEmpty': 208,
        './lib/isFQDN': 209,
        './lib/isFloat': 210,
        './lib/isFullWidth': 211,
        './lib/isHalfWidth': 212,
        './lib/isHash': 213,
        './lib/isHexColor': 214,
        './lib/isHexadecimal': 215,
        './lib/isIP': 216,
        './lib/isISBN': 217,
        './lib/isISIN': 218,
        './lib/isISO31661Alpha2': 219,
        './lib/isISO8601': 220,
        './lib/isISRC': 221,
        './lib/isISSN': 222,
        './lib/isIn': 223,
        './lib/isInt': 224,
        './lib/isJSON': 225,
        './lib/isLatLong': 226,
        './lib/isLength': 227,
        './lib/isLowercase': 228,
        './lib/isMACAddress': 229,
        './lib/isMD5': 230,
        './lib/isMimeType': 231,
        './lib/isMobilePhone': 232,
        './lib/isMongoId': 233,
        './lib/isMultibyte': 234,
        './lib/isNumeric': 235,
        './lib/isPort': 236,
        './lib/isPostalCode': 237,
        './lib/isSurrogatePair': 238,
        './lib/isURL': 239,
        './lib/isUUID': 240,
        './lib/isUppercase': 241,
        './lib/isVariableWidth': 242,
        './lib/isWhitelisted': 243,
        './lib/ltrim': 244,
        './lib/matches': 245,
        './lib/normalizeEmail': 246,
        './lib/rtrim': 247,
        './lib/stripLow': 248,
        './lib/toBoolean': 249,
        './lib/toDate': 250,
        './lib/toFloat': 251,
        './lib/toInt': 252,
        './lib/trim': 253,
        './lib/unescape': 254,
        './lib/util/toString': 257,
        './lib/whitelist': 258
      }
    ],
    189: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var alpha = exports.alpha = {
            'en-US': /^[A-Z]+$/i,
            'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
            'da-DK': /^[A-ZÆØÅ]+$/i,
            'de-DE': /^[A-ZÄÖÜß]+$/i,
            'el-GR': /^[Α-ω]+$/i,
            'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
            'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
            'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
            'nb-NO': /^[A-ZÆØÅ]+$/i,
            'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
            'nn-NO': /^[A-ZÆØÅ]+$/i,
            'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
            'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
            'pt-PT': /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
            'ru-RU': /^[А-ЯЁ]+$/i,
            'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
            'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
            'sv-SE': /^[A-ZÅÄÖ]+$/i,
            'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
            'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
            ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
          };
        var alphanumeric = exports.alphanumeric = {
            'en-US': /^[0-9A-Z]+$/i,
            'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
            'da-DK': /^[0-9A-ZÆØÅ]+$/i,
            'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
            'el-GR': /^[0-9Α-ω]+$/i,
            'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
            'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
            'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
            'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
            'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
            'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
            'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
            'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
            'pt-PT': /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
            'ru-RU': /^[0-9А-ЯЁ]+$/i,
            'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
            'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
            'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
            'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
            'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
            ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
          };
        var decimal = exports.decimal = {
            'en-US': '.',
            ar: '\u066b'
          };
        var englishLocales = exports.englishLocales = [
            'AU',
            'GB',
            'HK',
            'IN',
            'NZ',
            'ZA',
            'ZM'
          ];
        for (var locale, i = 0; i < englishLocales.length; i++) {
          locale = 'en-' + englishLocales[i];
          alpha[locale] = alpha['en-US'];
          alphanumeric[locale] = alphanumeric['en-US'];
          decimal[locale] = decimal['en-US'];
        }
        // Source: http://www.localeplanet.com/java/
        var arabicLocales = exports.arabicLocales = [
            'AE',
            'BH',
            'DZ',
            'EG',
            'IQ',
            'JO',
            'KW',
            'LB',
            'LY',
            'MA',
            'QM',
            'QA',
            'SA',
            'SD',
            'SY',
            'TN',
            'YE'
          ];
        for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
          _locale = 'ar-' + arabicLocales[_i];
          alpha[_locale] = alpha.ar;
          alphanumeric[_locale] = alphanumeric.ar;
          decimal[_locale] = decimal.ar;
        }
        // Source: https://en.wikipedia.org/wiki/Decimal_mark
        var dotDecimal = exports.dotDecimal = [];
        var commaDecimal = exports.commaDecimal = [
            'cs-CZ',
            'da-DK',
            'de-DE',
            'el-GR',
            'es-ES',
            'fr-FR',
            'it-IT',
            'hu-HU',
            'nb-NO',
            'nn-NO',
            'nl-NL',
            'pl-Pl',
            'pt-PT',
            'ru-RU',
            'sr-RS@latin',
            'sr-RS',
            'sv-SE',
            'tr-TR',
            'uk-UA'
          ];
        for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
          decimal[dotDecimal[_i2]] = decimal['en-US'];
        }
        for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
          decimal[commaDecimal[_i3]] = ',';
        }
        alpha['pt-BR'] = alpha['pt-PT'];
        alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
        decimal['pt-BR'] = decimal['pt-PT'];
      },
      {}
    ],
    190: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = blacklist;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function blacklist(str, chars) {
          (0, _assertString2.default)(str);
          return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    191: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = contains;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toString = require('./util/toString');
        var _toString2 = _interopRequireDefault(_toString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function contains(str, elem) {
          (0, _assertString2.default)(str);
          return str.indexOf((0, _toString2.default)(elem)) >= 0;
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 255,
        './util/toString': 257
      }
    ],
    192: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = equals;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function equals(str, comparison) {
          (0, _assertString2.default)(str);
          return str === comparison;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    193: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = escape;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function escape(str) {
          (0, _assertString2.default)(str);
          return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    194: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAfter;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toDate = require('./toDate');
        var _toDate2 = _interopRequireDefault(_toDate);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isAfter(str) {
          var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
          (0, _assertString2.default)(str);
          var comparison = (0, _toDate2.default)(date);
          var original = (0, _toDate2.default)(str);
          return !!(original && comparison && original > comparison);
        }
        module.exports = exports['default'];
      },
      {
        './toDate': 250,
        './util/assertString': 255
      }
    ],
    195: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAlpha;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _alpha = require('./alpha');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isAlpha(str) {
          var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
          (0, _assertString2.default)(str);
          if (locale in _alpha.alpha) {
            return _alpha.alpha[locale].test(str);
          }
          throw new Error('Invalid locale \'' + locale + '\'');
        }
        module.exports = exports['default'];
      },
      {
        './alpha': 189,
        './util/assertString': 255
      }
    ],
    196: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAlphanumeric;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _alpha = require('./alpha');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isAlphanumeric(str) {
          var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
          (0, _assertString2.default)(str);
          if (locale in _alpha.alphanumeric) {
            return _alpha.alphanumeric[locale].test(str);
          }
          throw new Error('Invalid locale \'' + locale + '\'');
        }
        module.exports = exports['default'];
      },
      {
        './alpha': 189,
        './util/assertString': 255
      }
    ],
    197: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isAscii;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable no-control-regex */
        var ascii = /^[\x00-\x7F]+$/;
        /* eslint-enable no-control-regex */
        function isAscii(str) {
          (0, _assertString2.default)(str);
          return ascii.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    198: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isBase64;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var notBase64 = /[^A-Z0-9+\/=]/i;
        function isBase64(str) {
          (0, _assertString2.default)(str);
          var len = str.length;
          if (!len || len % 4 !== 0 || notBase64.test(str)) {
            return false;
          }
          var firstPaddingChar = str.indexOf('=');
          return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    199: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isBefore;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toDate = require('./toDate');
        var _toDate2 = _interopRequireDefault(_toDate);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isBefore(str) {
          var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
          (0, _assertString2.default)(str);
          var comparison = (0, _toDate2.default)(date);
          var original = (0, _toDate2.default)(str);
          return !!(original && comparison && original < comparison);
        }
        module.exports = exports['default'];
      },
      {
        './toDate': 250,
        './util/assertString': 255
      }
    ],
    200: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isBoolean;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isBoolean(str) {
          (0, _assertString2.default)(str);
          return [
            'true',
            'false',
            '1',
            '0'
          ].indexOf(str) >= 0;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    201: [
      function (require, module, exports) {
        'use strict';
        var _typeof2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol' ? function (obj) {
            return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          };
        exports.default = isByteLength;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable prefer-rest-params */
        function isByteLength(str, options) {
          (0, _assertString2.default)(str);
          var min = void 0;
          var max = void 0;
          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            min = options.min || 0;
            max = options.max;
          } else {
            // backwards compatibility: isByteLength(str, min [, max])
            min = arguments[1];
            max = arguments[2];
          }
          var len = encodeURI(str).split(/%..|./).length - 1;
          return len >= min && (typeof max === 'undefined' || len <= max);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    202: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isCreditCard;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable max-len */
        var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|62[0-9]{14})$/;
        /* eslint-enable max-len */
        function isCreditCard(str) {
          (0, _assertString2.default)(str);
          var sanitized = str.replace(/[- ]+/g, '');
          if (!creditCard.test(sanitized)) {
            return false;
          }
          var sum = 0;
          var digit = void 0;
          var tmpNum = void 0;
          var shouldDouble = void 0;
          for (var i = sanitized.length - 1; i >= 0; i--) {
            digit = sanitized.substring(i, i + 1);
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
              tmpNum *= 2;
              if (tmpNum >= 10) {
                sum += tmpNum % 10 + 1;
              } else {
                sum += tmpNum;
              }
            } else {
              sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
          }
          return !!(sum % 10 === 0 ? sanitized : false);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    203: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isCurrency;
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function currencyRegex(options) {
          var decimal_digits = '\\d{' + options.digits_after_decimal[0] + '}';
          options.digits_after_decimal.forEach(function (digit, index) {
            if (index !== 0)
              decimal_digits = decimal_digits + '|\\d{' + digit + '}';
          });
          var symbol = '(\\' + options.symbol.replace(/\./g, '\\.') + ')' + (options.require_symbol ? '' : '?'), negative = '-?', whole_dollar_amount_without_sep = '[1-9]\\d*', whole_dollar_amount_with_sep = '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*', valid_whole_dollar_amounts = [
              '0',
              whole_dollar_amount_without_sep,
              whole_dollar_amount_with_sep
            ], whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?', decimal_amount = '(\\' + options.decimal_separator + '(' + decimal_digits + '))' + (options.require_decimal ? '' : '?');
          var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');
          // default is negative sign before symbol, but there are two other options (besides parens)
          if (options.allow_negatives && !options.parens_for_negatives) {
            if (options.negative_sign_after_digits) {
              pattern += negative;
            } else if (options.negative_sign_before_digits) {
              pattern = negative + pattern;
            }
          }
          // South African Rand, for example, uses R 123 (space) and R-123 (no space)
          if (options.allow_negative_sign_placeholder) {
            pattern = '( (?!\\-))?' + pattern;
          } else if (options.allow_space_after_symbol) {
            pattern = ' ?' + pattern;
          } else if (options.allow_space_after_digits) {
            pattern += '( (?!$))?';
          }
          if (options.symbol_after_digits) {
            pattern += symbol;
          } else {
            pattern = symbol + pattern;
          }
          if (options.allow_negatives) {
            if (options.parens_for_negatives) {
              pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
            } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
              pattern = negative + pattern;
            }
          }
          // ensure there's a dollar and/or decimal amount, and that
          // it doesn't start with a space or a negative sign followed by a space
          return new RegExp('^(?!-? )(?=.*\\d)' + pattern + '$');
        }
        var default_currency_options = {
            symbol: '$',
            require_symbol: false,
            allow_space_after_symbol: false,
            symbol_after_digits: false,
            allow_negatives: true,
            parens_for_negatives: false,
            negative_sign_before_digits: false,
            negative_sign_after_digits: false,
            allow_negative_sign_placeholder: false,
            thousands_separator: ',',
            decimal_separator: '.',
            allow_decimal: true,
            require_decimal: false,
            digits_after_decimal: [2],
            allow_space_after_digits: false
          };
        function isCurrency(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_currency_options);
          return currencyRegex(options).test(str);
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 255,
        './util/merge': 256
      }
    ],
    204: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDataURI;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var dataURI = /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9!\$&',\(\)\*\+,;=\-\._~:@\/\?%\s]*\s*$/i;
        // eslint-disable-line max-len
        function isDataURI(str) {
          (0, _assertString2.default)(str);
          return dataURI.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    205: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDecimal;
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _alpha = require('./alpha');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function decimalRegExp(options) {
          var regExp = new RegExp('^[-+]?([0-9]+)?(\\' + _alpha.decimal[options.locale] + '[0-9]{' + options.decimal_digits + '})' + (options.force_decimal ? '' : '?') + '$');
          return regExp;
        }
        var default_decimal_options = {
            force_decimal: false,
            decimal_digits: '1,',
            locale: 'en-US'
          };
        var blacklist = [
            '',
            '-',
            '+'
          ];
        function isDecimal(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_decimal_options);
          if (options.locale in _alpha.decimal) {
            return !blacklist.includes(str.replace(/ /g, '')) && decimalRegExp(options).test(str);
          }
          throw new Error('Invalid locale \'' + options.locale + '\'');
        }
        module.exports = exports['default'];
      },
      {
        './alpha': 189,
        './util/assertString': 255,
        './util/merge': 256
      }
    ],
    206: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isDivisibleBy;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toFloat = require('./toFloat');
        var _toFloat2 = _interopRequireDefault(_toFloat);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isDivisibleBy(str, num) {
          (0, _assertString2.default)(str);
          return (0, _toFloat2.default)(str) % parseInt(num, 10) === 0;
        }
        module.exports = exports['default'];
      },
      {
        './toFloat': 251,
        './util/assertString': 255
      }
    ],
    207: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isEmail;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        var _isByteLength = require('./isByteLength');
        var _isByteLength2 = _interopRequireDefault(_isByteLength);
        var _isFQDN = require('./isFQDN');
        var _isFQDN2 = _interopRequireDefault(_isFQDN);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_email_options = {
            allow_display_name: false,
            require_display_name: false,
            allow_utf8_local_part: true,
            require_tld: true
          };
        /* eslint-disable max-len */
        /* eslint-disable no-control-regex */
        var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
        var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
        var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
        var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
        var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
        /* eslint-enable max-len */
        /* eslint-enable no-control-regex */
        function isEmail(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_email_options);
          if (options.require_display_name || options.allow_display_name) {
            var display_email = str.match(displayName);
            if (display_email) {
              str = display_email[1];
            } else if (options.require_display_name) {
              return false;
            }
          }
          var parts = str.split('@');
          var domain = parts.pop();
          var user = parts.join('@');
          var lower_domain = domain.toLowerCase();
          if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
            user = user.replace(/\./g, '').toLowerCase();
          }
          if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {
            return false;
          }
          if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
            return false;
          }
          if (user[0] === '"') {
            user = user.slice(1, user.length - 1);
            return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
          }
          var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
          var user_parts = user.split('.');
          for (var i = 0; i < user_parts.length; i++) {
            if (!pattern.test(user_parts[i])) {
              return false;
            }
          }
          return true;
        }
        module.exports = exports['default'];
      },
      {
        './isByteLength': 201,
        './isFQDN': 209,
        './util/assertString': 255,
        './util/merge': 256
      }
    ],
    208: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isEmpty;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isEmpty(str) {
          (0, _assertString2.default)(str);
          return str.length === 0;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    209: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isFQDN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_fqdn_options = {
            require_tld: true,
            allow_underscores: false,
            allow_trailing_dot: false
          };
        function isFQDN(str, options) {
          (0, _assertString2.default)(str);
          options = (0, _merge2.default)(options, default_fqdn_options);
          /* Remove the optional trailing dot before checking validity */
          if (options.allow_trailing_dot && str[str.length - 1] === '.') {
            str = str.substring(0, str.length - 1);
          }
          var parts = str.split('.');
          if (options.require_tld) {
            var tld = parts.pop();
            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
              return false;
            }
            // disallow spaces
            if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
              return false;
            }
          }
          for (var part, i = 0; i < parts.length; i++) {
            part = parts[i];
            if (options.allow_underscores) {
              part = part.replace(/_/g, '');
            }
            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
              return false;
            }
            // disallow full-width chars
            if (/[\uff01-\uff5e]/.test(part)) {
              return false;
            }
            if (part[0] === '-' || part[part.length - 1] === '-') {
              return false;
            }
          }
          return true;
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 255,
        './util/merge': 256
      }
    ],
    210: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isFloat;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _alpha = require('./alpha');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isFloat(str, options) {
          (0, _assertString2.default)(str);
          options = options || {};
          var float = new RegExp('^(?:[-+])?(?:[0-9]+)?(?:\\' + (options.locale ? _alpha.decimal[options.locale] : '.') + '[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$');
          if (str === '' || str === '.' || str === '-' || str === '+') {
            return false;
          }
          return float.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max) && (!options.hasOwnProperty('lt') || str < options.lt) && (!options.hasOwnProperty('gt') || str > options.gt);
        }
        module.exports = exports['default'];
      },
      {
        './alpha': 189,
        './util/assertString': 255
      }
    ],
    211: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.fullWidth = undefined;
        exports.default = isFullWidth;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var fullWidth = exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        function isFullWidth(str) {
          (0, _assertString2.default)(str);
          return fullWidth.test(str);
        }
      },
      { './util/assertString': 255 }
    ],
    212: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.halfWidth = undefined;
        exports.default = isHalfWidth;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var halfWidth = exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        function isHalfWidth(str) {
          (0, _assertString2.default)(str);
          return halfWidth.test(str);
        }
      },
      { './util/assertString': 255 }
    ],
    213: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isHash;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var lengths = {
            md5: 32,
            md4: 32,
            sha1: 40,
            sha256: 64,
            sha384: 96,
            sha512: 128,
            ripemd128: 32,
            ripemd160: 40,
            tiger128: 32,
            tiger160: 40,
            tiger192: 48,
            crc32: 8,
            crc32b: 8
          };
        function isHash(str, algorithm) {
          (0, _assertString2.default)(str);
          var hash = new RegExp('^[a-f0-9]{' + lengths[algorithm] + '}$');
          return hash.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    214: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isHexColor;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;
        function isHexColor(str) {
          (0, _assertString2.default)(str);
          return hexcolor.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    215: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isHexadecimal;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var hexadecimal = /^[0-9A-F]+$/i;
        function isHexadecimal(str) {
          (0, _assertString2.default)(str);
          return hexadecimal.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    216: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isIP;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
        var ipv6Block = /^[0-9A-F]{1,4}$/i;
        function isIP(str) {
          var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          (0, _assertString2.default)(str);
          version = String(version);
          if (!version) {
            return isIP(str, 4) || isIP(str, 6);
          } else if (version === '4') {
            if (!ipv4Maybe.test(str)) {
              return false;
            }
            var parts = str.split('.').sort(function (a, b) {
                return a - b;
              });
            return parts[3] <= 255;
          } else if (version === '6') {
            var blocks = str.split(':');
            var foundOmissionBlock = false;
            // marker to indicate ::
            // At least some OS accept the last 32 bits of an IPv6 address
            // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
            // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
            // and '::a.b.c.d' is deprecated, but also valid.
            var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
            var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
            if (blocks.length > expectedNumberOfBlocks) {
              return false;
            }
            // initial or final ::
            if (str === '::') {
              return true;
            } else if (str.substr(0, 2) === '::') {
              blocks.shift();
              blocks.shift();
              foundOmissionBlock = true;
            } else if (str.substr(str.length - 2) === '::') {
              blocks.pop();
              blocks.pop();
              foundOmissionBlock = true;
            }
            for (var i = 0; i < blocks.length; ++i) {
              // test for a :: which can not be at the string start/end
              // since those cases have been handled above
              if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                if (foundOmissionBlock) {
                  return false;  // multiple :: in address
                }
                foundOmissionBlock = true;
              } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
              } else if (!ipv6Block.test(blocks[i])) {
                return false;
              }
            }
            if (foundOmissionBlock) {
              return blocks.length >= 1;
            }
            return blocks.length === expectedNumberOfBlocks;
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    217: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISBN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
        var isbn13Maybe = /^(?:[0-9]{13})$/;
        var factor = [
            1,
            3
          ];
        function isISBN(str) {
          var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          (0, _assertString2.default)(str);
          version = String(version);
          if (!version) {
            return isISBN(str, 10) || isISBN(str, 13);
          }
          var sanitized = str.replace(/[\s-]+/g, '');
          var checksum = 0;
          var i = void 0;
          if (version === '10') {
            if (!isbn10Maybe.test(sanitized)) {
              return false;
            }
            for (i = 0; i < 9; i++) {
              checksum += (i + 1) * sanitized.charAt(i);
            }
            if (sanitized.charAt(9) === 'X') {
              checksum += 10 * 10;
            } else {
              checksum += 10 * sanitized.charAt(9);
            }
            if (checksum % 11 === 0) {
              return !!sanitized;
            }
          } else if (version === '13') {
            if (!isbn13Maybe.test(sanitized)) {
              return false;
            }
            for (i = 0; i < 12; i++) {
              checksum += factor[i % 2] * sanitized.charAt(i);
            }
            if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
              return !!sanitized;
            }
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    218: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISIN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
        function isISIN(str) {
          (0, _assertString2.default)(str);
          if (!isin.test(str)) {
            return false;
          }
          var checksumStr = str.replace(/[A-Z]/g, function (character) {
              return parseInt(character, 36);
            });
          var sum = 0;
          var digit = void 0;
          var tmpNum = void 0;
          var shouldDouble = true;
          for (var i = checksumStr.length - 2; i >= 0; i--) {
            digit = checksumStr.substring(i, i + 1);
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
              tmpNum *= 2;
              if (tmpNum >= 10) {
                sum += tmpNum + 1;
              } else {
                sum += tmpNum;
              }
            } else {
              sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
          }
          return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    219: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISO31661Alpha2;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        // from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
        var validISO31661Alpha2CountriesCodes = [
            'AD',
            'AE',
            'AF',
            'AG',
            'AI',
            'AL',
            'AM',
            'AO',
            'AQ',
            'AR',
            'AS',
            'AT',
            'AU',
            'AW',
            'AX',
            'AZ',
            'BA',
            'BB',
            'BD',
            'BE',
            'BF',
            'BG',
            'BH',
            'BI',
            'BJ',
            'BL',
            'BM',
            'BN',
            'BO',
            'BQ',
            'BR',
            'BS',
            'BT',
            'BV',
            'BW',
            'BY',
            'BZ',
            'CA',
            'CC',
            'CD',
            'CF',
            'CG',
            'CH',
            'CI',
            'CK',
            'CL',
            'CM',
            'CN',
            'CO',
            'CR',
            'CU',
            'CV',
            'CW',
            'CX',
            'CY',
            'CZ',
            'DE',
            'DJ',
            'DK',
            'DM',
            'DO',
            'DZ',
            'EC',
            'EE',
            'EG',
            'EH',
            'ER',
            'ES',
            'ET',
            'FI',
            'FJ',
            'FK',
            'FM',
            'FO',
            'FR',
            'GA',
            'GB',
            'GD',
            'GE',
            'GF',
            'GG',
            'GH',
            'GI',
            'GL',
            'GM',
            'GN',
            'GP',
            'GQ',
            'GR',
            'GS',
            'GT',
            'GU',
            'GW',
            'GY',
            'HK',
            'HM',
            'HN',
            'HR',
            'HT',
            'HU',
            'ID',
            'IE',
            'IL',
            'IM',
            'IN',
            'IO',
            'IQ',
            'IR',
            'IS',
            'IT',
            'JE',
            'JM',
            'JO',
            'JP',
            'KE',
            'KG',
            'KH',
            'KI',
            'KM',
            'KN',
            'KP',
            'KR',
            'KW',
            'KY',
            'KZ',
            'LA',
            'LB',
            'LC',
            'LI',
            'LK',
            'LR',
            'LS',
            'LT',
            'LU',
            'LV',
            'LY',
            'MA',
            'MC',
            'MD',
            'ME',
            'MF',
            'MG',
            'MH',
            'MK',
            'ML',
            'MM',
            'MN',
            'MO',
            'MP',
            'MQ',
            'MR',
            'MS',
            'MT',
            'MU',
            'MV',
            'MW',
            'MX',
            'MY',
            'MZ',
            'NA',
            'NC',
            'NE',
            'NF',
            'NG',
            'NI',
            'NL',
            'NO',
            'NP',
            'NR',
            'NU',
            'NZ',
            'OM',
            'PA',
            'PE',
            'PF',
            'PG',
            'PH',
            'PK',
            'PL',
            'PM',
            'PN',
            'PR',
            'PS',
            'PT',
            'PW',
            'PY',
            'QA',
            'RE',
            'RO',
            'RS',
            'RU',
            'RW',
            'SA',
            'SB',
            'SC',
            'SD',
            'SE',
            'SG',
            'SH',
            'SI',
            'SJ',
            'SK',
            'SL',
            'SM',
            'SN',
            'SO',
            'SR',
            'SS',
            'ST',
            'SV',
            'SX',
            'SY',
            'SZ',
            'TC',
            'TD',
            'TF',
            'TG',
            'TH',
            'TJ',
            'TK',
            'TL',
            'TM',
            'TN',
            'TO',
            'TR',
            'TT',
            'TV',
            'TW',
            'TZ',
            'UA',
            'UG',
            'UM',
            'US',
            'UY',
            'UZ',
            'VA',
            'VC',
            'VE',
            'VG',
            'VI',
            'VN',
            'VU',
            'WF',
            'WS',
            'YE',
            'YT',
            'ZA',
            'ZM',
            'ZW'
          ];
        function isISO31661Alpha2(str) {
          (0, _assertString2.default)(str);
          return validISO31661Alpha2CountriesCodes.includes(str.toUpperCase());
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    220: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISO8601;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable max-len */
        // from http://goo.gl/0ejHHW
        var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
        /* eslint-enable max-len */
        function isISO8601(str) {
          (0, _assertString2.default)(str);
          return iso8601.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    221: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISRC;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        // see http://isrc.ifpi.org/en/isrc-standard/code-syntax
        var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
        function isISRC(str) {
          (0, _assertString2.default)(str);
          return isrc.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    222: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isISSN;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var issn = '^\\d{4}-?\\d{3}[\\dX]$';
        function isISSN(str) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          (0, _assertString2.default)(str);
          var testIssn = issn;
          testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
          testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');
          if (!testIssn.test(str)) {
            return false;
          }
          var issnDigits = str.replace('-', '');
          var position = 8;
          var checksum = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;
          try {
            for (var _iterator = issnDigits[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var digit = _step.value;
              var digitValue = digit.toUpperCase() === 'X' ? 10 : +digit;
              checksum += digitValue * position;
              --position;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return checksum % 11 === 0;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    223: [
      function (require, module, exports) {
        'use strict';
        var _typeof2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol' ? function (obj) {
            return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          };
        exports.default = isIn;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _toString = require('./util/toString');
        var _toString2 = _interopRequireDefault(_toString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isIn(str, options) {
          (0, _assertString2.default)(str);
          var i = void 0;
          if (Object.prototype.toString.call(options) === '[object Array]') {
            var array = [];
            for (i in options) {
              if ({}.hasOwnProperty.call(options, i)) {
                array[i] = (0, _toString2.default)(options[i]);
              }
            }
            return array.indexOf(str) >= 0;
          } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            return options.hasOwnProperty(str);
          } else if (options && typeof options.indexOf === 'function') {
            return options.indexOf(str) >= 0;
          }
          return false;
        }
        module.exports = exports['default'];
      },
      {
        './util/assertString': 255,
        './util/toString': 257
      }
    ],
    224: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isInt;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
        var intLeadingZeroes = /^[-+]?[0-9]+$/;
        function isInt(str, options) {
          (0, _assertString2.default)(str);
          options = options || {};
          // Get the regex to use for testing, based on whether
          // leading zeroes are allowed or not.
          var regex = options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ? int : intLeadingZeroes;
          // Check min/max/lt/gt
          var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
          var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
          var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;
          var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;
          return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    225: [
      function (require, module, exports) {
        'use strict';
        var _typeof2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol' ? function (obj) {
            return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          };
        exports.default = isJSON;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isJSON(str) {
          (0, _assertString2.default)(str);
          try {
            var obj = JSON.parse(str);
            return !!obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
          } catch (e) {
          }
          return false;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    226: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = function (str) {
          (0, _assertString2.default)(str);
          if (!str.includes(','))
            return false;
          var pair = str.split(',');
          return lat.test(pair[0]) && long.test(pair[1]);
        };
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
        var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    227: [
      function (require, module, exports) {
        'use strict';
        var _typeof2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol' ? function (obj) {
            return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          };
        exports.default = isLength;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable prefer-rest-params */
        function isLength(str, options) {
          (0, _assertString2.default)(str);
          var min = void 0;
          var max = void 0;
          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            min = options.min || 0;
            max = options.max;
          } else {
            // backwards compatibility: isLength(str, min [, max])
            min = arguments[1];
            max = arguments[2];
          }
          var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
          var len = str.length - surrogatePairs.length;
          return len >= min && (typeof max === 'undefined' || len <= max);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    228: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isLowercase;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isLowercase(str) {
          (0, _assertString2.default)(str);
          return str === str.toLowerCase();
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    229: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMACAddress;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
        function isMACAddress(str) {
          (0, _assertString2.default)(str);
          return macAddress.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    230: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMD5;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var md5 = /^[a-f0-9]{32}$/;
        function isMD5(str) {
          (0, _assertString2.default)(str);
          return md5.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    231: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMimeType;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /*
  Checks if the provided string matches to a correct Media type format (MIME type)

  This function only checks is the string format follows the
  etablished rules by the according RFC specifications.
  This function supports 'charset' in textual media types
  (https://tools.ietf.org/html/rfc6657).

  This function does not check against all the media types listed
  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
  because of lightness purposes : it would require to include
  all these MIME types in this librairy, which would weigh it
  significantly. This kind of effort maybe is not worth for the use that
  this function has in this entire librairy.

  More informations in the RFC specifications :
  - https://tools.ietf.org/html/rfc2045
  - https://tools.ietf.org/html/rfc2046
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
*/
        // Match simple MIME types
        // NB :
        //   Subtype length must not exceed 100 characters.
        //   This rule does not comply to the RFC specs (what is the max length ?).
        var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i;
        // eslint-disable-line max-len
        // Handle "charset" in "text/*"
        var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
        // eslint-disable-line max-len
        // Handle "boundary" in "multipart/*"
        var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
        // eslint-disable-line max-len
        function isMimeType(str) {
          (0, _assertString2.default)(str);
          return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    232: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMobilePhone;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable max-len */
        var phones = {
            'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
            'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
            'ar-EG': /^((\+?20)|0)?1[012]\d{8}$/,
            'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
            'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
            'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
            'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
            'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
            'de-DE': /^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
            'el-GR': /^(\+?30|0)?(69\d{8})$/,
            'en-AU': /^(\+?61|0)4\d{8}$/,
            'en-GB': /^(\+?44|0)7\d{9}$/,
            'en-HK': /^(\+?852\-?)?[456789]\d{3}\-?\d{4}$/,
            'en-IN': /^(\+?91|0)?[789]\d{9}$/,
            'en-KE': /^(\+?254|0)?[7]\d{8}$/,
            'en-NG': /^(\+?234|0)?[789]\d{9}$/,
            'en-NZ': /^(\+?64|0)2\d{7,9}$/,
            'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
            'en-RW': /^(\+?250|0)?[7]\d{8}$/,
            'en-SG': /^(\+65)?[89]\d{7}$/,
            'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
            'en-UG': /^(\+?256|0)?[7]\d{8}$/,
            'en-US': /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
            'en-ZA': /^(\+?27|0)\d{9}$/,
            'en-ZM': /^(\+?26)?09[567]\d{7}$/,
            'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
            'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
            'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
            'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
            'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
            'fr-FR': /^(\+?33|0)[67]\d{8}$/,
            'he-IL': /^(\+972|0)([23489]|5[0248]|77)[1-9]\d{6}/,
            'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
            'id-ID': /^(\+?62|0[1-9])[\s|\d]+$/,
            'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
            'ja-JP': /^(\+?81|0)[789]0[ \-]?[1-9]\d{2}[ \-]?\d{5}$/,
            'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
            'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
            'lt-LT': /^(\+370|8)\d{8}$/,
            'ms-MY': /^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
            'nb-NO': /^(\+?47)?[49]\d{7}$/,
            'nl-BE': /^(\+?32|0)4?\d{8}$/,
            'nn-NO': /^(\+?47)?[49]\d{7}$/,
            'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
            'pt-BR': /^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,
            'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
            'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
            'ru-RU': /^(\+?7|8)?9\d{9}$/,
            'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
            'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
            'tr-TR': /^(\+?90|0)?5\d{9}$/,
            'uk-UA': /^(\+?38|8)?0\d{9}$/,
            'vi-VN': /^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
            'zh-CN': /^(\+?0?86\-?)?1[345789]\d{9}$/,
            'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
          };
        /* eslint-enable max-len */
        // aliases
        phones['en-CA'] = phones['en-US'];
        phones['fr-BE'] = phones['nl-BE'];
        phones['zh-HK'] = phones['en-HK'];
        function isMobilePhone(str, locale) {
          (0, _assertString2.default)(str);
          if (locale in phones) {
            return phones[locale].test(str);
          } else if (locale === 'any') {
            for (var key in phones) {
              if (phones.hasOwnProperty(key)) {
                var phone = phones[key];
                if (phone.test(str)) {
                  return true;
                }
              }
            }
            return false;
          }
          throw new Error('Invalid locale \'' + locale + '\'');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    233: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMongoId;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isHexadecimal = require('./isHexadecimal');
        var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isMongoId(str) {
          (0, _assertString2.default)(str);
          return (0, _isHexadecimal2.default)(str) && str.length === 24;
        }
        module.exports = exports['default'];
      },
      {
        './isHexadecimal': 215,
        './util/assertString': 255
      }
    ],
    234: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isMultibyte;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        /* eslint-disable no-control-regex */
        var multibyte = /[^\x00-\x7F]/;
        /* eslint-enable no-control-regex */
        function isMultibyte(str) {
          (0, _assertString2.default)(str);
          return multibyte.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    235: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isNumeric;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var numeric = /^[-+]?[0-9]+$/;
        function isNumeric(str) {
          (0, _assertString2.default)(str);
          return numeric.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    236: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isPort;
        var _isInt = require('./isInt');
        var _isInt2 = _interopRequireDefault(_isInt);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isPort(str) {
          return (0, _isInt2.default)(str, {
            min: 0,
            max: 65535
          });
        }
        module.exports = exports['default'];
      },
      { './isInt': 224 }
    ],
    237: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.locales = undefined;
        exports.default = function (str, locale) {
          (0, _assertString2.default)(str);
          if (locale in patterns) {
            return patterns[locale].test(str);
          } else if (locale === 'any') {
            for (var key in patterns) {
              if (patterns.hasOwnProperty(key)) {
                var pattern = patterns[key];
                if (pattern.test(str)) {
                  return true;
                }
              }
            }
            return false;
          }
          throw new Error('Invalid locale \'' + locale + '\'');
        };
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        // common patterns
        var threeDigit = /^\d{3}$/;
        var fourDigit = /^\d{4}$/;
        var fiveDigit = /^\d{5}$/;
        var sixDigit = /^\d{6}$/;
        var patterns = {
            AT: fourDigit,
            AU: fourDigit,
            BE: fourDigit,
            CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
            CH: fourDigit,
            CZ: /^\d{3}\s?\d{2}$/,
            DE: fiveDigit,
            DK: fourDigit,
            DZ: fiveDigit,
            ES: fiveDigit,
            FI: fiveDigit,
            FR: /^\d{2}\s?\d{3}$/,
            GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
            GR: /^\d{3}\s?\d{2}$/,
            IL: fiveDigit,
            IN: sixDigit,
            IS: threeDigit,
            IT: fiveDigit,
            JP: /^\d{3}\-\d{4}$/,
            KE: fiveDigit,
            LI: /^(948[5-9]|949[0-7])$/,
            MX: fiveDigit,
            NL: /^\d{4}\s?[a-z]{2}$/i,
            NO: fourDigit,
            PL: /^\d{2}\-\d{3}$/,
            PT: /^\d{4}\-\d{3}?$/,
            RO: sixDigit,
            RU: sixDigit,
            SA: fiveDigit,
            SE: /^\d{3}\s?\d{2}$/,
            TW: /^\d{3}(\d{2})?$/,
            US: /^\d{5}(-\d{4})?$/,
            ZA: fourDigit,
            ZM: fiveDigit
          };
        var locales = exports.locales = Object.keys(patterns);
      },
      { './util/assertString': 255 }
    ],
    238: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isSurrogatePair;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
        function isSurrogatePair(str) {
          (0, _assertString2.default)(str);
          return surrogatePair.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    239: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isURL;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isFQDN = require('./isFQDN');
        var _isFQDN2 = _interopRequireDefault(_isFQDN);
        var _isIP = require('./isIP');
        var _isIP2 = _interopRequireDefault(_isIP);
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_url_options = {
            protocols: [
              'http',
              'https',
              'ftp'
            ],
            require_tld: true,
            require_protocol: false,
            require_host: true,
            require_valid_protocol: true,
            allow_underscores: false,
            allow_trailing_dot: false,
            allow_protocol_relative_urls: false
          };
        var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
        function isRegExp(obj) {
          return Object.prototype.toString.call(obj) === '[object RegExp]';
        }
        function checkHost(host, matches) {
          for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            if (host === match || isRegExp(match) && match.test(host)) {
              return true;
            }
          }
          return false;
        }
        function isURL(url, options) {
          (0, _assertString2.default)(url);
          if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
            return false;
          }
          if (url.indexOf('mailto:') === 0) {
            return false;
          }
          options = (0, _merge2.default)(options, default_url_options);
          var protocol = void 0, auth = void 0, host = void 0, hostname = void 0, port = void 0, port_str = void 0, split = void 0, ipv6 = void 0;
          split = url.split('#');
          url = split.shift();
          split = url.split('?');
          url = split.shift();
          split = url.split('://');
          if (split.length > 1) {
            protocol = split.shift();
            if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
              return false;
            }
          } else if (options.require_protocol) {
            return false;
          } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
            split[0] = url.substr(2);
          }
          url = split.join('://');
          if (url === '') {
            return false;
          }
          split = url.split('/');
          url = split.shift();
          if (url === '' && !options.require_host) {
            return true;
          }
          split = url.split('@');
          if (split.length > 1) {
            auth = split.shift();
            if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
              return false;
            }
          }
          hostname = split.join('@');
          port_str = null;
          ipv6 = null;
          var ipv6_match = hostname.match(wrapped_ipv6);
          if (ipv6_match) {
            host = '';
            ipv6 = ipv6_match[1];
            port_str = ipv6_match[2] || null;
          } else {
            split = hostname.split(':');
            host = split.shift();
            if (split.length) {
              port_str = split.join(':');
            }
          }
          if (port_str !== null) {
            port = parseInt(port_str, 10);
            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
              return false;
            }
          }
          if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6))) {
            return false;
          }
          host = host || ipv6;
          if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
            return false;
          }
          if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
            return false;
          }
          return true;
        }
        module.exports = exports['default'];
      },
      {
        './isFQDN': 209,
        './isIP': 216,
        './util/assertString': 255,
        './util/merge': 256
      }
    ],
    240: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isUUID;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var uuid = {
            3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
          };
        function isUUID(str) {
          var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
          (0, _assertString2.default)(str);
          var pattern = uuid[version];
          return pattern && pattern.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    241: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isUppercase;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isUppercase(str) {
          (0, _assertString2.default)(str);
          return str === str.toUpperCase();
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    242: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isVariableWidth;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _isFullWidth = require('./isFullWidth');
        var _isHalfWidth = require('./isHalfWidth');
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isVariableWidth(str) {
          (0, _assertString2.default)(str);
          return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
        }
        module.exports = exports['default'];
      },
      {
        './isFullWidth': 211,
        './isHalfWidth': 212,
        './util/assertString': 255
      }
    ],
    243: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = isWhitelisted;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function isWhitelisted(str, chars) {
          (0, _assertString2.default)(str);
          for (var i = str.length - 1; i >= 0; i--) {
            if (chars.indexOf(str[i]) === -1) {
              return false;
            }
          }
          return true;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    244: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = ltrim;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function ltrim(str, chars) {
          (0, _assertString2.default)(str);
          var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
          return str.replace(pattern, '');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    245: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = matches;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function matches(str, pattern, modifiers) {
          (0, _assertString2.default)(str);
          if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
            pattern = new RegExp(pattern, modifiers);
          }
          return pattern.test(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    246: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = normalizeEmail;
        var _merge = require('./util/merge');
        var _merge2 = _interopRequireDefault(_merge);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var default_normalize_email_options = {
            all_lowercase: true,
            gmail_lowercase: true,
            gmail_remove_dots: true,
            gmail_remove_subaddress: true,
            gmail_convert_googlemaildotcom: true,
            outlookdotcom_lowercase: true,
            outlookdotcom_remove_subaddress: true,
            yahoo_lowercase: true,
            yahoo_remove_subaddress: true,
            icloud_lowercase: true,
            icloud_remove_subaddress: true
          };
        // List of domains used by iCloud
        var icloud_domains = [
            'icloud.com',
            'me.com'
          ];
        // List of domains used by Outlook.com and its predecessors
        // This list is likely incomplete.
        // Partial reference:
        // https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/
        var outlookdotcom_domains = [
            'hotmail.at',
            'hotmail.be',
            'hotmail.ca',
            'hotmail.cl',
            'hotmail.co.il',
            'hotmail.co.nz',
            'hotmail.co.th',
            'hotmail.co.uk',
            'hotmail.com',
            'hotmail.com.ar',
            'hotmail.com.au',
            'hotmail.com.br',
            'hotmail.com.gr',
            'hotmail.com.mx',
            'hotmail.com.pe',
            'hotmail.com.tr',
            'hotmail.com.vn',
            'hotmail.cz',
            'hotmail.de',
            'hotmail.dk',
            'hotmail.es',
            'hotmail.fr',
            'hotmail.hu',
            'hotmail.id',
            'hotmail.ie',
            'hotmail.in',
            'hotmail.it',
            'hotmail.jp',
            'hotmail.kr',
            'hotmail.lv',
            'hotmail.my',
            'hotmail.ph',
            'hotmail.pt',
            'hotmail.sa',
            'hotmail.sg',
            'hotmail.sk',
            'live.be',
            'live.co.uk',
            'live.com',
            'live.com.ar',
            'live.com.mx',
            'live.de',
            'live.es',
            'live.eu',
            'live.fr',
            'live.it',
            'live.nl',
            'msn.com',
            'outlook.at',
            'outlook.be',
            'outlook.cl',
            'outlook.co.il',
            'outlook.co.nz',
            'outlook.co.th',
            'outlook.com',
            'outlook.com.ar',
            'outlook.com.au',
            'outlook.com.br',
            'outlook.com.gr',
            'outlook.com.pe',
            'outlook.com.tr',
            'outlook.com.vn',
            'outlook.cz',
            'outlook.de',
            'outlook.dk',
            'outlook.es',
            'outlook.fr',
            'outlook.hu',
            'outlook.id',
            'outlook.ie',
            'outlook.in',
            'outlook.it',
            'outlook.jp',
            'outlook.kr',
            'outlook.lv',
            'outlook.my',
            'outlook.ph',
            'outlook.pt',
            'outlook.sa',
            'outlook.sg',
            'outlook.sk',
            'passport.com'
          ];
        // List of domains used by Yahoo Mail
        // This list is likely incomplete
        var yahoo_domains = [
            'rocketmail.com',
            'yahoo.ca',
            'yahoo.co.uk',
            'yahoo.com',
            'yahoo.de',
            'yahoo.fr',
            'yahoo.in',
            'yahoo.it',
            'ymail.com'
          ];
        function normalizeEmail(email, options) {
          options = (0, _merge2.default)(options, default_normalize_email_options);
          var raw_parts = email.split('@');
          var domain = raw_parts.pop();
          var user = raw_parts.join('@');
          var parts = [
              user,
              domain
            ];
          // The domain is always lowercased, as it's case-insensitive per RFC 1035
          parts[1] = parts[1].toLowerCase();
          if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
            // Address is GMail
            if (options.gmail_remove_subaddress) {
              parts[0] = parts[0].split('+')[0];
            }
            if (options.gmail_remove_dots) {
              parts[0] = parts[0].replace(/\./g, '');
            }
            if (!parts[0].length) {
              return false;
            }
            if (options.all_lowercase || options.gmail_lowercase) {
              parts[0] = parts[0].toLowerCase();
            }
            parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
          } else if (~icloud_domains.indexOf(parts[1])) {
            // Address is iCloud
            if (options.icloud_remove_subaddress) {
              parts[0] = parts[0].split('+')[0];
            }
            if (!parts[0].length) {
              return false;
            }
            if (options.all_lowercase || options.icloud_lowercase) {
              parts[0] = parts[0].toLowerCase();
            }
          } else if (~outlookdotcom_domains.indexOf(parts[1])) {
            // Address is Outlook.com
            if (options.outlookdotcom_remove_subaddress) {
              parts[0] = parts[0].split('+')[0];
            }
            if (!parts[0].length) {
              return false;
            }
            if (options.all_lowercase || options.outlookdotcom_lowercase) {
              parts[0] = parts[0].toLowerCase();
            }
          } else if (~yahoo_domains.indexOf(parts[1])) {
            // Address is Yahoo
            if (options.yahoo_remove_subaddress) {
              var components = parts[0].split('-');
              parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
            }
            if (!parts[0].length) {
              return false;
            }
            if (options.all_lowercase || options.yahoo_lowercase) {
              parts[0] = parts[0].toLowerCase();
            }
          } else if (options.all_lowercase) {
            // Any other address
            parts[0] = parts[0].toLowerCase();
          }
          return parts.join('@');
        }
        module.exports = exports['default'];
      },
      { './util/merge': 256 }
    ],
    247: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = rtrim;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function rtrim(str, chars) {
          (0, _assertString2.default)(str);
          var pattern = chars ? new RegExp('[' + chars + ']') : /\s/;
          var idx = str.length - 1;
          while (idx >= 0 && pattern.test(str[idx])) {
            idx--;
          }
          return idx < str.length ? str.substr(0, idx + 1) : str;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    248: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = stripLow;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        var _blacklist = require('./blacklist');
        var _blacklist2 = _interopRequireDefault(_blacklist);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function stripLow(str, keep_new_lines) {
          (0, _assertString2.default)(str);
          var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
          return (0, _blacklist2.default)(str, chars);
        }
        module.exports = exports['default'];
      },
      {
        './blacklist': 190,
        './util/assertString': 255
      }
    ],
    249: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toBoolean;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toBoolean(str, strict) {
          (0, _assertString2.default)(str);
          if (strict) {
            return str === '1' || str === 'true';
          }
          return str !== '0' && str !== 'false' && str !== '';
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    250: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toDate;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toDate(date) {
          (0, _assertString2.default)(date);
          date = Date.parse(date);
          return !isNaN(date) ? new Date(date) : null;
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    251: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toFloat;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toFloat(str) {
          (0, _assertString2.default)(str);
          return parseFloat(str);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    252: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = toInt;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function toInt(str, radix) {
          (0, _assertString2.default)(str);
          return parseInt(str, radix || 10);
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    253: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = trim;
        var _rtrim = require('./rtrim');
        var _rtrim2 = _interopRequireDefault(_rtrim);
        var _ltrim = require('./ltrim');
        var _ltrim2 = _interopRequireDefault(_ltrim);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function trim(str, chars) {
          return (0, _rtrim2.default)((0, _ltrim2.default)(str, chars), chars);
        }
        module.exports = exports['default'];
      },
      {
        './ltrim': 244,
        './rtrim': 247
      }
    ],
    254: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = unescape;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function unescape(str) {
          (0, _assertString2.default)(str);
          return str.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#x27;/g, '\'').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    255: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = assertString;
        function assertString(input) {
          var isString = typeof input === 'string' || input instanceof String;
          if (!isString) {
            throw new TypeError('This library (validator.js) validates strings only');
          }
        }
        module.exports = exports['default'];
      },
      {}
    ],
    256: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = merge;
        function merge() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var defaults = arguments[1];
          for (var key in defaults) {
            if (typeof obj[key] === 'undefined') {
              obj[key] = defaults[key];
            }
          }
          return obj;
        }
        module.exports = exports['default'];
      },
      {}
    ],
    257: [
      function (require, module, exports) {
        'use strict';
        var _typeof2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        Object.defineProperty(exports, '__esModule', { value: true });
        var _typeof = typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol' ? function (obj) {
            return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
          };
        exports.default = toString;
        function toString(input) {
          if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input !== null) {
            if (typeof input.toString === 'function') {
              input = input.toString();
            } else {
              input = '[object Object]';
            }
          } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
            input = '';
          }
          return String(input);
        }
        module.exports = exports['default'];
      },
      {}
    ],
    258: [
      function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports.default = whitelist;
        var _assertString = require('./util/assertString');
        var _assertString2 = _interopRequireDefault(_assertString);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function whitelist(str, chars) {
          (0, _assertString2.default)(str);
          return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
        }
        module.exports = exports['default'];
      },
      { './util/assertString': 255 }
    ],
    259: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.7
        (function () {
          'use strict';
          exports.stripBOM = function (str) {
            if (str[0] === '\ufeff') {
              return str.substring(1);
            } else {
              return str;
            }
          };
        }.call(undefined));
      },
      {}
    ],
    260: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        // Generated by CoffeeScript 1.12.7
        (function () {
          'use strict';
          var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
          builder = require('xmlbuilder');
          defaults = require('./defaults').defaults;
          requiresCDATA = function requiresCDATA(entry) {
            return typeof entry === 'string' && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
          };
          wrapCDATA = function wrapCDATA(entry) {
            return '<![CDATA[' + escapeCDATA(entry) + ']]>';
          };
          escapeCDATA = function escapeCDATA(entry) {
            return entry.replace(']]>', ']]]]><![CDATA[>');
          };
          exports.Builder = function () {
            function Builder(opts) {
              var key, ref, value;
              this.options = {};
              ref = defaults['0.2'];
              for (key in ref) {
                if (!hasProp.call(ref, key))
                  continue;
                value = ref[key];
                this.options[key] = value;
              }
              for (key in opts) {
                if (!hasProp.call(opts, key))
                  continue;
                value = opts[key];
                this.options[key] = value;
              }
            }
            Builder.prototype.buildObject = function (rootObj) {
              var attrkey, charkey, render, rootElement, rootName;
              attrkey = this.options.attrkey;
              charkey = this.options.charkey;
              if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
              } else {
                rootName = this.options.rootName;
              }
              render = function (_this) {
                return function (element, obj) {
                  var attr, child, entry, index, key, value;
                  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
                    if (_this.options.cdata && requiresCDATA(obj)) {
                      element.raw(wrapCDATA(obj));
                    } else {
                      element.txt(obj);
                    }
                  } else if (Array.isArray(obj)) {
                    for (index in obj) {
                      if (!hasProp.call(obj, index))
                        continue;
                      child = obj[index];
                      for (key in child) {
                        entry = child[key];
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else {
                    for (key in obj) {
                      if (!hasProp.call(obj, key))
                        continue;
                      child = obj[key];
                      if (key === attrkey) {
                        if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) === 'object') {
                          for (attr in child) {
                            value = child[attr];
                            element = element.att(attr, value);
                          }
                        }
                      } else if (key === charkey) {
                        if (_this.options.cdata && requiresCDATA(child)) {
                          element = element.raw(wrapCDATA(child));
                        } else {
                          element = element.txt(child);
                        }
                      } else if (Array.isArray(child)) {
                        for (index in child) {
                          if (!hasProp.call(child, index))
                            continue;
                          entry = child[index];
                          if (typeof entry === 'string') {
                            if (_this.options.cdata && requiresCDATA(entry)) {
                              element = element.ele(key).raw(wrapCDATA(entry)).up();
                            } else {
                              element = element.ele(key, entry).up();
                            }
                          } else {
                            element = render(element.ele(key), entry).up();
                          }
                        }
                      } else if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) === 'object') {
                        element = render(element.ele(key), child).up();
                      } else {
                        if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                          element = element.ele(key).raw(wrapCDATA(child)).up();
                        } else {
                          if (child == null) {
                            child = '';
                          }
                          element = element.ele(key, child.toString()).up();
                        }
                      }
                    }
                  }
                  return element;
                };
              }(this);
              rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
              });
              return render(rootElement, rootObj).end(this.options.renderOpts);
            };
            return Builder;
          }();
        }.call(undefined));
      },
      {
        './defaults': 261,
        'xmlbuilder': 286
      }
    ],
    261: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.7
        (function () {
          exports.defaults = {
            '0.1': {
              explicitCharkey: false,
              trim: true,
              normalize: true,
              normalizeTags: false,
              attrkey: '@',
              charkey: '#',
              explicitArray: false,
              ignoreAttrs: false,
              mergeAttrs: false,
              explicitRoot: false,
              validator: null,
              xmlns: false,
              explicitChildren: false,
              childkey: '@@',
              charsAsChildren: false,
              includeWhiteChars: false,
              async: false,
              strict: true,
              attrNameProcessors: null,
              attrValueProcessors: null,
              tagNameProcessors: null,
              valueProcessors: null,
              emptyTag: ''
            },
            '0.2': {
              explicitCharkey: false,
              trim: false,
              normalize: false,
              normalizeTags: false,
              attrkey: '$',
              charkey: '_',
              explicitArray: true,
              ignoreAttrs: false,
              mergeAttrs: false,
              explicitRoot: true,
              validator: null,
              xmlns: false,
              explicitChildren: false,
              preserveChildrenOrder: false,
              childkey: '$$',
              charsAsChildren: false,
              includeWhiteChars: false,
              async: false,
              strict: true,
              attrNameProcessors: null,
              attrValueProcessors: null,
              tagNameProcessors: null,
              valueProcessors: null,
              rootName: 'root',
              xmldec: {
                'version': '1.0',
                'encoding': 'UTF-8',
                'standalone': true
              },
              doctype: null,
              renderOpts: {
                'pretty': true,
                'indent': '  ',
                'newline': '\n'
              },
              headless: false,
              chunkSize: 10000,
              emptyTag: '',
              cdata: false
            }
          };
        }.call(undefined));
      },
      {}
    ],
    262: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        // Generated by CoffeeScript 1.12.7
        (function () {
          'use strict';
          var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate, bind = function bind(fn, me) {
              return function () {
                return fn.apply(me, arguments);
              };
            }, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          sax = require('sax');
          events = require('events');
          bom = require('./bom');
          processors = require('./processors');
          setImmediate = require('timers').setImmediate;
          defaults = require('./defaults').defaults;
          isEmpty = function isEmpty(thing) {
            return (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object' && thing != null && Object.keys(thing).length === 0;
          };
          processItem = function processItem(processors, item, key) {
            var i, len, process;
            for (i = 0, len = processors.length; i < len; i++) {
              process = processors[i];
              item = process(item, key);
            }
            return item;
          };
          exports.Parser = function (superClass) {
            extend(Parser, superClass);
            function Parser(opts) {
              this.parseString = bind(this.parseString, this);
              this.reset = bind(this.reset, this);
              this.assignOrPush = bind(this.assignOrPush, this);
              this.processAsync = bind(this.processAsync, this);
              var key, ref, value;
              if (!(this instanceof exports.Parser)) {
                return new exports.Parser(opts);
              }
              this.options = {};
              ref = defaults['0.2'];
              for (key in ref) {
                if (!hasProp.call(ref, key))
                  continue;
                value = ref[key];
                this.options[key] = value;
              }
              for (key in opts) {
                if (!hasProp.call(opts, key))
                  continue;
                value = opts[key];
                this.options[key] = value;
              }
              if (this.options.xmlns) {
                this.options.xmlnskey = this.options.attrkey + 'ns';
              }
              if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) {
                  this.options.tagNameProcessors = [];
                }
                this.options.tagNameProcessors.unshift(processors.normalize);
              }
              this.reset();
            }
            Parser.prototype.processAsync = function () {
              var chunk, err;
              try {
                if (this.remaining.length <= this.options.chunkSize) {
                  chunk = this.remaining;
                  this.remaining = '';
                  this.saxParser = this.saxParser.write(chunk);
                  return this.saxParser.close();
                } else {
                  chunk = this.remaining.substr(0, this.options.chunkSize);
                  this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                  this.saxParser = this.saxParser.write(chunk);
                  return setImmediate(this.processAsync);
                }
              } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                  this.saxParser.errThrown = true;
                  return this.emit(err);
                }
              }
            };
            Parser.prototype.assignOrPush = function (obj, key, newValue) {
              if (!(key in obj)) {
                if (!this.options.explicitArray) {
                  return obj[key] = newValue;
                } else {
                  return obj[key] = [newValue];
                }
              } else {
                if (!(obj[key] instanceof Array)) {
                  obj[key] = [obj[key]];
                }
                return obj[key].push(newValue);
              }
            };
            Parser.prototype.reset = function () {
              var attrkey, charkey, ontext, stack;
              this.removeAllListeners();
              this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
              });
              this.saxParser.errThrown = false;
              this.saxParser.onerror = function (_this) {
                return function (error) {
                  _this.saxParser.resume();
                  if (!_this.saxParser.errThrown) {
                    _this.saxParser.errThrown = true;
                    return _this.emit('error', error);
                  }
                };
              }(this);
              this.saxParser.onend = function (_this) {
                return function () {
                  if (!_this.saxParser.ended) {
                    _this.saxParser.ended = true;
                    return _this.emit('end', _this.resultObject);
                  }
                };
              }(this);
              this.saxParser.ended = false;
              this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
              this.resultObject = null;
              stack = [];
              attrkey = this.options.attrkey;
              charkey = this.options.charkey;
              this.saxParser.onopentag = function (_this) {
                return function (node) {
                  var key, newValue, obj, processedKey, ref;
                  obj = {};
                  obj[charkey] = '';
                  if (!_this.options.ignoreAttrs) {
                    ref = node.attributes;
                    for (key in ref) {
                      if (!hasProp.call(ref, key))
                        continue;
                      if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                        obj[attrkey] = {};
                      }
                      newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                      processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                      if (_this.options.mergeAttrs) {
                        _this.assignOrPush(obj, processedKey, newValue);
                      } else {
                        obj[attrkey][processedKey] = newValue;
                      }
                    }
                  }
                  obj['#name'] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                  if (_this.options.xmlns) {
                    obj[_this.options.xmlnskey] = {
                      uri: node.uri,
                      local: node.local
                    };
                  }
                  return stack.push(obj);
                };
              }(this);
              this.saxParser.onclosetag = function (_this) {
                return function () {
                  var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                  obj = stack.pop();
                  nodeName = obj['#name'];
                  if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                    delete obj['#name'];
                  }
                  if (obj.cdata === true) {
                    cdata = obj.cdata;
                    delete obj.cdata;
                  }
                  s = stack[stack.length - 1];
                  if (obj[charkey].match(/^\s*$/) && !cdata) {
                    emptyStr = obj[charkey];
                    delete obj[charkey];
                  } else {
                    if (_this.options.trim) {
                      obj[charkey] = obj[charkey].trim();
                    }
                    if (_this.options.normalize) {
                      obj[charkey] = obj[charkey].replace(/\s{2,}/g, ' ').trim();
                    }
                    obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                      obj = obj[charkey];
                    }
                  }
                  if (isEmpty(obj)) {
                    obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                  }
                  if (_this.options.validator != null) {
                    xpath = '/' + function () {
                      var i, len, results;
                      results = [];
                      for (i = 0, len = stack.length; i < len; i++) {
                        node = stack[i];
                        results.push(node['#name']);
                      }
                      return results;
                    }().concat(nodeName).join('/');
                    (function () {
                      var err;
                      try {
                        return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                      } catch (error1) {
                        err = error1;
                        return _this.emit('error', err);
                      }
                    }());
                  }
                  if (_this.options.explicitChildren && !_this.options.mergeAttrs && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
                    if (!_this.options.preserveChildrenOrder) {
                      node = {};
                      if (_this.options.attrkey in obj) {
                        node[_this.options.attrkey] = obj[_this.options.attrkey];
                        delete obj[_this.options.attrkey];
                      }
                      if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                        node[_this.options.charkey] = obj[_this.options.charkey];
                        delete obj[_this.options.charkey];
                      }
                      if (Object.getOwnPropertyNames(obj).length > 0) {
                        node[_this.options.childkey] = obj;
                      }
                      obj = node;
                    } else if (s) {
                      s[_this.options.childkey] = s[_this.options.childkey] || [];
                      objClone = {};
                      for (key in obj) {
                        if (!hasProp.call(obj, key))
                          continue;
                        objClone[key] = obj[key];
                      }
                      s[_this.options.childkey].push(objClone);
                      delete obj['#name'];
                      if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                        obj = obj[charkey];
                      }
                    }
                  }
                  if (stack.length > 0) {
                    return _this.assignOrPush(s, nodeName, obj);
                  } else {
                    if (_this.options.explicitRoot) {
                      old = obj;
                      obj = {};
                      obj[nodeName] = old;
                    }
                    _this.resultObject = obj;
                    _this.saxParser.ended = true;
                    return _this.emit('end', _this.resultObject);
                  }
                };
              }(this);
              ontext = function (_this) {
                return function (text) {
                  var charChild, s;
                  s = stack[stack.length - 1];
                  if (s) {
                    s[charkey] += text;
                    if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                      s[_this.options.childkey] = s[_this.options.childkey] || [];
                      charChild = { '#name': '__text__' };
                      charChild[charkey] = text;
                      if (_this.options.normalize) {
                        charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, ' ').trim();
                      }
                      s[_this.options.childkey].push(charChild);
                    }
                    return s;
                  }
                };
              }(this);
              this.saxParser.ontext = ontext;
              return this.saxParser.oncdata = function (_this) {
                return function (text) {
                  var s;
                  s = ontext(text);
                  if (s) {
                    return s.cdata = true;
                  }
                };
              }(this);
            };
            Parser.prototype.parseString = function (str, cb) {
              var err;
              if (cb != null && typeof cb === 'function') {
                this.on('end', function (result) {
                  this.reset();
                  return cb(null, result);
                });
                this.on('error', function (err) {
                  this.reset();
                  return cb(err);
                });
              }
              try {
                str = str.toString();
                if (str.trim() === '') {
                  this.emit('end', null);
                  return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                  this.remaining = str;
                  setImmediate(this.processAsync);
                  return this.saxParser;
                }
                return this.saxParser.write(str).close();
              } catch (error1) {
                err = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                  this.emit('error', err);
                  return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) {
                  throw err;
                }
              }
            };
            return Parser;
          }(events.EventEmitter);
          exports.parseString = function (str, a, b) {
            var cb, options, parser;
            if (b != null) {
              if (typeof b === 'function') {
                cb = b;
              }
              if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
                options = a;
              }
            } else {
              if (typeof a === 'function') {
                cb = a;
              }
              options = {};
            }
            parser = new exports.Parser(options);
            return parser.parseString(str, cb);
          };
        }.call(undefined));
      },
      {
        './bom': 259,
        './defaults': 261,
        './processors': 263,
        'events': 13,
        'sax': 151,
        'timers': 182
      }
    ],
    263: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.7
        (function () {
          'use strict';
          var prefixMatch;
          prefixMatch = new RegExp(/(?!xmlns)^.*:/);
          exports.normalize = function (str) {
            return str.toLowerCase();
          };
          exports.firstCharLowerCase = function (str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
          };
          exports.stripPrefix = function (str) {
            return str.replace(prefixMatch, '');
          };
          exports.parseNumbers = function (str) {
            if (!isNaN(str)) {
              str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
            }
            return str;
          };
          exports.parseBooleans = function (str) {
            if (/^(?:true|false)$/i.test(str)) {
              str = str.toLowerCase() === 'true';
            }
            return str;
          };
        }.call(undefined));
      },
      {}
    ],
    264: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.7
        (function () {
          'use strict';
          var builder, defaults, parser, processors, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          defaults = require('./defaults');
          builder = require('./builder');
          parser = require('./parser');
          processors = require('./processors');
          exports.defaults = defaults.defaults;
          exports.processors = processors;
          exports.ValidationError = function (superClass) {
            extend(ValidationError, superClass);
            function ValidationError(message) {
              this.message = message;
            }
            return ValidationError;
          }(Error);
          exports.Builder = builder.Builder;
          exports.Parser = parser.Parser;
          exports.parseString = parser.parseString;
        }.call(undefined));
      },
      {
        './builder': 260,
        './defaults': 261,
        './parser': 262,
        './processors': 263
      }
    ],
    265: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        // Generated by CoffeeScript 1.12.6
        (function () {
          var assign, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
          assign = function assign() {
            var i, key, len, source, sources, target;
            target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (isFunction(Object.assign)) {
              Object.assign.apply(null, arguments);
            } else {
              for (i = 0, len = sources.length; i < len; i++) {
                source = sources[i];
                if (source != null) {
                  for (key in source) {
                    if (!hasProp.call(source, key))
                      continue;
                    target[key] = source[key];
                  }
                }
              }
            }
            return target;
          };
          isFunction = function isFunction(val) {
            return !!val && Object.prototype.toString.call(val) === '[object Function]';
          };
          isObject = function isObject(val) {
            var ref;
            return !!val && ((ref = typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'function' || ref === 'object');
          };
          isArray = function isArray(val) {
            if (isFunction(Array.isArray)) {
              return Array.isArray(val);
            } else {
              return Object.prototype.toString.call(val) === '[object Array]';
            }
          };
          isEmpty = function isEmpty(val) {
            var key;
            if (isArray(val)) {
              return !val.length;
            } else {
              for (key in val) {
                if (!hasProp.call(val, key))
                  continue;
                return false;
              }
              return true;
            }
          };
          isPlainObject = function isPlainObject(val) {
            var ctor, proto;
            return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === 'function' && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
          };
          module.exports.assign = assign;
          module.exports.isFunction = isFunction;
          module.exports.isObject = isObject;
          module.exports.isArray = isArray;
          module.exports.isEmpty = isEmpty;
          module.exports.isPlainObject = isPlainObject;
        }.call(undefined));
      },
      {}
    ],
    266: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLAttribute;
          module.exports = XMLAttribute = function () {
            function XMLAttribute(parent, name, value) {
              this.options = parent.options;
              this.stringify = parent.stringify;
              if (name == null) {
                throw new Error('Missing attribute name of element ' + parent.name);
              }
              if (value == null) {
                throw new Error('Missing attribute value for attribute ' + name + ' of element ' + parent.name);
              }
              this.name = this.stringify.attName(name);
              this.value = this.stringify.attValue(value);
            }
            XMLAttribute.prototype.clone = function () {
              return Object.create(this);
            };
            XMLAttribute.prototype.toString = function (options) {
              return this.options.writer.set(options).attribute(this);
            };
            return XMLAttribute;
          }();
        }.call(undefined));
      },
      {}
    ],
    267: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLCData, XMLNode, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLCData = function (superClass) {
            extend(XMLCData, superClass);
            function XMLCData(parent, text) {
              XMLCData.__super__.constructor.call(this, parent);
              if (text == null) {
                throw new Error('Missing CDATA text');
              }
              this.text = this.stringify.cdata(text);
            }
            XMLCData.prototype.clone = function () {
              return Object.create(this);
            };
            XMLCData.prototype.toString = function (options) {
              return this.options.writer.set(options).cdata(this);
            };
            return XMLCData;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    268: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLComment, XMLNode, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLComment = function (superClass) {
            extend(XMLComment, superClass);
            function XMLComment(parent, text) {
              XMLComment.__super__.constructor.call(this, parent);
              if (text == null) {
                throw new Error('Missing comment text');
              }
              this.text = this.stringify.comment(text);
            }
            XMLComment.prototype.clone = function () {
              return Object.create(this);
            };
            XMLComment.prototype.toString = function (options) {
              return this.options.writer.set(options).comment(this);
            };
            return XMLComment;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    269: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDTDAttList, XMLNode, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLDTDAttList = function (superClass) {
            extend(XMLDTDAttList, superClass);
            function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              XMLDTDAttList.__super__.constructor.call(this, parent);
              if (elementName == null) {
                throw new Error('Missing DTD element name');
              }
              if (attributeName == null) {
                throw new Error('Missing DTD attribute name');
              }
              if (!attributeType) {
                throw new Error('Missing DTD attribute type');
              }
              if (!defaultValueType) {
                throw new Error('Missing DTD attribute default');
              }
              if (defaultValueType.indexOf('#') !== 0) {
                defaultValueType = '#' + defaultValueType;
              }
              if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
                throw new Error('Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT');
              }
              if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
                throw new Error('Default value only applies to #FIXED or #DEFAULT');
              }
              this.elementName = this.stringify.eleName(elementName);
              this.attributeName = this.stringify.attName(attributeName);
              this.attributeType = this.stringify.dtdAttType(attributeType);
              this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
              this.defaultValueType = defaultValueType;
            }
            XMLDTDAttList.prototype.toString = function (options) {
              return this.options.writer.set(options).dtdAttList(this);
            };
            return XMLDTDAttList;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    270: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDTDElement, XMLNode, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLDTDElement = function (superClass) {
            extend(XMLDTDElement, superClass);
            function XMLDTDElement(parent, name, value) {
              XMLDTDElement.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error('Missing DTD element name');
              }
              if (!value) {
                value = '(#PCDATA)';
              }
              if (Array.isArray(value)) {
                value = '(' + value.join(',') + ')';
              }
              this.name = this.stringify.eleName(name);
              this.value = this.stringify.dtdElementValue(value);
            }
            XMLDTDElement.prototype.toString = function (options) {
              return this.options.writer.set(options).dtdElement(this);
            };
            return XMLDTDElement;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    271: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDTDEntity, XMLNode, isObject, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          isObject = require('./Utility').isObject;
          XMLNode = require('./XMLNode');
          module.exports = XMLDTDEntity = function (superClass) {
            extend(XMLDTDEntity, superClass);
            function XMLDTDEntity(parent, pe, name, value) {
              XMLDTDEntity.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error('Missing entity name');
              }
              if (value == null) {
                throw new Error('Missing entity value');
              }
              this.pe = !!pe;
              this.name = this.stringify.eleName(name);
              if (!isObject(value)) {
                this.value = this.stringify.dtdEntityValue(value);
              } else {
                if (!value.pubID && !value.sysID) {
                  throw new Error('Public and/or system identifiers are required for an external entity');
                }
                if (value.pubID && !value.sysID) {
                  throw new Error('System identifier is required for a public external entity');
                }
                if (value.pubID != null) {
                  this.pubID = this.stringify.dtdPubID(value.pubID);
                }
                if (value.sysID != null) {
                  this.sysID = this.stringify.dtdSysID(value.sysID);
                }
                if (value.nData != null) {
                  this.nData = this.stringify.dtdNData(value.nData);
                }
                if (this.pe && this.nData) {
                  throw new Error('Notation declaration is not allowed in a parameter entity');
                }
              }
            }
            XMLDTDEntity.prototype.toString = function (options) {
              return this.options.writer.set(options).dtdEntity(this);
            };
            return XMLDTDEntity;
          }(XMLNode);
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLNode': 278
      }
    ],
    272: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDTDNotation, XMLNode, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLDTDNotation = function (superClass) {
            extend(XMLDTDNotation, superClass);
            function XMLDTDNotation(parent, name, value) {
              XMLDTDNotation.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error('Missing notation name');
              }
              if (!value.pubID && !value.sysID) {
                throw new Error('Public or system identifiers are required for an external entity');
              }
              this.name = this.stringify.eleName(name);
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
            }
            XMLDTDNotation.prototype.toString = function (options) {
              return this.options.writer.set(options).dtdNotation(this);
            };
            return XMLDTDNotation;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    273: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDeclaration, XMLNode, isObject, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          isObject = require('./Utility').isObject;
          XMLNode = require('./XMLNode');
          module.exports = XMLDeclaration = function (superClass) {
            extend(XMLDeclaration, superClass);
            function XMLDeclaration(parent, version, encoding, standalone) {
              var ref;
              XMLDeclaration.__super__.constructor.call(this, parent);
              if (isObject(version)) {
                ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
              }
              if (!version) {
                version = '1.0';
              }
              this.version = this.stringify.xmlVersion(version);
              if (encoding != null) {
                this.encoding = this.stringify.xmlEncoding(encoding);
              }
              if (standalone != null) {
                this.standalone = this.stringify.xmlStandalone(standalone);
              }
            }
            XMLDeclaration.prototype.toString = function (options) {
              return this.options.writer.set(options).declaration(this);
            };
            return XMLDeclaration;
          }(XMLNode);
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLNode': 278
      }
    ],
    274: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          isObject = require('./Utility').isObject;
          XMLNode = require('./XMLNode');
          XMLDTDAttList = require('./XMLDTDAttList');
          XMLDTDEntity = require('./XMLDTDEntity');
          XMLDTDElement = require('./XMLDTDElement');
          XMLDTDNotation = require('./XMLDTDNotation');
          module.exports = XMLDocType = function (superClass) {
            extend(XMLDocType, superClass);
            function XMLDocType(parent, pubID, sysID) {
              var ref, ref1;
              XMLDocType.__super__.constructor.call(this, parent);
              this.documentObject = parent;
              if (isObject(pubID)) {
                ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
              }
              if (sysID == null) {
                ref1 = [
                  pubID,
                  sysID
                ], sysID = ref1[0], pubID = ref1[1];
              }
              if (pubID != null) {
                this.pubID = this.stringify.dtdPubID(pubID);
              }
              if (sysID != null) {
                this.sysID = this.stringify.dtdSysID(sysID);
              }
            }
            XMLDocType.prototype.element = function (name, value) {
              var child;
              child = new XMLDTDElement(this, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              var child;
              child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.entity = function (name, value) {
              var child;
              child = new XMLDTDEntity(this, false, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.pEntity = function (name, value) {
              var child;
              child = new XMLDTDEntity(this, true, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.notation = function (name, value) {
              var child;
              child = new XMLDTDNotation(this, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.toString = function (options) {
              return this.options.writer.set(options).docType(this);
            };
            XMLDocType.prototype.ele = function (name, value) {
              return this.element(name, value);
            };
            XMLDocType.prototype.att = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
            };
            XMLDocType.prototype.ent = function (name, value) {
              return this.entity(name, value);
            };
            XMLDocType.prototype.pent = function (name, value) {
              return this.pEntity(name, value);
            };
            XMLDocType.prototype.not = function (name, value) {
              return this.notation(name, value);
            };
            XMLDocType.prototype.up = function () {
              return this.root() || this.documentObject;
            };
            return XMLDocType;
          }(XMLNode);
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLDTDAttList': 269,
        './XMLDTDElement': 270,
        './XMLDTDEntity': 271,
        './XMLDTDNotation': 272,
        './XMLNode': 278
      }
    ],
    275: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          isPlainObject = require('./Utility').isPlainObject;
          XMLNode = require('./XMLNode');
          XMLStringifier = require('./XMLStringifier');
          XMLStringWriter = require('./XMLStringWriter');
          module.exports = XMLDocument = function (superClass) {
            extend(XMLDocument, superClass);
            function XMLDocument(options) {
              XMLDocument.__super__.constructor.call(this, null);
              options || (options = {});
              if (!options.writer) {
                options.writer = new XMLStringWriter();
              }
              this.options = options;
              this.stringify = new XMLStringifier(options);
              this.isDocument = true;
            }
            XMLDocument.prototype.end = function (writer) {
              var writerOptions;
              if (!writer) {
                writer = this.options.writer;
              } else if (isPlainObject(writer)) {
                writerOptions = writer;
                writer = this.options.writer.set(writerOptions);
              }
              return writer.document(this);
            };
            XMLDocument.prototype.toString = function (options) {
              return this.options.writer.set(options).document(this);
            };
            return XMLDocument;
          }(XMLNode);
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLNode': 278,
        './XMLStringWriter': 282,
        './XMLStringifier': 283
      }
    ],
    276: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
          ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;
          XMLElement = require('./XMLElement');
          XMLCData = require('./XMLCData');
          XMLComment = require('./XMLComment');
          XMLRaw = require('./XMLRaw');
          XMLText = require('./XMLText');
          XMLProcessingInstruction = require('./XMLProcessingInstruction');
          XMLDeclaration = require('./XMLDeclaration');
          XMLDocType = require('./XMLDocType');
          XMLDTDAttList = require('./XMLDTDAttList');
          XMLDTDEntity = require('./XMLDTDEntity');
          XMLDTDElement = require('./XMLDTDElement');
          XMLDTDNotation = require('./XMLDTDNotation');
          XMLAttribute = require('./XMLAttribute');
          XMLStringifier = require('./XMLStringifier');
          XMLStringWriter = require('./XMLStringWriter');
          module.exports = XMLDocumentCB = function () {
            function XMLDocumentCB(options, onData, onEnd) {
              var writerOptions;
              options || (options = {});
              if (!options.writer) {
                options.writer = new XMLStringWriter(options);
              } else if (isPlainObject(options.writer)) {
                writerOptions = options.writer;
                options.writer = new XMLStringWriter(writerOptions);
              }
              this.options = options;
              this.writer = options.writer;
              this.stringify = new XMLStringifier(options);
              this.onDataCallback = onData || function () {
              };
              this.onEndCallback = onEnd || function () {
              };
              this.currentNode = null;
              this.currentLevel = -1;
              this.openTags = {};
              this.documentStarted = false;
              this.documentCompleted = false;
              this.root = null;
            }
            XMLDocumentCB.prototype.node = function (name, attributes, text) {
              var ref1;
              if (name == null) {
                throw new Error('Missing node name');
              }
              if (this.root && this.currentLevel === -1) {
                throw new Error('Document can only have one root node');
              }
              this.openCurrent();
              name = name.valueOf();
              if (attributes == null) {
                attributes = {};
              }
              attributes = attributes.valueOf();
              if (!isObject(attributes)) {
                ref1 = [
                  attributes,
                  text
                ], text = ref1[0], attributes = ref1[1];
              }
              this.currentNode = new XMLElement(this, name, attributes);
              this.currentNode.children = false;
              this.currentLevel++;
              this.openTags[this.currentLevel] = this.currentNode;
              if (text != null) {
                this.text(text);
              }
              return this;
            };
            XMLDocumentCB.prototype.element = function (name, attributes, text) {
              if (this.currentNode && this.currentNode instanceof XMLDocType) {
                return this.dtdElement.apply(this, arguments);
              } else {
                return this.node(name, attributes, text);
              }
            };
            XMLDocumentCB.prototype.attribute = function (name, value) {
              var attName, attValue;
              if (!this.currentNode || this.currentNode.children) {
                throw new Error('att() can only be used immediately after an ele() call in callback mode');
              }
              if (name != null) {
                name = name.valueOf();
              }
              if (isObject(name)) {
                for (attName in name) {
                  if (!hasProp.call(name, attName))
                    continue;
                  attValue = name[attName];
                  this.attribute(attName, attValue);
                }
              } else {
                if (isFunction(value)) {
                  value = value.apply();
                }
                if (!this.options.skipNullAttributes || value != null) {
                  this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.text = function (value) {
              var node;
              this.openCurrent();
              node = new XMLText(this, value);
              this.onData(this.writer.text(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.cdata = function (value) {
              var node;
              this.openCurrent();
              node = new XMLCData(this, value);
              this.onData(this.writer.cdata(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.comment = function (value) {
              var node;
              this.openCurrent();
              node = new XMLComment(this, value);
              this.onData(this.writer.comment(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.raw = function (value) {
              var node;
              this.openCurrent();
              node = new XMLRaw(this, value);
              this.onData(this.writer.raw(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.instruction = function (target, value) {
              var i, insTarget, insValue, len, node;
              this.openCurrent();
              if (target != null) {
                target = target.valueOf();
              }
              if (value != null) {
                value = value.valueOf();
              }
              if (Array.isArray(target)) {
                for (i = 0, len = target.length; i < len; i++) {
                  insTarget = target[i];
                  this.instruction(insTarget);
                }
              } else if (isObject(target)) {
                for (insTarget in target) {
                  if (!hasProp.call(target, insTarget))
                    continue;
                  insValue = target[insTarget];
                  this.instruction(insTarget, insValue);
                }
              } else {
                if (isFunction(value)) {
                  value = value.apply();
                }
                node = new XMLProcessingInstruction(this, target, value);
                this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
              }
              return this;
            };
            XMLDocumentCB.prototype.declaration = function (version, encoding, standalone) {
              var node;
              this.openCurrent();
              if (this.documentStarted) {
                throw new Error('declaration() must be the first node');
              }
              node = new XMLDeclaration(this, version, encoding, standalone);
              this.onData(this.writer.declaration(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.doctype = function (root, pubID, sysID) {
              this.openCurrent();
              if (root == null) {
                throw new Error('Missing root node name');
              }
              if (this.root) {
                throw new Error('dtd() must come before the root node');
              }
              this.currentNode = new XMLDocType(this, pubID, sysID);
              this.currentNode.rootNodeName = root;
              this.currentNode.children = false;
              this.currentLevel++;
              this.openTags[this.currentLevel] = this.currentNode;
              return this;
            };
            XMLDocumentCB.prototype.dtdElement = function (name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDElement(this, name, value);
              this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              var node;
              this.openCurrent();
              node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
              this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.entity = function (name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDEntity(this, false, name, value);
              this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.pEntity = function (name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDEntity(this, true, name, value);
              this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.notation = function (name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDNotation(this, name, value);
              this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
              return this;
            };
            XMLDocumentCB.prototype.up = function () {
              if (this.currentLevel < 0) {
                throw new Error('The document node has no parent');
              }
              if (this.currentNode) {
                if (this.currentNode.children) {
                  this.closeNode(this.currentNode);
                } else {
                  this.openNode(this.currentNode);
                }
                this.currentNode = null;
              } else {
                this.closeNode(this.openTags[this.currentLevel]);
              }
              delete this.openTags[this.currentLevel];
              this.currentLevel--;
              return this;
            };
            XMLDocumentCB.prototype.end = function () {
              while (this.currentLevel >= 0) {
                this.up();
              }
              return this.onEnd();
            };
            XMLDocumentCB.prototype.openCurrent = function () {
              if (this.currentNode) {
                this.currentNode.children = true;
                return this.openNode(this.currentNode);
              }
            };
            XMLDocumentCB.prototype.openNode = function (node) {
              if (!node.isOpen) {
                if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
                  this.root = node;
                }
                this.onData(this.writer.openNode(node, this.currentLevel));
                return node.isOpen = true;
              }
            };
            XMLDocumentCB.prototype.closeNode = function (node) {
              if (!node.isClosed) {
                this.onData(this.writer.closeNode(node, this.currentLevel));
                return node.isClosed = true;
              }
            };
            XMLDocumentCB.prototype.onData = function (chunk) {
              this.documentStarted = true;
              return this.onDataCallback(chunk);
            };
            XMLDocumentCB.prototype.onEnd = function () {
              this.documentCompleted = true;
              return this.onEndCallback();
            };
            XMLDocumentCB.prototype.ele = function () {
              return this.element.apply(this, arguments);
            };
            XMLDocumentCB.prototype.nod = function (name, attributes, text) {
              return this.node(name, attributes, text);
            };
            XMLDocumentCB.prototype.txt = function (value) {
              return this.text(value);
            };
            XMLDocumentCB.prototype.dat = function (value) {
              return this.cdata(value);
            };
            XMLDocumentCB.prototype.com = function (value) {
              return this.comment(value);
            };
            XMLDocumentCB.prototype.ins = function (target, value) {
              return this.instruction(target, value);
            };
            XMLDocumentCB.prototype.dec = function (version, encoding, standalone) {
              return this.declaration(version, encoding, standalone);
            };
            XMLDocumentCB.prototype.dtd = function (root, pubID, sysID) {
              return this.doctype(root, pubID, sysID);
            };
            XMLDocumentCB.prototype.e = function (name, attributes, text) {
              return this.element(name, attributes, text);
            };
            XMLDocumentCB.prototype.n = function (name, attributes, text) {
              return this.node(name, attributes, text);
            };
            XMLDocumentCB.prototype.t = function (value) {
              return this.text(value);
            };
            XMLDocumentCB.prototype.d = function (value) {
              return this.cdata(value);
            };
            XMLDocumentCB.prototype.c = function (value) {
              return this.comment(value);
            };
            XMLDocumentCB.prototype.r = function (value) {
              return this.raw(value);
            };
            XMLDocumentCB.prototype.i = function (target, value) {
              return this.instruction(target, value);
            };
            XMLDocumentCB.prototype.att = function () {
              if (this.currentNode && this.currentNode instanceof XMLDocType) {
                return this.attList.apply(this, arguments);
              } else {
                return this.attribute.apply(this, arguments);
              }
            };
            XMLDocumentCB.prototype.a = function () {
              if (this.currentNode && this.currentNode instanceof XMLDocType) {
                return this.attList.apply(this, arguments);
              } else {
                return this.attribute.apply(this, arguments);
              }
            };
            XMLDocumentCB.prototype.ent = function (name, value) {
              return this.entity(name, value);
            };
            XMLDocumentCB.prototype.pent = function (name, value) {
              return this.pEntity(name, value);
            };
            XMLDocumentCB.prototype.not = function (name, value) {
              return this.notation(name, value);
            };
            return XMLDocumentCB;
          }();
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLAttribute': 266,
        './XMLCData': 267,
        './XMLComment': 268,
        './XMLDTDAttList': 269,
        './XMLDTDElement': 270,
        './XMLDTDEntity': 271,
        './XMLDTDNotation': 272,
        './XMLDeclaration': 273,
        './XMLDocType': 274,
        './XMLElement': 277,
        './XMLProcessingInstruction': 279,
        './XMLRaw': 280,
        './XMLStringWriter': 282,
        './XMLStringifier': 283,
        './XMLText': 284
      }
    ],
    277: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction;
          XMLNode = require('./XMLNode');
          XMLAttribute = require('./XMLAttribute');
          module.exports = XMLElement = function (superClass) {
            extend(XMLElement, superClass);
            function XMLElement(parent, name, attributes) {
              XMLElement.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error('Missing element name');
              }
              this.name = this.stringify.eleName(name);
              this.attributes = {};
              if (attributes != null) {
                this.attribute(attributes);
              }
              if (parent.isDocument) {
                this.isRoot = true;
                this.documentObject = parent;
                parent.rootObject = this;
              }
            }
            XMLElement.prototype.clone = function () {
              var att, attName, clonedSelf, ref1;
              clonedSelf = Object.create(this);
              if (clonedSelf.isRoot) {
                clonedSelf.documentObject = null;
              }
              clonedSelf.attributes = {};
              ref1 = this.attributes;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                clonedSelf.attributes[attName] = att.clone();
              }
              clonedSelf.children = [];
              this.children.forEach(function (child) {
                var clonedChild;
                clonedChild = child.clone();
                clonedChild.parent = clonedSelf;
                return clonedSelf.children.push(clonedChild);
              });
              return clonedSelf;
            };
            XMLElement.prototype.attribute = function (name, value) {
              var attName, attValue;
              if (name != null) {
                name = name.valueOf();
              }
              if (isObject(name)) {
                for (attName in name) {
                  if (!hasProp.call(name, attName))
                    continue;
                  attValue = name[attName];
                  this.attribute(attName, attValue);
                }
              } else {
                if (isFunction(value)) {
                  value = value.apply();
                }
                if (!this.options.skipNullAttributes || value != null) {
                  this.attributes[name] = new XMLAttribute(this, name, value);
                }
              }
              return this;
            };
            XMLElement.prototype.removeAttribute = function (name) {
              var attName, i, len;
              if (name == null) {
                throw new Error('Missing attribute name');
              }
              name = name.valueOf();
              if (Array.isArray(name)) {
                for (i = 0, len = name.length; i < len; i++) {
                  attName = name[i];
                  delete this.attributes[attName];
                }
              } else {
                delete this.attributes[name];
              }
              return this;
            };
            XMLElement.prototype.toString = function (options) {
              return this.options.writer.set(options).element(this);
            };
            XMLElement.prototype.att = function (name, value) {
              return this.attribute(name, value);
            };
            XMLElement.prototype.a = function (name, value) {
              return this.attribute(name, value);
            };
            return XMLElement;
          }(XMLNode);
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLAttribute': 266,
        './XMLNode': 278
      }
    ],
    278: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref, hasProp = {}.hasOwnProperty;
          ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;
          XMLElement = null;
          XMLCData = null;
          XMLComment = null;
          XMLDeclaration = null;
          XMLDocType = null;
          XMLRaw = null;
          XMLText = null;
          XMLProcessingInstruction = null;
          module.exports = XMLNode = function () {
            function XMLNode(parent) {
              this.parent = parent;
              if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
              }
              this.children = [];
              if (!XMLElement) {
                XMLElement = require('./XMLElement');
                XMLCData = require('./XMLCData');
                XMLComment = require('./XMLComment');
                XMLDeclaration = require('./XMLDeclaration');
                XMLDocType = require('./XMLDocType');
                XMLRaw = require('./XMLRaw');
                XMLText = require('./XMLText');
                XMLProcessingInstruction = require('./XMLProcessingInstruction');
              }
            }
            XMLNode.prototype.element = function (name, attributes, text) {
              var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
              lastChild = null;
              if (attributes == null) {
                attributes = {};
              }
              attributes = attributes.valueOf();
              if (!isObject(attributes)) {
                ref1 = [
                  attributes,
                  text
                ], text = ref1[0], attributes = ref1[1];
              }
              if (name != null) {
                name = name.valueOf();
              }
              if (Array.isArray(name)) {
                for (j = 0, len = name.length; j < len; j++) {
                  item = name[j];
                  lastChild = this.element(item);
                }
              } else if (isFunction(name)) {
                lastChild = this.element(name.apply());
              } else if (isObject(name)) {
                for (key in name) {
                  if (!hasProp.call(name, key))
                    continue;
                  val = name[key];
                  if (isFunction(val)) {
                    val = val.apply();
                  }
                  if (isObject(val) && isEmpty(val)) {
                    val = null;
                  }
                  if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                    lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                  } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                    for (k = 0, len1 = val.length; k < len1; k++) {
                      item = val[k];
                      childNode = {};
                      childNode[key] = item;
                      lastChild = this.element(childNode);
                    }
                  } else if (isObject(val)) {
                    lastChild = this.element(key);
                    lastChild.element(val);
                  } else {
                    lastChild = this.element(key, val);
                  }
                }
              } else {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.text(text);
                } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                  lastChild = this.cdata(text);
                } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                  lastChild = this.comment(text);
                } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                  lastChild = this.raw(text);
                } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                  lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                } else {
                  lastChild = this.node(name, attributes, text);
                }
              }
              if (lastChild == null) {
                throw new Error('Could not create any elements with: ' + name);
              }
              return lastChild;
            };
            XMLNode.prototype.insertBefore = function (name, attributes, text) {
              var child, i, removed;
              if (this.isRoot) {
                throw new Error('Cannot insert elements at root level');
              }
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              child = this.parent.element(name, attributes, text);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            };
            XMLNode.prototype.insertAfter = function (name, attributes, text) {
              var child, i, removed;
              if (this.isRoot) {
                throw new Error('Cannot insert elements at root level');
              }
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i + 1);
              child = this.parent.element(name, attributes, text);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            };
            XMLNode.prototype.remove = function () {
              var i, ref1;
              if (this.isRoot) {
                throw new Error('Cannot remove the root element');
              }
              i = this.parent.children.indexOf(this);
              [].splice.apply(this.parent.children, [
                i,
                i - i + 1
              ].concat(ref1 = [])), ref1;
              return this.parent;
            };
            XMLNode.prototype.node = function (name, attributes, text) {
              var child, ref1;
              if (name != null) {
                name = name.valueOf();
              }
              attributes || (attributes = {});
              attributes = attributes.valueOf();
              if (!isObject(attributes)) {
                ref1 = [
                  attributes,
                  text
                ], text = ref1[0], attributes = ref1[1];
              }
              child = new XMLElement(this, name, attributes);
              if (text != null) {
                child.text(text);
              }
              this.children.push(child);
              return child;
            };
            XMLNode.prototype.text = function (value) {
              var child;
              child = new XMLText(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.cdata = function (value) {
              var child;
              child = new XMLCData(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.comment = function (value) {
              var child;
              child = new XMLComment(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.commentBefore = function (value) {
              var child, i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              child = this.parent.comment(value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.commentAfter = function (value) {
              var child, i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i + 1);
              child = this.parent.comment(value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.raw = function (value) {
              var child;
              child = new XMLRaw(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.instruction = function (target, value) {
              var insTarget, insValue, instruction, j, len;
              if (target != null) {
                target = target.valueOf();
              }
              if (value != null) {
                value = value.valueOf();
              }
              if (Array.isArray(target)) {
                for (j = 0, len = target.length; j < len; j++) {
                  insTarget = target[j];
                  this.instruction(insTarget);
                }
              } else if (isObject(target)) {
                for (insTarget in target) {
                  if (!hasProp.call(target, insTarget))
                    continue;
                  insValue = target[insTarget];
                  this.instruction(insTarget, insValue);
                }
              } else {
                if (isFunction(value)) {
                  value = value.apply();
                }
                instruction = new XMLProcessingInstruction(this, target, value);
                this.children.push(instruction);
              }
              return this;
            };
            XMLNode.prototype.instructionBefore = function (target, value) {
              var child, i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              child = this.parent.instruction(target, value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.instructionAfter = function (target, value) {
              var child, i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i + 1);
              child = this.parent.instruction(target, value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.declaration = function (version, encoding, standalone) {
              var doc, xmldec;
              doc = this.document();
              xmldec = new XMLDeclaration(doc, version, encoding, standalone);
              if (doc.children[0] instanceof XMLDeclaration) {
                doc.children[0] = xmldec;
              } else {
                doc.children.unshift(xmldec);
              }
              return doc.root() || doc;
            };
            XMLNode.prototype.doctype = function (pubID, sysID) {
              var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
              doc = this.document();
              doctype = new XMLDocType(doc, pubID, sysID);
              ref1 = doc.children;
              for (i = j = 0, len = ref1.length; j < len; i = ++j) {
                child = ref1[i];
                if (child instanceof XMLDocType) {
                  doc.children[i] = doctype;
                  return doctype;
                }
              }
              ref2 = doc.children;
              for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
                child = ref2[i];
                if (child.isRoot) {
                  doc.children.splice(i, 0, doctype);
                  return doctype;
                }
              }
              doc.children.push(doctype);
              return doctype;
            };
            XMLNode.prototype.up = function () {
              if (this.isRoot) {
                throw new Error('The root node has no parent. Use doc() if you need to get the document object.');
              }
              return this.parent;
            };
            XMLNode.prototype.root = function () {
              var node;
              node = this;
              while (node) {
                if (node.isDocument) {
                  return node.rootObject;
                } else if (node.isRoot) {
                  return node;
                } else {
                  node = node.parent;
                }
              }
            };
            XMLNode.prototype.document = function () {
              var node;
              node = this;
              while (node) {
                if (node.isDocument) {
                  return node;
                } else {
                  node = node.parent;
                }
              }
            };
            XMLNode.prototype.end = function (options) {
              return this.document().end(options);
            };
            XMLNode.prototype.prev = function () {
              var i;
              i = this.parent.children.indexOf(this);
              if (i < 1) {
                throw new Error('Already at the first node');
              }
              return this.parent.children[i - 1];
            };
            XMLNode.prototype.next = function () {
              var i;
              i = this.parent.children.indexOf(this);
              if (i === -1 || i === this.parent.children.length - 1) {
                throw new Error('Already at the last node');
              }
              return this.parent.children[i + 1];
            };
            XMLNode.prototype.importDocument = function (doc) {
              var clonedRoot;
              clonedRoot = doc.root().clone();
              clonedRoot.parent = this;
              clonedRoot.isRoot = false;
              this.children.push(clonedRoot);
              return this;
            };
            XMLNode.prototype.ele = function (name, attributes, text) {
              return this.element(name, attributes, text);
            };
            XMLNode.prototype.nod = function (name, attributes, text) {
              return this.node(name, attributes, text);
            };
            XMLNode.prototype.txt = function (value) {
              return this.text(value);
            };
            XMLNode.prototype.dat = function (value) {
              return this.cdata(value);
            };
            XMLNode.prototype.com = function (value) {
              return this.comment(value);
            };
            XMLNode.prototype.ins = function (target, value) {
              return this.instruction(target, value);
            };
            XMLNode.prototype.doc = function () {
              return this.document();
            };
            XMLNode.prototype.dec = function (version, encoding, standalone) {
              return this.declaration(version, encoding, standalone);
            };
            XMLNode.prototype.dtd = function (pubID, sysID) {
              return this.doctype(pubID, sysID);
            };
            XMLNode.prototype.e = function (name, attributes, text) {
              return this.element(name, attributes, text);
            };
            XMLNode.prototype.n = function (name, attributes, text) {
              return this.node(name, attributes, text);
            };
            XMLNode.prototype.t = function (value) {
              return this.text(value);
            };
            XMLNode.prototype.d = function (value) {
              return this.cdata(value);
            };
            XMLNode.prototype.c = function (value) {
              return this.comment(value);
            };
            XMLNode.prototype.r = function (value) {
              return this.raw(value);
            };
            XMLNode.prototype.i = function (target, value) {
              return this.instruction(target, value);
            };
            XMLNode.prototype.u = function () {
              return this.up();
            };
            XMLNode.prototype.importXMLBuilder = function (doc) {
              return this.importDocument(doc);
            };
            return XMLNode;
          }();
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLCData': 267,
        './XMLComment': 268,
        './XMLDeclaration': 273,
        './XMLDocType': 274,
        './XMLElement': 277,
        './XMLProcessingInstruction': 279,
        './XMLRaw': 280,
        './XMLText': 284
      }
    ],
    279: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLNode, XMLProcessingInstruction, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLProcessingInstruction = function (superClass) {
            extend(XMLProcessingInstruction, superClass);
            function XMLProcessingInstruction(parent, target, value) {
              XMLProcessingInstruction.__super__.constructor.call(this, parent);
              if (target == null) {
                throw new Error('Missing instruction target');
              }
              this.target = this.stringify.insTarget(target);
              if (value) {
                this.value = this.stringify.insValue(value);
              }
            }
            XMLProcessingInstruction.prototype.clone = function () {
              return Object.create(this);
            };
            XMLProcessingInstruction.prototype.toString = function (options) {
              return this.options.writer.set(options).processingInstruction(this);
            };
            return XMLProcessingInstruction;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    280: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLNode, XMLRaw, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLRaw = function (superClass) {
            extend(XMLRaw, superClass);
            function XMLRaw(parent, text) {
              XMLRaw.__super__.constructor.call(this, parent);
              if (text == null) {
                throw new Error('Missing raw text');
              }
              this.value = this.stringify.raw(text);
            }
            XMLRaw.prototype.clone = function () {
              return Object.create(this);
            };
            XMLRaw.prototype.toString = function (options) {
              return this.options.writer.set(options).raw(this);
            };
            return XMLRaw;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    281: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLDeclaration = require('./XMLDeclaration');
          XMLDocType = require('./XMLDocType');
          XMLCData = require('./XMLCData');
          XMLComment = require('./XMLComment');
          XMLElement = require('./XMLElement');
          XMLRaw = require('./XMLRaw');
          XMLText = require('./XMLText');
          XMLProcessingInstruction = require('./XMLProcessingInstruction');
          XMLDTDAttList = require('./XMLDTDAttList');
          XMLDTDElement = require('./XMLDTDElement');
          XMLDTDEntity = require('./XMLDTDEntity');
          XMLDTDNotation = require('./XMLDTDNotation');
          XMLWriterBase = require('./XMLWriterBase');
          module.exports = XMLStreamWriter = function (superClass) {
            extend(XMLStreamWriter, superClass);
            function XMLStreamWriter(stream, options) {
              this.stream = stream;
              XMLStreamWriter.__super__.constructor.call(this, options);
            }
            XMLStreamWriter.prototype.document = function (doc) {
              var child, i, j, len, len1, ref, ref1, results;
              ref = doc.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                child.isLastRootNode = false;
              }
              doc.children[doc.children.length - 1].isLastRootNode = true;
              ref1 = doc.children;
              results = [];
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                child = ref1[j];
                switch (false) {
                case !(child instanceof XMLDeclaration):
                  results.push(this.declaration(child));
                  break;
                case !(child instanceof XMLDocType):
                  results.push(this.docType(child));
                  break;
                case !(child instanceof XMLComment):
                  results.push(this.comment(child));
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  results.push(this.processingInstruction(child));
                  break;
                default:
                  results.push(this.element(child));
                }
              }
              return results;
            };
            XMLStreamWriter.prototype.attribute = function (att) {
              return this.stream.write(' ' + att.name + '="' + att.value + '"');
            };
            XMLStreamWriter.prototype.cdata = function (node, level) {
              return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
            };
            XMLStreamWriter.prototype.comment = function (node, level) {
              return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
            };
            XMLStreamWriter.prototype.declaration = function (node, level) {
              this.stream.write(this.space(level));
              this.stream.write('<?xml version="' + node.version + '"');
              if (node.encoding != null) {
                this.stream.write(' encoding="' + node.encoding + '"');
              }
              if (node.standalone != null) {
                this.stream.write(' standalone="' + node.standalone + '"');
              }
              this.stream.write(this.spacebeforeslash + '?>');
              return this.stream.write(this.endline(node));
            };
            XMLStreamWriter.prototype.docType = function (node, level) {
              var child, i, len, ref;
              level || (level = 0);
              this.stream.write(this.space(level));
              this.stream.write('<!DOCTYPE ' + node.root().name);
              if (node.pubID && node.sysID) {
                this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
              } else if (node.sysID) {
                this.stream.write(' SYSTEM "' + node.sysID + '"');
              }
              if (node.children.length > 0) {
                this.stream.write(' [');
                this.stream.write(this.endline(node));
                ref = node.children;
                for (i = 0, len = ref.length; i < len; i++) {
                  child = ref[i];
                  switch (false) {
                  case !(child instanceof XMLDTDAttList):
                    this.dtdAttList(child, level + 1);
                    break;
                  case !(child instanceof XMLDTDElement):
                    this.dtdElement(child, level + 1);
                    break;
                  case !(child instanceof XMLDTDEntity):
                    this.dtdEntity(child, level + 1);
                    break;
                  case !(child instanceof XMLDTDNotation):
                    this.dtdNotation(child, level + 1);
                    break;
                  case !(child instanceof XMLCData):
                    this.cdata(child, level + 1);
                    break;
                  case !(child instanceof XMLComment):
                    this.comment(child, level + 1);
                    break;
                  case !(child instanceof XMLProcessingInstruction):
                    this.processingInstruction(child, level + 1);
                    break;
                  default:
                    throw new Error('Unknown DTD node type: ' + child.constructor.name);
                  }
                }
                this.stream.write(']');
              }
              this.stream.write(this.spacebeforeslash + '>');
              return this.stream.write(this.endline(node));
            };
            XMLStreamWriter.prototype.element = function (node, level) {
              var att, child, i, len, name, ref, ref1, space;
              level || (level = 0);
              space = this.space(level);
              this.stream.write(space + '<' + node.name);
              ref = node.attributes;
              for (name in ref) {
                if (!hasProp.call(ref, name))
                  continue;
                att = ref[name];
                this.attribute(att);
              }
              if (node.children.length === 0 || node.children.every(function (e) {
                  return e.value === '';
                })) {
                if (this.allowEmpty) {
                  this.stream.write('></' + node.name + '>');
                } else {
                  this.stream.write(this.spacebeforeslash + '/>');
                }
              } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
                this.stream.write('>');
                this.stream.write(node.children[0].value);
                this.stream.write('</' + node.name + '>');
              } else {
                this.stream.write('>' + this.newline);
                ref1 = node.children;
                for (i = 0, len = ref1.length; i < len; i++) {
                  child = ref1[i];
                  switch (false) {
                  case !(child instanceof XMLCData):
                    this.cdata(child, level + 1);
                    break;
                  case !(child instanceof XMLComment):
                    this.comment(child, level + 1);
                    break;
                  case !(child instanceof XMLElement):
                    this.element(child, level + 1);
                    break;
                  case !(child instanceof XMLRaw):
                    this.raw(child, level + 1);
                    break;
                  case !(child instanceof XMLText):
                    this.text(child, level + 1);
                    break;
                  case !(child instanceof XMLProcessingInstruction):
                    this.processingInstruction(child, level + 1);
                    break;
                  default:
                    throw new Error('Unknown XML node type: ' + child.constructor.name);
                  }
                }
                this.stream.write(space + '</' + node.name + '>');
              }
              return this.stream.write(this.endline(node));
            };
            XMLStreamWriter.prototype.processingInstruction = function (node, level) {
              this.stream.write(this.space(level) + '<?' + node.target);
              if (node.value) {
                this.stream.write(' ' + node.value);
              }
              return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
            };
            XMLStreamWriter.prototype.raw = function (node, level) {
              return this.stream.write(this.space(level) + node.value + this.endline(node));
            };
            XMLStreamWriter.prototype.text = function (node, level) {
              return this.stream.write(this.space(level) + node.value + this.endline(node));
            };
            XMLStreamWriter.prototype.dtdAttList = function (node, level) {
              this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
              if (node.defaultValueType !== '#DEFAULT') {
                this.stream.write(' ' + node.defaultValueType);
              }
              if (node.defaultValue) {
                this.stream.write(' "' + node.defaultValue + '"');
              }
              return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
            };
            XMLStreamWriter.prototype.dtdElement = function (node, level) {
              this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
              return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
            };
            XMLStreamWriter.prototype.dtdEntity = function (node, level) {
              this.stream.write(this.space(level) + '<!ENTITY');
              if (node.pe) {
                this.stream.write(' %');
              }
              this.stream.write(' ' + node.name);
              if (node.value) {
                this.stream.write(' "' + node.value + '"');
              } else {
                if (node.pubID && node.sysID) {
                  this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
                } else if (node.sysID) {
                  this.stream.write(' SYSTEM "' + node.sysID + '"');
                }
                if (node.nData) {
                  this.stream.write(' NDATA ' + node.nData);
                }
              }
              return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
            };
            XMLStreamWriter.prototype.dtdNotation = function (node, level) {
              this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
              if (node.pubID && node.sysID) {
                this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
              } else if (node.pubID) {
                this.stream.write(' PUBLIC "' + node.pubID + '"');
              } else if (node.sysID) {
                this.stream.write(' SYSTEM "' + node.sysID + '"');
              }
              return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
            };
            XMLStreamWriter.prototype.endline = function (node) {
              if (!node.isLastRootNode) {
                return this.newline;
              } else {
                return '';
              }
            };
            return XMLStreamWriter;
          }(XMLWriterBase);
        }.call(undefined));
      },
      {
        './XMLCData': 267,
        './XMLComment': 268,
        './XMLDTDAttList': 269,
        './XMLDTDElement': 270,
        './XMLDTDEntity': 271,
        './XMLDTDNotation': 272,
        './XMLDeclaration': 273,
        './XMLDocType': 274,
        './XMLElement': 277,
        './XMLProcessingInstruction': 279,
        './XMLRaw': 280,
        './XMLText': 284,
        './XMLWriterBase': 285
      }
    ],
    282: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLDeclaration = require('./XMLDeclaration');
          XMLDocType = require('./XMLDocType');
          XMLCData = require('./XMLCData');
          XMLComment = require('./XMLComment');
          XMLElement = require('./XMLElement');
          XMLRaw = require('./XMLRaw');
          XMLText = require('./XMLText');
          XMLProcessingInstruction = require('./XMLProcessingInstruction');
          XMLDTDAttList = require('./XMLDTDAttList');
          XMLDTDElement = require('./XMLDTDElement');
          XMLDTDEntity = require('./XMLDTDEntity');
          XMLDTDNotation = require('./XMLDTDNotation');
          XMLWriterBase = require('./XMLWriterBase');
          module.exports = XMLStringWriter = function (superClass) {
            extend(XMLStringWriter, superClass);
            function XMLStringWriter(options) {
              XMLStringWriter.__super__.constructor.call(this, options);
            }
            XMLStringWriter.prototype.document = function (doc) {
              var child, i, len, r, ref;
              this.textispresent = false;
              r = '';
              ref = doc.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                r += function () {
                  switch (false) {
                  case !(child instanceof XMLDeclaration):
                    return this.declaration(child);
                  case !(child instanceof XMLDocType):
                    return this.docType(child);
                  case !(child instanceof XMLComment):
                    return this.comment(child);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child);
                  default:
                    return this.element(child, 0);
                  }
                }.call(this);
              }
              if (this.pretty && r.slice(-this.newline.length) === this.newline) {
                r = r.slice(0, -this.newline.length);
              }
              return r;
            };
            XMLStringWriter.prototype.attribute = function (att) {
              return ' ' + att.name + '="' + att.value + '"';
            };
            XMLStringWriter.prototype.cdata = function (node, level) {
              return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
            };
            XMLStringWriter.prototype.comment = function (node, level) {
              return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
            };
            XMLStringWriter.prototype.declaration = function (node, level) {
              var r;
              r = this.space(level);
              r += '<?xml version="' + node.version + '"';
              if (node.encoding != null) {
                r += ' encoding="' + node.encoding + '"';
              }
              if (node.standalone != null) {
                r += ' standalone="' + node.standalone + '"';
              }
              r += this.spacebeforeslash + '?>';
              r += this.newline;
              return r;
            };
            XMLStringWriter.prototype.docType = function (node, level) {
              var child, i, len, r, ref;
              level || (level = 0);
              r = this.space(level);
              r += '<!DOCTYPE ' + node.root().name;
              if (node.pubID && node.sysID) {
                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                r += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children.length > 0) {
                r += ' [';
                r += this.newline;
                ref = node.children;
                for (i = 0, len = ref.length; i < len; i++) {
                  child = ref[i];
                  r += function () {
                    switch (false) {
                    case !(child instanceof XMLDTDAttList):
                      return this.dtdAttList(child, level + 1);
                    case !(child instanceof XMLDTDElement):
                      return this.dtdElement(child, level + 1);
                    case !(child instanceof XMLDTDEntity):
                      return this.dtdEntity(child, level + 1);
                    case !(child instanceof XMLDTDNotation):
                      return this.dtdNotation(child, level + 1);
                    case !(child instanceof XMLCData):
                      return this.cdata(child, level + 1);
                    case !(child instanceof XMLComment):
                      return this.comment(child, level + 1);
                    case !(child instanceof XMLProcessingInstruction):
                      return this.processingInstruction(child, level + 1);
                    default:
                      throw new Error('Unknown DTD node type: ' + child.constructor.name);
                    }
                  }.call(this);
                }
                r += ']';
              }
              r += this.spacebeforeslash + '>';
              r += this.newline;
              return r;
            };
            XMLStringWriter.prototype.element = function (node, level) {
              var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
              level || (level = 0);
              textispresentwasset = false;
              if (this.textispresent) {
                this.newline = '';
                this.pretty = false;
              } else {
                this.newline = this.newlinedefault;
                this.pretty = this.prettydefault;
              }
              space = this.space(level);
              r = '';
              r += space + '<' + node.name;
              ref = node.attributes;
              for (name in ref) {
                if (!hasProp.call(ref, name))
                  continue;
                att = ref[name];
                r += this.attribute(att);
              }
              if (node.children.length === 0 || node.children.every(function (e) {
                  return e.value === '';
                })) {
                if (this.allowEmpty) {
                  r += '></' + node.name + '>' + this.newline;
                } else {
                  r += this.spacebeforeslash + '/>' + this.newline;
                }
              } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
                r += '>';
                r += node.children[0].value;
                r += '</' + node.name + '>' + this.newline;
              } else {
                if (this.dontprettytextnodes) {
                  ref1 = node.children;
                  for (i = 0, len = ref1.length; i < len; i++) {
                    child = ref1[i];
                    if (child.value != null) {
                      this.textispresent++;
                      textispresentwasset = true;
                      break;
                    }
                  }
                }
                if (this.textispresent) {
                  this.newline = '';
                  this.pretty = false;
                  space = this.space(level);
                }
                r += '>' + this.newline;
                ref2 = node.children;
                for (j = 0, len1 = ref2.length; j < len1; j++) {
                  child = ref2[j];
                  r += function () {
                    switch (false) {
                    case !(child instanceof XMLCData):
                      return this.cdata(child, level + 1);
                    case !(child instanceof XMLComment):
                      return this.comment(child, level + 1);
                    case !(child instanceof XMLElement):
                      return this.element(child, level + 1);
                    case !(child instanceof XMLRaw):
                      return this.raw(child, level + 1);
                    case !(child instanceof XMLText):
                      return this.text(child, level + 1);
                    case !(child instanceof XMLProcessingInstruction):
                      return this.processingInstruction(child, level + 1);
                    default:
                      throw new Error('Unknown XML node type: ' + child.constructor.name);
                    }
                  }.call(this);
                }
                if (textispresentwasset) {
                  this.textispresent--;
                }
                if (!this.textispresent) {
                  this.newline = this.newlinedefault;
                  this.pretty = this.prettydefault;
                }
                r += space + '</' + node.name + '>' + this.newline;
              }
              return r;
            };
            XMLStringWriter.prototype.processingInstruction = function (node, level) {
              var r;
              r = this.space(level) + '<?' + node.target;
              if (node.value) {
                r += ' ' + node.value;
              }
              r += this.spacebeforeslash + '?>' + this.newline;
              return r;
            };
            XMLStringWriter.prototype.raw = function (node, level) {
              return this.space(level) + node.value + this.newline;
            };
            XMLStringWriter.prototype.text = function (node, level) {
              return this.space(level) + node.value + this.newline;
            };
            XMLStringWriter.prototype.dtdAttList = function (node, level) {
              var r;
              r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
              if (node.defaultValueType !== '#DEFAULT') {
                r += ' ' + node.defaultValueType;
              }
              if (node.defaultValue) {
                r += ' "' + node.defaultValue + '"';
              }
              r += this.spacebeforeslash + '>' + this.newline;
              return r;
            };
            XMLStringWriter.prototype.dtdElement = function (node, level) {
              return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
            };
            XMLStringWriter.prototype.dtdEntity = function (node, level) {
              var r;
              r = this.space(level) + '<!ENTITY';
              if (node.pe) {
                r += ' %';
              }
              r += ' ' + node.name;
              if (node.value) {
                r += ' "' + node.value + '"';
              } else {
                if (node.pubID && node.sysID) {
                  r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                } else if (node.sysID) {
                  r += ' SYSTEM "' + node.sysID + '"';
                }
                if (node.nData) {
                  r += ' NDATA ' + node.nData;
                }
              }
              r += this.spacebeforeslash + '>' + this.newline;
              return r;
            };
            XMLStringWriter.prototype.dtdNotation = function (node, level) {
              var r;
              r = this.space(level) + '<!NOTATION ' + node.name;
              if (node.pubID && node.sysID) {
                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.pubID) {
                r += ' PUBLIC "' + node.pubID + '"';
              } else if (node.sysID) {
                r += ' SYSTEM "' + node.sysID + '"';
              }
              r += this.spacebeforeslash + '>' + this.newline;
              return r;
            };
            XMLStringWriter.prototype.openNode = function (node, level) {
              var att, name, r, ref;
              level || (level = 0);
              if (node instanceof XMLElement) {
                r = this.space(level) + '<' + node.name;
                ref = node.attributes;
                for (name in ref) {
                  if (!hasProp.call(ref, name))
                    continue;
                  att = ref[name];
                  r += this.attribute(att);
                }
                r += (node.children ? '>' : '/>') + this.newline;
                return r;
              } else {
                r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
                if (node.pubID && node.sysID) {
                  r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                } else if (node.sysID) {
                  r += ' SYSTEM "' + node.sysID + '"';
                }
                r += (node.children ? ' [' : '>') + this.newline;
                return r;
              }
            };
            XMLStringWriter.prototype.closeNode = function (node, level) {
              level || (level = 0);
              switch (false) {
              case !(node instanceof XMLElement):
                return this.space(level) + '</' + node.name + '>' + this.newline;
              case !(node instanceof XMLDocType):
                return this.space(level) + ']>' + this.newline;
              }
            };
            return XMLStringWriter;
          }(XMLWriterBase);
        }.call(undefined));
      },
      {
        './XMLCData': 267,
        './XMLComment': 268,
        './XMLDTDAttList': 269,
        './XMLDTDElement': 270,
        './XMLDTDEntity': 271,
        './XMLDTDNotation': 272,
        './XMLDeclaration': 273,
        './XMLDocType': 274,
        './XMLElement': 277,
        './XMLProcessingInstruction': 279,
        './XMLRaw': 280,
        './XMLText': 284,
        './XMLWriterBase': 285
      }
    ],
    283: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLStringifier, bind = function bind(fn, me) {
              return function () {
                return fn.apply(me, arguments);
              };
            }, hasProp = {}.hasOwnProperty;
          module.exports = XMLStringifier = function () {
            function XMLStringifier(options) {
              this.assertLegalChar = bind(this.assertLegalChar, this);
              var key, ref, value;
              options || (options = {});
              this.noDoubleEncoding = options.noDoubleEncoding;
              ref = options.stringify || {};
              for (key in ref) {
                if (!hasProp.call(ref, key))
                  continue;
                value = ref[key];
                this[key] = value;
              }
            }
            XMLStringifier.prototype.eleName = function (val) {
              val = '' + val || '';
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.eleText = function (val) {
              val = '' + val || '';
              return this.assertLegalChar(this.elEscape(val));
            };
            XMLStringifier.prototype.cdata = function (val) {
              val = '' + val || '';
              val = val.replace(']]>', ']]]]><![CDATA[>');
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.comment = function (val) {
              val = '' + val || '';
              if (val.match(/--/)) {
                throw new Error('Comment text cannot contain double-hypen: ' + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.raw = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.attName = function (val) {
              return val = '' + val || '';
            };
            XMLStringifier.prototype.attValue = function (val) {
              val = '' + val || '';
              return this.attEscape(val);
            };
            XMLStringifier.prototype.insTarget = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.insValue = function (val) {
              val = '' + val || '';
              if (val.match(/\?>/)) {
                throw new Error('Invalid processing instruction value: ' + val);
              }
              return val;
            };
            XMLStringifier.prototype.xmlVersion = function (val) {
              val = '' + val || '';
              if (!val.match(/1\.[0-9]+/)) {
                throw new Error('Invalid version number: ' + val);
              }
              return val;
            };
            XMLStringifier.prototype.xmlEncoding = function (val) {
              val = '' + val || '';
              if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-]|-)*$/)) {
                throw new Error('Invalid encoding: ' + val);
              }
              return val;
            };
            XMLStringifier.prototype.xmlStandalone = function (val) {
              if (val) {
                return 'yes';
              } else {
                return 'no';
              }
            };
            XMLStringifier.prototype.dtdPubID = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.dtdSysID = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.dtdElementValue = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.dtdAttType = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.dtdAttDefault = function (val) {
              if (val != null) {
                return '' + val || '';
              } else {
                return val;
              }
            };
            XMLStringifier.prototype.dtdEntityValue = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.dtdNData = function (val) {
              return '' + val || '';
            };
            XMLStringifier.prototype.convertAttKey = '@';
            XMLStringifier.prototype.convertPIKey = '?';
            XMLStringifier.prototype.convertTextKey = '#text';
            XMLStringifier.prototype.convertCDataKey = '#cdata';
            XMLStringifier.prototype.convertCommentKey = '#comment';
            XMLStringifier.prototype.convertRawKey = '#raw';
            XMLStringifier.prototype.assertLegalChar = function (str) {
              var res;
              res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
              if (res) {
                throw new Error('Invalid character in string: ' + str + ' at index ' + res.index);
              }
              return str;
            };
            XMLStringifier.prototype.elEscape = function (str) {
              var ampregex;
              ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
              return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
            };
            XMLStringifier.prototype.attEscape = function (str) {
              var ampregex;
              ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
              return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
            };
            return XMLStringifier;
          }();
        }.call(undefined));
      },
      {}
    ],
    284: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLNode, XMLText, extend = function extend(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key))
                  child[key] = parent[key];
              }
              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            }, hasProp = {}.hasOwnProperty;
          XMLNode = require('./XMLNode');
          module.exports = XMLText = function (superClass) {
            extend(XMLText, superClass);
            function XMLText(parent, text) {
              XMLText.__super__.constructor.call(this, parent);
              if (text == null) {
                throw new Error('Missing element text');
              }
              this.value = this.stringify.eleText(text);
            }
            XMLText.prototype.clone = function () {
              return Object.create(this);
            };
            XMLText.prototype.toString = function (options) {
              return this.options.writer.set(options).text(this);
            };
            return XMLText;
          }(XMLNode);
        }.call(undefined));
      },
      { './XMLNode': 278 }
    ],
    285: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLWriterBase, hasProp = {}.hasOwnProperty;
          module.exports = XMLWriterBase = function () {
            function XMLWriterBase(options) {
              var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
              options || (options = {});
              this.pretty = options.pretty || false;
              this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
              if (this.pretty) {
                this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
                this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
                this.offset = (ref3 = options.offset) != null ? ref3 : 0;
                this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
              } else {
                this.indent = '';
                this.newline = '';
                this.offset = 0;
                this.dontprettytextnodes = 0;
              }
              this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
              if (this.spacebeforeslash === true) {
                this.spacebeforeslash = ' ';
              }
              this.newlinedefault = this.newline;
              this.prettydefault = this.pretty;
              ref6 = options.writer || {};
              for (key in ref6) {
                if (!hasProp.call(ref6, key))
                  continue;
                value = ref6[key];
                this[key] = value;
              }
            }
            XMLWriterBase.prototype.set = function (options) {
              var key, ref, value;
              options || (options = {});
              if ('pretty' in options) {
                this.pretty = options.pretty;
              }
              if ('allowEmpty' in options) {
                this.allowEmpty = options.allowEmpty;
              }
              if (this.pretty) {
                this.indent = 'indent' in options ? options.indent : '  ';
                this.newline = 'newline' in options ? options.newline : '\n';
                this.offset = 'offset' in options ? options.offset : 0;
                this.dontprettytextnodes = 'dontprettytextnodes' in options ? options.dontprettytextnodes : 0;
              } else {
                this.indent = '';
                this.newline = '';
                this.offset = 0;
                this.dontprettytextnodes = 0;
              }
              this.spacebeforeslash = 'spacebeforeslash' in options ? options.spacebeforeslash : '';
              if (this.spacebeforeslash === true) {
                this.spacebeforeslash = ' ';
              }
              this.newlinedefault = this.newline;
              this.prettydefault = this.pretty;
              ref = options.writer || {};
              for (key in ref) {
                if (!hasProp.call(ref, key))
                  continue;
                value = ref[key];
                this[key] = value;
              }
              return this;
            };
            XMLWriterBase.prototype.space = function (level) {
              var indent;
              if (this.pretty) {
                indent = (level || 0) + this.offset + 1;
                if (indent > 0) {
                  return new Array(indent).join(this.indent);
                } else {
                  return '';
                }
              } else {
                return '';
              }
            };
            return XMLWriterBase;
          }();
        }.call(undefined));
      },
      {}
    ],
    286: [
      function (require, module, exports) {
        'use strict';
        // Generated by CoffeeScript 1.12.6
        (function () {
          var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
          ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;
          XMLDocument = require('./XMLDocument');
          XMLDocumentCB = require('./XMLDocumentCB');
          XMLStringWriter = require('./XMLStringWriter');
          XMLStreamWriter = require('./XMLStreamWriter');
          module.exports.create = function (name, xmldec, doctype, options) {
            var doc, root;
            if (name == null) {
              throw new Error('Root element needs a name');
            }
            options = assign({}, xmldec, doctype, options);
            doc = new XMLDocument(options);
            root = doc.element(name);
            if (!options.headless) {
              doc.declaration(options);
              if (options.pubID != null || options.sysID != null) {
                doc.doctype(options);
              }
            }
            return root;
          };
          module.exports.begin = function (options, onData, onEnd) {
            var ref1;
            if (isFunction(options)) {
              ref1 = [
                options,
                onData
              ], onData = ref1[0], onEnd = ref1[1];
              options = {};
            }
            if (onData) {
              return new XMLDocumentCB(options, onData, onEnd);
            } else {
              return new XMLDocument(options);
            }
          };
          module.exports.stringWriter = function (options) {
            return new XMLStringWriter(options);
          };
          module.exports.streamWriter = function (stream, options) {
            return new XMLStreamWriter(stream, options);
          };
        }.call(undefined));
      },
      {
        './Utility': 265,
        './XMLDocument': 275,
        './XMLDocumentCB': 276,
        './XMLStreamWriter': 281,
        './XMLStringWriter': 282
      }
    ],
    287: [
      function (require, module, exports) {
        'use strict';
        module.exports = extend;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function extend() {
          var target = {};
          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      },
      {}
    ],
    288: [
      function (require, module, exports) {
        'use strict';
        module.exports = {
          INVALID_TYPE: 'Expected type {0} but found type {1}',
          INVALID_FORMAT: 'Object didn\'t pass validation for format {0}: {1}',
          ENUM_MISMATCH: 'No enum match for: {0}',
          ANY_OF_MISSING: 'Data does not match any schemas from \'anyOf\'',
          ONE_OF_MISSING: 'Data does not match any schemas from \'oneOf\'',
          ONE_OF_MULTIPLE: 'Data is valid against more than one schema from \'oneOf\'',
          NOT_PASSED: 'Data matches schema from \'not\'',
          ARRAY_LENGTH_SHORT: 'Array is too short ({0}), minimum {1}',
          ARRAY_LENGTH_LONG: 'Array is too long ({0}), maximum {1}',
          ARRAY_UNIQUE: 'Array items are not unique (indexes {0} and {1})',
          ARRAY_ADDITIONAL_ITEMS: 'Additional items not allowed',
          MULTIPLE_OF: 'Value {0} is not a multiple of {1}',
          MINIMUM: 'Value {0} is less than minimum {1}',
          MINIMUM_EXCLUSIVE: 'Value {0} is equal or less than exclusive minimum {1}',
          MAXIMUM: 'Value {0} is greater than maximum {1}',
          MAXIMUM_EXCLUSIVE: 'Value {0} is equal or greater than exclusive maximum {1}',
          OBJECT_PROPERTIES_MINIMUM: 'Too few properties defined ({0}), minimum {1}',
          OBJECT_PROPERTIES_MAXIMUM: 'Too many properties defined ({0}), maximum {1}',
          OBJECT_MISSING_REQUIRED_PROPERTY: 'Missing required property: {0}',
          OBJECT_ADDITIONAL_PROPERTIES: 'Additional properties not allowed: {0}',
          OBJECT_DEPENDENCY_KEY: 'Dependency failed - key must exist: {0} (due to key: {1})',
          MIN_LENGTH: 'String is too short ({0} chars), minimum {1}',
          MAX_LENGTH: 'String is too long ({0} chars), maximum {1}',
          PATTERN: 'String does not match pattern {0}: {1}',
          KEYWORD_TYPE_EXPECTED: 'Keyword \'{0}\' is expected to be of type \'{1}\'',
          KEYWORD_UNDEFINED_STRICT: 'Keyword \'{0}\' must be defined in strict mode',
          KEYWORD_UNEXPECTED: 'Keyword \'{0}\' is not expected to appear in the schema',
          KEYWORD_MUST_BE: 'Keyword \'{0}\' must be {1}',
          KEYWORD_DEPENDENCY: 'Keyword \'{0}\' requires keyword \'{1}\'',
          KEYWORD_PATTERN: 'Keyword \'{0}\' is not a valid RegExp pattern: {1}',
          KEYWORD_VALUE_TYPE: 'Each element of keyword \'{0}\' array must be a \'{1}\'',
          UNKNOWN_FORMAT: 'There is no validation function for format \'{0}\'',
          CUSTOM_MODE_FORCE_PROPERTIES: '{0} must define at least one property if present',
          REF_UNRESOLVED: 'Reference has not been resolved during compilation: {0}',
          UNRESOLVABLE_REFERENCE: 'Reference could not be resolved: {0}',
          SCHEMA_NOT_REACHABLE: 'Validator was not able to read schema with uri: {0}',
          SCHEMA_TYPE_EXPECTED: 'Schema is expected to be of type \'object\'',
          SCHEMA_NOT_AN_OBJECT: 'Schema is not an object: {0}',
          ASYNC_TIMEOUT: '{0} asynchronous task(s) have timed out after {1} ms',
          PARENT_SCHEMA_VALIDATION_FAILED: 'Schema failed to validate against its parent schema, see inner errors for details.',
          REMOTE_NOT_VALID: 'Remote reference didn\'t compile successfully: {0}'
        };
      },
      {}
    ],
    289: [
      function (require, module, exports) {
        'use strict';
        /*jshint maxlen: false*/
        var validator = require('validator');
        var FormatValidators = {
            'date': function date(_date) {
              if (typeof _date !== 'string') {
                return true;
              }
              // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
              var matches = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(_date);
              if (matches === null) {
                return false;
              }
              // var year = matches[1];
              // var month = matches[2];
              // var day = matches[3];
              if (matches[2] < '01' || matches[2] > '12' || matches[3] < '01' || matches[3] > '31') {
                return false;
              }
              return true;
            },
            'date-time': function dateTime(_dateTime) {
              if (typeof _dateTime !== 'string') {
                return true;
              }
              // date-time from http://tools.ietf.org/html/rfc3339#section-5.6
              var s = _dateTime.toLowerCase().split('t');
              if (!FormatValidators.date(s[0])) {
                return false;
              }
              var matches = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(s[1]);
              if (matches === null) {
                return false;
              }
              // var hour = matches[1];
              // var minute = matches[2];
              // var second = matches[3];
              // var fraction = matches[4];
              // var timezone = matches[5];
              if (matches[1] > '23' || matches[2] > '59' || matches[3] > '59') {
                return false;
              }
              return true;
            },
            'email': function email(_email) {
              if (typeof _email !== 'string') {
                return true;
              }
              return validator.isEmail(_email, { 'require_tld': true });
            },
            'hostname': function hostname(_hostname) {
              if (typeof _hostname !== 'string') {
                return true;
              }
              /*
            http://json-schema.org/latest/json-schema-validation.html#anchor114
            A string instance is valid against this attribute if it is a valid
            representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].
             http://tools.ietf.org/html/rfc1034#section-3.5
             <digit> ::= any one of the ten digits 0 through 9
            var digit = /[0-9]/;
             <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
            var letter = /[a-zA-Z]/;
             <let-dig> ::= <letter> | <digit>
            var letDig = /[0-9a-zA-Z]/;
             <let-dig-hyp> ::= <let-dig> | "-"
            var letDigHyp = /[-0-9a-zA-Z]/;
             <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
            var ldhStr = /[-0-9a-zA-Z]+/;
             <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
            var label = /[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?/;
             <subdomain> ::= <label> | <subdomain> "." <label>
            var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;
             <domain> ::= <subdomain> | " "
            var domain = null;
        */
              var valid = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(_hostname);
              if (valid) {
                // the sum of all label octets and label lengths is limited to 255.
                if (_hostname.length > 255) {
                  return false;
                }
                // Each node has a label, which is zero to 63 octets in length
                var labels = _hostname.split('.');
                for (var i = 0; i < labels.length; i++) {
                  if (labels[i].length > 63) {
                    return false;
                  }
                }
              }
              return valid;
            },
            'host-name': function hostName(hostname) {
              return FormatValidators.hostname.call(this, hostname);
            },
            'ipv4': function ipv4(_ipv) {
              if (typeof _ipv !== 'string') {
                return true;
              }
              return validator.isIP(_ipv, 4);
            },
            'ipv6': function ipv6(_ipv2) {
              if (typeof _ipv2 !== 'string') {
                return true;
              }
              return validator.isIP(_ipv2, 6);
            },
            'regex': function regex(str) {
              try {
                RegExp(str);
                return true;
              } catch (e) {
                return false;
              }
            },
            'uri': function uri(_uri) {
              if (this.options.strictUris) {
                return FormatValidators['strict-uri'].apply(this, arguments);
              }
              // https://github.com/zaggino/z-schema/issues/18
              // RegExp from http://tools.ietf.org/html/rfc3986#appendix-B
              return typeof _uri !== 'string' || RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?').test(_uri);
            },
            'strict-uri': function strictUri(uri) {
              return typeof uri !== 'string' || validator.isURL(uri);
            }
          };
        module.exports = FormatValidators;
      },
      { 'validator': 188 }
    ],
    290: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var FormatValidators = require('./FormatValidators'), Report = require('./Report'), Utils = require('./Utils');
        var JsonValidators = {
            multipleOf: function multipleOf(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2
              if (typeof json !== 'number') {
                return;
              }
              if (Utils.whatIs(json / schema.multipleOf) !== 'integer') {
                report.addError('MULTIPLE_OF', [
                  json,
                  schema.multipleOf
                ], null, schema.description);
              }
            },
            maximum: function maximum(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2
              if (typeof json !== 'number') {
                return;
              }
              if (schema.exclusiveMaximum !== true) {
                if (json > schema.maximum) {
                  report.addError('MAXIMUM', [
                    json,
                    schema.maximum
                  ], null, schema.description);
                }
              } else {
                if (json >= schema.maximum) {
                  report.addError('MAXIMUM_EXCLUSIVE', [
                    json,
                    schema.maximum
                  ], null, schema.description);
                }
              }
            },
            exclusiveMaximum: function exclusiveMaximum() {
            },
            minimum: function minimum(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2
              if (typeof json !== 'number') {
                return;
              }
              if (schema.exclusiveMinimum !== true) {
                if (json < schema.minimum) {
                  report.addError('MINIMUM', [
                    json,
                    schema.minimum
                  ], null, schema.description);
                }
              } else {
                if (json <= schema.minimum) {
                  report.addError('MINIMUM_EXCLUSIVE', [
                    json,
                    schema.minimum
                  ], null, schema.description);
                }
              }
            },
            exclusiveMinimum: function exclusiveMinimum() {
            },
            maxLength: function maxLength(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2
              if (typeof json !== 'string') {
                return;
              }
              if (Utils.ucs2decode(json).length > schema.maxLength) {
                report.addError('MAX_LENGTH', [
                  json.length,
                  schema.maxLength
                ], null, schema.description);
              }
            },
            minLength: function minLength(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2
              if (typeof json !== 'string') {
                return;
              }
              if (Utils.ucs2decode(json).length < schema.minLength) {
                report.addError('MIN_LENGTH', [
                  json.length,
                  schema.minLength
                ], null, schema.description);
              }
            },
            pattern: function pattern(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2
              if (typeof json !== 'string') {
                return;
              }
              if (RegExp(schema.pattern).test(json) === false) {
                report.addError('PATTERN', [
                  schema.pattern,
                  json
                ], null, schema.description);
              }
            },
            additionalItems: function additionalItems(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2
              if (!Array.isArray(json)) {
                return;
              }
              // if the value of "additionalItems" is boolean value false and the value of "items" is an array,
              // the json is valid if its size is less than, or equal to, the size of "items".
              if (schema.additionalItems === false && Array.isArray(schema.items)) {
                if (json.length > schema.items.length) {
                  report.addError('ARRAY_ADDITIONAL_ITEMS', null, null, schema.description);
                }
              }
            },
            items: function items() {
            },
            maxItems: function maxItems(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2
              if (!Array.isArray(json)) {
                return;
              }
              if (json.length > schema.maxItems) {
                report.addError('ARRAY_LENGTH_LONG', [
                  json.length,
                  schema.maxItems
                ], null, schema.description);
              }
            },
            minItems: function minItems(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2
              if (!Array.isArray(json)) {
                return;
              }
              if (json.length < schema.minItems) {
                report.addError('ARRAY_LENGTH_SHORT', [
                  json.length,
                  schema.minItems
                ], null, schema.description);
              }
            },
            uniqueItems: function uniqueItems(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2
              if (!Array.isArray(json)) {
                return;
              }
              if (schema.uniqueItems === true) {
                var matches = [];
                if (Utils.isUniqueArray(json, matches) === false) {
                  report.addError('ARRAY_UNIQUE', matches, null, schema.description);
                }
              }
            },
            maxProperties: function maxProperties(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var keysCount = Object.keys(json).length;
              if (keysCount > schema.maxProperties) {
                report.addError('OBJECT_PROPERTIES_MAXIMUM', [
                  keysCount,
                  schema.maxProperties
                ], null, schema.description);
              }
            },
            minProperties: function minProperties(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var keysCount = Object.keys(json).length;
              if (keysCount < schema.minProperties) {
                report.addError('OBJECT_PROPERTIES_MINIMUM', [
                  keysCount,
                  schema.minProperties
                ], null, schema.description);
              }
            },
            required: function required(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var idx = schema.required.length;
              while (idx--) {
                var requiredPropertyName = schema.required[idx];
                if (json[requiredPropertyName] === undefined) {
                  report.addError('OBJECT_MISSING_REQUIRED_PROPERTY', [requiredPropertyName], null, schema.description);
                }
              }
            },
            additionalProperties: function additionalProperties(report, schema, json) {
              // covered in properties and patternProperties
              if (schema.properties === undefined && schema.patternProperties === undefined) {
                return JsonValidators.properties.call(this, report, schema, json);
              }
            },
            patternProperties: function patternProperties(report, schema, json) {
              // covered in properties
              if (schema.properties === undefined) {
                return JsonValidators.properties.call(this, report, schema, json);
              }
            },
            properties: function properties(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var properties = schema.properties !== undefined ? schema.properties : {};
              var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};
              if (schema.additionalProperties === false) {
                // The property set of the json to validate.
                var s = Object.keys(json);
                // The property set from "properties".
                var p = Object.keys(properties);
                // The property set from "patternProperties".
                var pp = Object.keys(patternProperties);
                // remove from "s" all elements of "p", if any;
                s = Utils.difference(s, p);
                // for each regex in "pp", remove all elements of "s" which this regex matches.
                var idx = pp.length;
                while (idx--) {
                  var regExp = RegExp(pp[idx]), idx2 = s.length;
                  while (idx2--) {
                    if (regExp.test(s[idx2]) === true) {
                      s.splice(idx2, 1);
                    }
                  }
                }
                // Validation of the json succeeds if, after these two steps, set "s" is empty.
                if (s.length > 0) {
                  // assumeAdditional can be an array of allowed properties
                  var idx3 = this.options.assumeAdditional.length;
                  if (idx3) {
                    while (idx3--) {
                      var io = s.indexOf(this.options.assumeAdditional[idx3]);
                      if (io !== -1) {
                        s.splice(io, 1);
                      }
                    }
                  }
                  if (s.length > 0) {
                    report.addError('OBJECT_ADDITIONAL_PROPERTIES', [s], null, schema.description);
                  }
                }
              }
            },
            dependencies: function dependencies(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2
              if (Utils.whatIs(json) !== 'object') {
                return;
              }
              var keys = Object.keys(schema.dependencies), idx = keys.length;
              while (idx--) {
                // iterate all dependencies
                var dependencyName = keys[idx];
                if (json[dependencyName]) {
                  var dependencyDefinition = schema.dependencies[dependencyName];
                  if (Utils.whatIs(dependencyDefinition) === 'object') {
                    // if dependency is a schema, validate against this schema
                    exports.validate.call(this, report, dependencyDefinition, json);
                  } else {
                    // Array
                    // if dependency is an array, object needs to have all properties in this array
                    var idx2 = dependencyDefinition.length;
                    while (idx2--) {
                      var requiredPropertyName = dependencyDefinition[idx2];
                      if (json[requiredPropertyName] === undefined) {
                        report.addError('OBJECT_DEPENDENCY_KEY', [
                          requiredPropertyName,
                          dependencyName
                        ], null, schema.description);
                      }
                    }
                  }
                }
              }
            },
            enum: function _enum(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2
              var match = false, idx = schema.enum.length;
              while (idx--) {
                if (Utils.areEqual(json, schema.enum[idx])) {
                  match = true;
                  break;
                }
              }
              if (match === false) {
                report.addError('ENUM_MISMATCH', [json], null, schema.description);
              }
            },
            allOf: function allOf(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2
              var idx = schema.allOf.length;
              while (idx--) {
                var validateResult = exports.validate.call(this, report, schema.allOf[idx], json);
                if (this.options.breakOnFirstError && validateResult === false) {
                  break;
                }
              }
            },
            anyOf: function anyOf(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2
              var subReports = [], passed = false, idx = schema.anyOf.length;
              while (idx-- && passed === false) {
                var subReport = new Report(report);
                subReports.push(subReport);
                passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);
              }
              if (passed === false) {
                report.addError('ANY_OF_MISSING', undefined, subReports, schema.description);
              }
            },
            oneOf: function oneOf(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2
              var passes = 0, subReports = [], idx = schema.oneOf.length;
              while (idx--) {
                var subReport = new Report(report, { maxErrors: 1 });
                subReports.push(subReport);
                if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {
                  passes++;
                }
              }
              if (passes === 0) {
                report.addError('ONE_OF_MISSING', undefined, subReports, schema.description);
              } else if (passes > 1) {
                report.addError('ONE_OF_MULTIPLE', null, null, schema.description);
              }
            },
            not: function not(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2
              var subReport = new Report(report);
              if (exports.validate.call(this, subReport, schema.not, json) === true) {
                report.addError('NOT_PASSED', null, null, schema.description);
              }
            },
            definitions: function definitions() {
            },
            format: function format(report, schema, json) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2
              var formatValidatorFn = FormatValidators[schema.format];
              if (typeof formatValidatorFn === 'function') {
                if (formatValidatorFn.length === 2) {
                  // async
                  report.addAsyncTask(formatValidatorFn, [json], function (result) {
                    if (result !== true) {
                      report.addError('INVALID_FORMAT', [
                        schema.format,
                        json
                      ], null, schema.description);
                    }
                  });
                } else {
                  // sync
                  if (formatValidatorFn.call(this, json) !== true) {
                    report.addError('INVALID_FORMAT', [
                      schema.format,
                      json
                    ], null, schema.description);
                  }
                }
              } else if (this.options.ignoreUnknownFormats !== true) {
                report.addError('UNKNOWN_FORMAT', [schema.format], null, schema.description);
              }
            }
          };
        var recurseArray = function recurseArray(report, schema, json) {
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2
          var idx = json.length;
          // If "items" is an array, this situation, the schema depends on the index:
          // if the index is less than, or equal to, the size of "items",
          // the child instance must be valid against the corresponding schema in the "items" array;
          // otherwise, it must be valid against the schema defined by "additionalItems".
          if (Array.isArray(schema.items)) {
            while (idx--) {
              // equal to doesnt make sense here
              if (idx < schema.items.length) {
                report.path.push(idx.toString());
                exports.validate.call(this, report, schema.items[idx], json[idx]);
                report.path.pop();
              } else {
                // might be boolean, so check that it's an object
                if (_typeof(schema.additionalItems) === 'object') {
                  report.path.push(idx.toString());
                  exports.validate.call(this, report, schema.additionalItems, json[idx]);
                  report.path.pop();
                }
              }
            }
          } else if (_typeof(schema.items) === 'object') {
            // If items is a schema, then the child instance must be valid against this schema,
            // regardless of its index, and regardless of the value of "additionalItems".
            while (idx--) {
              report.path.push(idx.toString());
              exports.validate.call(this, report, schema.items, json[idx]);
              report.path.pop();
            }
          }
        };
        var recurseObject = function recurseObject(report, schema, json) {
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3
          // If "additionalProperties" is absent, it is considered present with an empty schema as a value.
          // In addition, boolean value true is considered equivalent to an empty schema.
          var additionalProperties = schema.additionalProperties;
          if (additionalProperties === true || additionalProperties === undefined) {
            additionalProperties = {};
          }
          // p - The property set from "properties".
          var p = schema.properties ? Object.keys(schema.properties) : [];
          // pp - The property set from "patternProperties". Elements of this set will be called regexes for convenience.
          var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];
          // m - The property name of the child.
          var keys = Object.keys(json), idx = keys.length;
          while (idx--) {
            var m = keys[idx], propertyValue = json[m];
            // s - The set of schemas for the child instance.
            var s = [];
            // 1. If set "p" contains value "m", then the corresponding schema in "properties" is added to "s".
            if (p.indexOf(m) !== -1) {
              s.push(schema.properties[m]);
            }
            // 2. For each regex in "pp", if it matches "m" successfully, the corresponding schema in "patternProperties" is added to "s".
            var idx2 = pp.length;
            while (idx2--) {
              var regexString = pp[idx2];
              if (RegExp(regexString).test(m) === true) {
                s.push(schema.patternProperties[regexString]);
              }
            }
            // 3. The schema defined by "additionalProperties" is added to "s" if and only if, at this stage, "s" is empty.
            if (s.length === 0 && additionalProperties !== false) {
              s.push(additionalProperties);
            }
            // we are passing tests even without this assert because this is covered by properties check
            // if s is empty in this stage, no additionalProperties are allowed
            // report.expect(s.length !== 0, 'E001', m);
            // Instance property value must pass all schemas from s
            idx2 = s.length;
            while (idx2--) {
              report.path.push(m);
              exports.validate.call(this, report, s[idx2], propertyValue);
              report.path.pop();
            }
          }
        };
        exports.validate = function (report, schema, json) {
          report.commonErrorMessage = 'JSON_OBJECT_VALIDATION_FAILED';
          // check if schema is an object
          var to = Utils.whatIs(schema);
          if (to !== 'object') {
            report.addError('SCHEMA_NOT_AN_OBJECT', [to], null, schema.description);
            return false;
          }
          // check if schema is empty, everything is valid against empty schema
          var keys = Object.keys(schema);
          if (keys.length === 0) {
            return true;
          }
          // this method can be called recursively, so we need to remember our root
          var isRoot = false;
          if (!report.rootSchema) {
            report.rootSchema = schema;
            isRoot = true;
          }
          // follow schema.$ref keys
          if (schema.$ref !== undefined) {
            // avoid infinite loop with maxRefs
            var maxRefs = 99;
            while (schema.$ref && maxRefs > 0) {
              if (!schema.__$refResolved) {
                report.addError('REF_UNRESOLVED', [schema.$ref], null, schema.description);
                break;
              } else if (schema.__$refResolved === schema) {
                break;
              } else {
                schema = schema.__$refResolved;
                keys = Object.keys(schema);
              }
              maxRefs--;
            }
            if (maxRefs === 0) {
              throw new Error('Circular dependency by $ref references!');
            }
          }
          // type checking first
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
          var jsonType = Utils.whatIs(json);
          if (schema.type) {
            if (typeof schema.type === 'string') {
              if (jsonType !== schema.type && (jsonType !== 'integer' || schema.type !== 'number')) {
                report.addError('INVALID_TYPE', [
                  schema.type,
                  jsonType
                ], null, schema.description);
                if (this.options.breakOnFirstError) {
                  return false;
                }
              }
            } else {
              if (schema.type.indexOf(jsonType) === -1 && (jsonType !== 'integer' || schema.type.indexOf('number') === -1)) {
                report.addError('INVALID_TYPE', [
                  schema.type,
                  jsonType
                ], null, schema.description);
                if (this.options.breakOnFirstError) {
                  return false;
                }
              }
            }
          }
          // now iterate all the keys in schema and execute validation methods
          var idx = keys.length;
          while (idx--) {
            if (JsonValidators[keys[idx]]) {
              JsonValidators[keys[idx]].call(this, report, schema, json);
              if (report.errors.length && this.options.breakOnFirstError) {
                break;
              }
            }
          }
          if (report.errors.length === 0 || this.options.breakOnFirstError === false) {
            if (jsonType === 'array') {
              recurseArray.call(this, report, schema, json);
            } else if (jsonType === 'object') {
              recurseObject.call(this, report, schema, json);
            }
          }
          if (typeof this.options.customValidator === 'function') {
            this.options.customValidator(report, schema, json);
          }
          // we don't need the root pointer anymore
          if (isRoot) {
            report.rootSchema = undefined;
          }
          // return valid just to be able to break at some code points
          return report.errors.length === 0;
        };
      },
      {
        './FormatValidators': 289,
        './Report': 292,
        './Utils': 296
      }
    ],
    291: [
      function (require, module, exports) {
        'use strict';
        // Number.isFinite polyfill
        // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite
        if (typeof Number.isFinite !== 'function') {
          Number.isFinite = function isFinite(value) {
            // 1. If Type(number) is not Number, return false.
            if (typeof value !== 'number') {
              return false;
            }
            // 2. If number is NaN, +∞, or −∞, return false.
            if (value !== value || value === Infinity || value === -Infinity) {
              return false;
            }
            // 3. Otherwise, return true.
            return true;
          };
        }
      },
      {}
    ],
    292: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          var get = require('lodash.get');
          var Errors = require('./Errors');
          var Utils = require('./Utils');
          function Report(parentOrOptions, reportOptions) {
            this.parentReport = parentOrOptions instanceof Report ? parentOrOptions : undefined;
            this.options = parentOrOptions instanceof Report ? parentOrOptions.options : parentOrOptions || {};
            this.reportOptions = reportOptions || {};
            this.errors = [];
            this.path = [];
            this.asyncTasks = [];
          }
          Report.prototype.isValid = function () {
            if (this.asyncTasks.length > 0) {
              throw new Error('Async tasks pending, can\'t answer isValid');
            }
            return this.errors.length === 0;
          };
          Report.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {
            this.asyncTasks.push([
              fn,
              args,
              asyncTaskResultProcessFn
            ]);
          };
          Report.prototype.processAsyncTasks = function (timeout, callback) {
            var validationTimeout = timeout || 2000, tasksCount = this.asyncTasks.length, idx = tasksCount, timedOut = false, self = this;
            function finish() {
              process.nextTick(function () {
                var valid = self.errors.length === 0, err = valid ? undefined : self.errors;
                callback(err, valid);
              });
            }
            function respond(asyncTaskResultProcessFn) {
              return function (asyncTaskResult) {
                if (timedOut) {
                  return;
                }
                asyncTaskResultProcessFn(asyncTaskResult);
                if (--tasksCount === 0) {
                  finish();
                }
              };
            }
            if (tasksCount === 0 || this.errors.length > 0) {
              finish();
              return;
            }
            while (idx--) {
              var task = this.asyncTasks[idx];
              task[0].apply(null, task[1].concat(respond(task[2])));
            }
            setTimeout(function () {
              if (tasksCount > 0) {
                timedOut = true;
                self.addError('ASYNC_TIMEOUT', [
                  tasksCount,
                  validationTimeout
                ]);
                callback(self.errors, false);
              }
            }, validationTimeout);
          };
          Report.prototype.getPath = function (returnPathAsString) {
            var path = [];
            if (this.parentReport) {
              path = path.concat(this.parentReport.path);
            }
            path = path.concat(this.path);
            if (returnPathAsString !== true) {
              // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)
              path = '#/' + path.map(function (segment) {
                if (Utils.isAbsoluteUri(segment)) {
                  return 'uri(' + segment + ')';
                }
                return segment.replace(/\~/g, '~0').replace(/\//g, '~1');
              }).join('/');
            }
            return path;
          };
          Report.prototype.getSchemaId = function () {
            if (!this.rootSchema) {
              return null;
            }
            // get the error path as an array
            var path = [];
            if (this.parentReport) {
              path = path.concat(this.parentReport.path);
            }
            path = path.concat(this.path);
            // try to find id in the error path
            while (path.length > 0) {
              var obj = get(this.rootSchema, path);
              if (obj && obj.id) {
                return obj.id;
              }
              path.pop();
            }
            // return id of the root
            return this.rootSchema.id;
          };
          Report.prototype.hasError = function (errorCode, params) {
            var idx = this.errors.length;
            while (idx--) {
              if (this.errors[idx].code === errorCode) {
                // assume match
                var match = true;
                // check the params too
                var idx2 = this.errors[idx].params.length;
                while (idx2--) {
                  if (this.errors[idx].params[idx2] !== params[idx2]) {
                    match = false;
                  }
                }
                // if match, return true
                if (match) {
                  return match;
                }
              }
            }
            return false;
          };
          Report.prototype.addError = function (errorCode, params, subReports, schemaDescription) {
            if (!errorCode) {
              throw new Error('No errorCode passed into addError()');
            }
            this.addCustomError(errorCode, Errors[errorCode], params, subReports, schemaDescription);
          };
          Report.prototype.addCustomError = function (errorCode, errorMessage, params, subReports, schemaDescription) {
            if (this.errors.length >= this.reportOptions.maxErrors) {
              return;
            }
            if (!errorMessage) {
              throw new Error('No errorMessage known for code ' + errorCode);
            }
            params = params || [];
            var idx = params.length;
            while (idx--) {
              var whatIs = Utils.whatIs(params[idx]);
              var param = whatIs === 'object' || whatIs === 'null' ? JSON.stringify(params[idx]) : params[idx];
              errorMessage = errorMessage.replace('{' + idx + '}', param);
            }
            var err = {
                code: errorCode,
                params: params,
                message: errorMessage,
                path: this.getPath(this.options.reportPathAsArray),
                schemaId: this.getSchemaId()
              };
            if (schemaDescription) {
              err.description = schemaDescription;
            }
            if (subReports != null) {
              if (!Array.isArray(subReports)) {
                subReports = [subReports];
              }
              err.inner = [];
              idx = subReports.length;
              while (idx--) {
                var subReport = subReports[idx], idx2 = subReport.errors.length;
                while (idx2--) {
                  err.inner.push(subReport.errors[idx2]);
                }
              }
              if (err.inner.length === 0) {
                err.inner = undefined;
              }
            }
            this.errors.push(err);
          };
          module.exports = Report;
        }.call(this, require('_process')));
      },
      {
        './Errors': 288,
        './Utils': 296,
        '_process': 145,
        'lodash.get': 77
      }
    ],
    293: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var isequal = require('lodash.isequal');
        var Report = require('./Report');
        var SchemaCompilation = require('./SchemaCompilation');
        var SchemaValidation = require('./SchemaValidation');
        var Utils = require('./Utils');
        function decodeJSONPointer(str) {
          // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3
          return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {
            return x === '~1' ? '/' : '~';
          });
        }
        function getRemotePath(uri) {
          var io = uri.indexOf('#');
          return io === -1 ? uri : uri.slice(0, io);
        }
        function getQueryPath(uri) {
          var io = uri.indexOf('#');
          var res = io === -1 ? undefined : uri.slice(io + 1);
          // WARN: do not slice slash, #/ means take root and go down from it
          // if (res && res[0] === "/") { res = res.slice(1); }
          return res;
        }
        function findId(schema, id) {
          // process only arrays and objects
          if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) !== 'object' || schema === null) {
            return;
          }
          // no id means root so return itself
          if (!id) {
            return schema;
          }
          if (schema.id) {
            if (schema.id === id || schema.id[0] === '#' && schema.id.substring(1) === id) {
              return schema;
            }
          }
          var idx, result;
          if (Array.isArray(schema)) {
            idx = schema.length;
            while (idx--) {
              result = findId(schema[idx], id);
              if (result) {
                return result;
              }
            }
          } else {
            var keys = Object.keys(schema);
            idx = keys.length;
            while (idx--) {
              var k = keys[idx];
              if (k.indexOf('__$') === 0) {
                continue;
              }
              result = findId(schema[k], id);
              if (result) {
                return result;
              }
            }
          }
        }
        exports.cacheSchemaByUri = function (uri, schema) {
          var remotePath = getRemotePath(uri);
          if (remotePath) {
            this.cache[remotePath] = schema;
          }
        };
        exports.removeFromCacheByUri = function (uri) {
          var remotePath = getRemotePath(uri);
          if (remotePath) {
            delete this.cache[remotePath];
          }
        };
        exports.checkCacheForUri = function (uri) {
          var remotePath = getRemotePath(uri);
          return remotePath ? this.cache[remotePath] != null : false;
        };
        exports.getSchema = function (report, schema) {
          if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object') {
            schema = exports.getSchemaByReference.call(this, report, schema);
          }
          if (typeof schema === 'string') {
            schema = exports.getSchemaByUri.call(this, report, schema);
          }
          return schema;
        };
        exports.getSchemaByReference = function (report, key) {
          var i = this.referenceCache.length;
          while (i--) {
            if (isequal(this.referenceCache[i][0], key)) {
              return this.referenceCache[i][1];
            }
          }
          // not found
          var schema = Utils.cloneDeep(key);
          this.referenceCache.push([
            key,
            schema
          ]);
          return schema;
        };
        exports.getSchemaByUri = function (report, uri, root) {
          var remotePath = getRemotePath(uri), queryPath = getQueryPath(uri), result = remotePath ? this.cache[remotePath] : root;
          if (result && remotePath) {
            // we need to avoid compiling schemas in a recursive loop
            var compileRemote = result !== root;
            // now we need to compile and validate resolved schema (in case it's not already)
            if (compileRemote) {
              report.path.push(remotePath);
              var remoteReport = new Report(report);
              if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {
                var savedOptions = this.options;
                try {
                  // If custom validationOptions were provided to setRemoteReference(),
                  // use them instead of the default options
                  this.options = result.__$validationOptions || this.options;
                  SchemaValidation.validateSchema.call(this, remoteReport, result);
                } finally {
                  this.options = savedOptions;
                }
              }
              var remoteReportIsValid = remoteReport.isValid();
              if (!remoteReportIsValid) {
                report.addError('REMOTE_NOT_VALID', [uri], remoteReport);
              }
              report.path.pop();
              if (!remoteReportIsValid) {
                return undefined;
              }
            }
          }
          if (result && queryPath) {
            var parts = queryPath.split('/');
            for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {
              var key = decodeJSONPointer(parts[idx]);
              if (idx === 0) {
                // it's an id
                result = findId(result, key);
              } else {
                // it's a path behind id
                result = result[key];
              }
            }
          }
          return result;
        };
        exports.getRemotePath = getRemotePath;
      },
      {
        './Report': 292,
        './SchemaCompilation': 294,
        './SchemaValidation': 295,
        './Utils': 296,
        'lodash.isequal': 78
      }
    ],
    294: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        var Report = require('./Report');
        var SchemaCache = require('./SchemaCache');
        var Utils = require('./Utils');
        function mergeReference(scope, ref) {
          if (Utils.isAbsoluteUri(ref)) {
            return ref;
          }
          var joinedScope = scope.join(''), isScopeAbsolute = Utils.isAbsoluteUri(joinedScope), isScopeRelative = Utils.isRelativeUri(joinedScope), isRefRelative = Utils.isRelativeUri(ref), toRemove;
          if (isScopeAbsolute && isRefRelative) {
            toRemove = joinedScope.match(/\/[^\/]*$/);
            if (toRemove) {
              joinedScope = joinedScope.slice(0, toRemove.index + 1);
            }
          } else if (isScopeRelative && isRefRelative) {
            joinedScope = '';
          } else {
            toRemove = joinedScope.match(/[^#\/]+$/);
            if (toRemove) {
              joinedScope = joinedScope.slice(0, toRemove.index);
            }
          }
          var res = joinedScope + ref;
          res = res.replace(/##/, '#');
          return res;
        }
        function collectReferences(obj, results, scope, path) {
          results = results || [];
          scope = scope || [];
          path = path || [];
          if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
            return results;
          }
          if (typeof obj.id === 'string') {
            scope.push(obj.id);
          }
          if (typeof obj.$ref === 'string' && typeof obj.__$refResolved === 'undefined') {
            results.push({
              ref: mergeReference(scope, obj.$ref),
              key: '$ref',
              obj: obj,
              path: path.slice(0)
            });
          }
          if (typeof obj.$schema === 'string' && typeof obj.__$schemaResolved === 'undefined') {
            results.push({
              ref: mergeReference(scope, obj.$schema),
              key: '$schema',
              obj: obj,
              path: path.slice(0)
            });
          }
          var idx;
          if (Array.isArray(obj)) {
            idx = obj.length;
            while (idx--) {
              path.push(idx.toString());
              collectReferences(obj[idx], results, scope, path);
              path.pop();
            }
          } else {
            var keys = Object.keys(obj);
            idx = keys.length;
            while (idx--) {
              // do not recurse through resolved references and other z-schema props
              if (keys[idx].indexOf('__$') === 0) {
                continue;
              }
              path.push(keys[idx]);
              collectReferences(obj[keys[idx]], results, scope, path);
              path.pop();
            }
          }
          if (typeof obj.id === 'string') {
            scope.pop();
          }
          return results;
        }
        var compileArrayOfSchemasLoop = function compileArrayOfSchemasLoop(mainReport, arr) {
          var idx = arr.length, compiledCount = 0;
          while (idx--) {
            // try to compile each schema separately
            var report = new Report(mainReport);
            var isValid = exports.compileSchema.call(this, report, arr[idx]);
            if (isValid) {
              compiledCount++;
            }
            // copy errors to report
            mainReport.errors = mainReport.errors.concat(report.errors);
          }
          return compiledCount;
        };
        function findId(arr, id) {
          var idx = arr.length;
          while (idx--) {
            if (arr[idx].id === id) {
              return arr[idx];
            }
          }
          return null;
        }
        var compileArrayOfSchemas = function compileArrayOfSchemas(report, arr) {
          var compiled = 0, lastLoopCompiled;
          do {
            // remove all UNRESOLVABLE_REFERENCE errors before compiling array again
            var idx = report.errors.length;
            while (idx--) {
              if (report.errors[idx].code === 'UNRESOLVABLE_REFERENCE') {
                report.errors.splice(idx, 1);
              }
            }
            // remember how many were compiled in the last loop
            lastLoopCompiled = compiled;
            // count how many are compiled now
            compiled = compileArrayOfSchemasLoop.call(this, report, arr);
            // fix __$missingReferences if possible
            idx = arr.length;
            while (idx--) {
              var sch = arr[idx];
              if (sch.__$missingReferences) {
                var idx2 = sch.__$missingReferences.length;
                while (idx2--) {
                  var refObj = sch.__$missingReferences[idx2];
                  var response = findId(arr, refObj.ref);
                  if (response) {
                    // this might create circular references
                    refObj.obj['__' + refObj.key + 'Resolved'] = response;
                    // it's resolved now so delete it
                    sch.__$missingReferences.splice(idx2, 1);
                  }
                }
                if (sch.__$missingReferences.length === 0) {
                  delete sch.__$missingReferences;
                }
              }
            }  // keep repeating if not all compiled and at least one more was compiled in the last loop
          } while (compiled !== arr.length && compiled !== lastLoopCompiled);
          return report.isValid();
        };
        exports.compileSchema = function (report, schema) {
          report.commonErrorMessage = 'SCHEMA_COMPILATION_FAILED';
          // if schema is a string, assume it's a uri
          if (typeof schema === 'string') {
            var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);
            if (!loadedSchema) {
              report.addError('SCHEMA_NOT_REACHABLE', [schema]);
              return false;
            }
            schema = loadedSchema;
          }
          // if schema is an array, assume it's an array of schemas
          if (Array.isArray(schema)) {
            return compileArrayOfSchemas.call(this, report, schema);
          }
          // if we have an id than it should be cached already (if this instance has compiled it)
          if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {
            schema.__$compiled = undefined;
          }
          // do not re-compile schemas
          if (schema.__$compiled) {
            return true;
          }
          if (schema.id && typeof schema.id === 'string') {
            // add this to our schemaCache (before compilation in case we have references including id)
            SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);
          }
          // this method can be called recursively, so we need to remember our root
          var isRoot = false;
          if (!report.rootSchema) {
            report.rootSchema = schema;
            isRoot = true;
          }
          // delete all __$missingReferences from previous compilation attempts
          var isValidExceptReferences = report.isValid();
          delete schema.__$missingReferences;
          // collect all references that need to be resolved - $ref and $schema
          var refs = collectReferences.call(this, schema), idx = refs.length;
          while (idx--) {
            // resolve all the collected references into __xxxResolved pointer
            var refObj = refs[idx];
            var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
            // we can try to use custom schemaReader if available
            if (!response) {
              var schemaReader = this.getSchemaReader();
              if (schemaReader) {
                // it's supposed to return a valid schema
                var s = schemaReader(refObj.ref);
                if (s) {
                  // it needs to have the id
                  s.id = refObj.ref;
                  // try to compile the schema
                  var subreport = new Report(report);
                  if (!exports.compileSchema.call(this, subreport, s)) {
                    // copy errors to report
                    report.errors = report.errors.concat(subreport.errors);
                  } else {
                    response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
                  }
                }
              }
            }
            if (!response) {
              var hasNotValid = report.hasError('REMOTE_NOT_VALID', [refObj.ref]);
              var isAbsolute = Utils.isAbsoluteUri(refObj.ref);
              var isDownloaded = false;
              var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;
              if (isAbsolute) {
                // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded
                // and set through setRemoteReference method
                isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);
              }
              if (hasNotValid) {
              } else if (ignoreUnresolvableRemotes && isAbsolute) {
              } else if (isDownloaded) {
              } else {
                Array.prototype.push.apply(report.path, refObj.path);
                report.addError('UNRESOLVABLE_REFERENCE', [refObj.ref]);
                report.path = report.path.slice(0, -refObj.path.length);
                // pusblish unresolved references out
                if (isValidExceptReferences) {
                  schema.__$missingReferences = schema.__$missingReferences || [];
                  schema.__$missingReferences.push(refObj);
                }
              }
            }
            // this might create circular references
            refObj.obj['__' + refObj.key + 'Resolved'] = response;
          }
          var isValid = report.isValid();
          if (isValid) {
            schema.__$compiled = true;
          } else {
            if (schema.id && typeof schema.id === 'string') {
              // remove this schema from schemaCache because it failed to compile
              SchemaCache.removeFromCacheByUri.call(this, schema.id);
            }
          }
          // we don't need the root pointer anymore
          if (isRoot) {
            report.rootSchema = undefined;
          }
          return isValid;
        };
      },
      {
        './Report': 292,
        './SchemaCache': 293,
        './Utils': 296
      }
    ],
    295: [
      function (require, module, exports) {
        'use strict';
        var FormatValidators = require('./FormatValidators'), JsonValidation = require('./JsonValidation'), Report = require('./Report'), Utils = require('./Utils');
        var SchemaValidators = {
            $ref: function $ref(report, schema) {
              // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07
              // http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03
              if (typeof schema.$ref !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  '$ref',
                  'string'
                ]);
              }
            },
            $schema: function $schema(report, schema) {
              // http://json-schema.org/latest/json-schema-core.html#rfc.section.6
              if (typeof schema.$schema !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  '$schema',
                  'string'
                ]);
              }
            },
            multipleOf: function multipleOf(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.1
              if (typeof schema.multipleOf !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'multipleOf',
                  'number'
                ]);
              } else if (schema.multipleOf <= 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'multipleOf',
                  'strictly greater than 0'
                ]);
              }
            },
            maximum: function maximum(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
              if (typeof schema.maximum !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maximum',
                  'number'
                ]);
              }
            },
            exclusiveMaximum: function exclusiveMaximum(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
              if (typeof schema.exclusiveMaximum !== 'boolean') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'exclusiveMaximum',
                  'boolean'
                ]);
              } else if (schema.maximum === undefined) {
                report.addError('KEYWORD_DEPENDENCY', [
                  'exclusiveMaximum',
                  'maximum'
                ]);
              }
            },
            minimum: function minimum(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
              if (typeof schema.minimum !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minimum',
                  'number'
                ]);
              }
            },
            exclusiveMinimum: function exclusiveMinimum(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
              if (typeof schema.exclusiveMinimum !== 'boolean') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'exclusiveMinimum',
                  'boolean'
                ]);
              } else if (schema.minimum === undefined) {
                report.addError('KEYWORD_DEPENDENCY', [
                  'exclusiveMinimum',
                  'minimum'
                ]);
              }
            },
            maxLength: function maxLength(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.1
              if (Utils.whatIs(schema.maxLength) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maxLength',
                  'integer'
                ]);
              } else if (schema.maxLength < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'maxLength',
                  'greater than, or equal to 0'
                ]);
              }
            },
            minLength: function minLength(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.1
              if (Utils.whatIs(schema.minLength) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minLength',
                  'integer'
                ]);
              } else if (schema.minLength < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'minLength',
                  'greater than, or equal to 0'
                ]);
              }
            },
            pattern: function pattern(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.1
              if (typeof schema.pattern !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'pattern',
                  'string'
                ]);
              } else {
                try {
                  RegExp(schema.pattern);
                } catch (e) {
                  report.addError('KEYWORD_PATTERN', [
                    'pattern',
                    schema.pattern
                  ]);
                }
              }
            },
            additionalItems: function additionalItems(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
              var type = Utils.whatIs(schema.additionalItems);
              if (type !== 'boolean' && type !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'additionalItems',
                  [
                    'boolean',
                    'object'
                  ]
                ]);
              } else if (type === 'object') {
                report.path.push('additionalItems');
                exports.validateSchema.call(this, report, schema.additionalItems);
                report.path.pop();
              }
            },
            items: function items(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
              var type = Utils.whatIs(schema.items);
              if (type === 'object') {
                report.path.push('items');
                exports.validateSchema.call(this, report, schema.items);
                report.path.pop();
              } else if (type === 'array') {
                var idx = schema.items.length;
                while (idx--) {
                  report.path.push('items');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.items[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              } else {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'items',
                  [
                    'array',
                    'object'
                  ]
                ]);
              }
              // custom - strict mode
              if (this.options.forceAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {
                report.addError('KEYWORD_UNDEFINED_STRICT', ['additionalItems']);
              }
              // custome - assume defined false mode
              if (this.options.assumeAdditional && schema.additionalItems === undefined && Array.isArray(schema.items)) {
                schema.additionalItems = false;
              }
            },
            maxItems: function maxItems(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.1
              if (typeof schema.maxItems !== 'number') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maxItems',
                  'integer'
                ]);
              } else if (schema.maxItems < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'maxItems',
                  'greater than, or equal to 0'
                ]);
              }
            },
            minItems: function minItems(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.1
              if (Utils.whatIs(schema.minItems) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minItems',
                  'integer'
                ]);
              } else if (schema.minItems < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'minItems',
                  'greater than, or equal to 0'
                ]);
              }
            },
            uniqueItems: function uniqueItems(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.1
              if (typeof schema.uniqueItems !== 'boolean') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'uniqueItems',
                  'boolean'
                ]);
              }
            },
            maxProperties: function maxProperties(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.1
              if (Utils.whatIs(schema.maxProperties) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'maxProperties',
                  'integer'
                ]);
              } else if (schema.maxProperties < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'maxProperties',
                  'greater than, or equal to 0'
                ]);
              }
            },
            minProperties: function minProperties(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.1
              if (Utils.whatIs(schema.minProperties) !== 'integer') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'minProperties',
                  'integer'
                ]);
              } else if (schema.minProperties < 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'minProperties',
                  'greater than, or equal to 0'
                ]);
              }
            },
            required: function required(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.1
              if (Utils.whatIs(schema.required) !== 'array') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'required',
                  'array'
                ]);
              } else if (schema.required.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'required',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.required.length;
                while (idx--) {
                  if (typeof schema.required[idx] !== 'string') {
                    report.addError('KEYWORD_VALUE_TYPE', [
                      'required',
                      'string'
                    ]);
                  }
                }
                if (Utils.isUniqueArray(schema.required) === false) {
                  report.addError('KEYWORD_MUST_BE', [
                    'required',
                    'an array with unique items'
                  ]);
                }
              }
            },
            additionalProperties: function additionalProperties(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
              var type = Utils.whatIs(schema.additionalProperties);
              if (type !== 'boolean' && type !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'additionalProperties',
                  [
                    'boolean',
                    'object'
                  ]
                ]);
              } else if (type === 'object') {
                report.path.push('additionalProperties');
                exports.validateSchema.call(this, report, schema.additionalProperties);
                report.path.pop();
              }
            },
            properties: function properties(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
              if (Utils.whatIs(schema.properties) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'properties',
                  'object'
                ]);
                return;
              }
              var keys = Object.keys(schema.properties), idx = keys.length;
              while (idx--) {
                var key = keys[idx], val = schema.properties[key];
                report.path.push('properties');
                report.path.push(key);
                exports.validateSchema.call(this, report, val);
                report.path.pop();
                report.path.pop();
              }
              // custom - strict mode
              if (this.options.forceAdditional === true && schema.additionalProperties === undefined) {
                report.addError('KEYWORD_UNDEFINED_STRICT', ['additionalProperties']);
              }
              // custome - assume defined false mode
              if (this.options.assumeAdditional && schema.additionalProperties === undefined) {
                schema.additionalProperties = false;
              }
              // custom - forceProperties
              if (this.options.forceProperties === true && keys.length === 0) {
                report.addError('CUSTOM_MODE_FORCE_PROPERTIES', ['properties']);
              }
            },
            patternProperties: function patternProperties(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
              if (Utils.whatIs(schema.patternProperties) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'patternProperties',
                  'object'
                ]);
                return;
              }
              var keys = Object.keys(schema.patternProperties), idx = keys.length;
              while (idx--) {
                var key = keys[idx], val = schema.patternProperties[key];
                try {
                  RegExp(key);
                } catch (e) {
                  report.addError('KEYWORD_PATTERN', [
                    'patternProperties',
                    key
                  ]);
                }
                report.path.push('patternProperties');
                report.path.push(key.toString());
                exports.validateSchema.call(this, report, val);
                report.path.pop();
                report.path.pop();
              }
              // custom - forceProperties
              if (this.options.forceProperties === true && keys.length === 0) {
                report.addError('CUSTOM_MODE_FORCE_PROPERTIES', ['patternProperties']);
              }
            },
            dependencies: function dependencies(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.1
              if (Utils.whatIs(schema.dependencies) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'dependencies',
                  'object'
                ]);
              } else {
                var keys = Object.keys(schema.dependencies), idx = keys.length;
                while (idx--) {
                  var schemaKey = keys[idx], schemaDependency = schema.dependencies[schemaKey], type = Utils.whatIs(schemaDependency);
                  if (type === 'object') {
                    report.path.push('dependencies');
                    report.path.push(schemaKey);
                    exports.validateSchema.call(this, report, schemaDependency);
                    report.path.pop();
                    report.path.pop();
                  } else if (type === 'array') {
                    var idx2 = schemaDependency.length;
                    if (idx2 === 0) {
                      report.addError('KEYWORD_MUST_BE', [
                        'dependencies',
                        'not empty array'
                      ]);
                    }
                    while (idx2--) {
                      if (typeof schemaDependency[idx2] !== 'string') {
                        report.addError('KEYWORD_VALUE_TYPE', [
                          'dependensices',
                          'string'
                        ]);
                      }
                    }
                    if (Utils.isUniqueArray(schemaDependency) === false) {
                      report.addError('KEYWORD_MUST_BE', [
                        'dependencies',
                        'an array with unique items'
                      ]);
                    }
                  } else {
                    report.addError('KEYWORD_VALUE_TYPE', [
                      'dependencies',
                      'object or array'
                    ]);
                  }
                }
              }
            },
            enum: function _enum(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.1
              if (Array.isArray(schema.enum) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'enum',
                  'array'
                ]);
              } else if (schema.enum.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'enum',
                  'an array with at least one element'
                ]);
              } else if (Utils.isUniqueArray(schema.enum) === false) {
                report.addError('KEYWORD_MUST_BE', [
                  'enum',
                  'an array with unique elements'
                ]);
              }
            },
            type: function type(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.1
              var primitiveTypes = [
                  'array',
                  'boolean',
                  'integer',
                  'number',
                  'null',
                  'object',
                  'string'
                ], primitiveTypeStr = primitiveTypes.join(','), isArray = Array.isArray(schema.type);
              if (isArray) {
                var idx = schema.type.length;
                while (idx--) {
                  if (primitiveTypes.indexOf(schema.type[idx]) === -1) {
                    report.addError('KEYWORD_TYPE_EXPECTED', [
                      'type',
                      primitiveTypeStr
                    ]);
                  }
                }
                if (Utils.isUniqueArray(schema.type) === false) {
                  report.addError('KEYWORD_MUST_BE', [
                    'type',
                    'an object with unique properties'
                  ]);
                }
              } else if (typeof schema.type === 'string') {
                if (primitiveTypes.indexOf(schema.type) === -1) {
                  report.addError('KEYWORD_TYPE_EXPECTED', [
                    'type',
                    primitiveTypeStr
                  ]);
                }
              } else {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'type',
                  [
                    'string',
                    'array'
                  ]
                ]);
              }
              if (this.options.noEmptyStrings === true) {
                if (schema.type === 'string' || isArray && schema.type.indexOf('string') !== -1) {
                  if (schema.minLength === undefined && schema.enum === undefined && schema.format === undefined) {
                    schema.minLength = 1;
                  }
                }
              }
              if (this.options.noEmptyArrays === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.minItems === undefined) {
                    schema.minItems = 1;
                  }
                }
              }
              if (this.options.forceProperties === true) {
                if (schema.type === 'object' || isArray && schema.type.indexOf('object') !== -1) {
                  if (schema.properties === undefined && schema.patternProperties === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['properties']);
                  }
                }
              }
              if (this.options.forceItems === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.items === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['items']);
                  }
                }
              }
              if (this.options.forceMinItems === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.minItems === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['minItems']);
                  }
                }
              }
              if (this.options.forceMaxItems === true) {
                if (schema.type === 'array' || isArray && schema.type.indexOf('array') !== -1) {
                  if (schema.maxItems === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['maxItems']);
                  }
                }
              }
              if (this.options.forceMinLength === true) {
                if (schema.type === 'string' || isArray && schema.type.indexOf('string') !== -1) {
                  if (schema.minLength === undefined && schema.format === undefined && schema.enum === undefined && schema.pattern === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['minLength']);
                  }
                }
              }
              if (this.options.forceMaxLength === true) {
                if (schema.type === 'string' || isArray && schema.type.indexOf('string') !== -1) {
                  if (schema.maxLength === undefined && schema.format === undefined && schema.enum === undefined && schema.pattern === undefined) {
                    report.addError('KEYWORD_UNDEFINED_STRICT', ['maxLength']);
                  }
                }
              }
            },
            allOf: function allOf(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.1
              if (Array.isArray(schema.allOf) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'allOf',
                  'array'
                ]);
              } else if (schema.allOf.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'allOf',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.allOf.length;
                while (idx--) {
                  report.path.push('allOf');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.allOf[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            anyOf: function anyOf(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.1
              if (Array.isArray(schema.anyOf) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'anyOf',
                  'array'
                ]);
              } else if (schema.anyOf.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'anyOf',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.anyOf.length;
                while (idx--) {
                  report.path.push('anyOf');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.anyOf[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            oneOf: function oneOf(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.1
              if (Array.isArray(schema.oneOf) === false) {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'oneOf',
                  'array'
                ]);
              } else if (schema.oneOf.length === 0) {
                report.addError('KEYWORD_MUST_BE', [
                  'oneOf',
                  'an array with at least one element'
                ]);
              } else {
                var idx = schema.oneOf.length;
                while (idx--) {
                  report.path.push('oneOf');
                  report.path.push(idx.toString());
                  exports.validateSchema.call(this, report, schema.oneOf[idx]);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            not: function not(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.1
              if (Utils.whatIs(schema.not) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'not',
                  'object'
                ]);
              } else {
                report.path.push('not');
                exports.validateSchema.call(this, report, schema.not);
                report.path.pop();
              }
            },
            definitions: function definitions(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.1
              if (Utils.whatIs(schema.definitions) !== 'object') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'definitions',
                  'object'
                ]);
              } else {
                var keys = Object.keys(schema.definitions), idx = keys.length;
                while (idx--) {
                  var key = keys[idx], val = schema.definitions[key];
                  report.path.push('definitions');
                  report.path.push(key);
                  exports.validateSchema.call(this, report, val);
                  report.path.pop();
                  report.path.pop();
                }
              }
            },
            format: function format(report, schema) {
              if (typeof schema.format !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'format',
                  'string'
                ]);
              } else {
                if (FormatValidators[schema.format] === undefined && this.options.ignoreUnknownFormats !== true) {
                  report.addError('UNKNOWN_FORMAT', [schema.format]);
                }
              }
            },
            id: function id(report, schema) {
              // http://json-schema.org/latest/json-schema-core.html#rfc.section.7.2
              if (typeof schema.id !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'id',
                  'string'
                ]);
              }
            },
            title: function title(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
              if (typeof schema.title !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'title',
                  'string'
                ]);
              }
            },
            description: function description(report, schema) {
              // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
              if (typeof schema.description !== 'string') {
                report.addError('KEYWORD_TYPE_EXPECTED', [
                  'description',
                  'string'
                ]);
              }
            },
            'default': function _default()
              /* report, schema */
              {
              }
          };
        var validateArrayOfSchemas = function validateArrayOfSchemas(report, arr) {
          var idx = arr.length;
          while (idx--) {
            exports.validateSchema.call(this, report, arr[idx]);
          }
          return report.isValid();
        };
        exports.validateSchema = function (report, schema) {
          report.commonErrorMessage = 'SCHEMA_VALIDATION_FAILED';
          // if schema is an array, assume it's an array of schemas
          if (Array.isArray(schema)) {
            return validateArrayOfSchemas.call(this, report, schema);
          }
          // do not revalidate schema that has already been validated once
          if (schema.__$validated) {
            return true;
          }
          // if $schema is present, this schema should validate against that $schema
          var hasParentSchema = schema.$schema && schema.id !== schema.$schema;
          if (hasParentSchema) {
            if (schema.__$schemaResolved && schema.__$schemaResolved !== schema) {
              var subReport = new Report(report);
              var valid = JsonValidation.validate.call(this, subReport, schema.__$schemaResolved, schema);
              if (valid === false) {
                report.addError('PARENT_SCHEMA_VALIDATION_FAILED', null, subReport);
              }
            } else {
              if (this.options.ignoreUnresolvableReferences !== true) {
                report.addError('REF_UNRESOLVED', [schema.$schema]);
              }
            }
          }
          if (this.options.noTypeless === true) {
            // issue #36 - inherit type to anyOf, oneOf, allOf if noTypeless is defined
            if (schema.type !== undefined) {
              var schemas = [];
              if (Array.isArray(schema.anyOf)) {
                schemas = schemas.concat(schema.anyOf);
              }
              if (Array.isArray(schema.oneOf)) {
                schemas = schemas.concat(schema.oneOf);
              }
              if (Array.isArray(schema.allOf)) {
                schemas = schemas.concat(schema.allOf);
              }
              schemas.forEach(function (sch) {
                if (!sch.type) {
                  sch.type = schema.type;
                }
              });
            }
            // end issue #36
            if (schema.enum === undefined && schema.type === undefined && schema.anyOf === undefined && schema.oneOf === undefined && schema.not === undefined && schema.$ref === undefined) {
              report.addError('KEYWORD_UNDEFINED_STRICT', ['type']);
            }
          }
          var keys = Object.keys(schema), idx = keys.length;
          while (idx--) {
            var key = keys[idx];
            if (key.indexOf('__') === 0) {
              continue;
            }
            if (SchemaValidators[key] !== undefined) {
              SchemaValidators[key].call(this, report, schema);
            } else if (!hasParentSchema) {
              if (this.options.noExtraKeywords === true) {
                report.addError('KEYWORD_UNEXPECTED', [key]);
              }
            }
          }
          if (this.options.pedanticCheck === true) {
            if (schema.enum) {
              // break recursion
              var tmpSchema = Utils.clone(schema);
              delete tmpSchema.enum;
              delete tmpSchema.default;
              report.path.push('enum');
              idx = schema.enum.length;
              while (idx--) {
                report.path.push(idx.toString());
                JsonValidation.validate.call(this, report, tmpSchema, schema.enum[idx]);
                report.path.pop();
              }
              report.path.pop();
            }
            if (schema.default) {
              report.path.push('default');
              JsonValidation.validate.call(this, report, schema, schema.default);
              report.path.pop();
            }
          }
          var isValid = report.isValid();
          if (isValid) {
            schema.__$validated = true;
          }
          return isValid;
        };
      },
      {
        './FormatValidators': 289,
        './JsonValidation': 290,
        './Report': 292,
        './Utils': 296
      }
    ],
    296: [
      function (require, module, exports) {
        'use strict';
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
          };
        exports.isAbsoluteUri = function (uri) {
          return /^https?:\/\//.test(uri);
        };
        exports.isRelativeUri = function (uri) {
          // relative URIs that end with a hash sign, issue #56
          return /.+#/.test(uri);
        };
        exports.whatIs = function (what) {
          var to = typeof what === 'undefined' ? 'undefined' : _typeof(what);
          if (to === 'object') {
            if (what === null) {
              return 'null';
            }
            if (Array.isArray(what)) {
              return 'array';
            }
            return 'object';  // typeof what === 'object' && what === Object(what) && !Array.isArray(what);
          }
          if (to === 'number') {
            if (Number.isFinite(what)) {
              if (what % 1 === 0) {
                return 'integer';
              } else {
                return 'number';
              }
            }
            if (Number.isNaN(what)) {
              return 'not-a-number';
            }
            return 'unknown-number';
          }
          return to;  // undefined, boolean, string, function
        };
        exports.areEqual = function areEqual(json1, json2) {
          // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6
          // Two JSON values are said to be equal if and only if:
          // both are nulls; or
          // both are booleans, and have the same value; or
          // both are strings, and have the same value; or
          // both are numbers, and have the same mathematical value; or
          if (json1 === json2) {
            return true;
          }
          var i, len;
          // both are arrays, and:
          if (Array.isArray(json1) && Array.isArray(json2)) {
            // have the same number of items; and
            if (json1.length !== json2.length) {
              return false;
            }
            // items at the same index are equal according to this definition; or
            len = json1.length;
            for (i = 0; i < len; i++) {
              if (!areEqual(json1[i], json2[i])) {
                return false;
              }
            }
            return true;
          }
          // both are objects, and:
          if (exports.whatIs(json1) === 'object' && exports.whatIs(json2) === 'object') {
            // have the same set of property names; and
            var keys1 = Object.keys(json1);
            var keys2 = Object.keys(json2);
            if (!areEqual(keys1, keys2)) {
              return false;
            }
            // values for a same property name are equal according to this definition.
            len = keys1.length;
            for (i = 0; i < len; i++) {
              if (!areEqual(json1[keys1[i]], json2[keys1[i]])) {
                return false;
              }
            }
            return true;
          }
          return false;
        };
        exports.isUniqueArray = function (arr, indexes) {
          var i, j, l = arr.length;
          for (i = 0; i < l; i++) {
            for (j = i + 1; j < l; j++) {
              if (exports.areEqual(arr[i], arr[j])) {
                if (indexes) {
                  indexes.push(i, j);
                }
                return false;
              }
            }
          }
          return true;
        };
        exports.difference = function (bigSet, subSet) {
          var arr = [], idx = bigSet.length;
          while (idx--) {
            if (subSet.indexOf(bigSet[idx]) === -1) {
              arr.push(bigSet[idx]);
            }
          }
          return arr;
        };
        // NOT a deep version of clone
        exports.clone = function (src) {
          if (typeof src === 'undefined') {
            return void 0;
          }
          if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) !== 'object' || src === null) {
            return src;
          }
          var res, idx;
          if (Array.isArray(src)) {
            res = [];
            idx = src.length;
            while (idx--) {
              res[idx] = src[idx];
            }
          } else {
            res = {};
            var keys = Object.keys(src);
            idx = keys.length;
            while (idx--) {
              var key = keys[idx];
              res[key] = src[key];
            }
          }
          return res;
        };
        exports.cloneDeep = function (src) {
          var visited = [], cloned = [];
          function cloneDeep(src) {
            if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) !== 'object' || src === null) {
              return src;
            }
            var res, idx, cidx;
            cidx = visited.indexOf(src);
            if (cidx !== -1) {
              return cloned[cidx];
            }
            visited.push(src);
            if (Array.isArray(src)) {
              res = [];
              cloned.push(res);
              idx = src.length;
              while (idx--) {
                res[idx] = cloneDeep(src[idx]);
              }
            } else {
              res = {};
              cloned.push(res);
              var keys = Object.keys(src);
              idx = keys.length;
              while (idx--) {
                var key = keys[idx];
                res[key] = cloneDeep(src[key]);
              }
            }
            return res;
          }
          return cloneDeep(src);
        };
        /*
  following function comes from punycode.js library
  see: https://github.com/bestiejs/punycode.js
*/
        /*jshint -W016*/
        /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
        exports.ucs2decode = function (string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              // high surrogate, and there is a next character
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                // low surrogate
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        };  /*jshint +W016*/
      },
      {}
    ],
    297: [
      function (require, module, exports) {
        (function (process) {
          'use strict';
          var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
            };
          require('./Polyfills');
          var get = require('lodash.get');
          var Report = require('./Report');
          var FormatValidators = require('./FormatValidators');
          var JsonValidation = require('./JsonValidation');
          var SchemaCache = require('./SchemaCache');
          var SchemaCompilation = require('./SchemaCompilation');
          var SchemaValidation = require('./SchemaValidation');
          var Utils = require('./Utils');
          var Draft4Schema = require('./schemas/schema.json');
          var Draft4HyperSchema = require('./schemas/hyper-schema.json');
          /*
    default options
*/
          var defaultOptions = {
              asyncTimeout: 2000,
              forceAdditional: false,
              assumeAdditional: false,
              forceItems: false,
              forceMinItems: false,
              forceMaxItems: false,
              forceMinLength: false,
              forceMaxLength: false,
              forceProperties: false,
              ignoreUnresolvableReferences: false,
              noExtraKeywords: false,
              noTypeless: false,
              noEmptyStrings: false,
              noEmptyArrays: false,
              strictUris: false,
              strictMode: false,
              reportPathAsArray: false,
              breakOnFirstError: true,
              pedanticCheck: false,
              ignoreUnknownFormats: false,
              customValidator: null
            };
          function normalizeOptions(options) {
            var normalized;
            // options
            if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
              var keys = Object.keys(options), idx = keys.length, key;
              // check that the options are correctly configured
              while (idx--) {
                key = keys[idx];
                if (defaultOptions[key] === undefined) {
                  throw new Error('Unexpected option passed to constructor: ' + key);
                }
              }
              // copy the default options into passed options
              keys = Object.keys(defaultOptions);
              idx = keys.length;
              while (idx--) {
                key = keys[idx];
                if (options[key] === undefined) {
                  options[key] = Utils.clone(defaultOptions[key]);
                }
              }
              normalized = options;
            } else {
              normalized = Utils.clone(defaultOptions);
            }
            if (normalized.strictMode === true) {
              normalized.forceAdditional = true;
              normalized.forceItems = true;
              normalized.forceMaxLength = true;
              normalized.forceProperties = true;
              normalized.noExtraKeywords = true;
              normalized.noTypeless = true;
              normalized.noEmptyStrings = true;
              normalized.noEmptyArrays = true;
            }
            return normalized;
          }
          /*
    constructor
*/
          function ZSchema(options) {
            this.cache = {};
            this.referenceCache = [];
            this.options = normalizeOptions(options);
            // Disable strict validation for the built-in schemas
            var metaschemaOptions = normalizeOptions({});
            this.setRemoteReference('http://json-schema.org/draft-04/schema', Draft4Schema, metaschemaOptions);
            this.setRemoteReference('http://json-schema.org/draft-04/hyper-schema', Draft4HyperSchema, metaschemaOptions);
          }
          /*
    instance methods
*/
          ZSchema.prototype.compileSchema = function (schema) {
            var report = new Report(this.options);
            schema = SchemaCache.getSchema.call(this, report, schema);
            SchemaCompilation.compileSchema.call(this, report, schema);
            this.lastReport = report;
            return report.isValid();
          };
          ZSchema.prototype.validateSchema = function (schema) {
            if (Array.isArray(schema) && schema.length === 0) {
              throw new Error('.validateSchema was called with an empty array');
            }
            var report = new Report(this.options);
            schema = SchemaCache.getSchema.call(this, report, schema);
            var compiled = SchemaCompilation.compileSchema.call(this, report, schema);
            if (compiled) {
              SchemaValidation.validateSchema.call(this, report, schema);
            }
            this.lastReport = report;
            return report.isValid();
          };
          ZSchema.prototype.validate = function (json, schema, options, callback) {
            if (Utils.whatIs(options) === 'function') {
              callback = options;
              options = {};
            }
            if (!options) {
              options = {};
            }
            var whatIs = Utils.whatIs(schema);
            if (whatIs !== 'string' && whatIs !== 'object') {
              var e = new Error('Invalid .validate call - schema must be an string or object but ' + whatIs + ' was passed!');
              if (callback) {
                process.nextTick(function () {
                  callback(e, false);
                });
                return;
              }
              throw e;
            }
            var foundError = false;
            var report = new Report(this.options);
            if (typeof schema === 'string') {
              var schemaName = schema;
              schema = SchemaCache.getSchema.call(this, report, schemaName);
              if (!schema) {
                throw new Error('Schema with id \'' + schemaName + '\' wasn\'t found in the validator cache!');
              }
            } else {
              schema = SchemaCache.getSchema.call(this, report, schema);
            }
            var compiled = false;
            if (!foundError) {
              compiled = SchemaCompilation.compileSchema.call(this, report, schema);
            }
            if (!compiled) {
              this.lastReport = report;
              foundError = true;
            }
            var validated = false;
            if (!foundError) {
              validated = SchemaValidation.validateSchema.call(this, report, schema);
            }
            if (!validated) {
              this.lastReport = report;
              foundError = true;
            }
            if (options.schemaPath) {
              report.rootSchema = schema;
              schema = get(schema, options.schemaPath);
              if (!schema) {
                throw new Error('Schema path \'' + options.schemaPath + '\' wasn\'t found in the schema!');
              }
            }
            if (!foundError) {
              JsonValidation.validate.call(this, report, schema, json);
            }
            if (callback) {
              report.processAsyncTasks(this.options.asyncTimeout, callback);
              return;
            } else if (report.asyncTasks.length > 0) {
              throw new Error('This validation has async tasks and cannot be done in sync mode, please provide callback argument.');
            }
            // assign lastReport so errors are retrievable in sync mode
            this.lastReport = report;
            return report.isValid();
          };
          ZSchema.prototype.getLastError = function () {
            if (this.lastReport.errors.length === 0) {
              return null;
            }
            var e = new Error();
            e.name = 'z-schema validation error';
            e.message = this.lastReport.commonErrorMessage;
            e.details = this.lastReport.errors;
            return e;
          };
          ZSchema.prototype.getLastErrors = function () {
            return this.lastReport && this.lastReport.errors.length > 0 ? this.lastReport.errors : undefined;
          };
          ZSchema.prototype.getMissingReferences = function (arr) {
            arr = arr || this.lastReport.errors;
            var res = [], idx = arr.length;
            while (idx--) {
              var error = arr[idx];
              if (error.code === 'UNRESOLVABLE_REFERENCE') {
                var reference = error.params[0];
                if (res.indexOf(reference) === -1) {
                  res.push(reference);
                }
              }
              if (error.inner) {
                res = res.concat(this.getMissingReferences(error.inner));
              }
            }
            return res;
          };
          ZSchema.prototype.getMissingRemoteReferences = function () {
            var missingReferences = this.getMissingReferences(), missingRemoteReferences = [], idx = missingReferences.length;
            while (idx--) {
              var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);
              if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {
                missingRemoteReferences.push(remoteReference);
              }
            }
            return missingRemoteReferences;
          };
          ZSchema.prototype.setRemoteReference = function (uri, schema, validationOptions) {
            if (typeof schema === 'string') {
              schema = JSON.parse(schema);
            } else {
              schema = Utils.cloneDeep(schema);
            }
            if (validationOptions) {
              schema.__$validationOptions = normalizeOptions(validationOptions);
            }
            SchemaCache.cacheSchemaByUri.call(this, uri, schema);
          };
          ZSchema.prototype.getResolvedSchema = function (schema) {
            var report = new Report(this.options);
            schema = SchemaCache.getSchema.call(this, report, schema);
            // clone before making any modifications
            schema = Utils.cloneDeep(schema);
            var visited = [];
            // clean-up the schema and resolve references
            var cleanup = function cleanup(schema) {
              var key, typeOf = Utils.whatIs(schema);
              if (typeOf !== 'object' && typeOf !== 'array') {
                return;
              }
              if (schema.___$visited) {
                return;
              }
              schema.___$visited = true;
              visited.push(schema);
              if (schema.$ref && schema.__$refResolved) {
                var from = schema.__$refResolved;
                var to = schema;
                delete schema.$ref;
                delete schema.__$refResolved;
                for (key in from) {
                  if (from.hasOwnProperty(key)) {
                    to[key] = from[key];
                  }
                }
              }
              for (key in schema) {
                if (schema.hasOwnProperty(key)) {
                  if (key.indexOf('__$') === 0) {
                    delete schema[key];
                  } else {
                    cleanup(schema[key]);
                  }
                }
              }
            };
            cleanup(schema);
            visited.forEach(function (s) {
              delete s.___$visited;
            });
            this.lastReport = report;
            if (report.isValid()) {
              return schema;
            } else {
              throw this.getLastError();
            }
          };
          ZSchema.prototype.setSchemaReader = function (schemaReader) {
            return ZSchema.setSchemaReader(schemaReader);
          };
          ZSchema.prototype.getSchemaReader = function () {
            return ZSchema.schemaReader;
          };
          /*
    static methods
*/
          ZSchema.setSchemaReader = function (schemaReader) {
            ZSchema.schemaReader = schemaReader;
          };
          ZSchema.registerFormat = function (formatName, validatorFunction) {
            FormatValidators[formatName] = validatorFunction;
          };
          ZSchema.unregisterFormat = function (formatName) {
            delete FormatValidators[formatName];
          };
          ZSchema.getRegisteredFormats = function () {
            return Object.keys(FormatValidators);
          };
          ZSchema.getDefaultOptions = function () {
            return Utils.cloneDeep(defaultOptions);
          };
          module.exports = ZSchema;
        }.call(this, require('_process')));
      },
      {
        './FormatValidators': 289,
        './JsonValidation': 290,
        './Polyfills': 291,
        './Report': 292,
        './SchemaCache': 293,
        './SchemaCompilation': 294,
        './SchemaValidation': 295,
        './Utils': 296,
        './schemas/hyper-schema.json': 298,
        './schemas/schema.json': 299,
        '_process': 145,
        'lodash.get': 77
      }
    ],
    298: [
      function (require, module, exports) {
        module.exports = {
          '$schema': 'http://json-schema.org/draft-04/hyper-schema#',
          'id': 'http://json-schema.org/draft-04/hyper-schema#',
          'title': 'JSON Hyper-Schema',
          'allOf': [{ '$ref': 'http://json-schema.org/draft-04/schema#' }],
          'properties': {
            'additionalItems': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ]
            },
            'additionalProperties': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ]
            },
            'dependencies': {
              'additionalProperties': {
                'anyOf': [
                  { '$ref': '#' },
                  { 'type': 'array' }
                ]
              }
            },
            'items': {
              'anyOf': [
                { '$ref': '#' },
                { '$ref': '#/definitions/schemaArray' }
              ]
            },
            'definitions': { 'additionalProperties': { '$ref': '#' } },
            'patternProperties': { 'additionalProperties': { '$ref': '#' } },
            'properties': { 'additionalProperties': { '$ref': '#' } },
            'allOf': { '$ref': '#/definitions/schemaArray' },
            'anyOf': { '$ref': '#/definitions/schemaArray' },
            'oneOf': { '$ref': '#/definitions/schemaArray' },
            'not': { '$ref': '#' },
            'links': {
              'type': 'array',
              'items': { '$ref': '#/definitions/linkDescription' }
            },
            'fragmentResolution': { 'type': 'string' },
            'media': {
              'type': 'object',
              'properties': {
                'type': {
                  'description': 'A media type, as described in RFC 2046',
                  'type': 'string'
                },
                'binaryEncoding': {
                  'description': 'A content encoding scheme, as described in RFC 2045',
                  'type': 'string'
                }
              }
            },
            'pathStart': {
              'description': 'Instances\' URIs must start with this value for this schema to apply to them',
              'type': 'string',
              'format': 'uri'
            }
          },
          'definitions': {
            'schemaArray': {
              'type': 'array',
              'items': { '$ref': '#' }
            },
            'linkDescription': {
              'title': 'Link Description Object',
              'type': 'object',
              'required': [
                'href',
                'rel'
              ],
              'properties': {
                'href': {
                  'description': 'a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing',
                  'type': 'string'
                },
                'rel': {
                  'description': 'relation to the target resource of the link',
                  'type': 'string'
                },
                'title': {
                  'description': 'a title for the link',
                  'type': 'string'
                },
                'targetSchema': {
                  'description': 'JSON Schema describing the link target',
                  '$ref': '#'
                },
                'mediaType': {
                  'description': 'media type (as defined by RFC 2046) describing the link target',
                  'type': 'string'
                },
                'method': {
                  'description': 'method for requesting the target of the link (e.g. for HTTP this might be "GET" or "DELETE")',
                  'type': 'string'
                },
                'encType': {
                  'description': 'The media type in which to submit data along with the request',
                  'type': 'string',
                  'default': 'application/json'
                },
                'schema': {
                  'description': 'Schema describing the data to submit along with the request',
                  '$ref': '#'
                }
              }
            }
          }
        };
      },
      {}
    ],
    299: [
      function (require, module, exports) {
        module.exports = {
          'id': 'http://json-schema.org/draft-04/schema#',
          '$schema': 'http://json-schema.org/draft-04/schema#',
          'description': 'Core schema meta-schema',
          'definitions': {
            'schemaArray': {
              'type': 'array',
              'minItems': 1,
              'items': { '$ref': '#' }
            },
            'positiveInteger': {
              'type': 'integer',
              'minimum': 0
            },
            'positiveIntegerDefault0': {
              'allOf': [
                { '$ref': '#/definitions/positiveInteger' },
                { 'default': 0 }
              ]
            },
            'simpleTypes': {
              'enum': [
                'array',
                'boolean',
                'integer',
                'null',
                'number',
                'object',
                'string'
              ]
            },
            'stringArray': {
              'type': 'array',
              'items': { 'type': 'string' },
              'minItems': 1,
              'uniqueItems': true
            }
          },
          'type': 'object',
          'properties': {
            'id': {
              'type': 'string',
              'format': 'uri'
            },
            '$schema': {
              'type': 'string',
              'format': 'uri'
            },
            'title': { 'type': 'string' },
            'description': { 'type': 'string' },
            'default': {},
            'multipleOf': {
              'type': 'number',
              'minimum': 0,
              'exclusiveMinimum': true
            },
            'maximum': { 'type': 'number' },
            'exclusiveMaximum': {
              'type': 'boolean',
              'default': false
            },
            'minimum': { 'type': 'number' },
            'exclusiveMinimum': {
              'type': 'boolean',
              'default': false
            },
            'maxLength': { '$ref': '#/definitions/positiveInteger' },
            'minLength': { '$ref': '#/definitions/positiveIntegerDefault0' },
            'pattern': {
              'type': 'string',
              'format': 'regex'
            },
            'additionalItems': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ],
              'default': {}
            },
            'items': {
              'anyOf': [
                { '$ref': '#' },
                { '$ref': '#/definitions/schemaArray' }
              ],
              'default': {}
            },
            'maxItems': { '$ref': '#/definitions/positiveInteger' },
            'minItems': { '$ref': '#/definitions/positiveIntegerDefault0' },
            'uniqueItems': {
              'type': 'boolean',
              'default': false
            },
            'maxProperties': { '$ref': '#/definitions/positiveInteger' },
            'minProperties': { '$ref': '#/definitions/positiveIntegerDefault0' },
            'required': { '$ref': '#/definitions/stringArray' },
            'additionalProperties': {
              'anyOf': [
                { 'type': 'boolean' },
                { '$ref': '#' }
              ],
              'default': {}
            },
            'definitions': {
              'type': 'object',
              'additionalProperties': { '$ref': '#' },
              'default': {}
            },
            'properties': {
              'type': 'object',
              'additionalProperties': { '$ref': '#' },
              'default': {}
            },
            'patternProperties': {
              'type': 'object',
              'additionalProperties': { '$ref': '#' },
              'default': {}
            },
            'dependencies': {
              'type': 'object',
              'additionalProperties': {
                'anyOf': [
                  { '$ref': '#' },
                  { '$ref': '#/definitions/stringArray' }
                ]
              }
            },
            'enum': {
              'type': 'array',
              'minItems': 1,
              'uniqueItems': true
            },
            'type': {
              'anyOf': [
                { '$ref': '#/definitions/simpleTypes' },
                {
                  'type': 'array',
                  'items': { '$ref': '#/definitions/simpleTypes' },
                  'minItems': 1,
                  'uniqueItems': true
                }
              ]
            },
            'format': { 'type': 'string' },
            'allOf': { '$ref': '#/definitions/schemaArray' },
            'anyOf': { '$ref': '#/definitions/schemaArray' },
            'oneOf': { '$ref': '#/definitions/schemaArray' },
            'not': { '$ref': '#' }
          },
          'dependencies': {
            'exclusiveMaximum': ['maximum'],
            'exclusiveMinimum': ['minimum']
          },
          'default': {}
        };
      },
      {}
    ]
  }, {}, [81])(81);
}));
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .
(function (mod) {
  if (typeof exports == 'object' && typeof module == 'object')
    // CommonJS
    module.exports = mod();
  else if (typeof define == 'function' && define.amd)
    // AMD
    return define([], mod);
  else
    // Plain browser env
    this.CodeMirror = mod();
}(function () {
  'use strict';
  // BROWSER SNIFFING
  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  // ie_uptoN means Internet Explorer version N or lower
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_upto7 = ie_upto10 && (document.documentMode == null || document.documentMode < 8);
  var ie_upto8 = ie_upto10 && (document.documentMode == null || document.documentMode < 9);
  var ie_upto9 = ie_upto10 && (document.documentMode == null || document.documentMode < 10);
  var ie_11up = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);
  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version)
    presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && !ie_upto8;
  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  // EDITOR CONSTRUCTOR
  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.
  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror))
      return new CodeMirror(place, options);
    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);
    var doc = options.value;
    if (typeof doc == 'string')
      doc = new Doc(doc, options.mode);
    this.doc = doc;
    var display = this.display = new Display(place, doc);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += ' CodeMirror-wrap';
    if (options.autofocus && !mobile)
      focusInput(this);
    this.state = {
      keyMaps: [],
      overlays: [],
      modeGen: 0,
      overwrite: false,
      focused: false,
      suppressEdits: false,
      pasteIncoming: false,
      cutIncoming: false,
      draggingText: false,
      highlight: new Delayed()
    };
    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie_upto10)
      setTimeout(bind(resetInput, this, true), 20);
    registerEventHandlers(this);
    ensureGlobalHandlers();
    var cm = this;
    runInOp(this, function () {
      cm.curOp.forceUpdate = true;
      attachDoc(cm, doc);
      if (options.autofocus && !mobile || activeElt() == display.input)
        setTimeout(bind(onFocus, cm), 20);
      else
        onBlur(cm);
      for (var opt in optionHandlers)
        if (optionHandlers.hasOwnProperty(opt))
          optionHandlers[opt](cm, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i)
        initHooks[i](cm);
    });
  }
  // DISPLAY CONSTRUCTOR
  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.
  function Display(place, doc) {
    var d = this;
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none');
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit)
      input.style.width = '1000px';
    else
      input.setAttribute('wrap', 'off');
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios)
      input.style.border = '1px solid black';
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    input.setAttribute('spellcheck', 'false');
    // Wraps and hides input textarea
    d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
    // The fake scrollbar elements.
    d.scrollbarH = elt('div', [elt('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar');
    d.scrollbarV = elt('div', [elt('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar');
    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt('div', null, 'CodeMirror-code');
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
    d.cursorDiv = elt('div', null, 'CodeMirror-cursors');
    // A visibility: hidden element used to find the size of things.
    d.measure = elt('div', null, 'CodeMirror-measure');
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt('div', null, 'CodeMirror-measure');
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt('div', [
      d.measure,
      d.lineMeasure,
      d.selectionDiv,
      d.cursorDiv,
      d.lineDiv
    ], null, 'position: relative; outline: none');
    // Moved around its parent to cover visible view.
    d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
    // Will contain the gutters, if any.
    d.gutters = elt('div', null, 'CodeMirror-gutters');
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt('div', [
      d.sizer,
      d.heightForcer,
      d.gutters
    ], 'CodeMirror-scroll');
    d.scroller.setAttribute('tabIndex', '-1');
    // The element in which the editor lives.
    d.wrapper = elt('div', [
      d.inputDiv,
      d.scrollbarH,
      d.scrollbarV,
      d.scrollbarFiller,
      d.gutterFiller,
      d.scroller
    ], 'CodeMirror');
    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie_upto7) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios)
      input.style.width = '0px';
    if (!webkit)
      d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) {
      d.inputDiv.style.height = '1px';
      d.inputDiv.style.position = 'absolute';
    }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie_upto7)
      d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = '18px';
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastSizeC = 0;
    d.updateLineNumbers = null;
    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = '';
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    // Tracks when resetInput has punted to just putting a short
    // string into the textarea instead of the full selection.
    d.inaccurateSelection = false;
    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    // True when shift is held down.
    d.shift = false;
    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;
  }
  // STATE UPDATES
  // Used to get the editor into a consistent state again when options change.
  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }
  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter)
        line.stateAfter = null;
      if (line.styles)
        line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp)
      regChange(cm);
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, 'CodeMirror-wrap');
      cm.display.sizer.style.minWidth = '';
    } else {
      rmClass(cm.display.wrapper, 'CodeMirror-wrap');
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      updateScrollbars(cm);
    }, 100);
  }
  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      var widgetsHeight = 0;
      if (line.widgets)
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height)
            widgetsHeight += line.widgets[i].height;
        }
      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height)
        updateLineHeight(line, estHeight);
    });
  }
  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
    clearCaches(cm);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function () {
      alignHorizontally(cm);
    }, 20);
  }
  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
      if (gutterClass == 'CodeMirror-linenumbers') {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
      }
    }
    gutters.style.display = i ? '' : 'none';
    updateGutterSpace(cm);
  }
  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + 'px';
    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + 'px' : 0;
  }
  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0)
      return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }
  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, 'CodeMirror-linenumbers');
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(['CodeMirror-linenumbers']);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }
  // SCROLLBARS
  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var scroll = cm.display.scroller;
    return {
      clientHeight: scroll.clientHeight,
      barHeight: cm.display.scrollbarV.clientHeight,
      scrollWidth: scroll.scrollWidth,
      clientWidth: scroll.clientWidth,
      barWidth: cm.display.scrollbarH.clientWidth,
      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
    };
  }
  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbars(cm, measure) {
    if (!measure)
      measure = measureForScrollbars(cm);
    var d = cm.display;
    var scrollHeight = measure.docHeight + scrollerCutOff;
    var needsH = measure.scrollWidth > measure.clientWidth;
    var needsV = scrollHeight > measure.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = 'block';
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
      // A bug in IE8 can cause this value to be negative, so guard it.
      d.scrollbarV.firstChild.style.height = Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + 'px';
    } else {
      d.scrollbarV.style.display = '';
      d.scrollbarV.firstChild.style.height = '0';
    }
    if (needsH) {
      d.scrollbarH.style.display = 'block';
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarH.firstChild.style.width = measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth) + 'px';
    } else {
      d.scrollbarH.style.display = '';
      d.scrollbarH.firstChild.style.width = '0';
    }
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = 'block';
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
    } else
      d.scrollbarFiller.style.display = '';
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = 'block';
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + 'px';
      d.gutterFiller.style.width = d.gutters.offsetWidth + 'px';
    } else
      d.gutterFiller.style.display = '';
    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
      if (scrollbarWidth(d.measure) === 0) {
        var w = mac && !mac_geMountainLion ? '12px' : '18px';
        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
        var barMouseDown = function (e) {
          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)
            operation(cm, onMouseDown)(e);
        };
        on(d.scrollbarV, 'mousedown', barMouseDown);
        on(d.scrollbarH, 'mousedown', barMouseDown);
      }
      cm.state.checkedOverlayScrollbar = true;
    }
  }
  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewPort may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewPort) {
    var top = viewPort && viewPort.top != null ? Math.max(0, viewPort.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewPort && viewPort.bottom != null ? viewPort.bottom : top + display.wrapper.clientHeight;
    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewPort && viewPort.ensure) {
      var ensureFrom = viewPort.ensure.from.line, ensureTo = viewPort.ensure.to.line;
      if (ensureFrom < from)
        return {
          from: ensureFrom,
          to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
        };
      if (Math.min(ensureTo, doc.lastLine()) >= to)
        return {
          from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
          to: ensureTo
        };
    }
    return {
      from: from,
      to: Math.max(to, from + 1)
    };
  }
  // LINE NUMBERS
  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
      return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + 'px';
    for (var i = 0; i < view.length; i++)
      if (!view[i].hidden) {
        if (cm.options.fixedGutter && view[i].gutter)
          view[i].gutter.style.left = left;
        var align = view[i].alignable;
        if (align)
          for (var j = 0; j < align.length; j++)
            align[j].style.left = left;
      }
    if (cm.options.fixedGutter)
      display.gutters.style.left = comp + gutterW + 'px';
  }
  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers)
      return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = '';
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + 'px';
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }
  // DISPLAY DRAWING
  // Updates the display, selection, and scrollbars, using the
  // information in display.view to find out which nodes are no longer
  // up-to-date. Tries to bail out early when no changes are needed,
  // unless forced is true.
  // Returns true if an actual update happened, false otherwise.
  function updateDisplay(cm, viewPort, forced) {
    var oldFrom = cm.display.viewFrom, oldTo = cm.display.viewTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (var first = true;; first = false) {
      var oldWidth = cm.display.scroller.clientWidth;
      if (!updateDisplayInner(cm, visible, forced))
        break;
      updated = true;
      // If the max line changed since it was last measured, measure it,
      // and ensure the document's width matches it.
      if (cm.display.maxLineChanged && !cm.options.lineWrapping)
        adjustContentWidth(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      if (webkit && cm.options.lineWrapping)
        checkForWebkitWidthBug(cm, barMeasure);
      // (Issue #2420)
      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
        forced = true;
        continue;
      }
      forced = false;
      // Clip forced viewport to actual scrollable area.
      if (viewPort && viewPort.top != null)
        viewPort = { top: Math.min(barMeasure.docHeight - scrollerCutOff - barMeasure.clientHeight, viewPort.top) };
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.viewFrom && visible.to <= cm.display.viewTo)
        break;
    }
    cm.display.updateLineNumbers = null;
    if (updated) {
      signalLater(cm, 'update', cm);
      if (cm.display.viewFrom != oldFrom || cm.display.viewTo != oldTo)
        signalLater(cm, 'viewportChange', cm, cm.display.viewFrom, cm.display.viewTo);
    }
    return updated;
  }
  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayInner(cm, visible, forced) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.offsetWidth) {
      resetView(cm);
      return;
    }
    // Bail out if the visible area is already rendered and nothing changed.
    if (!forced && visible.from >= display.viewFrom && visible.to <= display.viewTo && countDirtyView(cm) == 0)
      return;
    if (maybeUpdateLineNumberWidth(cm))
      resetView(cm);
    var dims = getDimensions(cm);
    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20)
      from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20)
      to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }
    var different = from != display.viewFrom || to != display.viewTo || display.lastSizeC != display.wrapper.clientHeight;
    adjustView(cm, from, to);
    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + 'px';
    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !forced)
      return;
    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4)
      display.lineDiv.style.display = 'none';
    patchDisplay(cm, display.updateLineNumbers, dims);
    if (toUpdate > 4)
      display.lineDiv.style.display = '';
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight)
      focused.focus();
    // Prevent selection and cursors from interfering with the scroll
    // width.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }
    updateHeightsInViewport(cm);
    return true;
  }
  function adjustContentWidth(cm) {
    var display = cm.display;
    var width = measureChar(cm, display.maxLine, display.maxLine.text.length).left;
    display.maxLineChanged = false;
    var minWidth = Math.max(0, width + 3);
    var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + minWidth + scrollerCutOff - display.scroller.clientWidth);
    display.sizer.style.minWidth = minWidth + 'px';
    if (maxScrollLeft < cm.doc.scrollLeft)
      setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
  }
  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + 'px';
    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + 'px';
  }
  function checkForWebkitWidthBug(cm, measure) {
    // Work around Webkit bug where it sometimes reserves space for a
    // non-existing phantom scrollbar in the scroller (Issue #2420)
    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {
      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = '0px';
      cm.display.gutters.style.height = measure.docHeight + 'px';
    }
  }
  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden)
        continue;
      if (ie_upto7) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2)
        height = textHeight(display);
      if (diff > 0.001 || diff < -0.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest)
          for (var j = 0; j < cur.rest.length; j++)
            updateWidgetHeight(cur.rest[j]);
      }
    }
  }
  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets)
      for (var i = 0; i < line.widgets.length; ++i)
        line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }
  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = 'none';
      else
        node.parentNode.removeChild(node);
      return next;
    }
    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node)
          cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, 'gutter') > -1)
            updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur)
      cur = rm(cur);
  }
  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == 'text')
        updateLineText(cm, lineView);
      else if (type == 'gutter')
        updateLineGutter(cm, lineView, lineN, dims);
      else if (type == 'class')
        updateLineClasses(lineView);
      else if (type == 'widget')
        updateLineWidgets(lineView, dims);
    }
    lineView.changes = null;
  }
  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt('div', null, null, 'position: relative');
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie_upto7)
        lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }
  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + ' ' + (lineView.line.bgClass || '') : lineView.line.bgClass;
    if (cls)
      cls += ' CodeMirror-linebackground';
    if (lineView.background) {
      if (cls)
        lineView.background.className = cls;
      else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt('div', null, cls), wrap.firstChild);
    }
  }
  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }
  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node)
      lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }
  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = '';
    var textClass = lineView.textClass ? lineView.textClass + ' ' + (lineView.line.textClass || '') : lineView.line.textClass;
    lineView.text.className = textClass || '';
  }
  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = wrap.insertBefore(elt('div', null, 'CodeMirror-gutter-wrapper', 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), lineView.text);
      if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
        lineView.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineN), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + cm.display.lineNumInnerWidth + 'px'));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
        }
    }
  }
  function updateLineWidgets(lineView, dims) {
    if (lineView.alignable)
      lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == 'CodeMirror-linewidget')
        lineView.node.removeChild(node);
    }
    insertLineWidgets(lineView, dims);
  }
  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass)
      lineView.bgClass = built.bgClass;
    if (built.textClass)
      lineView.textClass = built.textClass;
    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(lineView, dims);
    return lineView.node;
  }
  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(lineView, dims) {
    insertLineWidgetsFor(lineView.line, lineView, dims, true);
    if (lineView.rest)
      for (var i = 0; i < lineView.rest.length; i++)
        insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
  }
  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
    if (!line.widgets)
      return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
      if (!widget.handleMouseEvents)
        node.ignoreEvents = true;
      positionLineWidget(widget, node, lineView, dims);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, 'redraw');
    }
  }
  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + 'px';
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + 'px';
      }
      node.style.width = width + 'px';
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = 'relative';
      if (!widget.noHScroll)
        node.style.marginLeft = -dims.gutterTotalWidth + 'px';
    }
  }
  // POSITION OBJECT
  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function (line, ch) {
      if (!(this instanceof Pos))
        return new Pos(line, ch);
      this.line = line;
      this.ch = ch;
    };
  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function (a, b) {
      return a.line - b.line || a.ch - b.ch;
    };
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }
  // SELECTION / CURSOR
  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }
  Selection.prototype = {
    primary: function () {
      return this.ranges[this.primIndex];
    },
    equals: function (other) {
      if (other == this)
        return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
        return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0)
          return false;
      }
      return true;
    },
    deepCopy: function () {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function () {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty())
          return true;
      return false;
    },
    contains: function (pos, end) {
      if (!end)
        end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };
  function Range(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  Range.prototype = {
    from: function () {
      return minPos(this.anchor, this.head);
    },
    to: function () {
      return maxPos(this.anchor, this.head);
    },
    empty: function () {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };
  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex)
          --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }
  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }
  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first)
      return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last)
      return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen)
      return Pos(pos.line, linelen);
    else if (ch < 0)
      return Pos(pos.line, 0);
    else
      return pos;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++)
      out[i] = clipPos(doc, array[i]);
    return out;
  }
  // SELECTION UPDATES
  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.
  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }
  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }
  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }
  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }
  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }
  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
        ranges: sel.ranges,
        update: function (ranges) {
          this.ranges = [];
          for (var i = 0; i < ranges.length; i++)
            this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
        }
      };
    signal(doc, 'beforeSelectionChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
    if (obj.ranges != sel.ranges)
      return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else
      return sel;
  }
  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }
  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }
  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange'))
      sel = filterSelectionChange(doc, sel);
    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }
  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel))
      return;
    doc.sel = sel;
    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, 'cursorActivity', doc);
  }
  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }
  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out)
          out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }
  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search:
      for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, 'beforeCursorEnter');
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              var newPos = m.find(dir < 0 ? -1 : 1);
              if (cmp(newPos, curPos) == 0) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first)
                    newPos = clipPos(doc, Pos(newPos.line - 1));
                  else
                    newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1)
                    newPos = Pos(newPos.line + 1, 0);
                  else
                    newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    // Driven in a corner -- no valid cursor position found at all
                    // -- try again *with* clearing, if we didn't already
                    if (!mayClear)
                      return skipAtomic(doc, pos, bias, true);
                    // Otherwise, turn off editing until further notice, and return the start of the doc
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true;
                  newPos = pos;
                  dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
  }
  // SELECTION DRAWING
  // Redraw the selection and/or cursor
  function updateSelection(cm) {
    var display = cm.display, doc = cm.doc;
    var curFragment = document.createDocumentFragment();
    var selFragment = document.createDocumentFragment();
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, 'div');
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      var top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      var left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      display.inputDiv.style.top = top + 'px';
      display.inputDiv.style.left = left + 'px';
    }
    removeChildrenAndAdd(display.cursorDiv, curFragment);
    removeChildrenAndAdd(display.selectionDiv, selFragment);
  }
  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, 'div');
    var cursor = output.appendChild(elt('div', '\xa0', 'CodeMirror-cursor'));
    cursor.style.left = pos.left + 'px';
    cursor.style.top = pos.top + 'px';
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor'));
      otherCursor.style.display = '';
      otherCursor.style.left = pos.other.left + 'px';
      otherCursor.style.top = pos.other.top + 'px';
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
    }
  }
  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;
    function add(left, top, width, bottom) {
      if (top < 0)
        top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? rightSide - left : width) + 'px; height: ' + (bottom - top) + 'px'));
    }
    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);
      }
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from, 'left'), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, 'right');
          if (dir == 'rtl') {
            var tmp = leftPos;
            leftPos = rightPos;
            rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0)
          left = leftSide;
        if (rightPos.top - leftPos.top > 3) {
          // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top)
            add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen)
          right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1)
          left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {
        start: start,
        end: end
      };
    }
    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }
    output.appendChild(fragment);
  }
  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused)
      return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = '';
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function () {
        display.cursorDiv.style.visibility = (on = !on) ? '' : 'hidden';
      }, cm.options.cursorBlinkRate);
  }
  // HIGHLIGHT WORKER
  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first)
      doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo)
      return;
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    runInOp(cm, function () {
      doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
        if (doc.frontier >= cm.display.viewFrom) {
          // Visible
          var oldStyles = line.styles;
          var highlighted = highlightLine(cm, line, state, true);
          line.styles = highlighted.styles;
          if (highlighted.classes)
            line.styleClasses = highlighted.classes;
          else if (line.styleClasses)
            line.styleClasses = null;
          var ischange = !oldStyles || oldStyles.length != line.styles.length;
          for (var i = 0; !ischange && i < oldStyles.length; ++i)
            ischange = oldStyles[i] != line.styles[i];
          if (ischange)
            regLineChange(cm, doc.frontier, 'text');
          line.stateAfter = copyState(doc.mode, state);
        } else {
          processLine(cm, line.text, state);
          line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
        }
        ++doc.frontier;
        if (+new Date() > end) {
          startWorker(cm, cm.options.workDelay);
          return true;
        }
      });
    });
  }
  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first)
        return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier))
        return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState)
      return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state)
      state = startState(doc.mode);
    else
      state = copyState(doc.mode, state);
    doc.iter(pos, n, function (line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise)
      doc.frontier = pos;
    return state;
  }
  // POSITION MEASUREMENT
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH)
      return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt('pre', 'x'));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {
        left: parseInt(style.paddingLeft),
        right: parseInt(style.paddingRight)
      };
    if (!isNaN(data.left) && !isNaN(data.right))
      display.cachedPaddingH = data;
    return data;
  }
  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && cm.display.scroller.clientWidth;
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }
  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {
        map: lineView.measure.map,
        cache: lineView.measure.cache
      };
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {
          map: lineView.measure.maps[i],
          cache: lineView.measure.caches[i]
        };
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {
          map: lineView.measure.maps[i],
          cache: lineView.measure.caches[i],
          before: true
        };
  }
  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }
  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }
  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }
  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);
    var info = mapFromLineView(view, line, lineN);
    return {
      line: line,
      view: view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  }
  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias) {
    if (prepared.before)
      ch = -1;
    var key = ch + (bias || ''), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus)
        prepared.cache[key] = found;
    }
    return {
      left: found.left,
      right: found.right,
      top: found.top,
      bottom: found.bottom
    };
  }
  var nullRect = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
  function measureCharInner(cm, prepared, ch, bias) {
    var map = prepared.map;
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = 'left';
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd)
          collapse = 'right';
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right'))
          collapse = bias;
        if (bias == 'left' && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = 'left';
          }
        if (bias == 'right' && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = 'right';
          }
        break;
      }
    }
    var rect;
    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      while (start && isExtendingChar(prepared.line.text.charAt(mStart + start)))
        --start;
      while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end)))
        ++end;
      if (ie_upto8 && start == 0 && end == mEnd - mStart) {
        rect = node.parentNode.getBoundingClientRect();
      } else if (ie && cm.options.lineWrapping) {
        var rects = range(node, start, end).getClientRects();
        if (rects.length)
          rect = rects[bias == 'right' ? rects.length - 1 : 0];
        else
          rect = nullRect;
      } else {
        rect = range(node, start, end).getBoundingClientRect() || nullRect;
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0)
        collapse = bias = 'right';
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == 'right' ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie_upto8 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {
          left: rSpan.left,
          right: rSpan.left + charWidth(cm.display),
          top: rSpan.top,
          bottom: rSpan.bottom
        };
      else
        rect = nullRect;
    }
    var top, bot = (rect.bottom + rect.top) / 2 - prepared.rect.top;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (bot < heights[i])
        break;
    top = i ? heights[i - 1] : 0;
    bot = heights[i];
    var result = {
        left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,
        right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,
        top: top,
        bottom: bot
      };
    if (!rect.left && !rect.right)
      result.bogus = true;
    return result;
  }
  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest)
        for (var i = 0; i < lineView.rest.length; i++)
          lineView.measure.caches[i] = {};
    }
  }
  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }
  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping)
      cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }
  function pageScrollX() {
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }
  function pageScrollY() {
    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }
  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets)
      for (var i = 0; i < lineObj.widgets.length; ++i)
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;
          rect.bottom += size;
        }
    if (context == 'line')
      return rect;
    if (!context)
      context = 'local';
    var yOff = heightAtLine(lineObj);
    if (context == 'local')
      yOff += paddingTop(cm.display);
    else
      yOff -= cm.display.viewOffset;
    if (context == 'page' || context == 'window') {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
      var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == 'div')
      return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == 'page') {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == 'local' || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }
    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {
      left: left - lineSpaceBox.left,
      top: top - lineSpaceBox.top
    };
  }
  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj)
      lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }
  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure)
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left');
      if (right)
        m.left = m.right;
      else
        m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from)
        return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order)
      return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null)
      val.other = getBidi(ch, bidiOther);
    return val;
  }
  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping)
      left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {
      left: left,
      right: left,
      top: top,
      bottom: top + lineObj.height
    };
  }
  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside)
      pos.outside = true;
    return pos;
  }
  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0)
      return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0)
      x = 0;
    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }
  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom)
        return sp.left - adjust;
      else if (innerOff < sp.top)
        return sp.left + adjust;
      else
        wrongLine = false;
      return sp.left;
    }
    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
    if (x > toX)
      return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch)))
          ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i)
          middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;
        toX = middleX;
        if (toOutside = wrongLine)
          toX += 1000;
        dist = step;
      } else {
        from = middle;
        fromX = middleX;
        fromOutside = wrongLine;
        dist -= step;
      }
    }
  }
  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null)
      return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt('pre');
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode('x'));
        measureText.appendChild(elt('br'));
      }
      measureText.appendChild(document.createTextNode('x'));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3)
      display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }
  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null)
      return display.cachedCharWidth;
    var anchor = elt('span', 'xxxxxxxxxx');
    var pre = elt('pre', [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2)
      display.cachedCharWidth = width;
    return width || 10;
  }
  // OPERATIONS
  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.
  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      viewChanged: false,
      startHeight: cm.doc.height,
      forceUpdate: false,
      updateInput: null,
      typing: false,
      changeObjs: null,
      cursorActivityHandlers: null,
      selectionChanged: false,
      updateMaxLine: false,
      scrollLeft: null,
      scrollTop: null,
      scrollToPos: null,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++)
      delayedCallbacks = [];
  }
  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;
    if (op.updateMaxLine)
      findMaxLine(cm);
    // If it looks like an update might be needed, call updateDisplay
    if (op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping) {
      var updated = updateDisplay(cm, {
          top: op.scrollTop,
          ensure: op.scrollToPos
        }, op.forceUpdate);
      if (cm.display.scroller.offsetHeight)
        cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    // If no update was run, but the selection changed, redraw that.
    if (!updated && op.selectionChanged)
      updateSelection(cm);
    if (!updated && op.startHeight != cm.doc.height)
      updateScrollbars(cm);
    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;
    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && display.scroller.scrollTop != op.scrollTop) {
      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
    }
    if (op.scrollLeft != null && display.scroller.scrollLeft != op.scrollLeft) {
      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from), clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused)
        maybeScrollWindow(cm, coords);
    }
    if (op.selectionChanged)
      restartBlink(cm);
    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.typing);
    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden)
      for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length)
          signal(hidden[i], 'hide');
    if (unhidden)
      for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length)
          signal(unhidden[i], 'unhide');
    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, 'changes', cm, op.changeObjs);
    if (delayed)
      for (var i = 0; i < delayed.length; ++i)
        delayed[i]();
    if (op.cursorActivityHandlers)
      for (var i = 0; i < op.cursorActivityHandlers.length; i++)
        op.cursorActivityHandlers[i](cm);
  }
  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp)
      return f();
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function () {
      if (cm.curOp)
        return f.apply(cm, arguments);
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function () {
      if (this.curOp)
        return f.apply(this, arguments);
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function () {
      var cm = this.cm;
      if (!cm || cm.curOp)
        return f.apply(this, arguments);
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  // VIEW TRACKING
  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }
  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }
  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null)
      from = cm.doc.first;
    if (to == null)
      to = cm.doc.first + cm.doc.size;
    if (!lendiff)
      lendiff = 0;
    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;
    cm.curOp.viewChanged = true;
    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }
    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }
  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;
    if (line < display.viewFrom || line >= display.viewTo)
      return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null)
      return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1)
      arr.push(type);
  }
  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }
  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo)
      return null;
    n -= cm.display.viewFrom;
    if (n < 0)
      return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0)
        return i;
    }
  }
  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {
        index: index,
        lineN: newN
      };
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1)
          return null;
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;
      newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1))
        return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {
      index: index,
      lineN: newN
    };
  }
  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }
  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes))
        ++dirty;
    }
    return dirty;
  }
  // INPUT HANDLING
  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  function slowPoll(cm) {
    if (cm.display.pollingFast)
      return;
    cm.display.poll.set(cm.options.pollInterval, function () {
      readInput(cm);
      if (cm.state.focused)
        slowPoll(cm);
    });
  }
  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {
        missed = true;
        cm.display.poll.set(60, p);
      } else {
        cm.display.pollingFast = false;
        slowPoll(cm);
      }
    }
    cm.display.poll.set(20, p);
  }
  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (!cm.state.focused || hasSelection(input) && !prevInput || isReadOnly(cm) || cm.options.disableInput)
      return false;
    // See paste handler for more on the fakedLastChar kludge
    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
      input.value = input.value.substring(0, input.value.length - 1);
      cm.state.fakedLastChar = false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected())
      return false;
    // Work around nonsensical selection resetting in IE9/10
    if (ie && !ie_upto8 && cm.display.inputHasSelection === text) {
      resetInput(cm);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp)
      startOperation(cm);
    cm.display.shift = false;
    if (text.charCodeAt(0) == 8203 && doc.sel == cm.display.selForContextMenu && !prevInput)
      prevInput = '\u200b';
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    var inserted = text.slice(same), textLines = splitLines(inserted);
    // When pasing N lines into N selections, insert one line per selection
    var multiPaste = cm.state.pasteIncoming && textLines.length > 1 && doc.sel.ranges.length == textLines.length;
    // Normal behavior is to insert the new text into every selection
    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
      var range = doc.sel.ranges[i];
      var from = range.from(), to = range.to();
      // Handle deletion
      if (same < prevInput.length)
        from = Pos(from.line, from.ch - (prevInput.length - same));  // Handle overwrite
      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {
          from: from,
          to: to,
          text: multiPaste ? [textLines[i]] : textLines,
          origin: cm.state.pasteIncoming ? 'paste' : cm.state.cutIncoming ? 'cut' : '+input'
        };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, 'inputRead', cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars && cm.options.smartIndent && range.head.ch < 100 && (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, range.head.line, 'smart');
              break;
            }
        } else if (mode.electricInput) {
          var end = changeEnd(changeEvent);
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, range.head.line, 'smart');
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf('\n') > -1)
      input.value = cm.display.prevInput = '';
    else
      cm.display.prevInput = text;
    if (withOp)
      endOperation(cm);
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
    return true;
  }
  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  function resetInput(cm, typing) {
    var minimal, selected, doc = cm.doc;
    if (cm.somethingSelected()) {
      cm.display.prevInput = '';
      var range = doc.sel.primary();
      minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? '-' : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused)
        selectInput(cm.display.input);
      if (ie && !ie_upto8)
        cm.display.inputHasSelection = content;
    } else if (!typing) {
      cm.display.prevInput = cm.display.input.value = '';
      if (ie && !ie_upto8)
        cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }
  function focusInput(cm) {
    if (cm.options.readOnly != 'nocursor' && (!mobile || activeElt() != cm.display.input))
      cm.display.input.focus();
  }
  function ensureFocus(cm) {
    if (!cm.state.focused) {
      focusInput(cm);
      onFocus(cm);
    }
  }
  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }
  // EVENT HANDLERS
  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, 'mousedown', operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie_upto10)
      on(d.scroller, 'dblclick', operation(cm, function (e) {
        if (signalDOMEvent(cm, e))
          return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        var word = findWordAt(cm, pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, 'dblclick', function (e) {
        signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    // Prevent normal selection in the editor (we handle our own)
    on(d.lineSpace, 'selectstart', function (e) {
      if (!eventInWidget(d, e))
        e_preventDefault(e);
    });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick)
      on(d.scroller, 'contextmenu', function (e) {
        onContextMenu(cm, e);
      });
    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, 'scroll', function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, 'scroll', cm);
      }
    });
    on(d.scrollbarV, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });
    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, 'mousewheel', function (e) {
      onScrollWheel(cm, e);
    });
    on(d.scroller, 'DOMMouseScroll', function (e) {
      onScrollWheel(cm, e);
    });
    // Prevent clicks in the scrollbars from killing focus
    function reFocus() {
      if (cm.state.focused)
        setTimeout(bind(focusInput, cm), 0);
    }
    on(d.scrollbarH, 'mousedown', reFocus);
    on(d.scrollbarV, 'mousedown', reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, 'scroll', function () {
      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    on(d.input, 'keyup', operation(cm, onKeyUp));
    on(d.input, 'input', function () {
      if (ie && !ie_upto8 && cm.display.inputHasSelection)
        cm.display.inputHasSelection = null;
      fastPoll(cm);
    });
    on(d.input, 'keydown', operation(cm, onKeyDown));
    on(d.input, 'keypress', operation(cm, onKeyPress));
    on(d.input, 'focus', bind(onFocus, cm));
    on(d.input, 'blur', bind(onBlur, cm));
    function drag_(e) {
      if (!signalDOMEvent(cm, e))
        e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, 'dragstart', function (e) {
        onDragStart(cm, e);
      });
      on(d.scroller, 'dragenter', drag_);
      on(d.scroller, 'dragover', drag_);
      on(d.scroller, 'drop', operation(cm, onDrop));
    }
    on(d.scroller, 'paste', function (e) {
      if (eventInWidget(d, e))
        return;
      cm.state.pasteIncoming = true;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, 'paste', function () {
      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
      // Add a char to the end of textarea before paste occur so that
      // selection doesn't span to the end of textarea.
      if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
        var start = d.input.selectionStart, end = d.input.selectionEnd;
        d.input.value += '$';
        d.input.selectionStart = start;
        d.input.selectionEnd = end;
        cm.state.fakedLastChar = true;
      }
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });
    function prepareCopyCut(e) {
      if (cm.somethingSelected()) {
        if (d.inaccurateSelection) {
          d.prevInput = '';
          d.inaccurateSelection = false;
          d.input.value = cm.getSelection();
          selectInput(d.input);
        }
      } else {
        var text = '', ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {
              anchor: Pos(line, 0),
              head: Pos(line + 1, 0)
            };
          ranges.push(lineRange);
          text += cm.getRange(lineRange.anchor, lineRange.head);
        }
        if (e.type == 'cut') {
          cm.setSelections(ranges, null, sel_dontScroll);
        } else {
          d.prevInput = '';
          d.input.value = text;
          selectInput(d.input);
        }
      }
      if (e.type == 'cut')
        cm.state.cutIncoming = true;
    }
    on(d.input, 'cut', prepareCopyCut);
    on(d.input, 'copy', prepareCopyCut);
    // Needed to handle Tab key in KHTML
    if (khtml)
      on(d.sizer, 'mouseup', function () {
        if (activeElt() == d.input)
          d.input.blur();
        focusInput(cm);
      });
  }
  // Called when the window resizes
  function onResize(cm) {
    // Might be a text scaling operation, clear size caches.
    var d = cm.display;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    cm.setSize();
  }
  // MOUSE EVENTS
  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover)
        return true;
    }
  }
  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarV || target == display.scrollbarFiller || target == display.gutterFiller)
        return null;
    }
    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try {
      x = e.clientX - space.left;
      y = e.clientY - space.top;
    } catch (e) {
      return null;
    }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }
  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    if (signalDOMEvent(this, e))
      return;
    var cm = this, display = cm.display;
    display.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e))
      return;
    var start = posFromMouse(cm, e);
    window.focus();
    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit)
        cm.state.lastMiddleDown = +new Date();
      if (start)
        extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick)
        onContextMenu(cm, e);
      break;
    }
  }
  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    setTimeout(bind(ensureFocus, cm), 0);
    var now = +new Date(), type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = 'triple';
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = 'double';
      lastDoubleClick = {
        time: now,
        pos: start
      };
    } else {
      type = 'single';
      lastClick = {
        time: now,
        pos: start
      };
    }
    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && type == 'single' && sel.contains(start) > -1 && sel.somethingSelected())
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }
  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display;
    var dragEnd = operation(cm, function (e2) {
        if (webkit)
          display.scroller.draggable = false;
        cm.state.draggingText = false;
        off(document, 'mouseup', dragEnd);
        off(display.scroller, 'drop', dragEnd);
        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
          e_preventDefault(e2);
          if (!modifier)
            extendSelection(cm.doc, start);
          focusInput(cm);
          // Work around unexplainable focus problem in IE9 (#2127)
          if (ie_upto10 && !ie_upto8)
            setTimeout(function () {
              document.body.focus();
              focusInput(cm);
            }, 20);
        }
      });
    // Let the drag handler handle this.
    if (webkit)
      display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop)
      display.scroller.dragDrop();
    on(document, 'mouseup', dragEnd);
    on(display.scroller, 'drop', dragEnd);
  }
  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);
    var ourRange, ourIndex, startSel = doc.sel;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = doc.sel.ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
    }
    if (e.altKey) {
      type = 'rect';
      if (!addNew)
        ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == 'double') {
      var word = findWordAt(cm, start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == 'triple') {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }
    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex > -1) {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    } else {
      ourIndex = doc.sel.ranges.length;
      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex), {
        scroll: false,
        origin: '*mouse'
      });
    }
    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0)
        return;
      lastPos = pos;
      if (type == 'rect') {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length)
          ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
          origin: '*mouse',
          scroll: false
        });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != 'single') {
          if (type == 'double')
            var range = findWordAt(cm, pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }
    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == 'rect');
      if (!cur)
        return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function () {
            if (counter == curCount)
              extend(e);
          }), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside)
          setTimeout(operation(cm, function () {
            if (counter != curCount)
              return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
      }
    }
    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, 'mousemove', move);
      off(document, 'mouseup', up);
      doc.history.lastSelOrigin = null;
    }
    var move = operation(cm, function (e) {
        if (ie && !ie_upto9 ? !e.buttons : !e_button(e))
          done(e);
        else
          extend(e);
      });
    var up = operation(cm, done);
    on(document, 'mousemove', move);
    on(document, 'mouseup', up);
  }
  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try {
      var mX = e.clientX, mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
      return false;
    if (prevent)
      e_preventDefault(e);
    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();
    if (mY > lineBox.bottom || !hasHandler(cm, type))
      return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }
  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, 'gutterClick', true, signalLater);
  }
  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;
  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie)
      lastDrop = +new Date();
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm))
      return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        var reader = new FileReader();
        reader.onload = operation(cm, function () {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {
                from: pos,
                to: pos,
                text: splitLines(text.join('\n')),
                origin: 'paste'
              };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i)
        loadFile(files[i], i);
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData('Text');
        if (text) {
          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected)
            for (var i = 0; i < selected.length; ++i)
              replaceRange(cm.doc, '', selected[i].anchor, selected[i].head, 'drag');
          cm.replaceSelection(text, 'around', 'paste');
          focusInput(cm);
        }
      } catch (e) {
      }
    }
  }
  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e.dataTransfer.setData('Text', cm.getSelection());
    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
      img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto)
        img.parentNode.removeChild(img);
    }
  }
  // SCROLL EVENTS
  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2)
      return;
    cm.doc.scrollTop = val;
    if (!gecko)
      updateDisplay(cm, { top: val });
    if (cm.display.scroller.scrollTop != val)
      cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val)
      cm.display.scrollbarV.scrollTop = val;
    if (gecko)
      updateDisplay(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
      return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val)
      cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val)
      cm.display.scrollbarH.scrollLeft = val;
  }
  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie)
    wheelPixelsPerUnit = -0.53;
  else if (gecko)
    wheelPixelsPerUnit = 15;
  else if (chrome)
    wheelPixelsPerUnit = -0.7;
  else if (safari)
    wheelPixelsPerUnit = -1 / 3;
  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
      dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
      dy = e.detail;
    else if (dy == null)
      dy = e.wheelDelta;
    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
      return;
    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer:
        for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
          for (var i = 0; i < view.length; i++) {
            if (view[i].node == cur) {
              cm.display.currentWheelTarget = cur;
              break outer;
            }
          }
        }
    }
    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null;
      // Abort measurement, if in progress
      return;
    }
    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0)
        top = Math.max(0, top + pixels - 50);
      else
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null)
            return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample)
            return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  // KEY EVENTS
  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == 'string') {
      bound = commands[bound];
      if (!bound)
        return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm))
      cm.display.pollingFast = false;
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm))
        cm.state.suppressEdits = true;
      if (dropShift)
        cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  // Collect the currently active keymaps.
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys)
      maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }
  var maybeTransition;
  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    // Handle automatic keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e))
      maybeTransition = setTimeout(function () {
        if (getKeyMap(cm.options.keyMap) == startMap) {
          cm.options.keyMap = next.call ? next.call(null, cm) : next;
          keyMapChanged(cm);
        }
      }, 50);
    var name = keyName(e, true), handled = false;
    if (!name)
      return false;
    var keymaps = allKeyMaps(cm);
    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey('Shift-' + name, keymaps, function (b) {
        return doHandleBinding(cm, b, true);
      }) || lookupKey(name, keymaps, function (b) {
        if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
          return doHandleBinding(cm, b);
      });
    } else {
      handled = lookupKey(name, keymaps, function (b) {
        return doHandleBinding(cm, b);
      });
    }
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, 'keyHandled', cm, name, e);
    }
    return handled;
  }
  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
        return doHandleBinding(cm, b, true);
      });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, 'keyHandled', cm, '\'' + ch + '\'', e);
    }
    return handled;
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e))
      return;
    // IE does strange things with escape.
    if (ie_upto10 && e.keyCode == 27)
      e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection('', null, 'cut');
    }
    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }
  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, 'CodeMirror-crosshair');
    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, 'CodeMirror-crosshair');
        off(document, 'keyup', up);
        off(document, 'mouseover', up);
      }
    }
    on(document, 'keyup', up);
    on(document, 'mouseover', up);
  }
  function onKeyUp(e) {
    if (signalDOMEvent(this, e))
      return;
    if (e.keyCode == 16)
      this.doc.sel.shift = false;
  }
  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e))
      return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if ((presto && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
      return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch))
      return;
    if (ie && !ie_upto8)
      cm.display.inputHasSelection = null;
    fastPoll(cm);
  }
  // FOCUS/BLUR EVENTS
  function onFocus(cm) {
    if (cm.options.readOnly == 'nocursor')
      return;
    if (!cm.state.focused) {
      signal(cm, 'focus', cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, 'CodeMirror-focused');
      // The prevInput test prevents this from firing when a context
      // menu is closed (since the resetInput would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        resetInput(cm);
        if (webkit)
          setTimeout(bind(resetInput, cm, true), 0);  // Issue #1730
      }
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, 'blur', cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, 'CodeMirror-focused');
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused)
        cm.display.shift = false;
    }, 150);
  }
  // CONTEXT MENU HANDLING
  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, 'contextmenu'))
      return;
    var display = cm.display;
    if (eventInWidget(display, e) || contextMenuInGutter(cm, e))
      return;
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto)
      return;
    // Opera is difficult.
    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = 'absolute';
    display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: ' + (ie ? 'rgba(255, 255, 255, .05)' : 'transparent') + '; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);';
    focusInput(cm);
    resetInput(cm);
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected())
      display.input.value = display.prevInput = ' ';
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);
    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = display.input.value = '\u200b' + (selected ? display.input.value : '');
        display.prevInput = selected ? '' : '\u200b';
        display.input.selectionStart = 1;
        display.input.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      display.inputDiv.style.position = 'relative';
      display.input.style.cssText = oldCSS;
      if (ie_upto8)
        display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);
      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_upto8)
          prepareSelectAllHack();
        var i = 0, poll = function () {
            if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10)
              display.detectingSelectAll = setTimeout(poll, 500);
            else
              resetInput(cm);
          };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && !ie_upto8)
      prepareSelectAllHack();
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, 'mouseup', mouseup);
        setTimeout(rehide, 20);
      };
      on(window, 'mouseup', mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, 'gutterContextMenu'))
      return false;
    return gutterEvent(cm, e, 'gutterContextMenu', false, signal);
  }
  // UPDATING
  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function (change) {
      if (!change.text)
        return change.to;
      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    };
  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0)
      return pos;
    if (cmp(pos, change.to) <= 0)
      return changeEnd(change);
    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line)
      ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }
  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }
  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }
  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == 'around') {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }
  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function () {
          this.canceled = true;
        }
      };
    if (update)
      obj.update = function (from, to, text, origin) {
        if (from)
          this.from = clipPos(doc, from);
        if (to)
          this.to = clipPos(doc, to);
        if (text)
          this.text = text;
        if (origin !== undefined)
          this.origin = origin;
      };
    signal(doc, 'beforeChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeChange', doc.cm, obj);
    if (obj.canceled)
      return null;
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }
  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp)
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits)
        return;
    }
    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
      change = filterChange(doc, change, true);
      if (!change)
        return;
    }
    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {
          from: split[i].from,
          to: split[i].to,
          text: i ? [''] : change.text
        });
    } else {
      makeChangeInner(doc, change);
    }
  }
  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == '' && cmp(change.from, change.to) == 0)
      return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }
  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits)
      return;
    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == 'undo' ? hist.done : hist.undone, dest = type == 'undo' ? hist.undone : hist.done;
    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length)
      return;
    hist.lastOrigin = hist.lastSelOrigin = null;
    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, { clearRedo: false });
          return;
        }
        selAfter = event;
      } else
        break;
    }
    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({
      changes: antiChanges,
      generation: hist.generation
    });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');
    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }
      antiChanges.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change, null) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm)
        doc.cm.scrollIntoView(change);
      var rebased = [];
      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }
  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0)
      return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, 'gutter');
    }
  }
  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine())
      return;
    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter)
      selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm)
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    else
      updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }
  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);
    updateDoc(doc, change, spans, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength)
        cm.curOp.updateMaxLine = true;
    }
    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, 'text');
    else
      regChange(cm, from.line, to.line + 1, lendiff);
    var changesHandler = hasHandler(cm, 'changes'), changeHandler = hasHandler(cm, 'change');
    if (changeHandler || changesHandler) {
      var obj = {
          from: from,
          to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
      if (changeHandler)
        signalLater(cm, 'change', cm, obj);
      if (changesHandler)
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to)
      to = from;
    if (cmp(to, from) < 0) {
      var tmp = to;
      to = from;
      from = tmp;
    }
    if (typeof code == 'string')
      code = splitLines(code);
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    });
  }
  // SCROLLING THINGS INTO VIEW
  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0)
      doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
      doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt('div', '\u200b', null, 'position: absolute; top: ' + (coords.top - display.viewOffset - paddingTop(cm.display)) + 'px; height: ' + (coords.bottom - coords.top + scrollerCutOff) + 'px; left: ' + coords.left + 'px; width: 2px;');
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }
  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null)
      margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1)
          changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
          changed = true;
      }
      if (!changed)
        return coords;
    }
  }
  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null)
      setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null)
      setScrollLeft(cm, scrollPos.scrollLeft);
  }
  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0)
      y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop)
        result.scrollTop = newTop;
    }
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = display.scroller.clientWidth - scrollerCutOff;
    x1 += display.gutters.offsetWidth;
    x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft)
        x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }
  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null)
      resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }
  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {
      from: from,
      to: to,
      margin: cm.options.cursorScrollMargin,
      isCursor: true
    };
  }
  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }
  // API UTILITIES
  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null)
      how = 'add';
    if (how == 'smart') {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!cm.doc.mode.indent)
        how = 'prev';
      else
        state = getStateBefore(cm, n);
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter)
      line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = 'not';
    } else if (how == 'smart') {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive)
          return;
        how = 'prev';
      }
    }
    if (how == 'prev') {
      if (n > doc.first)
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      else
        indentation = 0;
    } else if (how == 'add') {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == 'subtract') {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == 'number') {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);
    var indentString = '', pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += '\t';
      }
    if (pos < indentation)
      indentString += spaceStr(indentation - pos);
    if (indentString != curSpaceString) {
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }
  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(cm, handle, changeType, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == 'number')
      line = getLine(doc, clipLine(doc, handle));
    else
      no = lineNo(handle);
    if (no == null)
      return null;
    if (op(line, no))
      regLineChange(cm, no, changeType);
    return line;
  }
  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, '', kill[i].from, kill[i].to, '+delete');
      ensureCursorVisible(cm);
    });
  }
  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size)
        return possible = false;
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually)
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else
            ch = dir < 0 ? lineObj.text.length : 0;
        } else
          return possible = false;
      } else
        ch = next;
      return true;
    }
    if (unit == 'char')
      moveOnce();
    else if (unit == 'column')
      moveOnce(true);
    else if (unit == 'word' || unit == 'group') {
      var sawType = null, group = unit == 'group';
      var helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first))
          break;
        var cur = lineObj.text.charAt(ch) || '\n';
        var type = isWordChar(cur, helper) ? 'w' : group && cur == '\n' ? 'n' : !group || /\s/.test(cur) ? null : 'p';
        if (group && !first && !type)
          type = 's';
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
          }
          break;
        }
        if (type)
          sawType = type;
        if (dir > 0 && !moveOnce(!first))
          break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible)
      result.hitSide = true;
    return result;
  }
  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == 'page') {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
    } else if (unit == 'line') {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside)
        break;
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  // Find the word at the given position (as returned by coordsChar).
  function findWordAt(cm, pos) {
    var doc = cm.doc, line = getLine(doc, pos.line).text;
    var start = pos.ch, end = pos.ch;
    if (line) {
      var helper = cm.getHelper(pos, 'wordChars');
      if ((pos.xRel < 0 || end == line.length) && start)
        --start;
      else
        ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar, helper) ? function (ch) {
          return isWordChar(ch, helper);
        } : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !isWordChar(ch);
        };
      while (start > 0 && check(line.charAt(start - 1)))
        --start;
      while (end < line.length && check(line.charAt(end)))
        ++end;
    }
    return new Range(Pos(pos.line, start), Pos(pos.line, end));
  }
  // EDITOR METHODS
  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.
  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.
  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function () {
      window.focus();
      focusInput(this);
      fastPoll(this);
    },
    setOption: function (option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != 'mode')
        return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },
    getOption: function (option) {
      return this.options[option];
    },
    getDoc: function () {
      return this.doc;
    },
    addKeyMap: function (map, bottom) {
      this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
    },
    removeKeyMap: function (map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || typeof maps[i] != 'string' && maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },
    addOverlay: methodOp(function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState)
        throw new Error('Overlays may not be stateful.');
      this.state.overlays.push({
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque
      });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function (spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == 'string' && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: methodOp(function (n, dir, aggressive) {
      if (typeof dir != 'string' && typeof dir != 'number') {
        if (dir == null)
          dir = this.options.smartIndent ? 'smart' : 'prev';
        else
          dir = dir ? 'add' : 'subtract';
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function (how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var start = Math.max(end, range.from().line);
          var to = range.to();
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex)
            ensureCursorVisible(this);
        }
      }
    }),
    getTokenAt: function (pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = readToken(mode, stream, state);
      }
      return {
        start: stream.start,
        end: stream.pos,
        string: stream.current(),
        type: style || null,
        state: state
      };
    },
    getTokenTypeAt: function (pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0)
        type = styles[2];
      else
        for (;;) {
          var mid = before + after >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
            after = mid;
          else if (styles[mid * 2 + 1] < ch)
            before = mid + 1;
          else {
            type = styles[mid * 2 + 2];
            break;
          }
        }
      var cut = type ? type.indexOf('cm-overlay ') : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },
    getModeAt: function (pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode)
        return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },
    getHelper: function (pos, type) {
      return this.getHelpers(pos, type)[0];
    },
    getHelpers: function (pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type))
        return helpers;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == 'string') {
        if (help[mode[type]])
          found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val)
            found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },
    getStateAfter: function (line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getStateBefore(this, line + 1, precise);
    },
    cursorCoords: function (start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null)
        pos = range.head;
      else if (typeof start == 'object')
        pos = clipPos(this.doc, start);
      else
        pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || 'page');
    },
    charCoords: function (pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || 'page');
    },
    coordsChar: function (coords, mode) {
      coords = fromCoordSystem(this, coords, mode || 'page');
      return coordsChar(this, coords.left, coords.top);
    },
    lineAtHeight: function (height, mode) {
      height = fromCoordSystem(this, {
        top: height,
        left: 0
      }, mode || 'page').top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function (line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first)
        line = this.doc.first;
      else if (line > last) {
        line = last;
        end = true;
      }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {
        top: 0,
        left: 0
      }, mode || 'page').top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },
    defaultTextHeight: function () {
      return textHeight(this.display);
    },
    defaultCharWidth: function () {
      return charWidth(this.display);
    },
    setGutterMarker: methodOp(function (line, gutterID, value) {
      return changeLine(this, line, 'gutter', function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers))
          line.gutterMarkers = null;
        return true;
      });
    }),
    clearGutter: methodOp(function (gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, 'gutter');
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
        }
        ++i;
      });
    }),
    addLineClass: methodOp(function (handle, where, cls) {
      return changeLine(this, handle, 'class', function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        if (!line[prop])
          line[prop] = cls;
        else if (new RegExp('(?:^|\\s)' + cls + '(?:$|\\s)').test(line[prop]))
          return false;
        else
          line[prop] += ' ' + cls;
        return true;
      });
    }),
    removeLineClass: methodOp(function (handle, where, cls) {
      return changeLine(this, handle, 'class', function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        var cur = line[prop];
        if (!cur)
          return false;
        else if (cls == null)
          line[prop] = null;
        else {
          var found = cur.match(new RegExp('(?:^|\\s+)' + cls + '(?:$|\\s+)'));
          if (!found)
            return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
        }
        return true;
      });
    }),
    addLineWidget: methodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    lineInfo: function (line) {
      if (typeof line == 'number') {
        if (!isLine(this.doc, line))
          return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line)
          return null;
      } else {
        var n = lineNo(line);
        if (n == null)
          return null;
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    getViewport: function () {
      return {
        from: this.display.viewFrom,
        to: this.display.viewTo
      };
    },
    addWidget: function (pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = 'absolute';
      display.sizer.appendChild(node);
      if (vert == 'over') {
        top = pos.top;
      } else if (vert == 'above' || vert == 'near') {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + 'px';
      node.style.left = node.style.right = '';
      if (horiz == 'right') {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = '0px';
      } else {
        if (horiz == 'left')
          left = 0;
        else if (horiz == 'middle')
          left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + 'px';
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },
    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: methodOp(onKeyUp),
    execCommand: function (cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },
    findPosH: function (from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: methodOp(function (dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function (range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),
    deleteH: methodOp(function (dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection('', null, '+delete');
      else
        deleteNearSelection(this, function (range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {
            from: other,
            to: range.head
          } : {
            from: range.head,
            to: other
          };
        });
    }),
    findPosV: function (from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, 'div');
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: methodOp(function (dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function (range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, 'div');
        if (range.goalColumn != null)
          headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == 'page' && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, 'div').top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length)
        for (var i = 0; i < doc.sel.ranges.length; i++)
          doc.sel.ranges[i].goalColumn = goals[i];
    }),
    toggleOverwrite: function (value) {
      if (value != null && value == this.state.overwrite)
        return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, 'CodeMirror-overwrite');
      else
        rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');
      signal(this, 'overwriteToggle', this, this.state.overwrite);
    },
    hasFocus: function () {
      return activeElt() == this.display.input;
    },
    scrollTo: methodOp(function (x, y) {
      if (x != null || y != null)
        resolveScrollToPos(this);
      if (x != null)
        this.curOp.scrollLeft = x;
      if (y != null)
        this.curOp.scrollTop = y;
    }),
    getScrollInfo: function () {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - co,
        width: scroller.scrollWidth - co,
        clientHeight: scroller.clientHeight - co,
        clientWidth: scroller.clientWidth - co
      };
    },
    scrollIntoView: methodOp(function (range, margin) {
      if (range == null) {
        range = {
          from: this.doc.sel.primary().head,
          to: null
        };
        if (margin == null)
          margin = this.options.cursorScrollMargin;
      } else if (typeof range == 'number') {
        range = {
          from: Pos(range, 0),
          to: null
        };
      } else if (range.from == null) {
        range = {
          from: range,
          to: null
        };
      }
      if (!range.to)
        range.to = range.from;
      range.margin = margin || 0;
      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),
    setSize: methodOp(function (width, height) {
      function interpret(val) {
        return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
      }
      if (width != null)
        this.display.wrapper.style.width = interpret(width);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping)
        clearLineMeasurementCache(this);
      this.curOp.forceUpdate = true;
      signal(this, 'refresh', this);
    }),
    operation: function (f) {
      return runInOp(this, f);
    },
    refresh: methodOp(function () {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5)
        estimateLineHeights(this);
      signal(this, 'refresh', this);
    }),
    swapDoc: methodOp(function (doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this);
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      signalLater(this, 'swapDoc', this, old);
      return old;
    }),
    getInputField: function () {
      return this.display.input;
    },
    getWrapperElement: function () {
      return this.display.wrapper;
    },
    getScrollerElement: function () {
      return this.display.scroller;
    },
    getGutterElement: function () {
      return this.display.gutters;
    }
  };
  eventMixin(CodeMirror);
  // OPTION DEFAULTS
  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};
  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle)
      optionHandlers[name] = notOnInit ? function (cm, val, old) {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {
      toString: function () {
        return 'CodeMirror.Init';
      }
    };
  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option('value', '', function (cm, val) {
    cm.setValue(val);
  }, true);
  option('mode', null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option('indentUnit', 2, loadMode, true);
  option('indentWithTabs', false);
  option('smartIndent', true);
  option('tabSize', 4, function (cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option('specialChars', /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\ufeff]/g, function (cm, val) {
    cm.options.specialChars = new RegExp(val.source + (val.test('\t') ? '' : '|\t'), 'g');
    cm.refresh();
  }, true);
  option('specialCharPlaceholder', defaultSpecialCharPlaceholder, function (cm) {
    cm.refresh();
  }, true);
  option('electricChars', true);
  option('rtlMoveVisually', !windows);
  option('wholeLineUpdateBefore', true);
  option('theme', 'default', function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option('keyMap', 'default', keyMapChanged);
  option('extraKeys', null);
  option('lineWrapping', false, wrappingChanged, true);
  option('gutters', [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('fixedGutter', true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
    cm.refresh();
  }, true);
  option('coverGutterNextToScrollbar', false, updateScrollbars, true);
  option('lineNumbers', false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('firstLineNumber', 1, guttersChanged, true);
  option('lineNumberFormatter', function (integer) {
    return integer;
  }, guttersChanged, true);
  option('showCursorWhenSelecting', false, updateSelection, true);
  option('resetSelectionOnContextMenu', true);
  option('readOnly', false, function (cm, val) {
    if (val == 'nocursor') {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val)
        resetInput(cm);
    }
  });
  option('disableInput', false, function (cm, val) {
    if (!val)
      resetInput(cm);
  }, true);
  option('dragDrop', true);
  option('cursorBlinkRate', 530);
  option('cursorScrollMargin', 0);
  option('cursorHeight', 1);
  option('workTime', 100);
  option('workDelay', 100);
  option('flattenSpans', true, resetModeState, true);
  option('addModeClass', false, resetModeState, true);
  option('pollInterval', 100);
  option('undoDepth', 200, function (cm, val) {
    cm.doc.history.undoDepth = val;
  });
  option('historyEventDelay', 1250);
  option('viewportMargin', 10, function (cm) {
    cm.refresh();
  }, true);
  option('maxHighlightLength', 10000, resetModeState, true);
  option('moveInputWithCursor', true, function (cm, val) {
    if (!val)
      cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });
  option('tabindex', null, function (cm, val) {
    cm.display.input.tabIndex = val || '';
  });
  option('autofocus', null);
  // MODE DEFINITION AND QUERYING
  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function (name, mode) {
    if (!CodeMirror.defaults.mode && name != 'null')
      CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i)
        mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function (mime, spec) {
    mimeModes[mime] = spec;
  };
  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function (spec) {
    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == 'string')
        found = { name: found };
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode('application/xml');
    }
    if (typeof spec == 'string')
      return { name: spec };
    else
      return spec || { name: 'null' };
  };
  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function (options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory)
      return CodeMirror.getMode(options, 'text/plain');
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop))
          continue;
        if (modeObj.hasOwnProperty(prop))
          modeObj['_' + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType)
      modeObj.helperType = spec.helperType;
    if (spec.modeProps)
      for (var prop in spec.modeProps)
        modeObj[prop] = spec.modeProps[prop];
    return modeObj;
  };
  // Minimal default mode.
  CodeMirror.defineMode('null', function () {
    return {
      token: function (stream) {
        stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME('text/plain', 'null');
  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function (mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  };
  // EXTENSIONS
  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;
  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    initHooks.push(f);
  };
  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function (type, name, value) {
    if (!helpers.hasOwnProperty(type))
      helpers[type] = CodeMirror[type] = { _global: [] };
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({
      pred: predicate,
      val: value
    });
  };
  // MODE STATE HANDLING
  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.
  var copyState = CodeMirror.copyState = function (mode, state) {
      if (state === true)
        return state;
      if (mode.copyState)
        return mode.copyState(state);
      var nstate = {};
      for (var n in state) {
        var val = state[n];
        if (val instanceof Array)
          val = val.concat([]);
        nstate[n] = val;
      }
      return nstate;
    };
  var startState = CodeMirror.startState = function (mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true;
    };
  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function (mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode)
        break;
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  };
  // STANDARD COMMANDS
  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
      selectAll: function (cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      },
      singleSelection: function (cm) {
        cm.setSelection(cm.getCursor('anchor'), cm.getCursor('head'), sel_dontScroll);
      },
      killLine: function (cm) {
        deleteNearSelection(cm, function (range) {
          if (range.empty()) {
            var len = getLine(cm.doc, range.head.line).text.length;
            if (range.head.ch == len && range.head.line < cm.lastLine())
              return {
                from: range.head,
                to: Pos(range.head.line + 1, 0)
              };
            else
              return {
                from: range.head,
                to: Pos(range.head.line, len)
              };
          } else {
            return {
              from: range.from(),
              to: range.to()
            };
          }
        });
      },
      deleteLine: function (cm) {
        deleteNearSelection(cm, function (range) {
          return {
            from: Pos(range.from().line, 0),
            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
          };
        });
      },
      delLineLeft: function (cm) {
        deleteNearSelection(cm, function (range) {
          return {
            from: Pos(range.from().line, 0),
            to: range.from()
          };
        });
      },
      undo: function (cm) {
        cm.undo();
      },
      redo: function (cm) {
        cm.redo();
      },
      undoSelection: function (cm) {
        cm.undoSelection();
      },
      redoSelection: function (cm) {
        cm.redoSelection();
      },
      goDocStart: function (cm) {
        cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function (cm) {
        cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function (cm) {
        cm.extendSelectionsBy(function (range) {
          return lineStart(cm, range.head.line);
        }, sel_move);
      },
      goLineStartSmart: function (cm) {
        cm.extendSelectionsBy(function (range) {
          var start = lineStart(cm, range.head.line);
          var line = cm.getLineHandle(start.line);
          var order = getOrder(line);
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(0, line.text.search(/\S/));
            var inWS = range.head.line == start.line && range.head.ch <= firstNonWS && range.head.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS);
          }
          return start;
        }, sel_move);
      },
      goLineEnd: function (cm) {
        cm.extendSelectionsBy(function (range) {
          return lineEnd(cm, range.head.line);
        }, sel_move);
      },
      goLineRight: function (cm) {
        cm.extendSelectionsBy(function (range) {
          var top = cm.charCoords(range.head, 'div').top + 5;
          return cm.coordsChar({
            left: cm.display.lineDiv.offsetWidth + 100,
            top: top
          }, 'div');
        }, sel_move);
      },
      goLineLeft: function (cm) {
        cm.extendSelectionsBy(function (range) {
          var top = cm.charCoords(range.head, 'div').top + 5;
          return cm.coordsChar({
            left: 0,
            top: top
          }, 'div');
        }, sel_move);
      },
      goLineUp: function (cm) {
        cm.moveV(-1, 'line');
      },
      goLineDown: function (cm) {
        cm.moveV(1, 'line');
      },
      goPageUp: function (cm) {
        cm.moveV(-1, 'page');
      },
      goPageDown: function (cm) {
        cm.moveV(1, 'page');
      },
      goCharLeft: function (cm) {
        cm.moveH(-1, 'char');
      },
      goCharRight: function (cm) {
        cm.moveH(1, 'char');
      },
      goColumnLeft: function (cm) {
        cm.moveH(-1, 'column');
      },
      goColumnRight: function (cm) {
        cm.moveH(1, 'column');
      },
      goWordLeft: function (cm) {
        cm.moveH(-1, 'word');
      },
      goGroupRight: function (cm) {
        cm.moveH(1, 'group');
      },
      goGroupLeft: function (cm) {
        cm.moveH(-1, 'group');
      },
      goWordRight: function (cm) {
        cm.moveH(1, 'word');
      },
      delCharBefore: function (cm) {
        cm.deleteH(-1, 'char');
      },
      delCharAfter: function (cm) {
        cm.deleteH(1, 'char');
      },
      delWordBefore: function (cm) {
        cm.deleteH(-1, 'word');
      },
      delWordAfter: function (cm) {
        cm.deleteH(1, 'word');
      },
      delGroupBefore: function (cm) {
        cm.deleteH(-1, 'group');
      },
      delGroupAfter: function (cm) {
        cm.deleteH(1, 'group');
      },
      indentAuto: function (cm) {
        cm.indentSelection('smart');
      },
      indentMore: function (cm) {
        cm.indentSelection('add');
      },
      indentLess: function (cm) {
        cm.indentSelection('subtract');
      },
      insertTab: function (cm) {
        cm.replaceSelection('\t');
      },
      insertSoftTab: function (cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i = 0; i < ranges.length; i++) {
          var pos = ranges[i].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(new Array(tabSize - col % tabSize + 1).join(' '));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected())
          cm.indentSelection('add');
        else
          cm.execCommand('insertTab');
      },
      transposeChars: function (cm) {
        runInOp(cm, function () {
          var ranges = cm.listSelections(), newSel = [];
          for (var i = 0; i < ranges.length; i++) {
            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length)
                cur = new Pos(cur.line, cur.ch - 1);
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, '+transpose');
              } else if (cur.line > cm.doc.first) {
                var prev = getLine(cm.doc, cur.line - 1).text;
                if (prev)
                  cm.replaceRange(line.charAt(0) + '\n' + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), '+transpose');
              }
            }
            newSel.push(new Range(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function (cm) {
        runInOp(cm, function () {
          var len = cm.listSelections().length;
          for (var i = 0; i < len; i++) {
            var range = cm.listSelections()[i];
            cm.replaceRange('\n', range.anchor, range.head, '+input');
            cm.indentLine(range.from().line + 1, null, true);
            ensureCursorVisible(cm);
          }
        });
      },
      toggleOverwrite: function (cm) {
        cm.toggleOverwrite();
      }
    };
  // STANDARD KEYMAPS
  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    'Left': 'goCharLeft',
    'Right': 'goCharRight',
    'Up': 'goLineUp',
    'Down': 'goLineDown',
    'End': 'goLineEnd',
    'Home': 'goLineStartSmart',
    'PageUp': 'goPageUp',
    'PageDown': 'goPageDown',
    'Delete': 'delCharAfter',
    'Backspace': 'delCharBefore',
    'Shift-Backspace': 'delCharBefore',
    'Tab': 'defaultTab',
    'Shift-Tab': 'indentAuto',
    'Enter': 'newlineAndIndent',
    'Insert': 'toggleOverwrite',
    'Esc': 'singleSelection'
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    'Ctrl-A': 'selectAll',
    'Ctrl-D': 'deleteLine',
    'Ctrl-Z': 'undo',
    'Shift-Ctrl-Z': 'redo',
    'Ctrl-Y': 'redo',
    'Ctrl-Home': 'goDocStart',
    'Ctrl-Up': 'goDocStart',
    'Ctrl-End': 'goDocEnd',
    'Ctrl-Down': 'goDocEnd',
    'Ctrl-Left': 'goGroupLeft',
    'Ctrl-Right': 'goGroupRight',
    'Alt-Left': 'goLineStart',
    'Alt-Right': 'goLineEnd',
    'Ctrl-Backspace': 'delGroupBefore',
    'Ctrl-Delete': 'delGroupAfter',
    'Ctrl-S': 'save',
    'Ctrl-F': 'find',
    'Ctrl-G': 'findNext',
    'Shift-Ctrl-G': 'findPrev',
    'Shift-Ctrl-F': 'replace',
    'Shift-Ctrl-R': 'replaceAll',
    'Ctrl-[': 'indentLess',
    'Ctrl-]': 'indentMore',
    'Ctrl-U': 'undoSelection',
    'Shift-Ctrl-U': 'redoSelection',
    'Alt-U': 'redoSelection',
    fallthrough: 'basic'
  };
  keyMap.macDefault = {
    'Cmd-A': 'selectAll',
    'Cmd-D': 'deleteLine',
    'Cmd-Z': 'undo',
    'Shift-Cmd-Z': 'redo',
    'Cmd-Y': 'redo',
    'Cmd-Up': 'goDocStart',
    'Cmd-End': 'goDocEnd',
    'Cmd-Down': 'goDocEnd',
    'Alt-Left': 'goGroupLeft',
    'Alt-Right': 'goGroupRight',
    'Cmd-Left': 'goLineStart',
    'Cmd-Right': 'goLineEnd',
    'Alt-Backspace': 'delGroupBefore',
    'Ctrl-Alt-Backspace': 'delGroupAfter',
    'Alt-Delete': 'delGroupAfter',
    'Cmd-S': 'save',
    'Cmd-F': 'find',
    'Cmd-G': 'findNext',
    'Shift-Cmd-G': 'findPrev',
    'Cmd-Alt-F': 'replace',
    'Shift-Cmd-Alt-F': 'replaceAll',
    'Cmd-[': 'indentLess',
    'Cmd-]': 'indentMore',
    'Cmd-Backspace': 'delLineLeft',
    'Cmd-U': 'undoSelection',
    'Shift-Cmd-U': 'redoSelection',
    fallthrough: [
      'basic',
      'emacsy'
    ]
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    'Ctrl-F': 'goCharRight',
    'Ctrl-B': 'goCharLeft',
    'Ctrl-P': 'goLineUp',
    'Ctrl-N': 'goLineDown',
    'Alt-F': 'goWordRight',
    'Alt-B': 'goWordLeft',
    'Ctrl-A': 'goLineStart',
    'Ctrl-E': 'goLineEnd',
    'Ctrl-V': 'goPageDown',
    'Shift-Ctrl-V': 'goPageUp',
    'Ctrl-D': 'delCharAfter',
    'Ctrl-H': 'delCharBefore',
    'Alt-D': 'delWordAfter',
    'Alt-Backspace': 'delWordBefore',
    'Ctrl-K': 'killLine',
    'Ctrl-T': 'transposeChars'
  };
  keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
  // KEYMAP DISPATCH
  function getKeyMap(val) {
    if (typeof val == 'string')
      return keyMap[val];
    else
      return val;
  }
  // Given an array of keymaps and a key name, call handle on any
  // bindings found, until that returns a truthy value, at which point
  // we consider the key handled. Implements things like binding a key
  // to false stopping further handling and keymap fallthrough.
  var lookupKey = CodeMirror.lookupKey = function (name, maps, handle) {
      function lookup(map) {
        map = getKeyMap(map);
        var found = map[name];
        if (found === false)
          return 'stop';
        if (found != null && handle(found))
          return true;
        if (map.nofallthrough)
          return 'stop';
        var fallthrough = map.fallthrough;
        if (fallthrough == null)
          return false;
        if (Object.prototype.toString.call(fallthrough) != '[object Array]')
          return lookup(fallthrough);
        for (var i = 0; i < fallthrough.length; ++i) {
          var done = lookup(fallthrough[i]);
          if (done)
            return done;
        }
        return false;
      }
      for (var i = 0; i < maps.length; ++i) {
        var done = lookup(maps[i]);
        if (done)
          return done != 'stop';
      }
    };
  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function (event) {
      var name = keyNames[event.keyCode];
      return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
    };
  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function (event, noShift) {
      if (presto && event.keyCode == 34 && event['char'])
        return false;
      var name = keyNames[event.keyCode];
      if (name == null || event.altGraphKey)
        return false;
      if (event.altKey)
        name = 'Alt-' + name;
      if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
        name = 'Ctrl-' + name;
      if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
        name = 'Cmd-' + name;
      if (!noShift && event.shiftKey)
        name = 'Shift-' + name;
      return name;
    };
  // FROMTEXTAREA
  CodeMirror.fromTextArea = function (textarea, options) {
    if (!options)
      options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    if (textarea.form) {
      on(textarea.form, 'submit', save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
        } catch (e) {
        }
      }
    }
    textarea.style.display = 'none';
    var cm = CodeMirror(function (node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
    cm.save = save;
    cm.getTextArea = function () {
      return textarea;
    };
    cm.toTextArea = function () {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = '';
      if (textarea.form) {
        off(textarea.form, 'submit', save);
        if (typeof textarea.form.submit == 'function')
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };
  // STRING STREAM
  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.
  var StringStream = CodeMirror.StringStream = function (string, tabSize) {
      this.pos = this.start = 0;
      this.string = string;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
    };
  StringStream.prototype = {
    eol: function () {
      return this.pos >= this.string.length;
    },
    sol: function () {
      return this.pos == this.lineStart;
    },
    peek: function () {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function (match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == 'string')
        var ok = ch == match;
      else
        var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {
        ++this.pos;
        return ch;
      }
    },
    eatWhile: function (match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    },
    eatSpace: function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function () {
      this.pos = this.string.length;
    },
    skipTo: function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },
    backUp: function (n) {
      this.pos -= n;
    },
    column: function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function () {
      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function (pattern, consume, caseInsensitive) {
      if (typeof pattern == 'string') {
        var cased = function (str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0)
          return null;
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },
    current: function () {
      return this.string.slice(this.start, this.pos);
    },
    hideFirstChars: function (n, inner) {
      this.lineStart += n;
      try {
        return inner();
      } finally {
        this.lineStart -= n;
      }
    }
  };
  // TEXTMARKERS
  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.
  var TextMarker = CodeMirror.TextMarker = function (doc, type) {
      this.lines = [];
      this.type = type;
      this.doc = doc;
    };
  eventMixin(TextMarker);
  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    if (hasHandler(this, 'clear')) {
      var found = this.find();
      if (found)
        signalLater(this, 'clear', found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed)
        regLineChange(cm, lineNo(line), 'text');
      else if (cm) {
        if (span.to != null)
          max = lineNo(line);
        if (span.from != null)
          min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(this.lines[i]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min != null && cm && this.collapsed)
      regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm.doc);
    }
    if (cm)
      signalLater(cm, 'markerCleared', cm, this);
    if (withOp)
      endOperation(cm);
    if (this.parent)
      this.parent.clear();
  };
  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == 'bookmark')
      side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1)
          return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1)
          return to;
      }
    }
    return from && {
      from: from,
      to: to
    };
  };
  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm)
      return;
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;
  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared)
      return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, markText)(doc, from, to, options, type);
    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options)
      copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt('span', [marker.replacedWith], 'CodeMirror-widget');
      if (!options.handleMouseEvents)
        marker.widgetNode.ignoreEvents = true;
      if (options.insertLeft)
        marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error('Inserting collapsed marker partially overlapping an existing one');
      sawCollapsedSpans = true;
    }
    if (marker.addToHistory)
      addChangeToHistory(doc, {
        from: from,
        to: to,
        origin: 'markText'
      }, doc.sel, NaN);
    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line)
        updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed)
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line))
          updateLineHeight(line, 0);
      });
    if (marker.clearOnEnter)
      on(marker, 'beforeCursorEnter', function () {
        marker.clear();
      });
    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine)
        cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
        for (var i = from.line; i <= to.line; i++)
          regLineChange(cm, i, 'text');
      if (marker.atomic)
        reCheckSelection(cm.doc);
      signalLater(cm, 'markerAdded', cm, marker);
    }
    return marker;
  }
  // SHARED TEXTMARKERS
  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function (markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i = 0; i < markers.length; ++i)
        markers[i].parent = this;
    };
  eventMixin(SharedTextMarker);
  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, 'clear');
  };
  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget)
        options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent)
          return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }
  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }
  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];
      ;
      linkedDocs(marker.primary.doc, function (d) {
        linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }
  // TEXTMARKER SPANS
  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  }
  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans)
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker)
          return span;
      }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span)
        (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }
  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    return nw;
  }
  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast)
      return null;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found)
            span.to = startCh;
          else if (sameLine)
            span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null)
          span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine)
              (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first)
      first = clearEmptySpans(first);
    if (last && last != first)
      last = clearEmptySpans(last);
    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }
  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length)
      return null;
    return spans;
  }
  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old)
      return stretched;
    if (!stretched)
      return old;
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans:
          for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker)
                continue spans;
            oldCur.push(span);
          }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }
  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans)
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
    });
    if (!markers)
      return null;
    var parts = [{
          from: from,
          to: to
        }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)
          continue;
        var newParts = [
            j,
            1
          ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({
            from: p.from,
            to: m.from
          });
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({
            from: m.to,
            to: p.to
          });
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }
  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }
  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }
  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0)
      return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp)
      return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp)
      return toCmp;
    return b.id - a.id;
  }
  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
          found = sp.marker;
      }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }
  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
          continue;
        if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 || fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)
          return true;
      }
  }
  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }
  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }
  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis)
      return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine())
      return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line))
      return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }
  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if (sp.from == null)
          return true;
        if (sp.marker.widgetNode)
          continue;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  // LINE WIDGETS
  // Line widgets are block elements displayed above or below a line.
  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
      if (options)
        for (var opt in options)
          if (options.hasOwnProperty(opt))
            this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
  eventMixin(LineWidget);
  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }
  LineWidget.prototype.clear = function () {
    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws)
      return;
    for (var i = 0; i < ws.length; ++i)
      if (ws[i] == this)
        ws.splice(i--, 1);
    if (!ws.length)
      line.widgets = null;
    var height = widgetHeight(this);
    runInOp(cm, function () {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, 'widget');
      updateLineHeight(line, Math.max(0, line.height - height));
    });
  };
  LineWidget.prototype.changed = function () {
    var oldH = this.height, cm = this.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    runInOp(cm, function () {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      updateLineHeight(line, line.height + diff);
    });
  };
  function widgetHeight(widget) {
    if (widget.height != null)
      return widget.height;
    if (!contains(document.body, widget.node))
      removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
    return widget.height = widget.node.offsetHeight;
  }
  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll)
      cm.display.alignWidgets = true;
    changeLine(cm, handle, 'widget', function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null)
        widgets.push(widget);
      else
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line)) {
        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }
  // LINE DATA STRUCTURE
  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
      this.text = text;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight ? estimateHeight(this) : 1;
    };
  eventMixin(Line);
  Line.prototype.lineNo = function () {
    return lineNo(this);
  };
  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
    if (line.order != null)
      line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  }
  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  function extractLineClasses(type, output) {
    if (type)
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass)
          break;
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? 'bgClass' : 'textClass';
        if (output[prop] == null)
          output[prop] = lineClass[2];
        else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(output[prop]))
          output[prop] += ' ' + lineClass[2];
      }
    return type;
  }
  function callBlankLine(mode, state) {
    if (mode.blankLine)
      return mode.blankLine(state);
    if (!mode.innerMode)
      return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine)
      return inner.mode.blankLine(inner.state);
  }
  function readToken(mode, stream, state) {
    for (var i = 0; i < 10; i++) {
      var style = mode.token(stream, state);
      if (stream.pos > stream.start)
        return style;
    }
    throw new Error('Mode ' + mode.name + ' failed to advance stream.');
  }
  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null)
      flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == '')
      extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd)
          processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state), lineClasses);
      }
      if (cm.options.addModeClass) {
        var mName = CodeMirror.innerMode(mode, state).mode.name;
        if (mName)
          style = 'm-' + (style ? mName + ' ' + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start)
          f(stream.start, curStyle);
        curStart = stream.start;
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }
  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);
    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i + 1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style)
          return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, 'cm-overlay ' + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + ' ' : '') + 'cm-overlay ' + style;
          }
        }
      }, lineClasses);
    }
    return {
      styles: st,
      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
    };
  }
  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes)
        line.styleClasses = result.classes;
      else if (line.styleClasses)
        line.styleClasses = null;
    }
    return line.styles;
  }
  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == '')
      callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }
  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style))
      return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, 'cm-$&'));
  }
  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt('span', null, null, webkit ? 'padding-right: .1px' : null);
    var builder = {
        pre: elt('pre', [content]),
        content: content,
        col: 0,
        pos: 0,
        cm: cm
      };
    lineView.measure = {};
    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if ((ie || webkit) && cm.getOption('lineWrapping'))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      insertLineContent(line, builder, getLineStyles(cm, line));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || '');
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || '');
      }
      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }
    signal(cm, 'renderLine', cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || '');
    return builder;
  }
  function defaultSpecialCharPlaceholder(ch) {
    var token = elt('span', '\u2022', 'cm-invalidchar');
    token.title = '\\u' + ch.charCodeAt(0).toString(16);
    return token;
  }
  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text)
      return;
    var special = builder.cm.options.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie_upto8)
        mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(text.slice(pos, pos + skipped));
          if (ie_upto8)
            content.appendChild(elt('span', [txt]));
          else
            content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m)
          break;
        pos += skipped + 1;
        if (m[0] == '\t') {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          if (ie_upto8)
            content.appendChild(elt('span', [txt]));
          else
            content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap) {
      var fullStyle = style || '';
      if (startStyle)
        fullStyle += startStyle;
      if (endStyle)
        fullStyle += endStyle;
      var token = elt('span', [content], fullStyle);
      if (title)
        token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }
  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = ' ';
      for (var i = 0; i < old.length - 2; ++i)
        out += i % 2 ? ' ' : '\xa0';
      out += ' ';
      return out;
    }
    return function (builder, text, style, startStyle, endStyle, title) {
      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
    };
  }
  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, title) {
      style = style ? style + ' cm-force-border' : 'cm-force-border';
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start)
            break;
        }
        if (part.to >= end)
          return inner(builder, text, style, startStyle, endStyle, title);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }
  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i += 2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));
      return;
    }
    var len = allText.length, pos = 0, i = 1, text = '', style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = '';
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = '';
            }
            if (m.className)
              spanStyle += ' ' + m.className;
            if (m.startStyle && sp.from == pos)
              spanStartStyle += ' ' + m.startStyle;
            if (m.endStyle && sp.to == nextChange)
              spanEndStyle += ' ' + m.endStyle;
            if (m.title && !title)
              title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == 'bookmark' && sp.from == pos && m.widgetNode)
            foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
          if (collapsed.to == null)
            return;
        }
        if (!collapsed && foundBookmarks.length)
          for (var j = 0; j < foundBookmarks.length; ++j)
            buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len)
        break;
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', title);
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = '';
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }
  // DOCUMENT DATA STRUCTURE
  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == '' && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }
  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, 'change', line, change);
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    // Adjust the line structure
    if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines)
        doc.remove(from.line, nlines);
      if (added.length)
        doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1)
        doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }
    signalLater(doc, 'change', doc, change);
  }
  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, 'delete');
      }
      this.lines.splice(at, n);
    },
    collapse: function (lines) {
      lines.push.apply(lines, this.lines);
    },
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i)
        lines[i].parent = this;
    },
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at]))
          return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },
    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function (lines) {
      for (var i = 0; i < this.children.length; ++i)
        this.children[i].collapse(lines);
    },
    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function () {
      if (this.children.length <= 10)
        return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [
            copy,
            sibling
          ];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function (at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op))
            return true;
          if ((n -= used) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
    }
  };
  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
      if (!(this instanceof Doc))
        return new Doc(text, mode, firstLine);
      if (firstLine == null)
        firstLine = 0;
      BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = simpleSelection(start);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode;
      if (typeof text == 'string')
        text = splitLines(text);
      updateDoc(this, {
        from: start,
        to: start,
        text: text
      });
      setSelection(this, simpleSelection(start), sel_dontScroll);
    };
  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    iter: function (from, to, op) {
      if (op)
        this.iterN(from - this.first, to - from, op);
      else
        this.iterN(this.first, this.first + this.size, from);
    },
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i)
        height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: splitLines(code),
        origin: 'setValue'
      }, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function (line) {
      if (isLine(this, line))
        return getLine(this, line);
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function (line) {
      if (typeof line == 'number')
        line = getLine(this, line);
      return visualLine(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == 'head')
        pos = range.head;
      else if (start == 'anchor')
        pos = range.anchor;
      else if (start == 'end' || start == 'to' || start === false)
        pos = range.to();
      else
        pos = range.from();
      return pos;
    },
    listSelections: function () {
      return this.sel.ranges;
    },
    somethingSelected: function () {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      if (!ranges.length)
        return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
      if (primary == null)
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),
    getSelection: function (lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false)
        return lines;
      else
        return lines.join(lineSep || '\n');
    },
    getSelections: function (lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false)
          sel = sel.join(lineSep || '\n');
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function (code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || '+input');
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {
          from: range.from(),
          to: range.to(),
          text: splitLines(code[i]),
          origin: origin
        };
      }
      var newSel = collapse && collapse != 'end' && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel)
        setSelectionReplaceHistory(this, newSel);
      else if (this.cm)
        ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, 'undo');
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, 'redo');
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, 'undo', true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, 'redo', true);
    }),
    setExtending: function (val) {
      this.extend = val;
    },
    getExtending: function () {
      return this.extend;
    },
    historySize: function () {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++)
        if (!hist.done[i].ranges)
          ++done;
      for (var i = 0; i < hist.undone.length; i++)
        if (!hist.undone[i].ranges)
          ++undone;
      return {
        undo: done,
        redo: undone
      };
    },
    clearHistory: function () {
      this.history = new History(this.history.maxGeneration);
    },
    markClean: function () {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function (forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
    },
    setBookmark: function (pos, options) {
      var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft,
          clearWhenEmpty: false,
          shared: options && options.shared
        };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, 'bookmark');
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans)
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
      return markers;
    },
    findMarks: function (from, to, filter) {
      from = clipPos(this, from);
      to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans)
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(lineNo == from.line && from.ch > span.to || span.from == null && lineNo != from.line || lineNo == to.line && span.from > to.ch) && (!filter || filter(span.marker)))
              found.push(span.marker.parent || span.marker);
          }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null)
              markers.push(sps[i].marker);
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch, lineNo = this.first;
      this.iter(function (line) {
        var sz = line.text.length + 1;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0)
        return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options)
        options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from)
        from = options.from;
      if (options.to != null && options.to < to)
        to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist)
        copy.history = this.history;
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
          doc: this,
          isParent: true,
          sharedHist: options.sharedHist
        }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror)
        other = other.doc;
      if (this.linked)
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other)
            continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          detachSharedMarkers(findSharedMarkers(this));
          break;
        }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    }
  });
  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;
  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
  for (var prop in Doc.prototype)
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
  eventMixin(Doc);
  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked)
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip)
            continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared)
            continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
    }
    propagate(doc, null, true);
  }
  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm)
      throw new Error('This document is already in use.');
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping)
      findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  // LINE UTILITIES
  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size)
      throw new Error('There is no line ' + (n + doc.first) + ' in the document.');
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line)
        text = text.slice(0, end.ch);
      if (n == start.line)
        text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    });
    return out;
  }
  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff)
      for (var n = line; n; n = n.parent)
        n.height += diff;
  }
  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null)
      return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur)
          break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }
  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer:
      do {
        for (var i = 0; i < chunk.children.length; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) {
            chunk = child;
            continue outer;
          }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh)
        break;
      h -= lh;
    }
    return n + i;
  }
  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj)
        break;
      else
        h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk)
          break;
        else
          h += cur.height;
      }
    }
    return h;
  }
  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null)
      order = line.order = bidiOrdering(line.text);
    return order;
  }
  // HISTORY
  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];
    this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }
  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {
        from: copyPos(change.from),
        to: changeEnd(change),
        text: getBetween(doc, change.from, change.to)
      };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges)
        array.pop();
      else
        break;
    }
  }
  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }
  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(), cur;
    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges)
          hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;
    if (!last)
      signal(doc, 'historyAdded');
  }
  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }
  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;
    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);
    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }
  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }
  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change['spans_' + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }
  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans)
      return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out)
          out = spans.slice(0, i);
      } else if (out)
        out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }
  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change['spans_' + doc.id];
    if (!found)
      return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }
  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({ changes: newChanges });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup)
          for (var prop in change)
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
      }
    }
    return copy;
  }
  // Rebasing/resetting history to deal with externally-sourced changes
  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();
          sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  // EVENT UTILITIES
  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.
  var e_preventDefault = CodeMirror.e_preventDefault = function (e) {
      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;
    };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function (e) {
      if (e.stopPropagation)
        e.stopPropagation();
      else
        e.cancelBubble = true;
    };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function (e) {
      e_preventDefault(e);
      e_stopPropagation(e);
    };
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1)
        b = 1;
      else if (e.button & 2)
        b = 3;
      else if (e.button & 4)
        b = 2;
    }
    if (mac && e.ctrlKey && b == 1)
      b = 3;
    return b;
  }
  // EVENT HANDLING
  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.
  var on = CodeMirror.on = function (emitter, type, f) {
      if (emitter.addEventListener)
        emitter.addEventListener(type, f, false);
      else if (emitter.attachEvent)
        emitter.attachEvent('on' + type, f);
      else {
        var map = emitter._handlers || (emitter._handlers = {});
        var arr = map[type] || (map[type] = []);
        arr.push(f);
      }
    };
  var off = CodeMirror.off = function (emitter, type, f) {
      if (emitter.removeEventListener)
        emitter.removeEventListener(type, f, false);
      else if (emitter.detachEvent)
        emitter.detachEvent('on' + type, f);
      else {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
          return;
        for (var i = 0; i < arr.length; ++i)
          if (arr[i] == f) {
            arr.splice(i, 1);
            break;
          }
      }
    };
  var signal = CodeMirror.signal = function (emitter, type) {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr)
        return;
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i = 0; i < arr.length; ++i)
        arr[i].apply(null, args);
    };
  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {
      return function () {
        f.apply(null, args);
      };
    }
    ;
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }
  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i)
      delayed[i]();
  }
  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }
  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr)
      return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i)
      if (indexOf(set, arr[i]) == -1)
        set.push(arr[i]);
  }
  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }
  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };
    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  }
  // MISC UTILITIES
  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;
  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {
      toString: function () {
        return 'CodeMirror.Pass';
      }
    };
  // Reused option objects for setSelection & friends
  var sel_dontScroll = { scroll: false }, sel_mouse = { origin: '*mouse' }, sel_move = { origin: '+move' };
  function Delayed() {
    this.id = null;
  }
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };
  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function (string, end, tabSize, startIndex, startValue) {
      if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
          end = string.length;
      }
      for (var i = startIndex || 0, n = startValue || 0;;) {
        var nextTab = string.indexOf('\t', i);
        if (nextTab < 0 || nextTab >= end)
          return n + (end - i);
        n += nextTab - i;
        n += tabSize - n % tabSize;
        i = nextTab + 1;
      }
    };
  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf('\t', pos);
      if (nextTab == -1)
        nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal)
        return pos;
    }
  }
  var spaceStrs = [''];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + ' ');
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  var selectInput = function (node) {
    node.select();
  };
  if (ios)
    // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function (node) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    };
  else if (ie)
    // Suppress mysterious IE10 errors
    selectInput = function (node) {
      try {
        node.select();
      } catch (_e) {
      }
    };
  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt)
        return i;
    return -1;
  }
  if ([].indexOf)
    indexOf = function (array, elt) {
      return array.indexOf(elt);
    };
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++)
      out[i] = f(array[i], i);
    return out;
  }
  if ([].map)
    map = function (array, f) {
      return array.map(f);
    };
  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      var ctor = function () {
      };
      ctor.prototype = base;
      inst = new ctor();
    }
    if (props)
      copyObj(props, inst);
    return inst;
  }
  ;
  function copyObj(obj, target, overwrite) {
    if (!target)
      target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  var nonASCIISingleCaseWordChar = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function (ch) {
      return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    };
  function isWordChar(ch, helper) {
    if (!helper)
      return isWordCharBasic(ch);
    if (helper.source.indexOf('\\w') > -1 && isWordCharBasic(ch))
      return true;
    return helper.test(ch);
  }
  function isEmpty(obj) {
    for (var n in obj)
      if (obj.hasOwnProperty(n) && obj[n])
        return false;
    return true;
  }
  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }
  // DOM UTILITIES
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className)
      e.className = className;
    if (style)
      e.style.cssText = style;
    if (typeof content == 'string')
      e.appendChild(document.createTextNode(content));
    else if (content)
      for (var i = 0; i < content.length; ++i)
        e.appendChild(content[i]);
    return e;
  }
  var range;
  if (document.createRange)
    range = function (node, start, end) {
      var r = document.createRange();
      r.setEnd(node, end);
      r.setStart(node, start);
      return r;
    };
  else
    range = function (node, start, end) {
      var r = document.body.createTextRange();
      r.moveToElementText(node.parentNode);
      r.collapse(true);
      r.moveEnd('character', end);
      r.moveStart('character', start);
      return r;
    };
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function contains(parent, child) {
    if (parent.contains)
      return parent.contains(child);
    while (child = child.parentNode)
      if (child == parent)
        return true;
  }
  function activeElt() {
    return document.activeElement;
  }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie_upto10)
    activeElt = function () {
      try {
        return document.activeElement;
      } catch (e) {
        return document.body;
      }
    };
  function classTest(cls) {
    return new RegExp('\\b' + cls + '\\b\\s*');
  }
  function rmClass(node, cls) {
    var test = classTest(cls);
    if (test.test(node.className))
      node.className = node.className.replace(test, '');
  }
  function addClass(node, cls) {
    if (!classTest(cls).test(node.className))
      node.className += ' ' + cls;
  }
  function joinClasses(a, b) {
    var as = a.split(' ');
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b))
        b += ' ' + as[i];
    return b;
  }
  // WINDOW-WIDE EVENTS
  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.
  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName)
      return;
    var byClass = document.body.getElementsByClassName('CodeMirror');
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm)
        f(cm);
    }
  }
  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered)
      return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, 'resize', function () {
      if (resizeTimer == null)
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          knownScrollbarWidth = null;
          forEachCodeMirror(onResize);
        }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, 'blur', function () {
      forEachCodeMirror(onBlur);
    });
  }
  // FEATURE DETECTION
  // Detect drag-and-drop
  var dragAndDrop = function () {
      // There is *some* kind of drag-and-drop support in IE6-8, but I
      // couldn't get it to work yet.
      if (ie_upto8)
        return false;
      var div = elt('div');
      return 'draggable' in div || 'dragDrop' in div;
    }();
  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null)
      return knownScrollbarWidth;
    var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt('span', '\u200b');
      removeChildrenAndAdd(measure, elt('span', [
        test,
        document.createTextNode('x')
      ]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_upto7;
    }
    if (zwspSupported)
      return elt('span', '\u200b');
    else
      return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
  }
  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null)
      return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode('A\u062eA'));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (r0.left == r0.right)
      return false;
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = r1.right - r0.right < 3;
  }
  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf('\n', pos);
        if (nl == -1)
          nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
        var rt = line.indexOf('\r');
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function (string) {
      return string.split(/\r\n?|\n/);
    };
  var hasSelection = window.getSelection ? function (te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function (te) {
      try {
        var range = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range || range.parentElement() != te)
        return false;
      return range.compareEndPoints('StartToEnd', range) != 0;
    };
  var hasCopyEvent = function () {
      var e = elt('div');
      if ('oncopy' in e)
        return true;
      e.setAttribute('oncopy', 'return;');
      return typeof e.oncopy == 'function';
    }();
  // KEY NAMES
  var keyNames = {
      3: 'Enter',
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Esc',
      32: 'Space',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      44: 'PrintScrn',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      61: '=',
      91: 'Mod',
      92: 'Mod',
      93: 'Mod',
      107: '=',
      109: '-',
      127: 'Delete',
      173: '-',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\'',
      63232: 'Up',
      63233: 'Down',
      63234: 'Left',
      63235: 'Right',
      63272: 'Delete',
      63273: 'Home',
      63275: 'End',
      63276: 'PageUp',
      63277: 'PageDown',
      63302: 'Insert'
    };
  CodeMirror.keyNames = keyNames;
  (function () {
    // Number keys
    for (var i = 0; i < 10; i++)
      keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++)
      keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++)
      keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
  }());
  // BIDI HELPERS
  function iterateBidiSections(order, from, to, f) {
    if (!order)
      return f(from, to, 'ltr');
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
        found = true;
      }
    }
    if (!found)
      f(from, to, 'ltr');
  }
  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }
  function lineLeft(line) {
    var order = getOrder(line);
    return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order)
      return line.text.length;
    return bidiRight(lst(order));
  }
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line)
      lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir)
      return true;
    if (b == linedir)
      return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos)
        return i;
      if (cur.from == pos || cur.to == pos) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to)
            bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to)
            bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }
  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit)
      return pos + dir;
    do
      pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }
  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi)
      return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
    for (;;) {
      if (target > part.from && target < part.to)
        return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos)
          return target;
        part = bidi[pos += dir];
        return dir > 0 == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part)
          return null;
        if (dir > 0 == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }
  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit)
      while (target > 0 && isExtendingChar(line.text.charAt(target)))
        target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }
  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.
  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals
  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = function () {
      // Character types for codepoints 0 to 0xff
      var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN';
      // Character types for codepoints 0x600 to 0x6ff
      var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm';
      function charType(code) {
        if (code <= 247)
          return lowTypes.charAt(code);
        else if (1424 <= code && code <= 1524)
          return 'R';
        else if (1536 <= code && code <= 1773)
          return arabicTypes.charAt(code - 1536);
        else if (1774 <= code && code <= 2220)
          return 'r';
        else if (8192 <= code && code <= 8203)
          return 'w';
        else if (code == 8204)
          return 'b';
        else
          return 'L';
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      // Browsers seem to always treat the boundaries of block elements as being L.
      var outerType = 'L';
      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from;
        this.to = to;
      }
      return function (str) {
        if (!bidiRE.test(str))
          return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == 'm')
            types[i] = prev;
          else
            prev = type;
        }
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == '1' && cur == 'r')
            types[i] = 'n';
          else if (isStrong.test(type)) {
            cur = type;
            if (type == 'r')
              types[i] = 'R';
          }
        }
        // W4. A single European separator between two European numbers
        // changes to a European number. A single common separator between
        // two numbers of the same type changes to that type.
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == '+' && prev == '1' && types[i + 1] == '1')
            types[i] = '1';
          else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
            types[i] = prev;
          prev = type;
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ',')
            types[i] = 'N';
          else if (type == '%') {
            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
            }
            var replace = i && types[i - 1] == '!' || end < len && types[end] == '1' ? '1' : 'N';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == 'L' && type == '1')
            types[i] = 'L';
          else if (isStrong.test(type))
            cur = type;
        }
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
            }
            var before = (i ? types[i - 1] : outerType) == 'L';
            var after = (end < len ? types[end] : outerType) == 'L';
            var replace = before || after ? 'L' : 'R';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        // Here we depart from the documented algorithm, in order to avoid
        // building up an actual levels array. Since there are only three
        // levels (0, 1, 2) in an implementation that doesn't take
        // explicit embedding into account, we can build up the order on
        // the fly, without following the level-based algorithm.
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
            }
            order.push(new BidiSpan(0, start, i));
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != 'L'; ++i) {
            }
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j)
                  order.splice(at, 0, new BidiSpan(1, pos, j));
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                }
                order.splice(at, 0, new BidiSpan(2, nstart, j));
                pos = j;
              } else
                ++j;
            }
            if (pos < i)
              order.splice(at, 0, new BidiSpan(1, pos, i));
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
        if (order[0].level != lst(order).level)
          order.push(new BidiSpan(order[0].level, len, len));
        return order;
      };
    }();
  // THE END
  CodeMirror.version = '4.2.0';
  return CodeMirror;
}));
(function () {
  'use strict';
  function doFold(cm, pos, options) {
    var finder = options && (options.call ? options : options.rangeFinder);
    if (!finder)
      finder = cm.getHelper(pos, 'fold');
    if (!finder)
      return;
    if (typeof pos == 'number')
      pos = CodeMirror.Pos(pos, 0);
    var minSize = options && options.minFoldSize || 0;
    function getRange(allowFolded) {
      var range = finder(cm, pos);
      if (!range || range.to.line - range.from.line < minSize)
        return null;
      var marks = cm.findMarksAt(range.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold) {
          if (!allowFolded)
            return null;
          range.cleared = true;
          marks[i].clear();
        }
      }
      return range;
    }
    var range = getRange(true);
    if (options && options.scanUp)
      while (!range && pos.line > cm.firstLine()) {
        pos = CodeMirror.Pos(pos.line - 1, 0);
        range = getRange(false);
      }
    if (!range || range.cleared)
      return;
    var myWidget = makeWidget(options);
    CodeMirror.on(myWidget, 'mousedown', function () {
      myRange.clear();
    });
    var myRange = cm.markText(range.from, range.to, {
        replacedWith: myWidget,
        clearOnEnter: true,
        __isFold: true
      });
    myRange.on('clear', function (from, to) {
      CodeMirror.signal(cm, 'unfold', cm, from, to);
    });
    CodeMirror.signal(cm, 'fold', cm, range.from, range.to);
  }
  function makeWidget(options) {
    var widget = options && options.widget || '\u2194';
    if (typeof widget == 'string') {
      var text = document.createTextNode(widget);
      widget = document.createElement('span');
      widget.appendChild(text);
      widget.className = 'CodeMirror-foldmarker';
    }
    return widget;
  }
  // Clumsy backwards-compatible interface
  CodeMirror.newFoldFunction = function (rangeFinder, widget) {
    return function (cm, pos) {
      doFold(cm, pos, {
        rangeFinder: rangeFinder,
        widget: widget
      });
    };
  };
  // New-style interface
  CodeMirror.defineExtension('foldCode', function (pos, options) {
    doFold(this, pos, options);
  });
  CodeMirror.registerHelper('fold', 'combine', function () {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function (cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found)
          return found;
      }
    };
  });
}());
(function () {
  'use strict';
  CodeMirror.defineOption('foldGutter', false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off('gutterClick', onGutterClick);
      cm.off('change', onChange);
      cm.off('viewportChange', onViewportChange);
      cm.off('fold', onFold);
      cm.off('unfold', onFold);
      cm.off('swapDoc', updateInViewport);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on('gutterClick', onGutterClick);
      cm.on('change', onChange);
      cm.on('viewportChange', onViewportChange);
      cm.on('fold', onFold);
      cm.on('unfold', onFold);
      cm.on('swapDoc', updateInViewport);
    }
  });
  var Pos = CodeMirror.Pos;
  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }
  function parseOptions(opts) {
    if (opts === true)
      opts = {};
    if (opts.gutter == null)
      opts.gutter = 'CodeMirror-foldgutter';
    if (opts.indicatorOpen == null)
      opts.indicatorOpen = 'CodeMirror-foldgutter-open';
    if (opts.indicatorFolded == null)
      opts.indicatorFolded = 'CodeMirror-foldgutter-folded';
    return opts;
  }
  function isFolded(cm, line) {
    var marks = cm.findMarksAt(Pos(line));
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold && marks[i].find().from.line == line)
        return true;
  }
  function marker(spec) {
    if (typeof spec == 'string') {
      var elt = document.createElement('div');
      elt.className = spec;
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }
  function updateFoldInfo(cm, from, to) {
    var opts = cm.state.foldGutter.options, cur = from;
    cm.eachLine(from, to, function (line) {
      var mark = null;
      if (isFolded(cm, cur)) {
        mark = marker(opts.indicatorFolded);
      } else {
        var pos = Pos(cur, 0), func = opts.rangeFinder || cm.getHelper(pos, 'fold');
        var range = func && func(cm, pos);
        if (range && range.from.line + 1 < range.to.line)
          mark = marker(opts.indicatorOpen);
      }
      cm.setGutterMarker(line, opts.gutter, mark);
      ++cur;
    });
  }
  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state)
      return;
    cm.operation(function () {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from;
    state.to = vp.to;
  }
  function onGutterClick(cm, line, gutter) {
    var opts = cm.state.foldGutter.options;
    if (gutter != opts.gutter)
      return;
    cm.foldCode(Pos(line, 0), opts.rangeFinder);
  }
  function onChange(cm) {
    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function () {
      updateInViewport(cm);
    }, opts.foldOnChangeTimeSpan || 600);
  }
  function onViewportChange(cm) {
    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function () {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function () {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts.updateViewportTimeSpan);
  }
  function onFold(cm, from) {
    var state = cm.state.foldGutter, line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
}());
CodeMirror.defineMode('gfm', function (config) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
      startState: function () {
        return {
          code: false,
          codeBlock: false,
          ateSpace: false
        };
      },
      copyState: function (s) {
        return {
          code: s.code,
          codeBlock: s.codeBlock,
          ateSpace: s.ateSpace
        };
      },
      token: function (stream, state) {
        // Hack to prevent formatting override inside code blocks (block and inline)
        if (state.codeBlock) {
          if (stream.match(/^```/)) {
            state.codeBlock = false;
            return null;
          }
          stream.skipToEnd();
          return null;
        }
        if (stream.sol()) {
          state.code = false;
        }
        if (stream.sol() && stream.match(/^```/)) {
          stream.skipToEnd();
          state.codeBlock = true;
          return null;
        }
        // If this block is changed, it may need to be updated in Markdown mode
        if (stream.peek() === '`') {
          stream.next();
          var before = stream.pos;
          stream.eatWhile('`');
          var difference = 1 + stream.pos - before;
          if (!state.code) {
            codeDepth = difference;
            state.code = true;
          } else {
            if (difference === codeDepth) {
              // Must be exact
              state.code = false;
            }
          }
          return null;
        } else if (state.code) {
          stream.next();
          return null;
        }
        // Check if space. If so, links can be formatted later on
        if (stream.eatSpace()) {
          state.ateSpace = true;
          return null;
        }
        if (stream.sol() || state.ateSpace) {
          state.ateSpace = false;
          if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
            // User/Project@SHA
            // User@SHA
            // SHA
            return 'link';
          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
            // User/Project#Num
            // User#Num
            // #Num
            return 'link';
          }
        }
        if (stream.match(/^((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i)) {
          // URLs
          // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
          // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
          return 'link';
        }
        stream.next();
        return null;
      },
      blankLine: blankLine
    };
  CodeMirror.defineMIME('gfmBase', {
    name: 'markdown',
    underscoresBreakWords: false,
    taskLists: true,
    fencedCodeBlocks: true
  });
  return CodeMirror.overlayMode(CodeMirror.getMode(config, 'gfmBase'), gfmOverlay);
}, 'markdown');
// TODO actually recognize syntax of TypeScript constructs
CodeMirror.defineMode('javascript', function (config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonMode = parserConfig.json;
  var isTS = parserConfig.typescript;
  // Tokenizer
  var keywords = function () {
      function kw(type) {
        return {
          type: type,
          style: 'keyword'
        };
      }
      var A = kw('keyword a'), B = kw('keyword b'), C = kw('keyword c');
      var operator = kw('operator'), atom = {
          type: 'atom',
          style: 'atom'
        };
      var jsKeywords = {
          'if': kw('if'),
          'while': A,
          'with': A,
          'else': B,
          'do': B,
          'try': B,
          'finally': B,
          'return': C,
          'break': C,
          'continue': C,
          'new': C,
          'delete': C,
          'throw': C,
          'var': kw('var'),
          'const': kw('var'),
          'let': kw('var'),
          'function': kw('function'),
          'catch': kw('catch'),
          'for': kw('for'),
          'switch': kw('switch'),
          'case': kw('case'),
          'default': kw('default'),
          'in': operator,
          'typeof': operator,
          'instanceof': operator,
          'true': atom,
          'false': atom,
          'null': atom,
          'undefined': atom,
          'NaN': atom,
          'Infinity': atom,
          'this': kw('this')
        };
      // Extend the 'normal' keywords with the TypeScript language extensions
      if (isTS) {
        var type = {
            type: 'variable',
            style: 'variable-3'
          };
        var tsKeywords = {
            'interface': kw('interface'),
            'class': kw('class'),
            'extends': kw('extends'),
            'constructor': kw('constructor'),
            'public': kw('public'),
            'private': kw('private'),
            'protected': kw('protected'),
            'static': kw('static'),
            'super': kw('super'),
            'string': type,
            'number': type,
            'bool': type,
            'any': type
          };
        for (var attr in tsKeywords) {
          jsKeywords[attr] = tsKeywords[attr];
        }
      }
      return jsKeywords;
    }();
  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }
  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == '\\';
    }
    return escaped;
  }
  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp;
    content = cont;
    return style;
  }
  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == '\'')
      return chain(stream, state, jsTokenString(ch));
    else if (ch == '.' && stream.match(/^\d+(?:[eE][+\-]?\d+)?/))
      return ret('number', 'number');
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == '0' && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret('number', 'number');
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret('number', 'number');
    } else if (ch == '/') {
      if (stream.eat('*')) {
        return chain(stream, state, jsTokenComment);
      } else if (stream.eat('/')) {
        stream.skipToEnd();
        return ret('comment', 'comment');
      } else if (state.lastType == 'operator' || state.lastType == 'keyword c' || /^[\[{}\(,;:]$/.test(state.lastType)) {
        nextUntilUnescaped(stream, '/');
        stream.eatWhile(/[gimy]/);
        // 'y' is "sticky" option in Mozilla
        return ret('regexp', 'string-2');
      } else {
        stream.eatWhile(isOperatorChar);
        return ret('operator', null, stream.current());
      }
    } else if (ch == '#') {
      stream.skipToEnd();
      return ret('error', 'error');
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret('operator', null, stream.current());
    } else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return known && state.lastType != '.' ? ret(known.type, known.style, word) : ret('variable', 'variable', word);
    }
  }
  function jsTokenString(quote) {
    return function (stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret('string', 'string');
    };
  }
  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == '/' && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = ch == '*';
    }
    return ret('comment', 'comment');
  }
  // Parser
  var atomicTypes = {
      'atom': true,
      'number': true,
      'variable': true,
      'string': true,
      'regexp': true,
      'this': true
    };
  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null)
      this.align = align;
  }
  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname)
        return true;
  }
  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state;
    cx.stream = stream;
    cx.marked = null, cx.cc = cc;
    if (!state.lexical.hasOwnProperty('align'))
      state.lexical.align = true;
    while (true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while (cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked)
          return cx.marked;
        if (type == 'variable' && inScope(state, content))
          return 'variable-2';
        return style;
      }
    }
  }
  // Combinator utils
  var cx = {
      state: null,
      column: null,
      marked: null,
      cc: null
    };
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--)
      cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname)
          return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = 'def';
      if (inList(state.localVars))
        return;
      state.localVars = {
        name: varname,
        next: state.localVars
      };
    } else {
      if (inList(state.globalVars))
        return;
      state.globalVars = {
        name: varname,
        next: state.globalVars
      };
    }
  }
  // Combinators
  var defaultVars = {
      name: 'this',
      next: { name: 'arguments' }
    };
  function pushcontext() {
    cx.state.context = {
      prev: cx.state.context,
      vars: cx.state.localVars
    };
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function () {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == 'stat')
        indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ')')
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;
  function expect(wanted) {
    return function (type) {
      if (type == wanted)
        return cont();
      else if (wanted == ';')
        return pass();
      else
        return cont(arguments.callee);
    };
  }
  function statement(type) {
    if (type == 'var')
      return cont(pushlex('vardef'), vardef1, expect(';'), poplex);
    if (type == 'keyword a')
      return cont(pushlex('form'), expression, statement, poplex);
    if (type == 'keyword b')
      return cont(pushlex('form'), statement, poplex);
    if (type == '{')
      return cont(pushlex('}'), block, poplex);
    if (type == ';')
      return cont();
    if (type == 'if')
      return cont(pushlex('form'), expression, statement, poplex, maybeelse);
    if (type == 'function')
      return cont(functiondef);
    if (type == 'for')
      return cont(pushlex('form'), expect('('), pushlex(')'), forspec1, expect(')'), poplex, statement, poplex);
    if (type == 'variable')
      return cont(pushlex('stat'), maybelabel);
    if (type == 'switch')
      return cont(pushlex('form'), expression, pushlex('}', 'switch'), expect('{'), block, poplex, poplex);
    if (type == 'case')
      return cont(expression, expect(':'));
    if (type == 'default')
      return cont(expect(':'));
    if (type == 'catch')
      return cont(pushlex('form'), pushcontext, expect('('), funarg, expect(')'), statement, poplex, popcontext);
    return pass(pushlex('stat'), expression, expect(';'), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type))
      return cont(maybeop);
    if (type == 'function')
      return cont(functiondef);
    if (type == 'keyword c')
      return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == '(')
      return cont(pushlex(')'), maybeexpression, expect(')'), poplex, maybeop);
    if (type == 'operator')
      return cont(noComma ? expressionNoComma : expression);
    if (type == '[')
      return cont(pushlex(']'), commasep(expressionNoComma, ']'), poplex, maybeop);
    if (type == '{')
      return cont(pushlex('}'), commasep(objprop, '}'), poplex, maybeop);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/))
      return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/))
      return pass();
    return pass(expressionNoComma);
  }
  function maybeoperatorComma(type, value) {
    if (type == ',')
      return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == 'operator') {
      if (/\+\+|--/.test(value))
        return cont(me);
      if (value == '?')
        return cont(expression, expect(':'), expr);
      return cont(expr);
    }
    if (type == ';')
      return;
    if (type == '(')
      return cont(pushlex(')', 'call'), commasep(expressionNoComma, ')'), poplex, me);
    if (type == '.')
      return cont(property, me);
    if (type == '[')
      return cont(pushlex(']'), maybeexpression, expect(']'), poplex, me);
  }
  function maybelabel(type) {
    if (type == ':')
      return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(';'), poplex);
  }
  function property(type) {
    if (type == 'variable') {
      cx.marked = 'property';
      return cont();
    }
  }
  function objprop(type, value) {
    if (type == 'variable') {
      cx.marked = 'property';
      if (value == 'get' || value == 'set')
        return cont(getterSetter);
    } else if (type == 'number' || type == 'string') {
      cx.marked = type + ' property';
    }
    if (atomicTypes.hasOwnProperty(type))
      return cont(expect(':'), expressionNoComma);
  }
  function getterSetter(type) {
    if (type == ':')
      return cont(expression);
    if (type != 'variable')
      return cont(expect(':'), expression);
    cx.marked = 'property';
    return cont(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ',') {
        var lex = cx.state.lexical;
        if (lex.info == 'call')
          lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end)
        return cont();
      return cont(expect(end));
    }
    return function (type) {
      if (type == end)
        return cont();
      else
        return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == '}')
      return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (type == ':')
      return cont(typedef);
    return pass();
  }
  function typedef(type) {
    if (type == 'variable') {
      cx.marked = 'variable-3';
      return cont();
    }
    return pass();
  }
  function vardef1(type, value) {
    if (type == 'variable') {
      register(value);
      return isTS ? cont(maybetype, vardef2) : cont(vardef2);
    }
    return pass();
  }
  function vardef2(type, value) {
    if (value == '=')
      return cont(expressionNoComma, vardef2);
    if (type == ',')
      return cont(vardef1);
  }
  function maybeelse(type, value) {
    if (type == 'keyword b' && value == 'else')
      return cont(pushlex('form'), statement, poplex);
  }
  function forspec1(type) {
    if (type == 'var')
      return cont(vardef1, expect(';'), forspec2);
    if (type == ';')
      return cont(forspec2);
    if (type == 'variable')
      return cont(formaybein);
    return pass(expression, expect(';'), forspec2);
  }
  function formaybein(_type, value) {
    if (value == 'in')
      return cont(expression);
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ';')
      return cont(forspec3);
    if (value == 'in')
      return cont(expression);
    return pass(expression, expect(';'), forspec3);
  }
  function forspec3(type) {
    if (type != ')')
      cont(expression);
  }
  function functiondef(type, value) {
    if (type == 'variable') {
      register(value);
      return cont(functiondef);
    }
    if (type == '(')
      return cont(pushlex(')'), pushcontext, commasep(funarg, ')'), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == 'variable') {
      register(value);
      return isTS ? cont(maybetype) : cont();
    }
  }
  // Interface
  return {
    startState: function (basecolumn) {
      return {
        tokenize: jsTokenBase,
        lastType: null,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, 'block', false),
        localVars: parserConfig.localVars,
        globalVars: parserConfig.globalVars,
        context: parserConfig.localVars && { vars: parserConfig.localVars },
        indented: 0
      };
    },
    token: function (stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty('align'))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (state.tokenize != jsTokenComment && stream.eatSpace())
        return null;
      var style = state.tokenize(stream, state);
      if (type == 'comment')
        return style;
      state.lastType = type == 'operator' && (content == '++' || content == '--') ? 'incdec' : type;
      return parseJS(state, style, type, content, stream);
    },
    indent: function (state, textAfter) {
      if (state.tokenize == jsTokenComment)
        return CodeMirror.Pass;
      if (state.tokenize != jsTokenBase)
        return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex)
          lexical = lexical.prev;
        else if (c != maybeelse || /^else\b/.test(textAfter))
          break;
      }
      if (lexical.type == 'stat' && firstChar == '}')
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ')' && lexical.prev.type == 'stat')
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;
      if (type == 'vardef')
        return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? 4 : 0);
      else if (type == 'form' && firstChar == '{')
        return lexical.indented;
      else if (type == 'form')
        return lexical.indented + indentUnit;
      else if (type == 'stat')
        return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? statementIndent || indentUnit : 0);
      else if (lexical.info == 'switch' && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align)
        return lexical.column + (closing ? 0 : 1);
      else
        return lexical.indented + (closing ? 0 : indentUnit);
    },
    electricChars: ':{}',
    blockCommentStart: jsonMode ? null : '/*',
    blockCommentEnd: jsonMode ? null : '*/',
    lineComment: jsonMode ? null : '//',
    fold: 'brace',
    helperType: jsonMode ? 'json' : 'javascript',
    jsonMode: jsonMode
  };
});
CodeMirror.defineMIME('text/javascript', 'javascript');
CodeMirror.defineMIME('text/ecmascript', 'javascript');
CodeMirror.defineMIME('application/javascript', 'javascript');
CodeMirror.defineMIME('application/ecmascript', 'javascript');
CodeMirror.defineMIME('application/json', {
  name: 'javascript',
  json: true
});
CodeMirror.defineMIME('application/x-json', {
  name: 'javascript',
  json: true
});
CodeMirror.defineMIME('text/typescript', {
  name: 'javascript',
  typescript: true
});
CodeMirror.defineMIME('application/typescript', {
  name: 'javascript',
  typescript: true
});
CodeMirror.defineMode('markdown', function (cmCfg, modeCfg) {
  var htmlFound = CodeMirror.modes.hasOwnProperty('xml');
  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {
      name: 'xml',
      htmlMode: true
    } : 'text/plain');
  var aliases = {
      html: 'htmlmixed',
      js: 'javascript',
      json: 'application/json',
      c: 'text/x-csrc',
      'c++': 'text/x-c++src',
      java: 'text/x-java',
      csharp: 'text/x-csharp',
      'c#': 'text/x-csharp',
      scala: 'text/x-scala'
    };
  var getMode = function () {
      var i, modes = {}, mimes = {}, mime;
      var list = [];
      for (var m in CodeMirror.modes)
        if (CodeMirror.modes.propertyIsEnumerable(m))
          list.push(m);
      for (i = 0; i < list.length; i++) {
        modes[list[i]] = list[i];
      }
      var mimesList = [];
      for (var m in CodeMirror.mimeModes)
        if (CodeMirror.mimeModes.propertyIsEnumerable(m))
          mimesList.push({
            mime: m,
            mode: CodeMirror.mimeModes[m]
          });
      for (i = 0; i < mimesList.length; i++) {
        mime = mimesList[i].mime;
        mimes[mime] = mimesList[i].mime;
      }
      for (var a in aliases) {
        if (aliases[a] in modes || aliases[a] in mimes)
          modes[a] = aliases[a];
      }
      return function (lang) {
        return modes[lang] ? CodeMirror.getMode(cmCfg, modes[lang]) : null;
      };
    }();
  // Should underscores in words open/close em/strong?
  if (modeCfg.underscoresBreakWords === undefined)
    modeCfg.underscoresBreakWords = true;
  // Turn on fenced code blocks? ("```" to start/end)
  if (modeCfg.fencedCodeBlocks === undefined)
    modeCfg.fencedCodeBlocks = false;
  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined)
    modeCfg.taskLists = false;
  var codeDepth = 0;
  var header = 'header', code = 'comment', quote1 = 'atom', quote2 = 'number', list1 = 'variable-2', list2 = 'variable-3', list3 = 'keyword', hr = 'hr', image = 'tag', linkinline = 'link', linkemail = 'link', linktext = 'link', linkhref = 'string', em = 'em', strong = 'strong';
  var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/, ulRE = /^[*\-+]\s+/, olRE = /^[0-9]+\.\s+/, taskListRE = /^\[(x| )\](?=\s)/, headerRE = /^(?:\={1,}|-{1,})$/, textRE = /^[^!\[\]*_\\<>` "'(]+/;
  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }
  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }
  // Blocks
  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset state.quote
    state.quote = 0;
    if (!htmlFound && state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.thisLineHasContent = false;
    return null;
  }
  function blockNormal(stream, state) {
    var prevLineIsList = state.list !== false;
    if (state.list !== false && state.indentationDiff >= 0) {
      // Continued list
      if (state.indentationDiff < 4) {
        // Only adjust indentation if *not* a code block
        state.indentation -= state.indentationDiff;
      }
      state.list = null;
    } else if (state.list !== false && state.indentation > 0) {
      state.list = null;
      state.listDepth = Math.floor(state.indentation / 4);
    } else if (state.list !== false) {
      // No longer a list
      state.list = false;
      state.listDepth = 0;
    }
    if (state.indentationDiff >= 4) {
      state.indentation -= 4;
      stream.skipToEnd();
      return code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (stream.peek() === '#' || state.prevLineHasContent && stream.match(headerRE)) {
      state.header = true;
    } else if (stream.eat('>')) {
      state.indentation++;
      state.quote = 1;
      stream.eatSpace();
      while (stream.eat('>')) {
        stream.eatSpace();
        state.quote++;
      }
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    } else if (stream.match(hrRE, true)) {
      return hr;
    } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, true) || stream.match(olRE, true))) {
      state.indentation += 4;
      state.list = true;
      state.listDepth++;
      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
    } else if (modeCfg.fencedCodeBlocks && stream.match(/^```([\w+#]*)/, true)) {
      // try switching mode
      state.localMode = getMode(RegExp.$1);
      if (state.localMode)
        state.localState = state.localMode.startState();
      switchBlock(stream, state, local);
      return code;
    }
    return switchInline(stream, state, state.inline);
  }
  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if (htmlFound && style === 'tag' && state.htmlState.type !== 'openTag' && !state.htmlState.context) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    if (state.md_inside && stream.current().indexOf('>') != -1) {
      state.f = inlineNormal;
      state.block = blockNormal;
      state.htmlState.context = undefined;
    }
    return style;
  }
  function local(stream, state) {
    if (stream.sol() && stream.match(/^```/, true)) {
      state.localMode = state.localState = null;
      state.f = inlineNormal;
      state.block = blockNormal;
      return code;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return code;
    }
  }
  // Inline
  function getType(state) {
    var styles = [];
    if (state.taskOpen) {
      return 'meta';
    }
    if (state.taskClosed) {
      return 'property';
    }
    if (state.strong) {
      styles.push(strong);
    }
    if (state.em) {
      styles.push(em);
    }
    if (state.linkText) {
      styles.push(linktext);
    }
    if (state.code) {
      styles.push(code);
    }
    if (state.header) {
      styles.push(header);
    }
    if (state.quote) {
      styles.push(state.quote % 2 ? quote1 : quote2);
    }
    if (state.list !== false) {
      var listMod = (state.listDepth - 1) % 3;
      if (!listMod) {
        styles.push(list1);
      } else if (listMod === 1) {
        styles.push(list2);
      } else {
        styles.push(list3);
      }
    }
    if (state.trailingSpaceNewLine) {
      styles.push('trailing-space-new-line');
    } else if (state.trailingSpace) {
      styles.push('trailing-space-' + (state.trailingSpace % 2 ? 'a' : 'b'));
    }
    return styles.length ? styles.join(' ') : null;
  }
  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }
  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;
    if (state.list) {
      // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }
    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] !== 'x';
      if (taskOpen)
        state.taskOpen = true;
      else
        state.taskClosed = true;
      state.taskList = false;
      return getType(state);
    }
    state.taskOpen = false;
    state.taskClosed = false;
    var ch = stream.next();
    if (ch === '\\') {
      stream.next();
      return getType(state);
    }
    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return linkhref;
      }
    }
    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var t = getType(state);
      var before = stream.pos;
      stream.eatWhile('`');
      var difference = 1 + stream.pos - before;
      if (!state.code) {
        codeDepth = difference;
        state.code = true;
        return getType(state);
      } else {
        if (difference === codeDepth) {
          // Must be exact
          state.code = false;
          return t;
        }
        return getType(state);
      }
    } else if (state.code) {
      return getType(state);
    }
    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      stream.match(/\[[^\]]*\]/);
      state.inline = state.f = linkHref;
      return image;
    }
    if (ch === '[' && stream.match(/.*\](\(| ?\[)/, false)) {
      state.linkText = true;
      return getType(state);
    }
    if (ch === ']' && state.linkText) {
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = linkHref;
      return type;
    }
    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      return switchInline(stream, state, inlineElement(linkinline, '>'));
    }
    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      return switchInline(stream, state, inlineElement(linkemail, '>'));
    }
    if (ch === '<' && stream.match(/^\w/, false)) {
      if (stream.string.indexOf('>') != -1) {
        var atts = stream.string.substring(1, stream.string.indexOf('>'));
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
          state.md_inside = true;
        }
      }
      stream.backUp(1);
      return switchBlock(stream, state, htmlBlock);
    }
    if (ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return 'tag';
    }
    var ignoreUnderscore = false;
    if (!modeCfg.underscoresBreakWords) {
      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
        var prevPos = stream.pos - 2;
        if (prevPos >= 0) {
          var prevCh = stream.string.charAt(prevPos);
          if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
            ignoreUnderscore = true;
          }
        }
      }
    }
    var t = getType(state);
    if (ch === '*' || ch === '_' && !ignoreUnderscore) {
      if (state.strong === ch && stream.eat(ch)) {
        // Remove STRONG
        state.strong = false;
        return t;
      } else if (!state.strong && stream.eat(ch)) {
        // Add STRONG
        state.strong = ch;
        return getType(state);
      } else if (state.em === ch) {
        // Remove EM
        state.em = false;
        return t;
      } else if (!state.em) {
        // Add EM
        state.em = ch;
        return getType(state);
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) {
        // Probably surrounded by spaces
        if (stream.peek() === ' ') {
          // Surrounded by spaces, ignore
          return getType(state);
        } else {
          // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }
    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }
    return getType(state);
  }
  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if (stream.eatSpace()) {
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      return switchInline(stream, state, inlineElement(linkhref, ch === '(' ? ')' : ']'));
    }
    return 'error';
  }
  function footnoteLink(stream, state) {
    if (stream.match(/^[^\]]*\]:/, true)) {
      state.f = footnoteUrl;
      return linktext;
    }
    return switchInline(stream, state, inlineNormal);
  }
  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if (stream.eatSpace()) {
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) {
      // End of line, set flag to check next line
      state.linkTitle = true;
    } else {
      // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return linkhref;
  }
  var savedInlineRE = [];
  function inlineRE(endChar) {
    if (!savedInlineRE[endChar]) {
      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
      endChar = (endChar + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      // Match any non-endChar, escaped character, as well as the closing
      // endChar.
      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
    }
    return savedInlineRE[endChar];
  }
  function inlineElement(type, endChar, next) {
    next = next || inlineNormal;
    return function (stream, state) {
      stream.match(inlineRE(endChar));
      state.inline = state.f = next;
      return type;
    };
  }
  return {
    startState: function () {
      return {
        f: blockNormal,
        prevLineHasContent: false,
        thisLineHasContent: false,
        block: blockNormal,
        htmlState: CodeMirror.startState(htmlMode),
        indentation: 0,
        inline: inlineNormal,
        text: handleText,
        linkText: false,
        linkTitle: false,
        em: false,
        strong: false,
        header: false,
        taskList: false,
        list: false,
        listDepth: 0,
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false,
        parentIndentation: 0
      };
    },
    copyState: function (s) {
      return {
        f: s.f,
        prevLineHasContent: s.prevLineHasContent,
        thisLineHasContent: s.thisLineHasContent,
        block: s.block,
        htmlState: CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,
        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
        inline: s.inline,
        text: s.text,
        linkTitle: s.linkTitle,
        em: s.em,
        strong: s.strong,
        header: s.header,
        taskList: s.taskList,
        list: s.list,
        listDepth: s.listDepth,
        quote: s.quote,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        parentIndentation: s.parentIndentation,
        md_inside: s.md_inside
      };
    },
    token: function (stream, state) {
      if (stream.sol()) {
        if (stream.match(/^\s*$/, true)) {
          state.prevLineHasContent = false;
          return blankLine(state);
        } else {
          state.prevLineHasContent = state.thisLineHasContent;
          state.thisLineHasContent = true;
        }
        // Reset state.header
        state.header = false;
        // Reset state.taskList
        state.taskList = false;
        // Reset state.code
        state.code = false;
        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;
        state.f = state.block;
        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length - state.parentIndentation;
        var difference = Math.floor((indentation - state.indentation - state.parentIndentation) / 4) * 4;
        if (difference > 4)
          difference = 4;
        var adjustedIndentation = state.indentation + difference - state.parentIndentation;
        state.indentationDiff = adjustedIndentation - state.indentation - state.parentIndentation;
        state.indentation = adjustedIndentation;
        if (indentation > 0)
          return null;
      }
      return state.f(stream, state);
    },
    blankLine: blankLine,
    getType: getType
  };
}, 'xml');
CodeMirror.defineMIME('text/x-markdown', 'markdown');
// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true, in which case
// the styles are combined.
// overlayParser is the old, deprecated name
CodeMirror.overlayMode = CodeMirror.overlayParser = function (base, overlay, combine) {
  return {
    startState: function () {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0,
        baseCur: null,
        overlayPos: 0,
        overlayCur: null
      };
    },
    copyState: function (state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos,
        baseCur: null,
        overlayPos: state.overlayPos,
        overlayCur: null
      };
    },
    token: function (stream, state) {
      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);
      if (stream.eol())
        state.basePos = state.overlayPos = 0;
      if (state.overlayCur == null)
        return state.baseCur;
      if (state.baseCur != null && combine)
        return state.baseCur + ' ' + state.overlayCur;
      else
        return state.overlayCur;
    },
    indent: base.indent && function (state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,
    innerMode: function (state) {
      return {
        state: state.base,
        mode: base
      };
    },
    blankLine: function (state) {
      if (base.blankLine)
        base.blankLine(state.base);
      if (overlay.blankLine)
        overlay.blankLine(state.overlay);
    }
  };
};
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
(function (mod) {
  if (typeof exports == 'object' && typeof module == 'object')
    // CommonJS
    mod(require('../../lib/codemirror'));
  else if (typeof define == 'function' && define.amd)
    // AMD
    define(['../../lib/codemirror'], mod);
  else
    // Plain browser env
    mod(CodeMirror);
}(function (CodeMirror) {
  'use strict';
  var HINT_ELEMENT_CLASS = 'CodeMirror-hint';
  var ACTIVE_HINT_ELEMENT_CLASS = 'CodeMirror-hint-active';
  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function (cm, getHints, options) {
    if (!getHints)
      return cm.showHint(options);
    if (options && options.async)
      getHints.async = true;
    var newOpts = { hint: getHints };
    if (options)
      for (var prop in options)
        newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };
  CodeMirror.defineExtension('showHint', function (options) {
    // We want a single cursor position.
    if (this.listSelections().length > 1 || this.somethingSelected())
      return;
    if (this.state.completionActive)
      this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    var getHints = completion.options.hint;
    if (!getHints)
      return;
    CodeMirror.signal(this, 'startCompletion', this);
    if (getHints.async)
      getHints(this, function (hints) {
        completion.showHints(hints);
      }, completion.options);
    else
      return completion.showHints(getHints(this, completion.options));
  });
  function Completion(cm, options) {
    this.cm = cm;
    this.options = this.buildOptions(options);
    this.widget = this.onClose = null;
  }
  Completion.prototype = {
    close: function () {
      if (!this.active())
        return;
      this.cm.state.completionActive = null;
      if (this.widget)
        this.widget.close();
      if (this.onClose)
        this.onClose();
      CodeMirror.signal(this.cm, 'endCompletion', this.cm);
    },
    active: function () {
      return this.cm.state.completionActive == this;
    },
    pick: function (data, i) {
      var completion = data.list[i];
      if (completion.hint)
        completion.hint(this.cm, data, completion);
      else
        this.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, 'complete');
      CodeMirror.signal(data, 'pick', completion);
      this.close();
    },
    showHints: function (data) {
      if (!data || !data.list.length || !this.active())
        return this.close();
      if (this.options.completeSingle && data.list.length == 1)
        this.pick(data, 0);
      else
        this.showWidget(data);
    },
    showWidget: function (data) {
      this.widget = new Widget(this, data);
      CodeMirror.signal(data, 'shown');
      var debounce = 0, completion = this, finished;
      var closeOn = this.options.closeCharacters;
      var startPos = this.cm.getCursor(), startLen = this.cm.getLine(startPos.line).length;
      var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
          return setTimeout(fn, 1000 / 60);
        };
      var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
      function done() {
        if (finished)
          return;
        finished = true;
        completion.close();
        completion.cm.off('cursorActivity', activity);
        if (data)
          CodeMirror.signal(data, 'close');
      }
      function update() {
        if (finished)
          return;
        CodeMirror.signal(data, 'update');
        var getHints = completion.options.hint;
        if (getHints.async)
          getHints(completion.cm, finishUpdate, completion.options);
        else
          finishUpdate(getHints(completion.cm, completion.options));
      }
      function finishUpdate(data_) {
        data = data_;
        if (finished)
          return;
        if (!data || !data.list.length)
          return done();
        if (completion.widget)
          completion.widget.close();
        completion.widget = new Widget(completion, data);
      }
      function clearDebounce() {
        if (debounce) {
          cancelAnimationFrame(debounce);
          debounce = 0;
        }
      }
      function activity() {
        clearDebounce();
        var pos = completion.cm.getCursor(), line = completion.cm.getLine(pos.line);
        if (pos.line != startPos.line || line.length - pos.ch != startLen - startPos.ch || pos.ch < startPos.ch || completion.cm.somethingSelected() || pos.ch && closeOn.test(line.charAt(pos.ch - 1))) {
          completion.close();
        } else {
          debounce = requestAnimationFrame(update);
          if (completion.widget)
            completion.widget.close();
        }
      }
      this.cm.on('cursorActivity', activity);
      this.onClose = done;
    },
    buildOptions: function (options) {
      var editor = this.cm.options.hintOptions;
      var out = {};
      for (var prop in defaultOptions)
        out[prop] = defaultOptions[prop];
      if (editor)
        for (var prop in editor)
          if (editor[prop] !== undefined)
            out[prop] = editor[prop];
      if (options)
        for (var prop in options)
          if (options[prop] !== undefined)
            out[prop] = options[prop];
      return out;
    }
  };
  function getText(completion) {
    if (typeof completion == 'string')
      return completion;
    else
      return completion.text;
  }
  function buildKeyMap(completion, handle) {
    var baseMap = {
        Up: function () {
          handle.moveFocus(-1);
        },
        Down: function () {
          handle.moveFocus(1);
        },
        PageUp: function () {
          handle.moveFocus(-handle.menuSize() + 1, true);
        },
        PageDown: function () {
          handle.moveFocus(handle.menuSize() - 1, true);
        },
        Home: function () {
          handle.setFocus(0);
        },
        End: function () {
          handle.setFocus(handle.length - 1);
        },
        Enter: handle.pick,
        Esc: handle.close
      };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != 'string')
        bound = function (cm) {
          return val(cm, handle);
        };  // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom)
        if (custom.hasOwnProperty(key))
          addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra)
        if (extra.hasOwnProperty(key))
          addBinding(key, extra[key]);
    return ourMap;
  }
  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === 'LI' && el.parentNode == hintsElement)
        return el;
      el = el.parentNode;
    }
  }
  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    var widget = this, cm = completion.cm;
    var hints = this.hints = document.createElement('ul');
    hints.className = 'CodeMirror-hints';
    this.selectedHint = data.selectedHint || 0;
    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement('li')), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? '' : ' ' + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null)
        className = cur.className + ' ' + className;
      elt.className = className;
      if (cur.render)
        cur.render(elt, data, cur);
      else
        elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + 'px';
    hints.style.top = top + 'px';
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (completion.options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = box.top - (pos.bottom - pos.top);
      if (curTop - height > 0) {
        // Fits above cursor
        hints.style.top = (top = curTop - height) + 'px';
        below = false;
      } else if (height > winH) {
        hints.style.height = winH - 5 + 'px';
        hints.style.top = (top = pos.bottom - box.top) + 'px';
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + 'px';
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.left - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + 'px';
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + 'px';
    }
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function (n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function (n) {
        widget.changeActive(n);
      },
      menuSize: function () {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function () {
        completion.close();
      },
      pick: function () {
        widget.pick();
      },
      data: data
    }));
    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on('blur', this.onBlur = function () {
        closingOnBlur = setTimeout(function () {
          completion.close();
        }, 100);
      });
      cm.on('focus', this.onFocus = function () {
        clearTimeout(closingOnBlur);
      });
    }
    var startScroll = cm.getScrollInfo();
    cm.on('scroll', this.onScroll = function () {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below)
        point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom)
        return completion.close();
      hints.style.top = newTop + 'px';
      hints.style.left = left + startScroll.left - curScroll.left + 'px';
    });
    CodeMirror.on(hints, 'dblclick', function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror.on(hints, 'click', function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick)
          widget.pick();
      }
    });
    CodeMirror.on(hints, 'mousedown', function () {
      setTimeout(function () {
        cm.focus();
      }, 20);
    });
    CodeMirror.signal(data, 'select', completions[0], hints.firstChild);
    return true;
  }
  Widget.prototype = {
    close: function () {
      if (this.completion.widget != this)
        return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off('blur', this.onBlur);
        cm.off('focus', this.onFocus);
      }
      cm.off('scroll', this.onScroll);
    },
    pick: function () {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function (i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i)
        return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(' ' + ACTIVE_HINT_ELEMENT_CLASS, '');
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += ' ' + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, 'select', this.data.list[this.selectedHint], node);
    },
    screenAmount: function () {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };
  CodeMirror.registerHelper('hint', 'auto', function (cm, options) {
    var helpers = cm.getHelpers(cm.getCursor(), 'hint'), words;
    if (helpers.length) {
      for (var i = 0; i < helpers.length; i++) {
        var cur = helpers[i](cm, options);
        if (cur && cur.list.length)
          return cur;
      }
    } else if (words = cm.getHelper(cm.getCursor(), 'hintWords')) {
      if (words)
        return CodeMirror.hint.fromList(cm, { words: words });
    } else if (CodeMirror.hint.anyword) {
      return CodeMirror.hint.anyword(cm, options);
    }
  });
  CodeMirror.registerHelper('hint', 'fromList', function (cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, token.string.length) == token.string)
        found.push(word);
    }
    if (found.length)
      return {
        list: found,
        from: CodeMirror.Pos(cur.line, token.start),
        to: CodeMirror.Pos(cur.line, token.end)
      };
  });
  CodeMirror.commands.autocomplete = CodeMirror.showHint;
  var defaultOptions = {
      hint: CodeMirror.hint.auto,
      completeSingle: true,
      alignWithWord: true,
      closeCharacters: /[\s()\[\]{};:>,]/,
      closeOnUnfocus: true,
      completeOnSingleClick: false,
      container: null,
      customKeys: null,
      extraKeys: null
    };
  CodeMirror.defineOption('hintOptions', null);
}));
CodeMirror.defineMode('xml', function (config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;
  var Kludges = parserConfig.htmlMode ? {
      autoSelfClosers: {
        'area': true,
        'base': true,
        'br': true,
        'col': true,
        'command': true,
        'embed': true,
        'frame': true,
        'hr': true,
        'img': true,
        'input': true,
        'keygen': true,
        'link': true,
        'meta': true,
        'param': true,
        'source': true,
        'track': true,
        'wbr': true
      },
      implicitlyClosed: {
        'dd': true,
        'li': true,
        'optgroup': true,
        'option': true,
        'p': true,
        'rp': true,
        'rt': true,
        'tbody': true,
        'td': true,
        'tfoot': true,
        'th': true,
        'tr': true
      },
      contextGrabbers: {
        'dd': {
          'dd': true,
          'dt': true
        },
        'dt': {
          'dd': true,
          'dt': true
        },
        'li': { 'li': true },
        'option': {
          'option': true,
          'optgroup': true
        },
        'optgroup': { 'optgroup': true },
        'p': {
          'address': true,
          'article': true,
          'aside': true,
          'blockquote': true,
          'dir': true,
          'div': true,
          'dl': true,
          'fieldset': true,
          'footer': true,
          'form': true,
          'h1': true,
          'h2': true,
          'h3': true,
          'h4': true,
          'h5': true,
          'h6': true,
          'header': true,
          'hgroup': true,
          'hr': true,
          'menu': true,
          'nav': true,
          'ol': true,
          'p': true,
          'pre': true,
          'section': true,
          'table': true,
          'ul': true
        },
        'rp': {
          'rp': true,
          'rt': true
        },
        'rt': {
          'rp': true,
          'rt': true
        },
        'tbody': {
          'tbody': true,
          'tfoot': true
        },
        'td': {
          'td': true,
          'th': true
        },
        'tfoot': { 'tbody': true },
        'th': {
          'td': true,
          'th': true
        },
        'thead': {
          'tbody': true,
          'tfoot': true
        },
        'tr': { 'tr': true }
      },
      doNotIndent: { 'pre': true },
      allowUnquoted: true,
      allowMissing: true
    } : {
      autoSelfClosers: {},
      implicitlyClosed: {},
      contextGrabbers: {},
      doNotIndent: {},
      allowUnquoted: false,
      allowMissing: false
    };
  var alignCDATA = parserConfig.alignCDATA;
  // Return variables for tokenizers
  var tagName, type;
  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }
    var ch = stream.next();
    if (ch == '<') {
      if (stream.eat('!')) {
        if (stream.eat('[')) {
          if (stream.match('CDATA['))
            return chain(inBlock('atom', ']]>'));
          else
            return null;
        } else if (stream.match('--')) {
          return chain(inBlock('comment', '-->'));
        } else if (stream.match('DOCTYPE', true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat('?')) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock('meta', '?>');
        return 'meta';
      } else {
        var isClose = stream.eat('/');
        tagName = '';
        var c;
        while (c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))
          tagName += c;
        if (!tagName)
          return 'error';
        type = isClose ? 'closeTag' : 'openTag';
        state.tokenize = inTag;
        return 'tag';
      }
    } else if (ch == '&') {
      var ok;
      if (stream.eat('#')) {
        if (stream.eat('x')) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(';');
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(';');
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(';');
      }
      return ok ? 'atom' : 'error';
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == '>' || ch == '/' && stream.eat('>')) {
      state.tokenize = inText;
      type = ch == '>' ? 'endTag' : 'selfcloseTag';
      return 'tag';
    } else if (ch == '=') {
      type = 'equals';
      return null;
    } else if (ch == '<') {
      return 'error';
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.eatWhile(/[^\s\u00a0=<>\"\']/);
      return 'word';
    }
  }
  function inAttribute(quote) {
    var closure = function (stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return 'string';
    };
    closure.isInAttribute = true;
    return closure;
  }
  function inBlock(style, terminator) {
    return function (stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function (stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == '<') {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == '>') {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return 'meta';
    };
  }
  var curState, curStream, setStyle;
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--)
      curState.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function pushContext(tagName, startOfLine) {
    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || curState.context && curState.context.noIndent;
    curState.context = {
      prev: curState.context,
      tagName: tagName,
      indent: curState.indented,
      startOfLine: startOfLine,
      noIndent: noIndent
    };
  }
  function popContext() {
    if (curState.context)
      curState.context = curState.context.prev;
  }
  function element(type) {
    if (type == 'openTag') {
      curState.tagName = tagName;
      curState.tagStart = curStream.column();
      return cont(attributes, endtag(curState.startOfLine));
    } else if (type == 'closeTag') {
      var err = false;
      if (curState.context) {
        if (curState.context.tagName != tagName) {
          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
            popContext();
          }
          err = !curState.context || curState.context.tagName != tagName;
        }
      } else {
        err = true;
      }
      if (err)
        setStyle = 'error';
      return cont(endclosetag(err));
    }
    return cont();
  }
  function endtag(startOfLine) {
    return function (type) {
      var tagName = curState.tagName;
      curState.tagName = curState.tagStart = null;
      if (type == 'selfcloseTag' || type == 'endTag' && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {
        maybePopContext(tagName.toLowerCase());
        return cont();
      }
      if (type == 'endTag') {
        maybePopContext(tagName.toLowerCase());
        pushContext(tagName, startOfLine);
        return cont();
      }
      return cont();
    };
  }
  function endclosetag(err) {
    return function (type) {
      if (err)
        setStyle = 'error';
      if (type == 'endTag') {
        popContext();
        return cont();
      }
      setStyle = 'error';
      return cont(arguments.callee);
    };
  }
  function maybePopContext(nextTagName) {
    var parentTagName;
    while (true) {
      if (!curState.context) {
        return;
      }
      parentTagName = curState.context.tagName.toLowerCase();
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext();
    }
  }
  function attributes(type) {
    if (type == 'word') {
      setStyle = 'attribute';
      return cont(attribute, attributes);
    }
    if (type == 'endTag' || type == 'selfcloseTag')
      return pass();
    setStyle = 'error';
    return cont(attributes);
  }
  function attribute(type) {
    if (type == 'equals')
      return cont(attvalue, attributes);
    if (!Kludges.allowMissing)
      setStyle = 'error';
    else if (type == 'word') {
      setStyle = 'attribute';
      return cont(attribute, attributes);
    }
    return type == 'endTag' || type == 'selfcloseTag' ? pass() : cont();
  }
  function attvalue(type) {
    if (type == 'string')
      return cont(attvaluemaybe);
    if (type == 'word' && Kludges.allowUnquoted) {
      setStyle = 'string';
      return cont();
    }
    setStyle = 'error';
    return type == 'endTag' || type == 'selfCloseTag' ? pass() : cont();
  }
  function attvaluemaybe(type) {
    if (type == 'string')
      return cont(attvaluemaybe);
    else
      return pass();
  }
  return {
    startState: function () {
      return {
        tokenize: inText,
        cc: [],
        indented: 0,
        startOfLine: true,
        tagName: null,
        tagStart: null,
        context: null
      };
    },
    token: function (stream, state) {
      if (!state.tagName && stream.sol()) {
        state.startOfLine = true;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace())
        return null;
      setStyle = type = tagName = null;
      var style = state.tokenize(stream, state);
      state.type = type;
      if ((style || type) && style != 'comment') {
        curState = state;
        curStream = stream;
        while (true) {
          var comb = state.cc.pop() || element;
          if (comb(type || style))
            break;
        }
      }
      state.startOfLine = false;
      return setStyle || style;
    },
    indent: function (state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        return state.stringStartCol + 1;
      }
      if (state.tokenize != inTag && state.tokenize != inText || context && context.noIndent)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (multilineTagIndentPastTag)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * multilineTagIndentFactor;
      }
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter))
        return 0;
      if (context && /^<\//.test(textAfter))
        context = context.prev;
      while (context && !context.startOfLine)
        context = context.prev;
      if (context)
        return context.indent + indentUnit;
      else
        return 0;
    },
    electricChars: '/',
    blockCommentStart: '<!--',
    blockCommentEnd: '-->',
    configuration: parserConfig.htmlMode ? 'html' : 'xml',
    helperType: parserConfig.htmlMode ? 'html' : 'xml'
  };
});
CodeMirror.defineMIME('text/xml', 'xml');
CodeMirror.defineMIME('application/xml', 'xml');
if (!CodeMirror.mimeModes.hasOwnProperty('text/html'))
  CodeMirror.defineMIME('text/html', {
    name: 'xml',
    htmlMode: true
  });
(function () {
  'use strict';
  angular.module('ramlEditorApp', [
    'ui.bootstrap.modal',
    'ui.bootstrap.tpls',
    'ui.tree',
    'ramlConsoleApp',
    'codeMirror',
    'fs',
    'raml',
    'stringFilters',
    'utils',
    'lightweightDOM',
    'splitter',
    'validate',
    'autoFocus',
    'rightClick',
    'dragAndDrop'
  ]);
}());
'use strict';
if (!Array.prototype.find) {
  Array.prototype.find = function (predicate) {
    for (var i = 0, len = this.length; i < len; i++) {
      var item = this[i];
      if (predicate(item)) {
        return item;
      }
    }
    return undefined;
  };
}
if (!Array.prototype.includes) {
  Array.prototype.includes = function (value) {
    for (var i = 0, len = this.length; i < len; i++) {
      var item = this[i];
      if (item === value) {
        return true;
      }
    }
    return false;
  };
}
'use strict';
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function (text) {
    return this.indexOf(text) === 0;
  };
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function (text) {
    return this.lastIndexOf(text) === this.length - text.length;
  };
}
(function () {
  'use strict';
  angular.module('utils', []).value('indentUnit', 2).factory('safeApply', [
    '$rootScope',
    '$exceptionHandler',
    function safeApplyFactory($rootScope, $exceptionHandler) {
      return function safeApply(scope, expr) {
        scope = scope || $rootScope;
        if ([
            '$apply',
            '$digest'
          ].indexOf(scope.$root && scope.$root.$$phase || scope.$$phase) !== -1) {
          try {
            return scope.$eval(expr);
          } catch (e) {
            $exceptionHandler(e);
          }
        } else {
          return scope.$apply(expr);
        }
      };
    }
  ]).factory('safeApplyWrapper', [
    'safeApply',
    function safeApplyWrapperFactory(safeApply) {
      return function safeApplyWrapper(scope, expr) {
        return function safeApplyWrapperInner1() {
          var args = Array.prototype.slice.call(arguments, 0);
          return safeApply(scope, function safeApplyWrapperInner2() {
            return expr.apply(this, args);
          });
        };
      };
    }
  ]).factory('getTime', function () {
    return Date.now || function () {
      return new Date().getTime();
    };
  }).factory('debounce', [
    '$timeout',
    '$q',
    function debounceFactory($timeout, $q) {
      /**
      * Ensures that a function will be called just once
      * after a period of time expires.
      *
      * @param {Function} target the function to debounce
      * @param {number} wait the wait delay in miliseconds
      */
      return function (target, wait) {
        var timeout = null;
        var deferred = $q.defer();
        return function () {
          var context = this;
          var args = arguments;
          var invokeTarget = function invokeTarget() {
            // call the target function, resolve the promise and reset local state for following calls
            timeout = null;
            deferred.resolve(target.apply(context, args));
            deferred = $q.defer();
          };
          // if timeout exists means that the function is being called again before the delay has finished
          // so we cancel the delayed execution in order to re-schedule it
          timeout && $timeout.cancel(timeout);
          // schedule (or re-schedule) the delayed execution
          timeout = $timeout(invokeTarget, wait);
          // return a promise that will be resolved when the target function is called
          return deferred.promise;
        };
      };
    }
  ]).value('generateSpaces', function (spaceCount) {
    spaceCount = spaceCount || 0;
    return new Array(spaceCount + 1).join(' ');
  }).factory('generateTabs', [
    'generateSpaces',
    'indentUnit',
    function (generateSpaces, indentUnit) {
      return function (tabs, customIndentUnit) {
        customIndentUnit = customIndentUnit || indentUnit;
        tabs = tabs || 0;
        return new Array(tabs + 1).join(generateSpaces(indentUnit));
      };
    }
  ]).value('$prompt', function (message, value) {
    return window.prompt(message, value);
  }).value('$confirm', function (message) {
    return window.confirm(message);
  }).factory('generateName', function () {
    // generateName(names, defaultName, extension)
    // Takes a list of names under the current directory, uses defaultName as a pattern,
    // and add enumeration to the end of the defaultName.
    //
    // For example:
    // name        = ["Untitled-1.raml", "Untitled-2.raml", "test.raml"]
    // defaultName = 'Untitled-'
    // extension   = 'raml'
    //
    // will return 'Untitled-3.raml'
    return function generateName(names, defaultName, extension) {
      extension = extension ? '.' + extension : '';
      var currentMax = Math.max.apply(undefined, names.map(function (name) {
          var re = new RegExp(defaultName + '(\\d+)');
          var match = name.match(re);
          return match ? match[1] : 0;
        }).concat(0));
      return defaultName + (currentMax + 1) + extension;
    };
  }).factory('scroll', function () {
    var keys = {
        37: true,
        38: true,
        39: true,
        40: true
      };
    function preventDefault(e) {
      e = e || window.event;
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
    function keyDown(e) {
      if (keys[e.keyCode]) {
        preventDefault(e);
      }
    }
    function wheel(e) {
      preventDefault(e);
    }
    return {
      enable: function () {
        if (window.removeEventListener) {
          window.removeEventListener('DOMMouseScroll', wheel, false);
        }
        window.onmousewheel = document.onmousewheel = document.onkeydown = null;
      },
      disable: function () {
        if (window.addEventListener) {
          window.addEventListener('DOMMouseScroll', wheel, false);
        }
        window.onmousewheel = document.onmousewheel = wheel;
        document.onkeydown = keyDown;
      }
    };
  }).factory('resolveUri', [
    '$window',
    function resolveUri($window) {
      return function resolveUri(uri) {
        // starts with "http://" OR "https://" OR <scheme>://"
        if (/^\w+:\/\//.test(uri)) {
          return uri;
        }
        // starts with "/"
        if (uri[0] === '/') {
          return $window.location.origin + uri;
        }
        return $window.location.origin + $window.location.pathname.split('/').slice(0, -1).concat(uri).join('/');
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('raml').value('config', {
    set: function (key, value) {
      localStorage['config.' + key] = value;
    },
    get: function (key, defaultValue) {
      key = 'config.' + key;
      if (key in localStorage) {
        return localStorage[key];
      }
      return defaultValue;
    },
    remove: function (key) {
      delete localStorage['config.' + key];
    },
    clear: function () {
      localStorage.clear();
    }
  });
  ;
}());
/**
 * The lightweight-dom module provides a DOM-like API over raml documents. For
 * performance reasons, this DOM is lazy; navigation from one node to
 * another involves parsing RAML rather than walking an actual DOM.
 *
 * The parsing code is built on lightweight-parse, for which this module is
 * intended to be a facade.
 * It is designed for editor purposes and not intended to be a compliant
 * RAML parser, but an MVP implementation designed to make things like reliably
 * showing the right shelf items a matter not of string parsing but of RAML DOM
 * inspection/traversal.
 *
 * Since this is a designer DOM, it attempts to return as much data as possible
 * even if a document is correctly formed. To this end, parents/children are
 * defined as having a less than/greater than tab count. For example:
 * Foo:
 *     Bar:
 *           Baz:
 * The child of Foo is Bar and the child of Bar is Baz. The reverse traversal
 * is Baz to Bar to Foo. So, it is thus up to client code to detect proper
 * nesting by inspecting nodes' tabCount. For example, code could autocorrect
 * users' code, show an error, or ignore the issue and let the user fix the
 * errors themselves.
 */
(function () {
  'use strict';
  angular.module('lightweightDOM', ['lightweightParse']).factory('getNode', [
    'getSpaceCount',
    'getTabCount',
    'getLineIndent',
    'isArrayStarter',
    'isCommentStarter',
    'extractKeyValue',
    function getNodeFactory(getSpaceCount, getTabCount, getLineIndent, isArrayStarter, isCommentStarter, extractKeyValue) {
      var cache = {};
      //region LazyNode Class Definition
      /**
       * Builds a new lazy node from the given content.
       * @param editor The CodeMirror raml editor containing the RAML document
       * @param lineNumber The line to read the node from.
       * @constructor
       * @throws If lineNumber is out of range of the editor's contents
       */
      function LazyNode(editor, lineNumber, line) {
        this.editor = editor;
        this.lineNumber = lineNumber;
        this.line = line;
        this.lineIndent = getLineIndent(this.line, editor.getOption('indentUnit'));
        this.isEmpty = this.lineIndent.spaceCount === this.line.length;
        this.isComment = !this.isEmpty && isCommentStarter(this.line);
        this.isArrayStarter = !this.isComment && isArrayStarter(this.line);
        this.isStructural = !this.isEmpty && !this.isComment;
      }
      LazyNode.prototype.getKeyValue = function getKeyValue() {
        if (!this.keyValue) {
          this.keyValue = extractKeyValue(this.line);
        }
        return this.keyValue;
      };
      LazyNode.prototype.getKey = function getKey() {
        return this.getKeyValue().key;
      };
      LazyNode.prototype.getValue = function getValue() {
        return this.getKeyValue().value;
      };
      /**
       * @returns {LazyNode} The next structural sibling node, or null.
       */
      LazyNode.prototype.getNextSibling = function getNextSibling() {
        // Calculate the correct tab indent for the next sibling:
        // For non-array nodes, the indent is identical
        // For array node, the indent is one greater
        var nextLineNumber = this.lineNumber;
        while (true) {
          var nextNode = getNode(this.editor, ++nextLineNumber);
          if (nextNode === null) {
            return null;
          }
          // Skip empty elements and comments
          if (!nextNode.isStructural) {
            continue;
          }
          // If the next node is at our tab level it is always a sibling
          if (nextNode.lineIndent.tabCount === this.lineIndent.tabCount) {
            return nextNode;
          }
          // Array case:
          // Previous element is non-starter in previous array:
          if (this.isArrayStarter && !nextNode.isArrayStarter && nextNode.lineIndent.tabCount === this.lineIndent.tabCount + 1) {
            return nextNode;
          }
          // Previous element is starter in previous array:
          if (!this.isArrayStarter && nextNode.isArrayStarter && nextNode.lineIndent.tabCount === this.lineIndent.tabCount - 1) {
            return nextNode;
          }
          // If we end up at a lower tab count, then there are no more siblings possible
          if (nextNode.lineIndent.tabCount < this.lineIndent.tabCount) {
            return null;
          }
        }
      };
      /**
       * @returns {LazyNode} The previous structural sibling node, or null.
       */
      LazyNode.prototype.getPreviousSibling = function getPreviousSibling() {
        // Calculate the correct tab indent for the previous sibling:
        // For non-array nodes, the indent is identical
        // For array node, the indent is one less OR an element that is an array starter
        var prevLineNumber = this.lineNumber;
        while (true) {
          prevLineNumber -= 1;
          var prevNode = getNode(this.editor, prevLineNumber);
          if (prevNode === null) {
            return null;
          }
          // Ignore comments and empty lines
          if (!prevNode.isStructural) {
            continue;
          }
          // If the previous node is at our tab level it is always a sibling
          if (prevNode.lineIndent.tabCount === this.lineIndent.tabCount) {
            return prevNode;
          }
          // Array cases:
          // Previous element is non-starter in previous array:
          if (this.isArrayStarter && !prevNode.isArrayStarter && prevNode.lineIndent.tabCount === this.lineIndent.tabCount + 1) {
            return prevNode;
          }
          // Previous element is starter in previous array:
          if (!this.isArrayStarter && prevNode.isArrayStarter && prevNode.lineIndent.tabCount === this.lineIndent.tabCount - 1) {
            return prevNode;
          }
          //If we end up at a lower tab count, then there are no more siblings possible
          if (prevNode.lineIndent.tabCount < this.lineIndent.tabCount) {
            return null;
          }
        }
      };
      /**
       * @returns {LazyNode} The first structural child node, or null.
       */
      LazyNode.prototype.getFirstChild = function getFirstChild() {
        var nextNodeTabCount = this.lineIndent.tabCount + (this.isArrayStarter ? 2 : 1);
        var nextLineNumber = this.lineNumber;
        while (true) {
          var nextNode = getNode(this.editor, ++nextLineNumber);
          if (nextNode === null) {
            return null;
          }
          // If we end up at the same or lower tab count, then there are no children possible
          if (nextNode.lineIndent.tabCount < nextNodeTabCount) {
            return null;
          }
          // look at any node at or beyond the tabCount since the document could be malformed,
          // but we still want to return children.
          if (nextNode.lineIndent.tabCount >= nextNodeTabCount && nextNode.isStructural) {
            return nextNode;
          }
        }
      };
      /**
       * @returns {LazyNode} The parent node, or null if this is a root node
       */
      LazyNode.prototype.getParent = function getParent() {
        // For members of arrays that aren't the first array element, the parent is
        // two tabs over, e.g
        // documentation:
        //   - title: foo
        //     content: bar <- 2 tabs over from parent
        var parentNodeTabCount = this.lineIndent.tabCount - (!this.isArrayStarter && this.getIsInArray() ? 2 : 1);
        var prevLineNumber = this.lineNumber;
        while (true) {
          var prevNode = getNode(this.editor, --prevLineNumber);
          if (prevNode === null) {
            return null;
          }
          // look at any node at or beyond the tabCount since the document could be malformed,
          // but we still want to return a parent if we can find one.
          if (prevNode.lineIndent.tabCount <= parentNodeTabCount && prevNode.isStructural) {
            return prevNode;
          }
        }
      };
      /**
       * @returns {[LazyNode]} All direct descendants of this node
       */
      LazyNode.prototype.getChildren = function getChildren() {
        var children = [];
        var child = this.getFirstChild();
        while (child !== null) {
          children.push(child);
          child = child.getNextSibling();
        }
        return children;
      };
      /**
       * @returns {[LazyNode]} The current node plus any nodes at the same tab
       * level with the same parent. For arrays, returns all members of the
       * node's array. Array consists first of current node, then previous neighbors
       * then next neighbors.
       */
      LazyNode.prototype.getSelfAndNeighbors = function getSelfAndNeighbors() {
        var nodes = [];
        var inArray = this.getIsInArray();
        var node = this;
        while (node && node.getIsInArray() === inArray) {
          nodes.push(node);
          if (node.isArrayStarter) {
            break;
          }
          node = node.getPreviousSibling();
        }
        node = this.getNextSibling();
        while (node && !node.isArrayStarter && node.getIsInArray() === inArray) {
          nodes.push(node);
          node = node.getNextSibling();
        }
        return nodes;
      };
      /**
       * @returns {Boolean} Whether or not the node is in an array
       */
      LazyNode.prototype.getIsInArray = function getIsInArray() {
        // Walk previous siblings until we find one that starts an array, or we run
        // out of siblings.
        // Note: We don't use recursion here since JS has a low recursion limit of 1000
        if (this.isArrayStarter) {
          return true;
        }
        // Move up until we find a node one tab count less: If it is
        // an array starter, we are in an array
        var node = this.getPreviousSibling();
        while (node && node.lineIndent.tabCount >= this.lineIndent.tabCount) {
          node = node.getPreviousSibling();
        }
        return !!(node && node.isArrayStarter && node.lineIndent.tabCount === this.lineIndent.tabCount - 1);
      };
      /**
       * @returns {Array} Returns array containing all parent nodes of
       * this node, with the direct parent being the last element in the
       * array.
       */
      LazyNode.prototype.getPath = function getPath() {
        var path = [];
        var node = this;
        while (node = node.getParent()) {
          path.unshift(node);
        }
        return path;
      };
      /**
       * Executes the testFunc against this node and its parents, moving up the
       * tree until no more nodes are found.  Will halt if the test function
       * returns true.
       * @param testFunc Function to execute against current node and parents
       * @returns {LazyNode} The first node where testFunc returns true, or null.
       */
      LazyNode.prototype.selfOrParent = function selfOrParent(testFunc) {
        return this.first(this.getParent, testFunc);
      };
      /**
       * Executes the testFunc against this node and its prior siblings. Will
       * halt if the test function returns true.
       * @param testFunc Function to execute against current node and parents
       * @returns {LazyNode} The first node where testFunc returns true, or null.
       */
      LazyNode.prototype.selfOrPrevious = function selfOrPrevious(testFunc) {
        return this.first(this.getPreviousSibling, testFunc);
      };
      /**
       * Executes the test function against all nodes, including the current one,
       * returned by nextNodeFunc. Halts when no more nodes are found or testFunc
       * returns a truthy value.
       * @param nextNodeFunc Function that returns the next node to search.
       * @param testFunc Function that returns a node that matches a filter.
       * @returns {LazyNode} The first node where testFunc returns true, or null.
       */
      LazyNode.prototype.first = function first(nextNodeFunc, testFunc) {
        var node = this;
        while (node) {
          if (testFunc(node)) {
            return node;
          }
          node = nextNodeFunc.apply(node);
        }
        return null;
      };
      //endregion
      /**
       * @param editor The CodeMirror raml editor containing the RAML document
       * @param lineNumber The line to read the node from, or the current cursor
       *                line if not specified.
       * @returns {LazyNode} Instance of LazyNode at given line, or null if the
       * line is not a number or out of editor bounds.
       */
      function getNode(editor, lineNumber) {
        // If the line number is a number but out of bounds then we return null.
        // If the line number is not a number, we use the current editor line.
        var cursor = editor.getCursor();
        var codeLineNum = arguments.length > 1 ? lineNumber : cursor.line;
        var line = editor.getLine(codeLineNum);
        var cachedNode = cache[codeLineNum];
        if (line === undefined) {
          return null;
        }
        // Special case: If a node is non-structural, e.g. an empty line or a comment, then by
        // contract with upper layers, we use the cursor position if it is at the line.
        // This matches the behavior of the shelf and autocomplete features.
        // It is, admittedly, a little bit obscure but based on all editor use cases we've looked at, it works.
        if (cursor.line === codeLineNum) {
          var spaceCount = getSpaceCount(line);
          if (spaceCount === line.length || line[spaceCount] === '#') {
            line = line.slice(0, cursor.ch);
          }
        }
        if (!cachedNode || cachedNode.line !== line) {
          cachedNode = cache[codeLineNum] = new LazyNode(editor, codeLineNum, line);
        }
        return cachedNode;
      }
      return getNode;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('lightweightParse', ['utils']).factory('getSpaceCount', function getSpaceCountFactory() {
    return function getSpaceCount(line) {
      for (var i = 0, length = line.length; i < length; i++) {
        if (line[i] !== ' ') {
          break;
        }
      }
      return i;
    };
  }).factory('getTabCount', [
    'indentUnit',
    function getTabCountFactory(indentUnit) {
      return function getTabCount(spaceCount, indentSize) {
        indentSize = indentSize || indentUnit;
        return Math.floor(spaceCount / indentSize);
      };
    }
  ]).factory('getLineIndent', [
    'getSpaceCount',
    'getTabCount',
    function getLineIndentFactory(getSpaceCount, getTabCount) {
      return function getLineIndent(line, indentSize) {
        var spaceCount = getSpaceCount(line);
        return {
          spaceCount: spaceCount,
          tabCount: getTabCount(spaceCount, indentSize),
          content: spaceCount ? line.slice(spaceCount) : line
        };
      };
    }
  ]).factory('isArrayStarter', [
    'getSpaceCount',
    function isArrayStarterFactory(getSpaceCount) {
      return function isArrayStarter(line) {
        var spaceCount = getSpaceCount(line);
        return line[spaceCount] === '-' && line[spaceCount + 1] === ' ';
      };
    }
  ]).factory('isCommentStarter', [
    'getSpaceCount',
    function isCommentStarterFactory(getSpaceCount) {
      return function isCommentStarter(line) {
        var spaceCount = getSpaceCount(line);
        return line[spaceCount] === '#';
      };
    }
  ]).factory('extractKeyValue', function extractKeyValueFactory() {
    /**
       * Removes the whitespaces from the line between start and end indices.
       *
       * @param line The line that needs to be trimmed.
       * @param start The index of left border of the line where trimming should begin.
       * If value is negative, it'll be computed based on length of the line as [length + start].
       * @param end The index of the right border of the line where trimming should end.
       * If value is negative, it'll be computed based on length of the line as [length + end].
       *
       * @returns The trimmed line without whitespaces between start and end.
       */
    function trim(line, start, end) {
      start = start || 0;
      end = end || line.length;
      if (start < 0) {
        start = line.length + start;
      }
      if (end < 0) {
        end = line.length + end;
      }
      while (start < end && line[start] === ' ') {
        start += 1;
      }
      while (start < end && line[end - 1] === ' ') {
        end -= 1;
      }
      if (start === 0 && end === line.length) {
        return line;
      }
      return line.slice(start, end);
    }
    /**
       * Transforms a value which is a string into an object that provides additional
       * information such as whether value is an alias or a reference.
       *
       * @param value The value that needs to be transformed.
       *
       * @returns {{text, isAlias, isReference}}
       */
    function transformValue(value) {
      if (!value) {
        return null;
      }
      return {
        text: value,
        isAlias: value[0] === '&',
        isReference: value[0] === '*'
      };
    }
    return function extractKeyValue(line) {
      var start = 0;
      var end = line.length;
      var indexOf = line.indexOf('#');
      if (indexOf !== -1) {
        end = indexOf;
      }
      indexOf = line.indexOf('- ');
      if (indexOf !== -1 && indexOf < end) {
        start = indexOf + 2;
      }
      indexOf = line.indexOf(': ', start);
      if (indexOf !== -1 && indexOf < end) {
        return {
          key: trim(line, start, indexOf),
          value: transformValue(trim(line, indexOf + 2, end))
        };
      }
      indexOf = line.lastIndexOf(':', end);
      if (indexOf === end - 1) {
        return {
          key: trim(line, start, end - 1),
          value: null
        };
      }
      return {
        key: null,
        value: transformValue(trim(line, start, end))
      };
    };
  }).factory('getScopes', [
    'getLineIndent',
    function getScopesFactory(getLineIndent) {
      var lastArrayCache;
      function areArraysEqual(a, b) {
        if (a === undefined || b === undefined) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      return function getScopes(arrayOfLines) {
        if (lastArrayCache && areArraysEqual(lastArrayCache.key, arrayOfLines)) {
          return lastArrayCache.value;
        }
        var currentIndexes = {};
        var zipValues = arrayOfLines.map(function (line, index) {
            var lineIndentInfo = getLineIndent(line);
            return {
              tabCount: lineIndentInfo.tabCount,
              content: lineIndentInfo.content,
              lineNumber: index
            };
          });
        var levelTable = zipValues.reduce(function (result, currentLine) {
            var currentArray = currentIndexes[currentLine.tabCount - 1], lastArrayIndex, currentIndex;
            if (currentArray) {
              lastArrayIndex = currentArray.length - 1;
              currentIndex = currentIndexes[currentLine.tabCount - 1][lastArrayIndex];
            } else if (currentLine.tabCount > 1) {
              // Case for lists, we fetch a level lower
              currentArray = currentIndexes[currentLine.tabCount - 2];
              // Ignore this line if the tab level is invalid
              if (currentArray) {
                lastArrayIndex = currentArray.length - 1;
                currentIndex = currentIndexes[currentLine.tabCount - 2][lastArrayIndex];
                result[currentIndex] = result[currentIndex] || [];
                result[currentIndex].push({
                  lineNumber: currentLine.lineNumber,
                  content: currentLine.content,
                  tabCount: currentLine.tabCount
                });
                currentIndexes[currentLine.tabCount - 1] = currentIndexes[currentLine.tabCount - 1] || [];
                currentIndexes[currentLine.tabCount - 1].push(currentLine.lineNumber);
              }
              return result;
            } else {
              // Case of the first element of the first level
              currentIndex = 0;
            }
            result[currentIndex] = result[currentIndex] || [];
            result[currentIndex].push({
              lineNumber: currentLine.lineNumber,
              content: currentLine.content,
              tabCount: currentLine.tabCount
            });
            currentIndexes[currentLine.tabCount] = currentIndexes[currentLine.tabCount] || [];
            currentIndexes[currentLine.tabCount].push(currentLine.lineNumber);
            return result;
          }, {});
        lastArrayCache = {
          result: {
            scopeLevels: currentIndexes,
            scopesByLine: levelTable
          },
          lines: arrayOfLines
        };
        return {
          scopeLevels: currentIndexes,
          scopesByLine: levelTable
        };
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeFolding', [
    'raml',
    'lightweightParse'
  ]).factory('getFoldRange', [
    'getLineIndent',
    function getFoldRangeFactory(getLineIndent) {
      return function getFoldRange(cm, start) {
        var line = cm.getLine(start.line);
        var lineIndentInfo = getLineIndent(line);
        var nextLineIndentInfo;
        if (!lineIndentInfo.content) {
          return;
        }
        var nextLine = cm.getLine(start.line + 1);
        if (!nextLine) {
          return;
        }
        var tabCount = lineIndentInfo.tabCount;
        var nextTabCount = getLineIndent(nextLine).tabCount;
        if (nextTabCount > tabCount) {
          for (var i = start.line + 2, end = cm.lineCount(); i < end; i++) {
            nextLine = cm.getLine(i);
            nextLineIndentInfo = getLineIndent(nextLine);
            nextTabCount = nextLineIndentInfo.tabCount;
            if (nextTabCount <= tabCount && nextLineIndentInfo.content) {
              nextLine = cm.getLine(i - 1);
              return {
                from: CodeMirror.Pos(start.line, line.length),
                to: CodeMirror.Pos(i - 1, nextLine.length)
              };
            }
            if (i === end - 1) {
              nextLine = cm.getLine(end - 1);
              return {
                from: CodeMirror.Pos(start.line, line.length),
                to: CodeMirror.Pos(end - 1, nextLine.length)
              };
            }
          }
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror', [
    'raml',
    'ramlEditorApp',
    'codeFolding'
  ]).factory('codeMirror', [
    '$rootScope',
    'ramlSuggest',
    'codeMirrorHighLight',
    'generateSpaces',
    'generateTabs',
    'getFoldRange',
    'isArrayStarter',
    'getSpaceCount',
    'getTabCount',
    'config',
    'extractKeyValue',
    function ($rootScope, ramlSuggest, codeMirrorHighLight, generateSpaces, generateTabs, getFoldRange, isArrayStarter, getSpaceCount, getTabCount, config, extractKeyValue) {
      var editor = null;
      var service = { CodeMirror: CodeMirror };
      service.removeTabs = function (line, indentUnit) {
        var spaceCount = getTabCount(getSpaceCount(line), indentUnit) * indentUnit;
        return spaceCount ? line.slice(spaceCount) : line;
      };
      service.tabKey = function (cm) {
        var cursor = cm.getCursor();
        var line = cm.getLine(cursor.line);
        var indentUnit = cm.getOption('indentUnit');
        var spaces;
        var result;
        var unitsToIndent;
        if (cm.somethingSelected()) {
          cm.indentSelection('add');
          return;
        }
        result = service.removeTabs(line, indentUnit);
        result = result.length ? result : '';
        // if in half/part of a tab, add the necessary spaces to complete the tab
        if (result !== '' && result.replace(/ /g, '') === '') {
          unitsToIndent = indentUnit - result.length;  // if not ident normally
        } else {
          unitsToIndent = indentUnit;
        }
        spaces = generateSpaces(unitsToIndent);
        cm.replaceSelection(spaces, 'end', '+input');
      };
      service.backspaceKey = function (cm) {
        var cursor = cm.getCursor();
        var line = cm.getLine(cursor.line).slice(0, cursor.ch);
        var indentUnit = cm.getOption('indentUnit');
        var spaceCount = line.length - line.replace(/\s+$/, '').length;
        var lineEndsWithTab = spaceCount >= indentUnit;
        // delete indentation if there is at least one right before
        // the cursor and number of whitespaces is a multiple of indentUnit
        //
        // we do it for better user experience as if you had 3 whitespaces
        // before cursor and pressed Backspace, you'd expect cursor to stop
        // at second whitespace to continue typing RAML content, otherwise
        // you'd end up at first whitespace and be forced to hit Spacebar
        if (lineEndsWithTab && spaceCount % indentUnit === 0) {
          for (var i = 0; i < indentUnit; i++) {
            cm.deleteH(-1, 'char');
          }
          return;
        }
        cm.deleteH(-1, 'char');
      };
      var MODES = {
          xml: { name: 'xml' },
          xsd: {
            name: 'xml',
            alignCDATA: true
          },
          json: {
            name: 'javascript',
            json: true
          },
          md: { name: 'gfm' },
          raml: { name: 'raml' }
        };
      var defaultKeys = {
          'Cmd-S': 'save',
          'Ctrl-S': 'save',
          'Shift-Tab': 'indentLess',
          'Shift-Ctrl-T': 'toggleTheme'
        };
      var ramlKeys = {
          'Ctrl-Space': 'autocomplete',
          'Cmd-S': 'save',
          'Ctrl-S': 'save',
          'Shift-Tab': 'indentLess',
          'Shift-Ctrl-T': 'toggleTheme'
        };
      service.configureEditor = function (editor, extension) {
        var mode = MODES[extension] || MODES.raml;
        editor.setOption('mode', mode);
        if (mode.name === 'raml') {
          editor.setOption('extraKeys', ramlKeys);
        } else {
          editor.setOption('extraKeys', defaultKeys);
        }
      };
      service.enterKey = function (cm) {
        function getParent(lineNumber, spaceCount) {
          for (var i = lineNumber - 1; i >= 0; i--) {
            if (getSpaceCount(cm.getLine(i)) < spaceCount) {
              return extractKeyValue(cm.getLine(i)).key;
            }
          }
        }
        var cursor = cm.getCursor();
        var endOfLine = cursor.ch >= cm.getLine(cursor.line).length - 1;
        var line = cm.getLine(cursor.line).slice(0, cursor.ch);
        var lineStartsArray = isArrayStarter(line);
        var spaceCount = getSpaceCount(line);
        var spaces = generateSpaces(spaceCount);
        var parent = getParent(cursor.line, spaceCount);
        var traitOrType = [
            'traits',
            'resourceTypes'
          ].indexOf(parent) !== -1;
        if (endOfLine) {
          (function () {
            if (traitOrType) {
              spaces += generateTabs(2);
              return;
            } else if (lineStartsArray) {
              spaces += generateTabs(1);
            }
            if (line.replace(/\s+$/, '').slice(-1) === '|') {
              spaces += generateTabs(1);
              return;
            }
            var nextLine = cm.getLine(cursor.line + 1);
            if (nextLine && getSpaceCount(nextLine) > spaceCount) {
              spaces += generateTabs(1);
            }
          }());
        } else {
          if (lineStartsArray) {
            spaces += generateTabs(1);
          }
        }
        cm.replaceSelection('\n' + spaces, 'end', '+input');
      };
      service.createEditor = function (el, extraOptions) {
        var shouldEnableFoldGutter = JSON.parse(config.get('folding', 'true'));
        var foldGutterConfig = false;
        var cm;
        var options;
        if (shouldEnableFoldGutter) {
          foldGutterConfig = {
            rangeFinder: CodeMirror.fold.indent,
            foldOnChangeTimeSpan: 300,
            updateViewportTimeSpan: 200
          };
        }
        options = {
          mode: 'raml',
          theme: 'solarized dark',
          lineNumbers: true,
          lineWrapping: true,
          autofocus: true,
          indentWithTabs: false,
          indentUnit: 2,
          tabSize: 2,
          keyMap: 'tabSpace',
          foldGutter: foldGutterConfig,
          gutters: [
            'CodeMirror-lint-markers',
            'CodeMirror-linenumbers',
            'CodeMirror-foldgutter'
          ]
        };
        if (extraOptions) {
          Object.keys(extraOptions).forEach(function (key) {
            options[key] = extraOptions[key];
          });
        }
        cm = new CodeMirror(el, options);
        cm.setSize('100%', '100%');
        cm.foldCode(0, { rangeFinder: CodeMirror.fold.indent });
        var charWidth = cm.defaultCharWidth();
        var basePadding = 4;
        cm.on('renderLine', function (cm, line, el) {
          var offset = CodeMirror.countColumn(line.text, null, cm.getOption('tabSize')) * charWidth;
          el.style.textIndent = '-' + offset + 'px';
          el.style.paddingLeft = basePadding + offset + 'px';
        });
        return cm;
      };
      service.initEditor = function () {
        var el = document.getElementById('code');
        var cm = service.createEditor(el);
        // for testing automation purposes
        editor = window.editor = cm;
        return cm;
      };
      service.setLine = function (editor, lineNumber, text) {
        editor.replaceRange(text, {
          line: lineNumber,
          ch: 0
        }, { line: lineNumber });
      };
      service.removeLine = function (editor, lineNumber) {
        editor.replaceRange('', { line: lineNumber === 0 ? lineNumber : lineNumber - 1 }, { line: lineNumber });
      };
      service.getEditor = function () {
        return editor;
      };
      (function bootstrap() {
        CodeMirror.keyMap.tabSpace = {
          Tab: service.tabKey,
          Backspace: service.backspaceKey,
          Enter: service.enterKey,
          fallthrough: ['default']
        };
        CodeMirror.commands.save = function () {
          $rootScope.$broadcast('event:save');
        };
        CodeMirror.commands.autocomplete = function (cm) {
          CodeMirror.showHint(cm, CodeMirror.hint.raml, {
            completeSingle: false,
            ghosting: false,
            async: true
          });
        };
        CodeMirror.commands.toggleTheme = function () {
          $rootScope.$broadcast('event:toggle-theme');
        };
        CodeMirror.defineMode('raml', codeMirrorHighLight.highlight);
        CodeMirror.defineMIME('text/x-raml', 'raml');
        CodeMirror.registerHelper('hint', 'raml', ramlSuggest.autocompleteHelper.bind(ramlSuggest));
        CodeMirror.registerHelper('fold', 'indent', getFoldRange);
      }());
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror').factory('codeMirrorErrors', [
    'codeMirror',
    '$timeout',
    function (codeMirror, $timeout) {
      var CodeMirror = codeMirror.CodeMirror;
      var GUTTER_ID = 'CodeMirror-lint-markers';
      var SEVERITIES = /^(?:error|warning)$/;
      var service = {};
      function showTooltip(content, node) {
        var tt = document.createElement('div');
        tt.className = 'CodeMirror-lint-tooltip';
        tt.appendChild(content.cloneNode(true));
        // need to append element to DOM to get its height
        tt.style.visibility = 'hidden';
        document.body.appendChild(tt);
        var offset = $(node).offset();
        tt.style.top = Math.max(0, offset.top - tt.offsetHeight) + 'px';
        tt.style.left = offset.left + 20 + 'px';
        if (tt.style.opacity !== null) {
          tt.style.opacity = 1;
        }
        tt.style.visibility = 'visible';
        return tt;
      }
      function rm(elt) {
        if (elt.parentNode) {
          elt.parentNode.removeChild(elt);
        }
      }
      function hideTooltip(tt) {
        if (!tt.parentNode) {
          return;
        }
        if (tt.style.opacity === null) {
          rm(tt);
        }
        tt.style.opacity = 0;
        $timeout(function () {
          rm(tt);
        }, 200);
      }
      function showTooltipFor(content, node) {
        var tooltip = showTooltip(content, node);
        var errorNode = node;
        var openTrace = function (event) {
          hide(tooltip);
          var path = event.target.dataset.path;
          if (path) {
            var $scope = angular.element(errorNode).scope();
            $scope.$emit('event:raml-editor-file-select', path);
          }
        };
        function isMouseOverElement(element, e) {
          if (!e) {
            return false;
          }
          var left = $(element).offset().left;
          var right = left + $(element).outerWidth();
          var mouseOverX = left <= e.clientX && e.clientX <= right + 5;
          var top = $(element).offset().top;
          var bottom = top + $(element).outerHeight();
          var mouseOverY = top <= e.clientY && e.clientY <= bottom;
          return mouseOverX && mouseOverY;
        }
        function hide(e) {
          if (tooltip) {
            var mouseOverError = isMouseOverElement(errorNode, e);
            var mouseOverTooltip = isMouseOverElement(tooltip, e);
            if (!(mouseOverTooltip || mouseOverError)) {
              CodeMirror.off(tooltip, 'mousedown', openTrace);
              CodeMirror.off(document, 'mousemove', hide);
              hideTooltip(tooltip);
              tooltip = null;
            }
          }
        }
        var poll = setInterval(function () {
            if (tooltip) {
              for (var n = node;; n = n.parentNode) {
                if (n === document.body) {
                  return;
                }
                if (!n) {
                  hide();
                  break;
                }
              }
            } else {
              return clearInterval(poll);
            }
          }, 400);
        CodeMirror.on(tooltip, 'mousedown', openTrace);
        CodeMirror.on(document, 'mousemove', hide);
      }
      function clearMarks(cm) {
        cm.clearGutter(GUTTER_ID);
      }
      function getMaxSeverity(a, b) {
        return a === 'error' ? a : b;
      }
      function groupByLine(annotations) {
        var lines = [];
        for (var i = 0, len = annotations.length; i < len; ++i) {
          var annotation = annotations[i], line = annotation.line || 1;
          (lines[line] || (lines[line] = [])).push(annotation);
        }
        return lines;
      }
      function annotationTooltip(annotation) {
        var severity = annotation.severity;
        if (!SEVERITIES.test(severity)) {
          severity = 'error';
        }
        var tip = document.createElement('div');
        tip.className = 'CodeMirror-lint-message-' + severity;
        var message = annotation.message;
        // if error belongs to different file, add tracing information to message
        if (annotation.path) {
          message += ' at line ' + annotation.tracingLine + ' col ' + annotation.tracingColumn + ' in ' + '<a href="javascript:" data-path="/' + annotation.path + '">' + annotation.path + '</a>';
        }
        tip.innerHTML = '<p class=CodeMirror-tag-' + severity + '>' + severity + '</p>' + '<p class="CodeMirror-message">' + message + '</p>';
        return tip;
      }
      function makeMarker(labels, severity, multiple, tooltips, annotations) {
        var marker = document.createElement('div');
        var inner = marker;
        marker.className = 'CodeMirror-lint-marker-' + severity;
        if (multiple) {
          inner = marker.appendChild(document.createElement('div'));
          inner.className = 'CodeMirror-lint-marker-multiple';
        }
        if (tooltips !== false) {
          CodeMirror.on(inner, 'mouseenter', function () {
            showTooltipFor(labels, inner);
          });
        }
        //For testing automation purposes
        marker.setAttribute('data-marker-line', annotations[0].line);
        marker.setAttribute('data-marker-message', annotations[0].message);
        return marker;
      }
      service.displayAnnotations = function (annotationsNotSorted, editor) {
        editor = editor || codeMirror.getEditor();
        clearMarks(editor);
        var annotations = groupByLine(annotationsNotSorted);
        for (var line = 0; line < annotations.length; ++line) {
          var anns = annotations[line];
          if (!anns) {
            continue;
          }
          var maxSeverity = null;
          var tipLabel = document.createDocumentFragment();
          for (var i = 0; i < anns.length; ++i) {
            var ann = anns[i];
            var severity = ann.severity;
            if (!SEVERITIES.test(severity)) {
              severity = 'error';
            }
            maxSeverity = getMaxSeverity(maxSeverity, severity);
            tipLabel.appendChild(annotationTooltip(ann));
          }
          editor.setGutterMarker(line - 1, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1, true, anns));
        }
      };
      service.clearAnnotations = function () {
        clearMarks(codeMirror.getEditor());
      };
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('raml').value('snippets', {
    options: [
      'options:',
      '  description: <<insert text or markdown here>>'
    ],
    head: [
      'head:',
      '  description: <<insert text or markdown here>>'
    ],
    get: [
      'get:',
      '  description: <<insert text or markdown here>>'
    ],
    post: [
      'post:',
      '  description: <<insert text or markdown here>>'
    ],
    put: [
      'put:',
      '  description: <<insert text or markdown here>>'
    ],
    delete: [
      'delete:',
      '  description: <<insert text or markdown here>>'
    ],
    trace: [
      'trace:',
      '  description: <<insert text or markdown here>>'
    ],
    connect: [
      'connect:',
      '  description: <<insert text or markdown here>>'
    ],
    patch: [
      'patch:',
      '  description: <<insert text or markdown here>>'
    ],
    '<resource>': [
      '/newResource:',
      '  displayName: resourceName'
    ],
    title: ['title: My API'],
    version: ['version: v0.1'],
    baseuri: ['baseUri: http://server/api/{version}']
  }).factory('ramlSnippets', [
    'snippets',
    function (snippets) {
      var service = {};
      var emptyValues = [];
      var extendValue = ['extends'];
      var fragments = [
          {
            label: 'Trait',
            keyValues: emptyValues
          },
          {
            label: 'ResourceType',
            keyValues: emptyValues
          },
          {
            label: 'Library',
            keyValues: ['usage']
          },
          {
            label: 'Overlay',
            keyValues: extendValue
          },
          {
            label: 'Extension',
            keyValues: extendValue
          },
          {
            label: 'DataType',
            keyValues: emptyValues
          },
          {
            label: 'DocumentationItem',
            keyValues: [
              'title',
              'content'
            ]
          },
          {
            label: 'NamedExample',
            keyValues: ['value']
          },
          {
            label: 'AnnotationTypeDeclaration',
            keyValues: emptyValues
          },
          {
            label: 'SecurityScheme',
            keyValues: ['type']
          },
          {
            label: '',
            keyValues: ['title']
          }
        ];
      function getRequiredValuesForFragment(typedFragment) {
        return fragments.find(function (fragment) {
          return fragment.label === typedFragment;
        }).keyValues;
      }
      service.getEmptyRaml = function (ramlVersion, fragmentLabel) {
        var version = ramlVersion ? ramlVersion : '1.0';
        var type = fragmentLabel ? ' ' + fragmentLabel : '';
        var requiredValues = getRequiredValuesForFragment(fragmentLabel ? fragmentLabel : '');
        var ramlContent = ['#%RAML ' + version + type];
        requiredValues.forEach(function (value) {
          ramlContent.push(value + ':');
        });
        return ramlContent.join('\n');
      };
      service.getSnippet = function getSnippet(suggestion) {
        var key = suggestion.key;
        var metadata = suggestion.metadata || {};
        var snippet = snippets[key.toLowerCase()];
        if (snippet) {
          return snippet;
        }
        if (metadata.isText) {
          //For text elements that are part of an array
          //we do not add an empty line break:
          return suggestion.isList ? [key] : [
            key,
            ''
          ];
        }
        return [key + ':'];
      };
      return service;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror').value('highlightRootElement', function (name, titleClass, contentClass, state, level, key) {
    // Using one level of nesting nest (ie. [name + '.level']) instead of
    // [name].level to use default copy state function.
    if (level <= state[name + '.level']) {
      state[name + '.level'] = 0;
      state[name + '.inside'] = false;
    }
    if (name.indexOf(key) >= 0) {
      state[name + '.level'] = level;
      state[name + '.inside'] = true;
      return titleClass;
    }
    if (state[name + '.inside']) {
      return contentClass;
    }
    return false;
  }).value('booleanValues', [
    'true',
    'false'
  ]).factory('keywordRegex', [
    'booleanValues',
    function (booleanValues) {
      return new RegExp('\\b((' + booleanValues.join(')|(') + '))$', 'i');
    }
  ]).factory('token', [
    'keywordRegex',
    'highlightRootElement',
    'getLineIndent',
    'indentUnit',
    function (keywordRegex, highlightRootElement, getLineIndent, indentUnit) {
      return function (stream, state) {
        var ch = stream.peek();
        var esc = state.escaped;
        state.escaped = false;
        /* RAML tag */
        if (ch === '#' && /^#%RAML (0\.8|1\.0|1\.0\s\w+)$/.test(stream.string.trim())) {
          stream.skipToEnd();
          return 'raml-tag';
        }
        /* comments */
        if (ch === '#' && (stream.pos === 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
          stream.skipToEnd();
          return 'comment';
        }
        if (state.literal && stream.indentation() > state.keyCol) {
          stream.skipToEnd();
          return 'none';
        } else if (state.literal) {
          state.literal = false;
        }
        if (stream.sol()) {
          state.keyCol = 0;
          state.pair = false;
          state.pairStart = false;
          /* document start */
          if (stream.match(/---/)) {
            return 'def';
          }
          /* document end */
          if (stream.match(/\.\.\./)) {
            return 'def';
          }
          /* array list item */
          if (stream.match(/\s*-\s+/)) {
            return 'meta';
          }
        }
        /* pairs (associative arrays) -> key */
        if (!state.pair && stream.match(/^\s*([a-z0-9\?\/\{\}\._\-])+(?=\s*:)/i)) {
          var key = stream.string.replace(/^\s+|\s+$/g, '').split(':')[0];
          var sanitizedKey = key.slice(-1) === '?' ? key.slice(0, -1) : key;
          var level = getLineIndent(stream.string).tabCount;
          state.pair = true;
          state.keyCol = stream.indentation();
          if (stream.string.match(/^\s*\- /i)) {
            state.keyCol += indentUnit;
          }
          /* methods */
          if (level <= state.methodLevel || key.indexOf('/') === 0) {
            state.methodLevel = 0;
            state.insideMethod = false;
          }
          if ([
              'options',
              'get',
              'head',
              'post',
              'put',
              'delete',
              'trace',
              'connect',
              'patch'
            ].indexOf(sanitizedKey) !== -1) {
            state.methodLevel = level;
            state.insideMethod = true;
            return 'method-title';
          }
          if (state.insideMethod) {
            return 'method-content';
          }
          var rootElements = highlightRootElement('traits', 'trait-title', 'trait-content', state, level, key) || highlightRootElement('resourceTypes', 'resource-type-title', 'resource-type-content', state, level, key) || highlightRootElement('schemas', 'schema-title', 'schema-content', state, level, key) || highlightRootElement('securitySchemes', 'security-scheme-title', 'security-scheme-content', state, level, key);
          if (rootElements) {
            return rootElements;
          }
          /* resources */
          if (key.indexOf('/') === 0) {
            return 'resource';
          }
          return 'key';
        }
        if (state.pair && stream.match(/^:\s*/)) {
          state.pairStart = true;
          return 'meta';
        }
        /* inline pairs/lists */
        if (stream.match(/^(\{|\}|\[|\])/)) {
          if (ch === '{') {
            state.inlinePairs++;
          } else if (ch === '}') {
            state.inlinePairs--;
          } else if (ch === '[') {
            state.inlineList++;
          } else {
            state.inlineList--;
          }
          return 'meta';
        }
        /* list seperator */
        if (state.inlineList > 0 && !esc && ch === ',') {
          stream.next();
          return 'meta';
        }
        /* pairs seperator */
        if (state.inlinePairs > 0 && !esc && ch === ',') {
          state.keyCol = 0;
          state.pair = false;
          state.pairStart = false;
          stream.next();
          return 'meta';
        }
        /* start of value of a pair */
        if (state.pairStart) {
          /* block literals */
          if (stream.match(/^\s*(\||\>)\s*/)) {
            state.literal = true;
            return 'meta';
          }
          /* references */
          if (stream.match(/^\s*(\&|\*)[a-z0-9\._\-]+\b/i)) {
            return 'variable-2';
          }
          /* numbers */
          if (state.inlinePairs === 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) {
            return 'number';
          }
          if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|\}))/)) {
            return 'number';
          }
          /* keywords */
          if (stream.match(keywordRegex)) {
            return 'keyword';
          }
        }
        /* nothing found, continue */
        state.pairStart = false;
        state.escaped = ch === '\\';
        stream.next();
        return null;
      };
    }
  ]).value('startState', function () {
    return {
      pair: false,
      pairStart: false,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: false,
      escaped: false
    };
  }).factory('yamlMode', [
    'token',
    'startState',
    function (token, startState) {
      return function () {
        return {
          token: token,
          startState: startState
        };
      };
    }
  ]).run([
    'codeMirror',
    'yamlMode',
    function (codeMirror, yamlMode) {
      var CodeMirror = codeMirror.CodeMirror;
      CodeMirror.defineMode('yaml', yamlMode);
      CodeMirror.defineMIME('text/x-yaml', 'yaml');
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('codeMirror').factory('codeMirrorHighLight', [
    'indentUnit',
    function (indentUnit) {
      var mode = {};
      mode.highlight = function highlight(config) {
        mode.indentationOverlay = {
          token: function token(stream, state) {
            if (state.cutoff === undefined || stream.column() <= state.cutoff) {
              if (stream.match('  ')) {
                return 'indent indent-col-' + stream.column();
              } else if (stream.match(' ')) {
                return 'indent-incomplete';
              }
            }
            stream.skipToEnd();
          },
          startState: function startState() {
            return {};
          }
        };
        mode.yaml = CodeMirror.overlayMode(CodeMirror.getMode(config, 'yaml'), mode.indentationOverlay);
        mode.xml = CodeMirror.overlayMode(CodeMirror.getMode(config, 'xml'), mode.indentationOverlay);
        mode.json = CodeMirror.overlayMode(CodeMirror.getMode(config, {
          name: 'javascript',
          json: true
        }), mode.indentationOverlay);
        mode.markdown = CodeMirror.overlayMode(CodeMirror.getMode(config, 'gfm'), mode.indentationOverlay);
        return {
          startState: function startState() {
            return {
              token: mode._yaml,
              localMode: null,
              localState: null,
              yamlState: mode.yaml.startState()
            };
          },
          copyState: function copyState(state) {
            var local;
            if (state.localState) {
              local = CodeMirror.copyState(state.localMode, state.localState);
              if (!local.parentIndentation) {
                local.parentIndentation = state.localState.parentIndentation;
              }
            }
            return {
              token: state.token,
              localMode: state.localMode,
              localState: local,
              yamlState: CodeMirror.copyState(mode.yaml, state.yamlState)
            };
          },
          innerMode: function innerMode(state) {
            return {
              state: state.localState || state.yamlState,
              mode: state.localMode || mode.yaml
            };
          },
          token: function token(stream, state) {
            return state.token(stream, state);
          }
        };
      };
      mode._yaml = function (stream, state) {
        if (/(content|description):(\s?)\|/.test(stream.string)) {
          mode._setMode('markdown', stream, state);
        }
        if (/application\/json:/.test(stream.string)) {
          mode._setMode('json', stream, state, 2);
        }
        if (/text\/xml:/.test(stream.string)) {
          mode._setMode('xml', stream, state, 2);
        }
        return mode.yaml.token(stream, state.yamlState);
      };
      mode._xml = function (stream, state) {
        return mode._applyMode('xml', stream, state);
      };
      mode._json = function (stream, state) {
        return mode._applyMode('json', stream, state);
      };
      mode._markdown = function (stream, state) {
        return mode._applyMode('markdown', stream, state);
      };
      mode._setMode = function (modeName, stream, state, indent) {
        state.token = mode['_' + modeName];
        state.localMode = mode[modeName];
        state.localState = mode[modeName].startState();
        state.localState.parentIndentation = stream.indentation() + (indent || 0);
        if (stream.string.match(/^\s*\- /i)) {
          state.localState.parentIndentation += indentUnit;
        }
        if (modeName === 'markdown') {
          state.localState.base.parentIndentation = state.localState.parentIndentation;
        }
      };
      mode._applyMode = function (modeName, stream, state) {
        if (/(schema|example):(\s?)\|/.test(stream.string)) {
          return mode._yaml(stream, state);
        }
        if (stream.string.trim().length > 0 && stream.indentation() <= state.localState.parentIndentation) {
          state.token = mode._yaml;
          state.localState = state.localMode = null;
          return mode._yaml(stream, state);
        }
        state.localState.overlay.cutoff = state.localState.parentIndentation;
        return mode[modeName].token(stream, state.localState);
      };
      return mode;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  function RamlFile(path, contents, options) {
    options = options || {};
    // remove the trailing slash to path if it exists
    if (path.slice(-1) === '/' && path.length > 1) {
      path = path.slice(0, -1);
    }
    this.type = 'file';
    this.path = path;
    this.name = path.slice(path.lastIndexOf('/') + 1);
    this.isDirectory = false;
    // extract extension
    if (this.name.lastIndexOf('.') > 0) {
      this.extension = this.name.slice(this.name.lastIndexOf('.') + 1);
    }
    this.contents = contents || '';
    this.persisted = options.persisted || false;
    this.dirty = options.dirty || !this.persisted;
    this.root = options.root;
  }
  angular.module('fs', [
    'raml',
    'utils'
  ]).factory('ramlRepository', [
    '$q',
    '$rootScope',
    'ramlSnippets',
    'fileSystem',
    function ($q, $rootScope, ramlSnippets, fileSystem) {
      var service = {};
      var BASE_PATH = '/';
      var rootFile;
      service.supportsFolders = fileSystem.supportsFolders || false;
      function notMetaFile(file) {
        return file.path.slice(-5) !== '.meta';
      }
      function metaFile(file) {
        return !notMetaFile(file);
      }
      function handleErrorFor(file) {
        return function markFileWithError(error) {
          file.error = error;
          throw error;
        };
      }
      /**
        * Function used to compare two ramlFile/ramlDirectory.
        * Sorting policy:
        * - Directories comes before files
        * - Sort file/directories alphabetically
        *
        * @returns {Integer} If the returned value is less than 0, sort a to a lower index than b, vice versa
        */
      function sortingFunction(a, b) {
        if (a.isDirectory === b.isDirectory) {
          return a.name.localeCompare(b.name);
        } else {
          return a.isDirectory ? -1 : 1;
        }
      }
      function findInsertIndex(source, dest) {
        var low = 0, high = dest.children.length - 1, mid;
        while (high >= low) {
          mid = Math.floor((low + high) / 2);
          if (sortingFunction(dest.children[mid], source) > 0) {
            high = mid - 1;
          } else {
            low = mid + 1;
          }
        }
        return low;
      }
      function insertFileSystem(parent, child) {
        // This assumes the paths are correct.
        var before = parent.path === '/' ? [''] : parent.path.split('/');
        var parts = child.path.split('/').slice(0, -1);
        var promise = $q.when(parent);
        parts.slice(before.length).forEach(function (part) {
          promise = promise.then(function (parent) {
            var path = service.join(parent.path, part);
            var exists = service.getByPath(path);
            // If the current path already exists.
            if (exists) {
              if (!exists.isDirectory) {
                return $q.reject(new Error('Can not create directory, file already exists: ' + path));
              }
              return exists;
            }
            return service.createDirectory(parent, part);
          });
        });
        return promise.then(function (parent) {
          var exists = service.getByPath(child.path);
          if (exists) {
            if (exists.isDirectory && child.isDirectory) {
              return exists;
            }
            return $q.reject(new Error('Path already exists: ' + child.path));
          }
          parent.children.splice(findInsertIndex(child, parent), 0, child);
          return child;
        });
      }
      // this function takes a target(ramlFile/ramlDirectory) and a name(String) as input
      // and returns the new path(String) after renaming the target
      function generateNewName(target, newName) {
        var parentPath = target.path.slice(0, target.path.lastIndexOf('/'));
        return parentPath + '/' + newName;
      }
      function RamlDirectory(path, meta, contents) {
        // remove the trailing slash to path if it exists
        if (path.slice(-1) === '/' && path.length > 1) {
          path = path.slice(0, -1);
        }
        contents = contents || [];
        this.type = 'directory';
        this.path = path;
        this.name = path.slice(path.lastIndexOf('/') + 1);
        this.meta = meta;
        this.collapsed = true;
        this.isDirectory = true;
        var separated = {
            folder: [],
            file: []
          };
        contents.forEach(function (entry) {
          separated[entry.type || 'file'].push(entry);
        });
        var createRamlFile = function (file) {
          return new RamlFile(file.path, file.contents, {
            dirty: false,
            persisted: true,
            root: file.root
          });
        };
        var files = separated.file.filter(notMetaFile).map(createRamlFile);
        var metaFiles = separated.file.filter(metaFile).map(createRamlFile);
        var directories = separated.folder.map(function (directory) {
            return new RamlDirectory(directory.path, directory.meta, directory.children);
          });
        this.children = directories.concat(files).sort(sortingFunction);
        this.metaChildren = directories.concat(metaFiles).sort(sortingFunction);
      }
      RamlDirectory.prototype.getDirectories = function getDirectories() {
        return this.children.filter(function (t) {
          return t.isDirectory;
        });
      };
      RamlDirectory.prototype.getFiles = function getFiles() {
        return this.children.filter(function (t) {
          return !t.isDirectory;
        });
      };
      RamlDirectory.prototype.getMetaFiles = function getMetaFiles() {
        return this.metaChildren.filter(function (t) {
          return !t.isDirectory;
        });
      };
      RamlDirectory.prototype.forEachItemDo = function forEachItemDo(action, isMetaChildren) {
        // BFS
        var queue = isMetaChildren ? this.metaChildren.slice() : this.children.slice();
        var current;
        while (queue.length > 0) {
          current = queue.shift();
          if (current.isDirectory) {
            queue = queue.concat(isMetaChildren ? current.metaChildren : current.children);
          }
          action.call(current, current);
        }
      };
      RamlDirectory.prototype.forEachChildDo = function forEachChildDo(action) {
        this.forEachItemDo(action, false);
      };
      RamlDirectory.prototype.forEachMetaChildDo = function forEachChildDo(action) {
        this.forEachItemDo(action, true);
      };
      RamlDirectory.prototype.sortChildren = function sortChildren() {
        this.children.sort(sortingFunction);
      };
      // Expose the sorting function
      service.sortingFunction = sortingFunction;
      // Returns the parent directory object of a file or a directory
      service.getParent = function getParent(target) {
        var path = target.path.slice(0, target.path.lastIndexOf('/'));
        if (path.length === 0) {
          path = '/';
        }
        return service.getByPath(path);
      };
      service.canExport = function canExport() {
        return fileSystem.hasOwnProperty('exportFiles');
      };
      service.exportFiles = function exportFiles() {
        return fileSystem.exportFiles();
      };
      service.createDirectory = function createDirectory(parent, name) {
        var path = service.join(parent.path, name);
        var directory = new RamlDirectory(path);
        var exists = service.getByPath(path);
        // If the file already exists, return it.
        if (exists) {
          return $q.when(exists);
        }
        return insertFileSystem(parent, directory).then(function () {
          return fileSystem.createFolder(directory.path);
        }).then(function () {
          return directory;
        });
      };
      service.generateDirectory = function createDirectory(parent, name) {
        return service.createDirectory(parent, name).then(function (directory) {
          $rootScope.$broadcast('event:raml-editor-directory-created', directory);
          return directory;
        });
      };
      // Loads the directory from the fileSystem into memory
      service.loadDirectory = function loadDirectory() {
        return fileSystem.directory(BASE_PATH).then(function (directory) {
          rootFile = new RamlDirectory(directory.path, directory.meta, directory.children);
          return rootFile;
        });
      };
      service.removeDirectory = function removeDirectory(directory) {
        // recursively remove all the child directory and files
        // and collect all promises into an array
        var promises = [];
        directory.getDirectories().forEach(function (dir) {
          promises.push(service.removeDirectory(dir));
        });
        directory.getFiles().concat(directory.getMetaFiles()).forEach(function (file) {
          promises.push(service.removeFile(file));
        });
        // remove this directory object from parent's children list
        var parent = service.getParent(directory);
        var index = parent.children.indexOf(directory);
        if (index !== -1) {
          parent.children.splice(index, 1);
        }
        // make sure all children is removed from FS before we remove ourselves
        return $q.all(promises).then(function () {
          return fileSystem.remove(directory.path);
        }).then(function (directory) {
          $rootScope.$broadcast('event:raml-editor-directory-removed', directory);
        });
      };
      service.renameDirectory = function renameDirectory(directory, newName) {
        var newPath = generateNewName(directory, newName);
        var promise = fileSystem.rename(directory.path, newPath);
        // renames the path of each child under the current directory
        directory.forEachChildDo(function (c) {
          c.path = c.path.replace(directory.path, newPath);
        });
        return promise.then(function () {
          directory.name = newName;
          directory.path = newPath;
          $rootScope.$broadcast('event:raml-editor-filetree-modified', directory);
          return directory;
        }, handleErrorFor(directory));
      };
      service.saveFile = function saveFile(file) {
        function modifyFile() {
          file.dirty = false;
          file.persisted = true;
          return file;
        }
        return fileSystem.save(file.path, file.contents).then(modifyFile, handleErrorFor(file));
      };
      service.renameFile = function renameFile(file, newName) {
        var newPath = generateNewName(file, newName);
        var promise = file.persisted ? fileSystem.rename(file.path, newPath) : $q.when(file);
        function modifyFile() {
          file.name = newName;
          file.path = newPath;
          $rootScope.$broadcast('event:raml-editor-filetree-modified', file);
          return file;
        }
        return promise.then(modifyFile, handleErrorFor(file));
      };
      service.loadFile = function loadFile(file, nativeTimeout) {
        function modifyFile(data) {
          file.dirty = false;
          file.persisted = true;
          file.loaded = true;
          file.contents = data;
          return file;
        }
        return fileSystem.load(file.path, nativeTimeout).then(modifyFile, handleErrorFor(file));
        ;
      };
      service.removeFile = function removeFile(file) {
        var promise;
        var parent = service.getParent(file);
        function modifyFile() {
          file.dirty = false;
          file.persisted = false;
          return Object.freeze(file);
        }
        // call to file system only when file is persisted
        // otherwise it's unknown because it's never been saved
        if (file.persisted) {
          promise = fileSystem.remove(file.path);
        } else {
          promise = $q.when(file);
        }
        return promise.then(modifyFile, handleErrorFor(file)).then(function () {
          // remove the file object from the parent's children list
          if (notMetaFile(file)) {
            var index = parent.children.indexOf(file);
            if (index !== -1) {
              parent.children.splice(index, 1);
            }
          } else {
            var metaIndex = parent.metaChildren.indexOf(file);
            if (metaIndex !== -1) {
              parent.metaChildren.splice(metaIndex, 1);
            }
          }
          $rootScope.$broadcast('event:raml-editor-file-removed', file);
        });
      };
      service.createFile = function createFile(parent, name) {
        var path = service.join(parent.path, name);
        var file = new RamlFile(path);
        return insertFileSystem(parent, file).then(function () {
          $rootScope.$broadcast('event:raml-editor-file-created', file);
          return file;
        });
      };
      service.generateFile = function generateFile(parent, name, ramlVersion, fragmentLabel) {
        return service.createFile(parent, name).then(function (file) {
          if (file.extension === 'raml') {
            file.contents = ramlSnippets.getEmptyRaml(ramlVersion, fragmentLabel);
          }
          $rootScope.$broadcast('event:raml-editor-file-generated', file);
          return file;
        });
      };
      // Gets a promise of the ramlDirectory/ramlFile object by path from the memory, loading the content if not loaded yet
      service.getContentByPath = function getByPath(path, nativeTimeout) {
        var file = service.getByPath(path);
        if (!file) {
          return $q.reject('getByPathLoaded: ' + path + ': no such path');
        }
        if (file.loaded) {
          return $q.when(file.contents);
        }
        return service.loadFile(file, nativeTimeout).then(function mapContent(file) {
          return file.contents;
        });
      };
      // Gets the ramlDirectory/ramlFile object by path from the memory
      service.getByPath = function getByPath(path) {
        // Nothing to do if no path
        if (!path) {
          return;
        }
        if (path === '/') {
          return rootFile;
        }
        path = path.replace(/\/$/, '');
        var queue = rootFile.children.slice();
        var current;
        while (queue.length) {
          current = queue.shift();
          if (current.path === path) {
            return current;
          }
          if (current.isDirectory) {
            queue = queue.concat(current.children);
          }
        }
      };
      service.rename = function rename(target, newName) {
        return target.isDirectory ? service.renameDirectory(target, newName) : service.renameFile(target, newName);
      };
      service.remove = function remove(target) {
        return target.isDirectory ? service.removeDirectory(target) : service.removeFile(target);
      };
      // move a file or directory to a specific destination
      // destination must be a ramlDirectory
      service.move = function move(target, destination) {
        if (!destination.isDirectory) {
          return;
        }
        var newPath = service.join(destination.path, target.name);
        var promise;
        if (target.isDirectory) {
          promise = fileSystem.rename(target.path, newPath);
          // renames the path of each child under the current directory
          target.forEachChildDo(function (c) {
            c.path = c.path.replace(target.path, newPath);
          });
          // renames the path of each meta child under the current directory
          target.forEachMetaChildDo(function (c) {
            c.path = c.path.replace(target.path, newPath);
          });
        } else {
          service.moveMeta(target, destination);
          promise = target.persisted ? fileSystem.rename(target.path, newPath) : $q.when(target);
        }
        return promise.then(function () {
          target.path = newPath;
          return target;
        }, handleErrorFor(target));
      };
      service.saveMeta = function saveMeta(file, meta) {
        var metaFile = new RamlFile(file.path + '.meta', JSON.stringify(meta));
        return service.saveFile(metaFile).then(function () {
          var parent = service.getParent(metaFile);
          parent.metaChildren.push(metaFile);
          return meta;
        });
        ;
      };
      service.loadMeta = function loadMeta(file) {
        var metaFile = new RamlFile(file.path + '.meta');
        return service.loadFile(metaFile).then(function success(file) {
          return JSON.parse(file.contents);
        }, function failure() {
          return {};
        });
      };
      service.moveMeta = function moveMeta(file, destination) {
        var metaName = file.name + '.meta';
        var newMetaPath = service.join(destination.path, metaName);
        var metaPathName = file.path + '.meta';
        var oldParent = service.getParent(file);
        var metaFile = oldParent.metaChildren.find(function (meta) {
            return meta.path === metaPathName;
          });
        if (metaFile) {
          return fileSystem.rename(metaFile.path, newMetaPath).then(function success() {
            //Remove old parent meta data
            var index = oldParent.metaChildren.indexOf(metaFile);
            if (index !== -1) {
              oldParent.metaChildren.splice(index, 1);
            }
            metaFile.path = newMetaPath;
            destination.metaChildren.push(metaFile);
            return metaFile;
          }, function failure() {
            return metaFile;
          });
        }
      };
      service.join = function () {
        return Array.prototype.reduce.call(arguments, function (path, segment) {
          if (segment == null) {
            return path;
          }
          if (segment.charAt(0) === '/') {
            return segment;
          }
          return path.replace(/\/$/, '') + '/' + segment;
        }, '/');
      };
      return service;
    }
  ]);
  ;
}());
'use strict';
// Util Functions
function range(start, stop) {
  var result = new Array(stop - start + 1);
  for (var i = start; i <= stop; i++) {
    result[i - start] = i;
  }
  return result;
}
// end Util Functions
var FSResolver = function (homeDirectory, ramlRepository) {
  this.parsePath = function (path) {
    return path.split('/').filter(function (pathMember) {
      return pathMember && pathMember !== '';
    });
  };
  this.getElement = function (path) {
    var pathMembers = this.parsePath(path);
    return this.getElementFromPath(pathMembers, 0, homeDirectory);
  };
  this.getElementFromPath = function (pathMembers, index, element) {
    if (pathMembers.length === index) {
      return element;
    }
    if (!element.isDirectory) {
      return undefined;
    }
    var child = this.getChild(element, pathMembers[index]);
    if (!child) {
      return child;
    }
    return this.getElementFromPath(pathMembers, index + 1, child);
  };
  this.getChild = function (directory, childName) {
    return directory.children.find(function (child) {
      return child.name === childName;
    });
  };
  this.getFileContentAsync = function (file) {
    if (file.loaded) {
      if (file.doc) {
        return Promise.resolve(file.doc.getValue());
      }
      if (file.contents) {
        return Promise.resolve(file.contents);
      }
    }
    var getFileContent = function (file) {
      return file.contents;
    };
    return ramlRepository.loadFile(file, true).then(getFileContent);
  };
  this.contentAsync = function (path) {
    var element = this.getElement(path);
    if (!element || element.isDirectory) {
      return Promise.resolve('');
    }
    return this.getFileContentAsync(element);
  };
  this.list = function (path) {
    var element = this.getElement(path);
    if (!element || !element.isDirectory) {
      return [];
    }
    return element.children.map(function (child) {
      return child.name;
    });
  };
  this.listAsync = function (path) {
    return Promise.resolve(this.list(path));
  };
  this.exists = function (path) {
    return !!this.getElement(path);
  };
  this.existsAsync = function (path) {
    return Promise.resolve(this.exists(path));
  };
  this.dirname = function (path) {
    var element = this.getElement(path);
    if (!element) {
      return '';
    }
    if (element.isDirectory) {
      return element.path;
    }
    var result = path.substring(0, path.lastIndexOf('/') + 1);
    return result || '';
  };
  this.resolve = function (contextPath, relativePath) {
    if (relativePath.startsWith('/')) {
      return relativePath;
    }
    var pathBeginning = contextPath.endsWith('/') ? contextPath : contextPath + '/';
    return pathBeginning + relativePath;
  };
  this.extname = function (path) {
    var element = this.getElement(path);
    if (!element || element.isDirectory) {
      return '';
    }
    var nameParts = element.name.split('.');
    if (nameParts.length <= 1) {
      return '';
    }
    return nameParts[nameParts.length - 1];
  };
  this.isDirectory = function (path) {
    var element = this.getElement(path);
    return !!(element && element.isDirectory);
  };
  this.isDirectoryAsync = function (path) {
    return Promise.resolve(this.isDirectory(path));
  };
};
var EditorStateProvider = function (fsResolver, path, editor) {
  function sum(total, size) {
    return total + size;
  }
  this.getText = function () {
    return editor.getValue();
  };
  this.getPath = function () {
    return path;
  };
  this.getBaseName = function () {
    var element = fsResolver.getElement(path);
    return element ? element.name : '';
  };
  var calcOffset = function (editor) {
    var cursor = editor.getCursor();
    var allPreviewsLinesSize = range(0, cursor.line - 1).map(function (index) {
        return editor.getLine(index).length + 1;
      }).reduce(sum, 0);
    return allPreviewsLinesSize + cursor.ch;
  };
  this.offset = calcOffset(editor);
  this.getOffset = function () {
    return this.offset;
  };
};
angular.module('ramlEditorApp').factory('ramlSuggest', [
  'ramlRepository',
  'ramlEditorMainHelpers',
  function (ramlRepository, ramlEditorMainHelpers) {
    this.FSResolver = FSResolver;
    this.EditorStateProvider = EditorStateProvider;
    function codemirrorHint(editor, suggestions) {
      var separator = /:?(:|\s|\.|\[|]|-)+|!/;
      var currentPrefix = function (line, ch) {
        if (!line) {
          return '';
        }
        var split = line.slice(0, ch).split(separator);
        return split[split.length - 1];
      };
      var currentSufix = function (line, ch) {
        if (!line) {
          return '';
        }
        var split = line.slice(ch).split(separator);
        return split[0];
      };
      var render = function (element, self, data) {
        element.innerHTML = [
          '<div>',
          data.displayText,
          '</div>',
          '<div class="category">',
          data.category,
          '</div>'
        ].join('');
      };
      var codemirrorSuggestion = function (suggestion) {
        return {
          displayText: suggestion.displayText || suggestion.text,
          text: suggestion.text,
          category: suggestion.category,
          render: render
        };
      };
      function isWordPartOfTheSuggestion(word, suggestion) {
        if (!word) {
          return true;
        }
        var lowerCaseText = suggestion.text.toLowerCase();
        return lowerCaseText.startsWith(word) && lowerCaseText !== word;
      }
      var cursor = editor.getCursor();
      var line = editor.getLine(cursor.line);
      var ch = cursor.ch;
      var prefix = currentPrefix(line, ch) || '';
      var suffix = currentSufix(line, ch);
      var word = prefix + suffix;
      var lowerCaseWord = word.toLowerCase();
      var toCh = editor.getLine(cursor.line).length;
      var fromCh = ch - prefix.length;
      var codeMirrorSuggestions = suggestions.filter(function (suggestion) {
          return isWordPartOfTheSuggestion(lowerCaseWord, suggestion);
        }).map(codemirrorSuggestion);
      return {
        word: word,
        list: codeMirrorSuggestions,
        from: CodeMirror.Pos(cursor.line, fromCh),
        to: CodeMirror.Pos(cursor.line, toCh)
      };
    }
    function beautifyCategoryName(suggestion) {
      if (suggestion.category === undefined || suggestion.category.toLowerCase() === 'unknown') {
        suggestion.category = 'others';
      }
      return suggestion;
    }
    function ensureTextFieldNotUndefined(suggestion) {
      suggestion.text = suggestion.text || suggestion.displayText || '';
      return suggestion;
    }
    function addTextSnippets(editor, suggestions) {
      var ch = editor.getCursor().ch;
      var addNewResource = suggestions.length > 0 && (ch === 0 || suggestions.find(function (s) {
          return s.category === 'methods' ? s : null;
        }));
      if (addNewResource && ramlEditorMainHelpers.isApiDefinition(editor.getValue())) {
        var prefix = addNewResource.replacementPrefix || '';
        var spaces = '\n' + new Array(ch - prefix.length + 1).join(' ') + '  ';
        return suggestions.concat({
          text: '/newResource:' + spaces + 'displayName: resourceName' + spaces,
          displayText: 'New Resource',
          category: 'resources',
          replacementPrefix: prefix
        });
      }
      return suggestions;
    }
    this.getSuggestions = function (homeDirectory, currentFile, editor) {
      var ramlSuggestions = RAML.Suggestions;
      var fsResolver = new FSResolver(homeDirectory, ramlRepository);
      var contentProvider = ramlSuggestions.getContentProvider(fsResolver);
      var editorStateProvider = new EditorStateProvider(fsResolver, currentFile.path, editor);
      return ramlSuggestions.suggestAsync(editorStateProvider, contentProvider).then(function (result) {
        return Array.isArray(result) ? result : [];
      }, function () {
        return [];
      }).then(function (suggestions) {
        return suggestions.map(beautifyCategoryName);
      }).then(function (suggestions) {
        return suggestions.map(ensureTextFieldNotUndefined);
      }).then(function (suggestions) {
        return addTextSnippets(editor, suggestions);
      });
    };
    // class methods
    this.suggest = function (homeDirectory, currentFile, editor) {
      return this.getSuggestions(homeDirectory, currentFile, editor);
    };
    this.autocompleteHelper = function (editor, callback, options, homeDirectory, currentFile) {
      if (!homeDirectory || !currentFile) {
        var $scope = angular.element(editor.getInputField()).scope();
        homeDirectory = homeDirectory || $scope.homeDirectory;
        currentFile = currentFile || $scope.fileBrowser.selectedFile;
      }
      this.getSuggestions(homeDirectory, currentFile, editor).then(function (suggestions) {
        return codemirrorHint(editor, suggestions);
      }).then(function (codemirrorHint) {
        callback(codemirrorHint);
      });
    };
    return this;
  }
]);
(function () {
  'use strict';
  function FileSystem() {
  }
  FileSystem.prototype = {
    directory: function (fullpath) {
      throw 'Not implemented: FileSystem list invoked with [fullpath=' + fullpath + ']';
    },
    save: function (fullpath, content) {
      throw 'Not implemented: FileSystem save invoked with [fullpath=' + fullpath + '] and [content=' + content + ']';
    },
    createFolder: function (fullpath) {
      throw 'Not implemented: FileSystem createFolder invoked with [fullpath=' + fullpath + ']';
    },
    load: function (fullpath) {
      throw 'Not implemented: FileSystem load invoked with [fullpath=' + fullpath + ']';
    },
    remove: function (fullpath) {
      throw 'Not implemented: FileSystem remove invoked with [fullpath=' + fullpath + ']';
    },
    rename: function (source, destination) {
      throw 'Not implemented: FileSystem rename invoked with [source=' + source + '] and [destination=' + destination + ']';
    }
  };
  angular.module('fs').provider('fileSystem', function fileSystemProvider() {
    this.hasFactory = false;
    this.setFileSystemFactory = function (fileSystemFactory) {
      this.$get = fileSystemFactory;
      this.hasFactory = true;
    };
    this.$get = function () {
      return new FileSystem();
    };
    return this;
  });
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('newFileService', [
    'ramlRepository',
    'newNameModal',
    '$rootScope',
    'generateName',
    function newFolderService(ramlRepository, newNameModal, $rootScope, generateName) {
      var self = this;
      var specUrl = 'https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#';
      self.files = {
        '0.8': {
          '': {
            label: '',
            name: 'API Spec',
            description: 'RAML 0.8 API Spec.',
            spec: 'https://github.com/raml-org/raml-spec/blob/master/versions/raml-08/raml-08.md'
          }
        },
        '1.0': {
          '': {
            label: '',
            name: 'API Spec',
            description: 'RAML 1.0 API Spec.',
            spec: specUrl + 'the-root-of-the-document'
          },
          'Trait': {
            label: 'Trait',
            name: 'Trait',
            description: 'Define a single trait with common characteristics for methods.',
            spec: specUrl + 'resource-types-and-traits'
          },
          'ResourceType': {
            label: 'ResourceType',
            name: 'Resource Type',
            description: 'Define a single resource type with common characteristics for resources.',
            spec: specUrl + 'resource-types-and-traits'
          },
          'Library': {
            label: 'Library',
            name: 'Library',
            description: 'Define a collection of data type declarations, resource type declarations, trait declarations, and security scheme declarations into modular, externalized, reusable groups.',
            spec: specUrl + 'libraries'
          },
          'Overlay': {
            label: 'Overlay',
            name: 'Overlay',
            description: 'Define an overlay that adds or overrides nodes of a RAML API definition while preserving its behavioral, functional aspects.',
            spec: specUrl + 'overlays'
          },
          'Extension': {
            label: 'Extension',
            name: 'Extension',
            description: 'Define an extension that adds or modifies nodes of a RAML API definition.',
            spec: specUrl + 'extensions'
          },
          'DataType': {
            label: 'DataType',
            name: 'Type',
            description: 'Define a single data type declaration.',
            spec: specUrl + 'raml-data-types'
          },
          'DocumentationItem': {
            label: 'DocumentationItem',
            name: 'User Documentation',
            description: 'Define a single page documentation item.',
            spec: specUrl + 'user-documentation'
          },
          'NamedExample': {
            label: 'NamedExample',
            name: 'Example',
            description: 'Define a single example for a given data type.',
            spec: specUrl + 'defining-examples-in-raml'
          },
          'AnnotationTypeDeclaration': {
            label: 'AnnotationTypeDeclaration',
            name: 'Annotation',
            description: 'Define a single annotation type declaration that describes additional metadata that can be applied to any RAML node.',
            spec: specUrl + 'annotations'
          },
          'SecurityScheme': {
            label: 'SecurityScheme',
            name: 'Security Scheme',
            description: 'Define a single security scheme that describes the mechanism to secure data access, identify requests, and determine access level and data visibility.',
            spec: specUrl + 'security-schemes'
          }
        }
      };
      function nameSuggestion(target, fragment, fragmentLabel) {
        var names = target.children.map(function (file) {
            return file.name;
          });
        var defaultName = (fragment.label !== '' ? fragmentLabel : 'api') + '-';
        return generateName(names, defaultName, 'raml');
      }
      self.prompt = function prompt(target, ramlVersion, fragmentLabel) {
        var parent = target.isDirectory ? target : ramlRepository.getParent(target);
        var validations = [{
              message: 'That file name is already taken.',
              validate: function (input) {
                var path = ramlRepository.join(parent.path, input);
                return !ramlRepository.getByPath(path);
              }
            }];
        var label = fragmentLabel ? fragmentLabel : '';
        var fragment = self.files[ramlVersion][label];
        var suggestedName = nameSuggestion(target, fragment, fragmentLabel);
        var title = 'Add new ' + fragment.name + ' file';
        return newNameModal.open(fragment.description, suggestedName, validations, title, fragment.spec).then(function (name) {
          // Need to catch errors from `generateFile`, otherwise
          // `newNameModel.open` will error random modal close strings.
          return ramlRepository.generateFile(parent, name, ramlVersion, label).catch(function (err) {
            return $rootScope.$broadcast('event:notification', {
              message: err.message,
              expires: true,
              level: 'error'
            });
          });
        });
      };
      self.newFragmentFile = function newFragmentFile(homeDirectory, fragmentType) {
        if (fragmentType === '') {
          return self.prompt(homeDirectory, '1.0');
        }
        return self.prompt(homeDirectory, '1.0', fragmentType);
      };
      self.newFile = function newFile(homeDirectory, version) {
        return self.prompt(homeDirectory, version);
      };
      return self;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('newFolderService', [
    'ramlRepository',
    'newNameModal',
    function newFolderService(ramlRepository, newNameModal) {
      var self = this;
      self.prompt = function prompt(target) {
        var parent = target.isDirectory ? target : ramlRepository.getParent(target);
        var message = 'Input a name for your new folder:';
        var title = 'Add a new folder';
        var validations = [{
              message: 'That folder name is already taken.',
              validate: function (input) {
                var path = ramlRepository.join(parent.path, input);
                return !ramlRepository.getByPath(path);
              }
            }];
        return newNameModal.open(message, '', validations, title).then(function (name) {
          return ramlRepository.generateDirectory(parent, name);
        });
      };
      return self;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  function localStorageFileSystemFactory($window, $q, $prompt, $timeout, localStorageHelper, FOLDER) {
    function fileNotFoundMessage(path) {
      return 'file with path="' + path + '" does not exist';
    }
    function addChildren(entry, fn) {
      if (entry.type === FOLDER) {
        entry.children = fn(entry.path);
      }
    }
    function findFolder(path) {
      var entries = [];
      localStorageHelper.forEach(function (entry) {
        if (entry.path.toLowerCase() === path.toLowerCase()) {
          addChildren(entry, findFiles);
          entries.push(entry);
        }
      });
      return entries.length > 0 ? entries[0] : null;
    }
    function findFiles(path) {
      if (path.lastIndexOf('/') !== path.length - 1) {
        path += '/';
      }
      var entries = [];
      localStorageHelper.forEach(function (entry) {
        if (entry.path.toLowerCase() !== path.toLowerCase() && extractParentPath(entry.path) + '/' === path) {
          addChildren(entry, findFiles);
          entries.push(entry);
        }
      });
      return entries;
    }
    /**
     *
     * Save in localStorage entries.
     *
     * File structure are objects that contain the following attributes:
     * * path: The full path (including the filename).
     * * content: The content of the file (only valid for files).
     * * isFolder: A flag that indicates whether is a folder or file.
     */
    var service = {};
    var delay = 500;
    service.supportsFolders = true;
    function validatePath(path) {
      if (path.indexOf('/') !== 0) {
        return {
          valid: false,
          reason: 'Path should start with "/"'
        };
      }
      return { valid: true };
    }
    function isValidParent(path) {
      var parent = extractParentPath(path);
      if (!localStorageHelper.has(parent) && parent !== '') {
        return false;
      }
      return true;
    }
    function hasChildrens(path) {
      var has = false;
      localStorageHelper.forEach(function (entry) {
        if (entry.path.indexOf(path + '/') === 0) {
          has = true;
        }
      });
      return has;
    }
    function extractNameFromPath(path) {
      var pathInfo = validatePath(path);
      if (!pathInfo.valid) {
        throw 'Invalid Path!';
      }
      // When the path is ended in '/'
      if (path.lastIndexOf('/') === path.length - 1) {
        path = path.slice(0, -1);
      }
      return path.slice(path.lastIndexOf('/') + 1);
    }
    function extractParentPath(path) {
      var pathInfo = validatePath(path);
      if (!pathInfo.valid) {
        throw 'Invalid Path!';
      }
      // When the path is ended in '/'
      if (path.lastIndexOf('/') === path.length - 1) {
        path = path.slice(0, -1);
      }
      return path.slice(0, path.lastIndexOf('/'));
    }
    /**
     * List files found in a given path.
     */
    service.directory = function (path) {
      var deferred = $q.defer();
      $timeout(function () {
        var isValidPath = validatePath(path);
        if (!isValidPath.valid) {
          deferred.reject(isValidPath.reason);
          return deferred.promise;
        }
        if (!localStorageHelper.has('/')) {
          localStorageHelper.set(path, {
            path: '/',
            name: '',
            type: 'folder',
            meta: { 'created': Math.round(new Date().getTime() / 1000) }
          });
        }
        deferred.resolve(findFolder(path));
      }, delay);
      return deferred.promise;
    };
    /**
     * Persist a file to an existing folder.
     */
    service.save = function (path, content) {
      var deferred = $q.defer();
      $timeout(function () {
        var name = extractNameFromPath(path);
        var entry = localStorageHelper.get(path);
        if (!isValidParent(path)) {
          deferred.reject(new Error('Parent folder does not exists: ' + path));
          return deferred.promise;
        }
        var file = {};
        if (entry) {
          if (entry.type === FOLDER) {
            deferred.reject('file has the same name as a folder');
            return deferred.promise;
          }
          entry.content = content;
          entry.meta.lastUpdated = Math.round(new Date().getTime() / 1000);
          file = entry;
        } else {
          file = {
            path: path,
            name: name,
            content: content,
            type: 'file',
            meta: { 'created': Math.round(new Date().getTime() / 1000) }
          };
        }
        localStorageHelper.set(path, file);
        deferred.resolve();
      }, delay);
      return deferred.promise;
    };
    /**
     * Create the folders contained in a path.
     */
    service.createFolder = function (path) {
      var deferred = $q.defer();
      var isValidPath = validatePath(path);
      if (!isValidPath.valid) {
        deferred.reject(isValidPath.reason);
        return deferred.promise;
      }
      if (localStorageHelper.has(path)) {
        deferred.reject(new Error('Folder already exists: ' + path));
        return deferred.promise;
      }
      var parent = extractParentPath(path);
      if (!localStorageHelper.has(parent)) {
        deferred.reject(new Error('Parent folder does not exists: ' + path));
        return deferred.promise;
      }
      $timeout(function () {
        localStorageHelper.set(path, {
          path: path,
          name: extractNameFromPath(path),
          type: 'folder',
          meta: { 'created': Math.round(new Date().getTime() / 1000) }
        });
        deferred.resolve();
      }, delay);
      return deferred.promise;
    };
    /**
     * Loads the content of a file.
     */
    service.load = function (path, nativeTimeout) {
      var deferred = $q.defer();
      (nativeTimeout ? setTimeout : $timeout)(function () {
        var entry = localStorageHelper.get(path);
        if (entry && entry.type === 'file') {
          deferred.resolve(localStorageHelper.get(path).content);
        } else {
          deferred.reject(fileNotFoundMessage(path));
        }
      }, delay);
      return deferred.promise;
    };
    /**
     * Removes a file or directory.
     */
    service.remove = function (path) {
      var deferred = $q.defer();
      $timeout(function () {
        var entry = localStorageHelper.get(path);
        if (entry && entry.type === FOLDER && hasChildrens(path)) {
          deferred.reject('folder not empty');
          return deferred.promise;
        }
        localStorageHelper.remove(path);
        deferred.resolve();
      }, delay);
      return deferred.promise;
    };
    /**
     * Renames a file or directory
     */
    service.rename = function (source, destination) {
      var deferred = $q.defer();
      $timeout(function () {
        var sourceEntry = localStorageHelper.get(source);
        if (!sourceEntry) {
          deferred.reject('Source file or folder does not exists.');
          return deferred.promise;
        }
        var destinationEntry = localStorageHelper.get(destination);
        if (destinationEntry) {
          deferred.reject('File or folder already exists.');
          return deferred.promise;
        }
        if (!isValidParent(destination)) {
          deferred.reject('Destination folder does not exist.');
          return deferred.promise;
        }
        sourceEntry.path = destination;
        sourceEntry.name = extractNameFromPath(destination);
        localStorageHelper.remove(destination);
        localStorageHelper.remove(source);
        localStorageHelper.set(destination, sourceEntry);
        if (sourceEntry.type === FOLDER) {
          // if (!isValidPath(destination)) {
          //   deferred.reject('Destination is not a valid folder');
          //   return deferred.promise;
          // }
          //move all child items
          localStorageHelper.forEach(function (entry) {
            if (entry.path.toLowerCase() !== destination.toLowerCase() && entry.path.indexOf(source + '/') === 0) {
              var newPath = destination + entry.path.substring(source.length);
              localStorageHelper.remove(entry.path);
              entry.path = newPath;
              localStorageHelper.set(newPath, entry);
            }
          });
        }
        deferred.resolve();
      }, delay);
      return deferred.promise;
    };
    service.exportFiles = function exportFiles() {
      var jszip = new $window.JSZip();
      localStorageHelper.forEach(function (item) {
        // Skip root folder
        if (item.path === '/') {
          return;
        }
        // Skip meta files
        if (item.name.slice(-5) === '.meta') {
          return;
        }
        var path = item.path.slice(1);
        // Remove starting slash
        item.type === 'folder' ? jszip.folder(path) : jszip.file(path, item.content);
      });
      var fileName = $prompt('Please enter a ZIP file name:', 'api.zip');
      fileName && $window.saveAs(jszip.generate({ type: 'blob' }), fileName);
    };
    return service;
  }
  angular.module('fs').constant('LOCAL_PERSISTENCE_KEY', 'localStorageFilePersistence').constant('FOLDER', 'folder').factory('localStorageHelper', [
    'LOCAL_PERSISTENCE_KEY',
    function (LOCAL_PERSISTENCE_KEY) {
      return {
        forEach: function (fn) {
          for (var key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
              // A key is a local storage file system entry if it starts
              //with LOCAL_PERSISTENCE_KEY + '.'
              if (key.indexOf(LOCAL_PERSISTENCE_KEY + '.') === 0) {
                fn(JSON.parse(localStorage.getItem(key)));
              }
            }
          }
        },
        has: function (path) {
          var has = false;
          path = path || '/';
          this.forEach(function (entry) {
            if (entry.path.toLowerCase() === path.toLowerCase()) {
              has = true;
            }
          });
          return has;
        },
        set: function (path, content) {
          localStorage.setItem(LOCAL_PERSISTENCE_KEY + '.' + path, JSON.stringify(content));
        },
        get: function (path) {
          return JSON.parse(localStorage.getItem(LOCAL_PERSISTENCE_KEY + '.' + path));
        },
        remove: function (path) {
          localStorage.removeItem(LOCAL_PERSISTENCE_KEY + '.' + path);
        }
      };
    }
  ]).factory('localStorageFileSystem', localStorageFileSystemFactory).config(function (fileSystemProvider) {
    if (!fileSystemProvider.hasFactory) {
      fileSystemProvider.setFileSystemFactory(localStorageFileSystemFactory);
    }
  });
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('mockingServiceUtils', [
    '$q',
    'jsTraverse',
    'ramlRepository',
    'refParser',
    function mockingServiceUtils($q, jsTraverse, ramlRepository, refParser) {
      return { dereference: dereference };
      // ---
      function dereferenceJsons(raml) {
        return $q.when().then(function () {
          var promises = [];
          jsTraverse.traverse(raml).forEach(function (value) {
            if (this.path.slice(-2).join('.') === 'body.application/json') {
              var jsonSchema;
              if (value.schema) {
                jsonSchema = value.schema;
              } else if (value.type) {
                jsonSchema = value.type;
              }
              if (Array.isArray(jsonSchema)) {
                jsonSchema = jsonSchema[0];
              }
              try {
                promises.push(refParser.dereference(JSON.parse(jsonSchema), { $refs: { read$Ref: read$Ref } }).then(JSON.stringify).then(function (schema) {
                  value.schema = schema;
                }));
              } catch (e) {
              }
            }
          });
          return $q.all(promises);
        });
      }
      function dereference(raml) {
        return dereferenceJsons(raml);
      }
      // ---
      function read$Ref($ref) {
        var path = $ref.path[0] === '/' ? $ref.path : '/' + $ref.path;
        return ramlRepository.getContentByPath(path, true);
      }
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('mockingServiceClient', [
    '$http',
    '$q',
    '$window',
    'resolveUri',
    function mockingServiceClientFactory($http, $q, $window, resolveUri) {
      var self = this;
      self.proxy = null;
      self.baseUri = 'https://mocksvc.qax.mulesoft.com';
      self.buildURL = function buildURL() {
        var url = self.baseUri + ['/mocks'].concat(Array.prototype.slice.call(arguments, 0)).join('/');
        var proxy = self.proxy || $window.RAML.Settings.proxy;
        if (proxy) {
          url = proxy + resolveUri(url);
        }
        return url;
      };
      function cleanBaseUri(mock) {
        var baseUri = mock.baseUri;
        var mocksQuantity = baseUri.match(/mocks\//g).length;
        if (mocksQuantity > 1) {
          var mocks = 'mocks/';
          for (var i = mocksQuantity; i > 1; i--) {
            var from = baseUri.indexOf(mocks);
            var to = baseUri.indexOf('/', from + mocks.length);
            baseUri = baseUri.substring(0, from) + baseUri.substring(to + 1, baseUri.length);
          }
        }
        mock.baseUri = baseUri;
      }
      self.simplifyMock = function simplifyMock(mock) {
        if (mock.baseUri) {
          cleanBaseUri(mock);
        }
        return {
          id: mock.id,
          baseUri: mock.baseUri,
          manageKey: mock.manageKey
        };
      };
      self.getMock = function getMock(mock) {
        return $http.get(self.buildURL(mock.id, mock.manageKey)).then(function success(response) {
          return self.simplifyMock(response.data);
        }, function failure(response) {
          if (response.status === 404) {
            return;
          }
          return $q.reject(response);
        });
      };
      self.createMock = function createMock(mock) {
        return $http.post(self.buildURL(), mock).then(function success(response) {
          return self.simplifyMock(response.data);
        });
      };
      self.updateMock = function updateMock(mock) {
        return $http({
          method: 'PATCH',
          url: self.buildURL(mock.id, mock.manageKey),
          data: {
            raml: mock.raml,
            json: mock.json
          }
        }).then(function success(response) {
          return self.simplifyMock(angular.extend(mock, response.data));
        });
      };
      self.deleteMock = function deleteMock(mock) {
        return $http.delete(self.buildURL(mock.id, mock.manageKey));
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('mockingService', [
    'mockingServiceClient',
    'mockingServiceUtils',
    'ramlRepository',
    function mockingServiceFactory(mockingServiceClient, mockingServiceUtils, ramlRepository) {
      var self = this;
      function getMockMeta(file) {
        return ramlRepository.loadMeta(file).then(function success(meta) {
          return meta.mock;
        });
        ;
      }
      function setMockMeta(file, mock) {
        return ramlRepository.loadMeta(file).then(function success(meta) {
          meta.mock = mock;
          return ramlRepository.saveMeta(file, meta);
        }).then(function success() {
          return mock;
        });
        ;
      }
      self.getMock = function getMock(file) {
        return getMockMeta(file);
      };
      self.createMock = function createMock(file, raml) {
        return dereferenceRaml(raml).then(function () {
          return mockingServiceClient.createMock({
            raml: file.contents,
            json: raml
          });
        }).then(function (mock) {
          return setMockMeta(file, mock);
        });
        ;
      };
      self.updateMock = function updateMock(file, raml) {
        return dereferenceRaml(raml).then(function () {
          return getMockMeta(file);
        }).then(function (mock) {
          return mock && mockingServiceClient.updateMock(angular.extend(mock, {
            raml: file.contents,
            json: raml
          }));
        }).then(function (mock) {
          return setMockMeta(file, mock);
        });
        ;
      };
      self.deleteMock = function deleteMock(file) {
        return getMockMeta(file).then(function (mock) {
          return mock && mockingServiceClient.deleteMock(mock);
        }).then(function success() {
          return setMockMeta(file, null);
        });
        ;
      };
      // ---
      function dereferenceRaml(raml) {
        return mockingServiceUtils.dereference(raml).catch(function (error) {
          console.error('dereferenceRaml failed', error.stack);
        });
        ;
      }
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('subMenuService', [
    '$timeout',
    '$window',
    function subMenuService($timeout, $window) {
      this.open = function (scope, subMenuName) {
        $timeout(function () {
          $window.addEventListener('click', function self() {
            scope.$apply(function () {
              scope[subMenuName] = false;
            });
            $window.removeEventListener('click', self);
          });
        });
        scope[subMenuName] = true;
      };
      this.openSubMenu = function (scope, subMenuName) {
        scope[subMenuName] = true;
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('importModal', [
    '$modal',
    function importModal($modal) {
      var self = this;
      self.open = function open() {
        return $modal.open({
          templateUrl: 'views/import-modal.html',
          controller: 'ImportController'
        }).result;
      };
      return self;
    }
  ]).controller('ImportController', [
    '$scope',
    '$modalInstance',
    'swaggerToRAML',
    '$q',
    '$window',
    '$rootScope',
    'importService',
    'ramlRepository',
    function ConfirmController($scope, $modalInstance, swaggerToRAML, $q, $window, $rootScope, importService, ramlRepository) {
      $scope.importing = false;
      $scope.rootDirectory = ramlRepository.getByPath('/');
      // Handles <input type="file" onchange="angular.element(this).scope().handleFileSelect(this)">
      // this workaroud for binding the input file to a model won't work for 1.3.x since scope isn't available in onchange
      $scope.handleFileSelect = function (element) {
        $scope.mode.value = element.files[0];
      };
      function broadcastError(msg) {
        return $rootScope.$broadcast('event:notification', {
          message: msg,
          expires: true,
          level: 'error'
        });
      }
      /**
       * Import files from the local filesystem.
       *
       * @param {Object} mode
       */
      function importFile(mode) {
        if (!$scope.fileSupported) {
          return broadcastError('File upload not supported. Try upgrading your browser.');
        }
        $scope.importing = true;
        return importService.mergeFile($scope.rootDirectory, mode.value).then(function () {
          if (importService.isZip(mode.value)) {
            $rootScope.$broadcast('event:save-all');
          }
        }).then(function () {
          return $modalInstance.close(true);
        }).catch(function (err) {
          broadcastError(err.message || err);
        }).finally(function () {
          $scope.importing = false;
        });
      }
      /**
       * Import a RAML file from a Swagger specification.
       */
      function importSwagger(mode) {
        $scope.importing = true;
        // Attempt to import from a Swagger definition.
        var proxy = $window.RAML.Settings.proxy || '';
        var url = proxy + mode.value;
        return swaggerToRAML.url(url).then(function (contents) {
          var filename = extractFileName(mode.value, 'raml');
          return importService.createAndSaveFile($scope.rootDirectory, filename, contents);
        }).then(function () {
          return $modalInstance.close(true);
        }).catch(function (err) {
          broadcastError('Failed to import Swagger: ' + err.message);
        }).finally(function () {
          $scope.importing = false;
        });
      }
      function importSwaggerFile(mode) {
        $scope.importing = true;
        var importSwaggerPromise;
        if (importService.isZip(mode.value)) {
          importSwaggerPromise = swaggerToRAML.zip($scope.rootDirectory, mode.value).then(function () {
            $rootScope.$broadcast('event:save-all');
          });
        } else {
          importSwaggerPromise = swaggerToRAML.file(mode.value).then(function (contents) {
            var filename = extractFileName(mode.value.name, 'raml');
            return importService.createAndSaveFile($scope.rootDirectory, filename, contents);
          });
        }
        return importSwaggerPromise.then(function () {
          return $modalInstance.close(true);
        }).catch(function (err) {
          broadcastError('Failed to parse Swagger: ' + err.message);
        }).finally(function () {
          $scope.importing = false;
        });
      }
      $scope.options = [
        {
          name: 'RAML file',
          type: 'file',
          spec: 'RAML',
          callback: importFile
        },
        {
          name: 'OAS file',
          type: 'file',
          spec: 'OAS',
          callback: importSwaggerFile
        },
        {
          name: 'OAS spec',
          type: 'url',
          spec: 'OAS',
          callback: importSwagger
        }
      ];
      $scope.mode = $scope.options[0];
      // Check whether file import is supported.
      $scope.fileSupported = !!(window.File && window.FileReader && window.FileList && window.Blob);
      /**
       * Import using either import modes.
       *
       * @param {Object} form
       */
      $scope.import = function (form) {
        form.$submitted = true;
        $scope.submittedType = $scope.mode.type;
        if (form.$invalid || $scope.importing) {
          return;
        }
        try {
          return $scope.mode.callback($scope.mode);
        } catch (err) {
          $scope.importing = false;
          broadcastError(err.message || err);
        }
      };
      /**
       * Extract a usable filename from a path.
       *
       * @param  {String} path
       * @param  {String} [ext]
       * @return {String}
       */
      function extractFileName(path, ext) {
        var name = path.replace(/\/*$/, '');
        var index = name.lastIndexOf('/');
        if (index > -1) {
          name = name.substr(index);
        }
        if (ext) {
          name = name.replace(/\.[^\.]*$/, '') + '.' + ext;
        }
        return name;
      }
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('confirmModal', [
    '$rootScope',
    '$modal',
    function confirmModal($rootScope, $modal) {
      var self = this;
      /**
       * @param {String} title
       * @param {String} message
       * @param {Object} [options = {canDiscard, closeButtonLabel, discardButtonLabel, dismissButtonLabel, closeButtonCssClass}]
       */
      self.open = function open(message, title, options) {
        options = angular.extend({
          canDiscard: false,
          closeButtonLabel: 'OK',
          discardButtonLabel: 'Discard',
          dismissButtonLabel: 'Cancel',
          closeButtonCssClass: 'btn-primary'
        }, options);
        return $modal.open({
          templateUrl: 'views/confirm-modal.html',
          controller: 'ConfirmController',
          scope: angular.extend($rootScope.$new(), {
            title: title,
            message: message,
            canDiscard: options.canDiscard,
            closeButtonLabel: options.closeButtonLabel,
            discardButtonLabel: options.discardButtonLabel,
            dismissButtonLabel: options.dismissButtonLabel,
            closeButtonCssClass: options.closeButtonCssClass
          })
        }).result;
        ;
      };
      return self;
    }
  ]).controller('ConfirmController', [
    '$modalInstance',
    '$scope',
    function ConfirmController($modalInstance, $scope) {
      $scope.discard = function discard() {
        $modalInstance.dismiss(angular.extend(new Error(), { discard: true }));
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('newNameModal', [
    '$modal',
    function newNameModal($modal) {
      var self = this;
      self.open = function open(message, defaultName, validations, title, link) {
        return $modal.open({
          templateUrl: 'views/new-name-modal.html',
          controller: 'NewNameController',
          windowClass: 'modal in',
          resolve: {
            message: function messageResolver() {
              return message;
            },
            title: function titleResolver() {
              return title;
            },
            defaultName: function defaultNameResolver() {
              return defaultName;
            },
            validations: function validationsResolver() {
              return validations;
            },
            link: function linkResolver() {
              return link;
            }
          }
        }).result;
        ;
      };
      return self;
    }
  ]).controller('NewNameController', [
    '$modalInstance',
    '$scope',
    'message',
    'defaultName',
    'validations',
    'title',
    'link',
    function NewNameController($modalInstance, $scope, message, defaultName, validations, title, link) {
      $scope.input = {
        newName: defaultName,
        message: message,
        title: title,
        link: link
      };
      $scope.validationErrorMessage = '';
      $scope.isValid = function isValid(value) {
        if (value) {
          for (var i = 0; i < validations.length; i++) {
            if (!validations[i].validate(value)) {
              $scope.validationErrorMessage = validations[i].message;
              return false;
            }
          }
        }
        return true;
      };
      $scope.submit = function submit(form) {
        if (form.$invalid) {
          form.$submitted = true;
          return;
        }
        $modalInstance.close($scope.input.newName);
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('swaggerToRAML', [
    '$window',
    '$q',
    '$http',
    'importService',
    'oasRamlConverter',
    function swaggerToRAML($window, $q, $http, importService, oasRamlConverter) {
      var self = this;
      function replaceExtension(path, ext) {
        var index = path.lastIndexOf('.');
        if (index > -1) {
          path = path.substr(0, index);
        }
        return path + '.' + ext;
      }
      function ramlConverter() {
        return new oasRamlConverter.Converter(oasRamlConverter.Formats.OAS, oasRamlConverter.Formats.RAML10);
      }
      function convertZip(root, contents) {
        var decimalRegexp = /^\d+\.\d+$/;
        var swaggerYamlRegexp = /swagger\s*:\s*"{0,1}\d+\.\d+"{0,1}/;
        function isSwaggerSpec(text) {
          try {
            var parsedData = JSON.parse(text);
            return decimalRegexp.test(parsedData.swagger);
          } catch (err) {
            // Possibly YAML Data
            return swaggerYamlRegexp.test(text);
          }
        }
        function converte(files, name, deferred) {
          var content = files[name];
          // leave files that are not swagger unmodified
          if (!isSwaggerSpec(content)) {
            return deferred.resolve({
              name: name,
              content: content
            });
          }
          function toAbsolute(path) {
            return path.indexOf('http') !== 0 ? 'http://zip/' + path : path;
          }
          function toRelative(path) {
            return path.indexOf('http://zip/') === 0 ? path.substring('http://zip/'.length) : path;
          }
          // custom fileResolver to take in memory files from the zip
          var fsResolver = {
              canRead: function (url) {
                return this.read(url) != null;
              },
              read: function (url) {
                var path = toRelative(url.url);
                var content = files[path];
                if (!content) {
                  throw new Error('Could not load content for file ' + path);
                }
                return content;
              }
            };
          // convert main swagger spec
          ramlConverter().convertFile(toAbsolute(name), {
            resolve: {
              file: fsResolver,
              http: fsResolver
            }
          }).then(function (convertedData) {
            deferred.resolve({
              name: replaceExtension(name, 'raml'),
              content: convertedData
            });
          }).catch(function (err) {
            deferred.reject(err);
          });
        }
        return importService.importZip(root, contents, converte);
      }
      self.url = function convert(url) {
        // fetch and convert single file
        var deferred = $q.defer();
        ramlConverter().convertFile(url).then(deferred.resolve).catch(deferred.reject);
        return deferred.promise;
      };
      self.file = function f(file) {
        var deferred = $q.defer();
        importService.readFile(file).then(function (content) {
          ramlConverter().convertData(content).then(deferred.resolve).catch(deferred.reject);
        }).catch(deferred.reject);
        return deferred.promise;
      };
      self.zip = function zip(rootDirectory, file) {
        var deferred = $q.defer();
        importService.readFile(file).then(function (contents) {
          convertZip(rootDirectory, contents).then(deferred.resolve).catch(deferred.reject);
        }).catch(deferred.reject);
        return deferred.promise;
      };
      return self;
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('ramlToSwagger', [
    '$q',
    '$window',
    'ramlRepository',
    'ramlEditorMainHelpers',
    'oasRamlConverter',
    function ramlToSwagger($q, $window, ramlRepository, ramlEditorMainHelpers, oasRamlConverter) {
      var self = this;
      function findRootRaml(selectedFile) {
        if (selectedFile && ramlEditorMainHelpers.isApiDefinition(selectedFile.contents)) {
          return $q.when(selectedFile);
        }
        var defer = $q.defer();
        var rootDirectory = ramlRepository.getByPath('/');
        findRootRamlRecursive(rootDirectory, defer);
        return defer.promise;
      }
      function loadFile(file, defer) {
        (file.loaded ? $q.when(file) : ramlRepository.loadFile(file)).then(function (loadedFile) {
          if (ramlEditorMainHelpers.isApiDefinition(loadedFile.contents)) {
            defer.resolve(loadedFile);
          }
        });
      }
      function findRootRamlRecursive(directory, defer) {
        for (var i = 0; i < directory.children.length; i++) {
          var child = directory.children[i];
          if (child.isDirectory) {
            findRootRamlRecursive(child, defer);
          } else {
            loadFile(child, defer);
          }
        }
      }
      function swaggerConverter(file) {
        var from = ramlEditorMainHelpers.isApiDefinitionV08(file.contents) ? oasRamlConverter.Formats.RAML08 : oasRamlConverter.Formats.RAML10;
        return new oasRamlConverter.Converter(from, oasRamlConverter.Formats.OAS);
      }
      function convertData(file, deferred, format) {
        var options = {
            format: format,
            fsResolver: {
              content: function content(path) {
                throw new Error('ramlParser: loadPath: loadApi: content: ' + path + ': no such path');
              },
              contentAsync: function contentAsync(path) {
                return ramlRepository.getContentByPath(path);
              }
            }
          };
        swaggerConverter(file).convertFile(file.path, options).then(function (result) {
          deferred.resolve({
            name: file.name,
            path: file.path,
            contents: result
          });
        }).catch(deferred.reject);
      }
      function toSwagger(format, selectedFile) {
        var deferred = $q.defer();
        findRootRaml(selectedFile).then(function (rootRaml) {
          convertData(rootRaml, deferred, format);
        }).catch(function (err) {
          deferred.reject(err);
        });
        return deferred.promise;
      }
      self.json = function json(selectedFile) {
        return toSwagger('json', selectedFile);
      };
      self.yaml = function yaml(selectedFile) {
        return toSwagger('yaml', selectedFile);
      };
      return self;
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').service('importService', [
    '$q',
    '$window',
    'ramlRepository',
    'importServiceConflictModal',
    function importServiceFactory($q, $window, ramlRepository, importServiceConflictModal) {
      var self = this;
      /**
       * Merge a file with the specified directory.
       *
       * @param  {Object}  directory
       * @param  {File}    file
       * @return {Promise}
       */
      self.mergeFile = function (directory, file) {
        // Import every other file as normal.
        if (!self.isZip(file)) {
          return self.importFile(directory, file).then(ramlRepository.saveFile);
        }
        return self.readFile(file).then(function (contents) {
          return self.mergeZip(directory, contents);
        });
      };
      /**
       * Merge files into the specified directory.
       *
       * @param  {Object}   directory
       * @param  {FileList} files
       * @return {Promise}
       */
      self.mergeFileList = function (directory, files) {
        var imports = Array.prototype.map.call(files, function (file) {
            return function () {
              return self.mergeFile(directory, file);
            };
          });
        return promiseChain(imports);
      };
      /**
       * Import a single entry into the file system.
       *
       * @param  {Object}                     directory
       * @param  {(DirectoryEntry|FileEntry)} entry
       * @return {Promise}
       */
      self.importEntry = function (directory, entry) {
        var deferred = $q.defer();
        if (entry.isFile) {
          entry.file(function (file) {
            var path = ramlRepository.join(directory.path, entry.fullPath);
            return importFileToPath(directory, path, file).then(deferred.resolve, deferred.reject);
          }, deferred.reject);
        } else {
          var reader = entry.createReader();
          reader.readEntries(function (entries) {
            var imports = entries.filter(function (entry) {
                return canImport(entry.name);
              }).map(function (entry) {
                return function () {
                  return self.importEntry(directory, entry);
                };
              });
            return promiseChain(imports).then(deferred.resolve, deferred.reject);
          });
        }
        return deferred.promise;
      };
      /**
       * Import a single item into the file system.
       *
       * @param  {Object}           directory
       * @param  {DataTransferItem} item
       * @return {Promise}
       */
      self.importItem = function (directory, item) {
        if (item.webkitGetAsEntry) {
          return self.importEntry(directory, item.webkitGetAsEntry());
        }
        return self.importFile(directory, item.getAsFile());
      };
      /**
       * Import a single file into the file system.
       *
       * @param  {Object}  directory
       * @param  {File}    file
       * @return {Promise}
       */
      self.importFile = function (directory, file) {
        return importFileToPath(directory, file.name, file);
      };
      /**
       * Import using an event object.
       *
       * @param  {Object}  directory
       * @param  {Object}  e
       * @return {Promise}
       */
      self.importFromEvent = function (directory, e) {
        // Handle items differently since Chrome has support for folders.
        if (e.dataTransfer.items) {
          return self.importItemList(directory, e.dataTransfer.items);
        }
        return self.importFileList(directory, e.dataTransfer.files);
      };
      /**
       * Import an array of items into the file system.
       *
       * @param  {Object}               directory
       * @param  {DataTransferItemList} items
       * @return {Promise}
       */
      self.importItemList = function (directory, items) {
        var imports = Array.prototype.map.call(items, function (item) {
            return function () {
              return self.importItem(directory, item);
            };
          });
        return promiseChain(imports);
      };
      /**
       * Import an array of files into the file system.
       *
       * @param  {Object}   directory
       * @param  {FileList} files
       * @return {Promise}
       */
      self.importFileList = function (directory, files) {
        var imports = Array.prototype.map.call(files, function (file) {
            return function () {
              return self.importFile(directory, file);
            };
          });
        return promiseChain(imports);
      };
      /**
       * Create and save file.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @param  {String}  content
       * @return {Promise}
       */
      self.createAndSaveFile = function (directory, name, content) {
        return self.createFile(directory, name, content).then(ramlRepository.saveFile);
      };
      /**
       * Create a file in the filesystem.
       *
       * @param  {Object}  directory
       * @param  {String}  fname
       * @param  {String}  contents
       * @return {Promise}
       */
      self.createFile = function (directory, fname, contents) {
        var name = sanitizeFilePath(fname);
        return self.checkExistence(directory, name).then(function (option) {
          if (option === importServiceConflictModal.SKIP_FILE) {
            return;
          }
          if (option === importServiceConflictModal.KEEP_FILE) {
            var altname = altFilename(directory, name);
            return createFileFromContents(directory, altname, contents);
          }
          if (option === importServiceConflictModal.REPLACE_FILE) {
            var path = ramlRepository.join(directory.path, name);
            var file = ramlRepository.getByPath(path);
            // Load the file if not loaded.
            return (file.loaded ? $q.when(file) : ramlRepository.loadFile({ path: path })).then(function (theFile) {
              // Check if content has changed.
              if (theFile.contents !== contents) {
                // Load the file current contents.
                file.contents = theFile.contents;
                // Mark the file as loaded.
                file.loaded = true;
                // When replacing a file, if it had not been opened in
                // the Designer yet, it might had not been initialized with its
                // CodeMirror instance.
                // Replace the original file contents with the imported file
                // contents.
                if (!file.doc) {
                  file.doc = new CodeMirror.Doc(contents);
                } else {
                  file.doc.setValue(contents);
                }
                // Mark the file as dirty.
                file.dirty = true;
              }
              return file;
            });
            ;
          }
          return createFileFromContents(directory, name, contents);
        });
      };
      /**
       * Create a directory in the filesystem.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @return {Promise}
       */
      self.createDirectory = function (directory, name) {
        return ramlRepository.createDirectory(directory, name);
      };
      /**
       * Check whether a file exists and make a decision based on that.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @return {Promise}
       */
      self.checkExistence = function (directory, name) {
        var path = ramlRepository.join(directory.path, name);
        if (!pathExists(path)) {
          return $q.when(null);
        }
        return importServiceConflictModal.open(path);
      };
      /**
       * Check whether a file is a zip.
       *
       * @param  {File}    file
       * @return {Boolean}
       */
      self.isZip = function (file) {
        // Can't check `file.type` as it's empty when read from a `FileEntry`.
        return /\.zip$/i.test(file.name);
      };
      /**
       * Read a file object as a text file.
       *
       * @param  {File}    file
       * @return {Promise}
       */
      self.readFile = function (file) {
        if (!validateFileSize(file)) {
          return $q.reject('Only files up to 10mb are allowed');
        }
        if (!validateFileType(file)) {
          return $q.reject('Invalid file type "' + extractFileExtension(file) + '"');
        }
        var deferred = $q.defer();
        var reader = new $window.FileReader();
        reader.onload = function () {
          return deferred.resolve(reader.result);
        };
        reader.onerror = function () {
          return deferred.reject(reader.error);
        };
        if (self.isZip(file)) {
          reader.readAsArrayBuffer(file);
        } else {
          reader.readAsText(file);
        }
        return deferred.promise;
      };
      /**
       * Parse a ZIP file.
       *
       * @param  {String} contents
       * @return {Object}
       */
      self.parseZip = function (contents) {
        var zip = new $window.JSZip(contents);
        return sanitizeZipFiles(zip.files);
      };
      /**
       * Merge a zip with a directory in the file system.
       *
       * @param  {Object}  directory
       * @param  {String}  contents
       * @return {Promise}
       */
      self.mergeZip = function (directory, contents) {
        var files = removeCommonFilePrefixes(self.parseZip(contents));
        return importZipFiles(directory, files);
      };
      /**
       * Import a zip file into the current directory.
       *
       * @param  {Object}  directory
       * @param  {String}  contents
       * @param  {Function}  converter
       * @return {Promise}
       */
      self.importZip = function (directory, contents, converter) {
        var files = self.parseZip(contents);
        return importZipFiles(directory, files, converter);
      };
      /**
       * Import a single file at specific path.
       *
       * @param  {Object}  directory
       * @param  {String}  path
       * @param  {File}    file
       * @return {Promise}
       */
      function importFileToPath(directory, path, file) {
        return self.readFile(file).then(function (contents) {
          if (self.isZip(file)) {
            // Remove the zip file name from the end of the path.
            var dirname = path.replace(/[\\\/][^\\\/]*$/, '');
            return self.createDirectory(directory, dirname).then(function (directory) {
              return self.importZip(directory, contents);
            });
          }
          return self.createFile(directory, path, contents);
        });
      }
      /**
       * Import files from the zip object.
       *
       * @param  {Object}  directory
       * @param  {Object}  files
       * @param  {Function}  converter
       * @return {Promise}
       */
      function importZipFiles(directory, files, converter) {
        if (files.length === 0) {
          return $q.reject('No valid files to import in .zip');
        }
        var imports = Object.keys(files).filter(canImport).map(function (name) {
            return function () {
              if (!converter) {
                return self.createFile(directory, name, files[name]);
              } else {
                // convert content before importing file
                var defer = $q.defer();
                converter(files, name, defer);
                return defer.promise.then(function (file) {
                  return self.createFile(directory, file.name, file.content);
                });
              }
            };
          });
        return promiseChain(imports);
      }
      /**
       * Sanitize a zip file object and remove unwanted metadata.
       *
       * @param  {Object} originalFiles
       * @return {Object}
       */
      function sanitizeZipFiles(originalFiles) {
        var files = {};
        Object.keys(originalFiles).forEach(function (name) {
          if (/^__MACOSX\//.test(name) || /\/$/.test(name)) {
            return;
          }
          var file = originalFiles[name];
          if (validateFileType(file)) {
            files[name] = file.asText();
          }
        });
        return files;
      }
      /**
       * Remove the common file prefix from a files object.
       *
       * @param  {Object} prefixedFiles
       * @return {Object} files
       */
      function removeCommonFilePrefixes(prefixedFiles) {
        // Sort the file names in order of length to get the common prefix.
        var keys = Object.keys(prefixedFiles);
        if (keys.length === 0) {
          return [];
        }
        var prefix = keys.map(function (name) {
            if (!/[\\\/]/.test(name)) {
              return [];
            }
            return name.replace(/[\\\/][^\\\/]*$/, '').split(/[\\\/]/);
          }).reduce(function (prefix, name) {
            // Iterate over each part and check the prefix matches. If a part
            // does not match, return everything before it as the new prefix.
            for (var i = 0; i < prefix.length; i++) {
              if (name[i] !== prefix[i]) {
                return name.slice(0, i);
              }
            }
            return prefix;
          }).join('/');
        // Return the file object with the same file names.
        if (!prefix) {
          return angular.extend({}, prefixedFiles);
        }
        var files = {};
        // Iterate over the original files and create a new object.
        Object.keys(prefixedFiles).forEach(function (name) {
          var newName = name.substr(prefix.length + 1);
          // If no text is left, it must have been the root directory.
          if (newName) {
            files[newName] = prefixedFiles[name];
          }
        });
        return files;
      }
      /**
       * Check whether a certain file should be imported.
       *
       * @param  {String}  name
       * @return {Boolean}
       */
      function canImport(name) {
        return !/(?:^|[\/\\])\./.test(name);
      }
      /**
       * Check whether the path already exists.
       *
       * @param  {String}  path
       * @return {Boolean}
       */
      function pathExists(path) {
        return !!ramlRepository.getByPath(path);
      }
      /**
       * Create a file in the filesystem without checking prior existence.
       *
       * @param  {Object}  directory
       * @param  {String}  name
       * @param  {String}  contents
       * @return {Promise}
       */
      function createFileFromContents(directory, name, contents) {
        return ramlRepository.createFile(directory, name).then(function (file) {
          file.contents = contents;
          return file;
        });
      }
      /**
       * Generate an alternative file name for storage.
       *
       * @param  {Object} directory
       * @param  {String} name
       * @return {String}
       */
      function altFilename(directory, name) {
        var path;
        var index = 0;
        var extIndex = name.lastIndexOf('.');
        var basename = extIndex > -1 ? name.substr(0, extIndex) : name;
        var extension = extIndex > -1 ? name.substr(extIndex) : '';
        do {
          var filename = basename + '-' + ++index + extension;
          path = ramlRepository.join(directory.path, filename);
        } while (pathExists(path));
        return path;
      }
      /**
       * Chain promises one after another.
       *
       * @param  {Array}   promises
       * @return {Promise}
       */
      function promiseChain(promises) {
        return promises.reduce(function (promise, chain) {
          return promise.then(chain);
        }, $q.when());
      }
      /**
       * Returns a sanitized file path
       *
       * @param  {String}   path
       * @return {String}
       */
      function sanitizeFilePath(path) {
        return path.split('/').map(function (n) {
          // Remove all non-word and non-number chars
          return n.replace(/[^A-Za-z0-9. _-]/g, '');
        }).join('/');
      }
      /**
       * Returns if file has a valid file size, up to 10mg
       *
       * @param  {File}   file
       * @return {boolean}
       */
      function validateFileSize(file) {
        return file.size <= 10000000;
      }
      /**
       * Returns if file has a valid file type.
       *
       * @param  {File}   file
       * @return {boolean}
       */
      function validateFileType(file) {
        // attempt mime-type
        var validFileTypes = $window.RAML.Settings.customValidFileTypes || 'text|image|raml|json|yaml|xml|xsd|zip';
        var validateFileTypesRegExp = new RegExp(validFileTypes, 'i');
        if (file.type && validateFileTypesRegExp.test(file.type)) {
          return true;
        }
        // fallback to file extension...
        var validFileExtensions = $window.RAML.Settings.customValidFileExtensions || '.raml|.json|.yaml|.yml|.xml|.xsd|.jsd|.md|.txt|.jpg|.jpeg|.png|.html|.csv|.properties|.zip$';
        var validateFileExtensionRegExp = new RegExp(validFileExtensions, 'i');
        return validateFileExtensionRegExp.test(file.name);
      }
      /**
       * Returns file extension
       *
       * @param  {File}   file
       * @return {String}
       */
      function extractFileExtension(file) {
        return file.name.slice(file.name.lastIndexOf('.') + 1);
      }
    }
  ]);
}());
(function () {
  'use strict';
  var SKIP_FILE = 0;
  var KEEP_FILE = 1;
  var REPLACE_FILE = 2;
  angular.module('ramlEditorApp').service('importServiceConflictModal', [
    '$modal',
    function newNameModal($modal) {
      var self = this;
      self.open = function open(path) {
        return $modal.open({
          backdrop: 'static',
          templateUrl: 'views/import-service-conflict-modal.html',
          controller: 'ImportServiceConflictModal',
          resolve: {
            path: function pathResolver() {
              return path;
            }
          }
        }).result;
      };
      self.KEEP_FILE = KEEP_FILE;
      self.SKIP_FILE = SKIP_FILE;
      self.REPLACE_FILE = REPLACE_FILE;
      return self;
    }
  ]).controller('ImportServiceConflictModal', [
    '$scope',
    '$modalInstance',
    'path',
    function ImportServiceConflictModal($scope, $modalInstance, path) {
      $scope.path = path;
      $scope.skip = function () {
        $modalInstance.close(SKIP_FILE);
      };
      $scope.keep = function () {
        $modalInstance.close(KEEP_FILE);
      };
      $scope.replace = function () {
        $modalInstance.close(REPLACE_FILE);
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('oasRamlConverter', [
    '$window',
    function oasRamlConverter($window) {
      return $window.oasRamlConverter;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('jsTraverse', [
    '$window',
    function jsTraverse($window) {
      return $window.jsTraverse;
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('refParser', [
    '$window',
    function refParser($window) {
      return $window.$RefParser;
    }
  ]);
  ;
}());
'use strict';
angular.module('ramlEditorApp').factory('ramlWorker', [
  'ramlRepository',
  'ramlParser',
  '$q',
  '$window',
  function (ramlRepository, ramlParser, $q, $window) {
    // default parse method on same thread
    var ramlParse = function oldParse(data) {
      return ramlParser.loadPath(data.path, function contentAsync(path) {
        return ramlRepository.getContentByPath(path);
      });
    };
    // use worker if available
    var worker = $window.RAML.worker;
    if (worker) {
      var currentParse = null;
      var parsingPending = null;
      ramlParse = function ramlParse(data) {
        var deferred = $q.defer();
        var path = data.path;
        if (currentParse) {
          // if we already have a parse request pending, reject it as aborted
          if (parsingPending) {
            parsingPending.deferred.reject('aborted');
          }
          // leave the parser request as pending
          parsingPending = {
            deferred: deferred,
            data: data
          };
        } else {
          currentParse = data;
          _postAndExpect('ramlParse', data).then(function parseOk(result) {
            result.path = path;
            deferred.resolve(result);
            parsePending();
          }).catch(function parseFail(error) {
            error.path = path;
            deferred.reject(error);
            parsePending();
          });
        }
        return deferred.promise;
      };
      var parsePending = function parsePending() {
        currentParse = null;
        if (parsingPending) {
          ramlParse(parsingPending.data).then(parsingPending.deferred.resolve).catch(parsingPending.deferred.reject);
          parsingPending = null;
        }
      };
      var _listen = function _listen(type, fn) {
        worker.addEventListener('message', function workerMessage(e) {
          if (e.data.type === type) {
            fn(e.data.payload);
          }
        }, false);
      };
      var _post = function _post(type, payload) {
        try {
          worker.postMessage({
            type: type,
            payload: payload
          });
        } catch (e) {
          console.error('Error when trying to post to worker', e);
          worker.postMessage({ type: type });  // send just the type, so the flow can continue
        }
      };
      var _postAndExpect = function _postAndExpect(type, payload) {
        var deferred = $q.defer();
        const listener = function postListener(e) {
          if (e.data.type === type + '-resolve') {
            worker.removeEventListener('message', listener, false);
            deferred.resolve(e.data.payload);
          } else if (e.data.type === type + '-reject') {
            worker.removeEventListener('message', listener, false);
            deferred.reject(e.data.payload);
          }
        };
        worker.addEventListener('message', listener, false);
        _post(type, payload);
        return deferred.promise;
      };
      _listen('requestFile', function requestFile(request) {
        if (request.path === currentParse.path) {
          _post('requestFile', {
            path: request.path,
            content: currentParse.contents
          });
        } else {
          ramlRepository.getContentByPath(request.path, true).then(function (contents) {
            _post('requestFile', {
              path: request.path,
              content: contents
            });
          }).catch(function (err) {
            //console.error('requestFile failed', err);
            var message = typeof err === 'string' ? err : err.message || 'File not found ' + request.path;
            _post('requestFile', {
              path: request.path,
              error: message
            });
          });
        }
      });
    }
    return { ramlParse: ramlParse };
  }
]);
(function () {
  'use strict';
  angular.module('stringFilters', []).filter('dasherize', function () {
    return function (input) {
      return input ? input.toLowerCase().trim().replace(/\s/g, '-') : '';
    };
  });
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').constant('UPDATE_RESPONSIVENESS_INTERVAL', 800).controller('ramlEditorMain', [
    'UPDATE_RESPONSIVENESS_INTERVAL',
    '$scope',
    '$rootScope',
    '$timeout',
    '$window',
    'safeApply',
    'safeApplyWrapper',
    'debounce',
    'ramlWorker',
    'ramlRepository',
    'codeMirror',
    'codeMirrorErrors',
    'config',
    '$prompt',
    '$confirm',
    '$modal',
    'mockingServiceClient',
    '$q',
    'ramlEditorMainHelpers',
    function (UPDATE_RESPONSIVENESS_INTERVAL, $scope, $rootScope, $timeout, $window, safeApply, safeApplyWrapper, debounce, ramlWorker, ramlRepository, codeMirror, codeMirrorErrors, config, $prompt, $confirm, $modal, mockingServiceClient, $q, ramlEditorMainHelpers) {
      var editor, lineOfCurrentError, currentFile;
      function extractCurrentFileLabel(file) {
        var label = '';
        if (file) {
          label = file.path;
          if (file.dirty) {
            label = '* ' + label;
          }
        }
        return label;
      }
      function calculatePositionOfErrorMark(currentLine) {
        function onlyFolds(textMark) {
          return textMark.__isFold;
        }
        function toStartingLine(textMark) {
          return textMark.find().from.line;
        }
        function toMinimum(currentMin, val) {
          return Math.min(currentMin, val);
        }
        var position = { line: currentLine };
        return editor.findMarksAt(position).filter(onlyFolds).map(toStartingLine).reduce(toMinimum, lineOfCurrentError);
      }
      function formatErrorMessage(message, actualLine, displayLine) {
        if (displayLine === actualLine) {
          return message;
        }
        return 'Error on line ' + (actualLine + 1) + ': ' + message;
      }
      $window.setTheme = function setTheme(theme) {
        config.set('theme', theme);
        $scope.theme = $rootScope.theme = theme;
        safeApply($scope);
      };
      $scope.$on('event:raml-editor-file-selected', function onFileSelected(event, file) {
        currentFile = file;
        if (ramlEditorMainHelpers.isApiDefinitionLike(file.contents)) {
          // Empty console so that we remove content from previous open RAML file
          $rootScope.$broadcast('event:raml-parsed', {});
        }
        // Every file must have a unique document for history and cursors.
        if (!file.doc) {
          file.doc = new CodeMirror.Doc(file.contents);
        }
        editor.swapDoc(file.doc);
        editor.focus();
        // After swapping the doc, configure the editor for the current file
        // extension.
        codeMirror.configureEditor(editor, file.extension);
        $scope.fileParsable = $scope.getIsFileParsable(file);
        // Inform the editor source has changed. This is also called when the
        // editor triggers the change event, swapping the doc does not trigger
        // that event, so we must explicitly call the sourceUpdated function.
        $scope.sourceUpdated();
      });
      $scope.$watch('fileBrowser.selectedFile.contents', function (contents) {
        if (contents != null && contents !== editor.getValue()) {
          currentFile.doc = new CodeMirror.Doc(contents);
          editor.swapDoc(currentFile.doc);
        }
      });
      var updateFile = debounce(function updateFile() {
          $rootScope.$broadcast('event:file-updated');
        }, config.get('updateResponsivenessInterval', UPDATE_RESPONSIVENESS_INTERVAL));
      $scope.$on('event:raml-editor-file-created', updateFile);
      $scope.$on('event:raml-editor-file-removed', updateFile);
      $scope.$on('event:raml-editor-file-removed', function onFileSelected(event, file) {
        if (currentFile === file) {
          currentFile = undefined;
          editor.swapDoc(new CodeMirror.Doc(''));
        }
      });
      $scope.canExportFiles = function canExportFiles() {
        return ramlRepository.canExport();
      };
      $scope.supportsFolders = ramlRepository.supportsFolders;
      $scope.sourceUpdated = function sourceUpdated() {
        var source = editor.getValue();
        var selectedFile = $scope.fileBrowser.selectedFile;
        $scope.clearErrorMarks();
        selectedFile.contents = source;
        $scope.fileParsable = $scope.getIsFileParsable(selectedFile);
        updateFile();
      };
      $scope.loadRaml = function loadRaml(definition, path) {
        return ramlWorker.ramlParse({
          path: path,
          contents: definition
        }).then(function (raml) {
          return ramlEditorMainHelpers.isApiDefinitionLike(definition) ? raml : null;
        });
      };
      $scope.clearErrorMarks = function clearErrorMarks() {
        codeMirrorErrors.clearAnnotations();
        $scope.hasErrors = false;
        $scope.currentErrorCount = 0;
        $scope.currentWarningCount = 0;
        if (!currentFile || !$scope.fileParsable || currentFile.doc.getValue().trim() === '') {
          $scope.currentError = undefined;
          lineOfCurrentError = undefined;
        }
      };
      var parseTimer;
      $scope.parsing = 0;
      $scope.$on('event:file-updated', function onFileUpdated() {
        $scope.clearErrorMarks();
        $timeout.cancel(parseTimer);
        parseTimer = $timeout(function defer() {
          $scope.clearErrorMarks();
          if (!currentFile || !$scope.fileParsable || currentFile.doc.getValue().trim() === '') {
            return;
          }
          $scope.parsing++;
          $scope.loadRaml(currentFile.doc.getValue(), currentFile.path).then(safeApplyWrapper($scope, function completeParse(api) {
            $scope.parsing--;
            $scope.clearErrorMarks();
            if (api && api.path === currentFile.path && $scope.parsing === 0) {
              var issues = api.errors;
              // errors and warnings
              if (issues && issues.length > 0) {
                $rootScope.$broadcast('event:raml-parser-error', issues);
                $scope.currentWarningCount = issues.reduce(function (count, issue) {
                  return issue.isWarning ? count + 1 : count;
                }, 0);
                $scope.currentErrorCount = issues.reduce(function (count, issue) {
                  return !issue.isWarning ? count + 1 : count;
                }, 0);
              }
              if ($scope.currentErrorCount === 0) {
                var raml = api.specification;
                $rootScope.$broadcast('event:raml-parsed', raml);
              }
              $('.CodeMirror').each(function (i, el) {
                el.CodeMirror.refresh();
              });
            }
          })).catch(safeApplyWrapper($scope, function failureParse(error) {
            $scope.parsing--;
            if (error !== 'aborted' && error.path === currentFile.path && $scope.parsing === 0) {
              $scope.currentErrorCount = 0;
              $scope.currentWarningCount = 0;
              $rootScope.$broadcast('event:raml-parser-error', error.parserErrors || error);
            }
          }));
        }, 700);
      });
      $scope.$on('event:raml-parsed', safeApplyWrapper($scope, function onRamlParser(event, raml) {
        $scope.fileBrowser.selectedFile.raml = raml;
        $scope.raml = raml;
        $scope.title = raml && raml.title;
        $scope.version = raml && raml.version;
        $scope.ramlError = undefined;
        $scope.currentError = undefined;
        lineOfCurrentError = undefined;
      }));
      $scope.$on('event:raml-parser-error', safeApplyWrapper($scope, function onRamlParserError(event, errors) {
        var parserErrors = Array.isArray(errors) ? errors : [{
              line: 0,
              column: 1,
              message: errors.message,
              isWarning: errors.isWarning
            }];
        $scope.ramlError = errors;
        codeMirrorErrors.displayAnnotations(parserErrors.map(function mapErrorToAnnotation(error) {
          var errorInfo = error;
          var tracingInfo = {
              line: undefined,
              column: undefined,
              path: undefined
            };
          var needErrorPath = error.trace !== undefined;
          function findError(errors, selectedFile) {
            for (var i = 0; i < errors.length; i++) {
              var error = errors[i];
              if (error.path === selectedFile.name) {
                error.from = errorInfo;
                return error;
              } else if (error.trace) {
                var innerError = findError(error.trace, selectedFile);
                if (innerError) {
                  innerError.from = error;
                  return innerError;
                }
              }
            }
          }
          if (needErrorPath) {
            var selectedFile = event.currentScope.fileBrowser.selectedFile;
            var selectedFilePath = selectedFile.path;
            var lastDirectoryIndex = selectedFilePath.lastIndexOf('/') + 1;
            var folderPath = selectedFilePath.substring(selectedFilePath[0] === '/' ? 1 : 0, lastDirectoryIndex);
            errorInfo = findError(error.trace, selectedFile);
            if (errorInfo) {
              errorInfo.isWarning = error.isWarning;
              var rangeFrom = rangePoint(errorInfo.from.range);
              tracingInfo = {
                line: rangeFrom.line,
                column: rangeFrom.column,
                path: folderPath + errorInfo.from.path
              };
            } else {
              // should not happen... todo parser bug
              errorInfo = {
                message: error.message,
                isWarning: error.isWarning
              };
              var traceRange = rangePoint(error.range);
              tracingInfo = {
                line: traceRange.line,
                column: traceRange.column,
                path: folderPath + error.path
              };
            }
          }
          var range = rangePoint(errorInfo.range);
          return {
            line: range.line,
            column: range.column,
            message: errorInfo.message,
            severity: errorInfo.isWarning ? 'warning' : 'error',
            path: tracingInfo.path,
            tracingLine: tracingInfo.line,
            tracingColumn: tracingInfo.column
          };
        }));
      }));
      function rangePoint(range) {
        if (range && range.start) {
          return {
            line: 1 + range.start.line,
            column: range.start.column
          };
        }
        if (range && Array.isArray(range)) {
          return {
            line: 1 + range[0],
            column: range[1]
          };
        }
        return {
          line: 1,
          column: 1
        };
      }
      $scope.openHelp = function openHelp() {
        $modal.open({ templateUrl: 'views/help.html' });
      };
      $scope.getIsFileParsable = function getIsFileParsable(file) {
        return ramlEditorMainHelpers.isRamlFile(file.extension) && ramlEditorMainHelpers.isApiDefinitionLike(file.contents);
      };
      $scope.getIsMockingServiceVisible = function getIsMockingServiceVisible() {
        return !($scope.mockingServiceDisabled || !$scope.fileParsable);
      };
      $scope.getIsShelfVisible = function getIsShelfVisible() {
        return $scope.fileParsable;
      };
      $scope.getIsConsoleVisible = function getIsConsoleVisible() {
        return $scope.fileParsable && $scope.raml;
      };
      $scope.toggleShelf = function toggleShelf() {
        $scope.shelf.collapsed = !$scope.shelf.collapsed;
        config.set('shelf.collapsed', $scope.shelf.collapsed);
      };
      $scope.getSelectedFileAbsolutePath = function getSelectedFileAbsolutePath() {
        if (!currentFile) {
          return '';
        }
        var status = '';
        if ($scope.fileParsable) {
          if ($scope.parsing > 0) {
            status = 'validating...';
          } else if ($scope.currentErrorCount || $scope.currentWarningCount) {
            if ($scope.currentErrorCount) {
              status += $scope.currentErrorCount + ' ' + ($scope.currentErrorCount > 1 ? 'errors' : 'error');
            }
            if ($scope.currentErrorCount && $scope.currentWarningCount) {
              status += ', ';
            }
            if ($scope.currentWarningCount) {
              status += $scope.currentWarningCount + ' ' + ($scope.currentWarningCount > 1 ? 'warnings' : 'warning');
            }
          }
        }
        return extractCurrentFileLabel(currentFile) + (!status ? '' : ' (' + status + ')');
      };
      $scope.$on('event:toggle-theme', function onToggleTheme() {
        $window.setTheme($scope.theme === 'dark' ? 'light' : 'dark');
      });
      (function bootstrap() {
        $scope.currentError = undefined;
        $scope.theme = $rootScope.theme = config.get('theme', 'dark');
        $scope.shelf = {};
        $scope.shelf.collapsed = JSON.parse(config.get('shelf.collapsed', 'false'));
        $scope.editor = editor = codeMirror.initEditor();
        editor.on('fold', function (cm, start, end) {
          if (start.line <= lineOfCurrentError && lineOfCurrentError <= end.line) {
            codeMirrorErrors.displayAnnotations([{
                line: start.line + 1,
                message: formatErrorMessage($scope.currentError.message, lineOfCurrentError, start.line)
              }]);
          }
        });
        editor.on('unfold', function () {
          var displayLine = calculatePositionOfErrorMark(lineOfCurrentError);
          var message = formatErrorMessage($scope.currentError.message, lineOfCurrentError, displayLine);
          codeMirrorErrors.displayAnnotations([{
              line: displayLine + 1,
              message: message
            }]);
        });
        editor.on('change', function onChange() {
          $scope.sourceUpdated();
        });
        $window.alreadyNotifiedExit = false;
        $window.editorFilesystemIsDirty = function editorFilesystemIsDirty() {
          var dirtyFile = false;
          $scope.homeDirectory.forEachChildDo(function (t) {
            dirtyFile = t.dirty || dirtyFile;
          });
          return dirtyFile;
        };
        // Warn before leaving the page
        $window.onbeforeunload = function () {
          if (!$window.alreadyNotifiedExit && $window.editorFilesystemIsDirty()) {
            return 'WARNING: You have unsaved changes. Those will be lost if you leave this page.';
          }
        };
        if ($scope.mockingServiceBaseUri) {
          mockingServiceClient.baseUri = $scope.mockingServiceBaseUri;
        }
      }());
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('ramlEditorMainHelpers', function ramlEditorMainHelpers() {
    return {
      isRamlFile: isRamlFile,
      isApiDefinition: isApiDefinition,
      isApiDefinitionV08: isApiDefinitionV08,
      isApiDefinitionLike: isApiDefinitionLike
    };
    // ---
    function isRamlFile(extension) {
      return extension === 'raml';
    }
    function isApiDefinitionLike(raml) {
      return isApiDefinition(raml) || isTypedFragment(raml);
    }
    // ---
    function isApiDefinition(raml) {
      return /^#%RAML\s(0\.8|1\.0)\s*$/.test(getFirstLine(raml));
    }
    function isApiDefinitionV08(raml) {
      return /^#%RAML\s(0\.8)\s*$/.test(getFirstLine(raml));
    }
    function isTypedFragment(raml) {
      return /^#%RAML\s1\.0\s(Trait|ResourceType|Library|Overlay|Extension|DataType|DocumentationItem|NamedExample|AnnotationTypeDeclaration|SecurityScheme)\s*$/.test(getFirstLine(raml));
    }
    function getFirstLine(raml) {
      return raml.split(/\r\n|\n/)[0];
    }
  });
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').factory('applySuggestion', function applySuggestionFactory() {
    return function applySuggestion(editor, suggestion) {
      var replacementPrefix = suggestion.replacementPrefix || '';
      var cursor = editor.getCursor();
      var rangeEnd = {
          line: cursor.line,
          ch: editor.getLine(cursor.line).length
        };
      var rangeStart = {
          line: cursor.line,
          ch: cursor.ch - replacementPrefix.length
        };
      editor.replaceRange(suggestion.key, rangeStart, rangeEnd);
      var suggestionLines = suggestion.key.split('\n');
      var ch = suggestionLines.length > 1 ? suggestionLines[suggestionLines.length - 1].length : cursor.ch + suggestionLines[0].length - replacementPrefix.length;
      var line = cursor.line + suggestionLines.length - 1;
      editor.setCursor({
        line: line,
        ch: ch
      });
      editor.focus();
    };
  }).factory('newSuggestions', [
    'ramlSuggest',
    function (ramlSuggest) {
      var groupBy = function (items, key) {
        var addItemToResult = function (result, item) {
          var list = result[item[key]] || [];
          list.push(item);
          result[item[key]] = list;
          return result;
        };
        return items.reduce(addItemToResult, {});
      };
      var createModel = function (suggestions) {
        var items = suggestions.map(function (suggestion) {
            return {
              category: suggestion.category,
              title: suggestion.displayText || suggestion.text,
              key: suggestion.text,
              replacementPrefix: suggestion.replacementPrefix || ''
            };
          });
        var categoryMap = groupBy(items, 'category');
        var categories = Object.keys(categoryMap).map(function (key) {
            return {
              name: key,
              items: categoryMap[key]
            };
          });
        return { categories: categories };  // model
      };
      return function (homeDirectory, selectedFile, editor) {
        return ramlSuggest.suggest(homeDirectory, selectedFile, editor).then(createModel);
      };
    }
  ]).controller('ramlEditorShelf', [
    '$scope',
    'safeApplyWrapper',
    'newSuggestions',
    'applySuggestion',
    function ($scope, safeApplyWrapper, newSuggestions, applySuggestion) {
      var editor = $scope.editor;
      function updateModel(suggestions) {
        $scope.model = suggestions;
        $scope.$digest();
      }
      $scope.cursorMoved = safeApplyWrapper(null, function cursorMoved() {
        if ($scope.shelf.collapsed) {
          $scope.model = [];
        } else {
          newSuggestions($scope.homeDirectory, $scope.fileBrowser.selectedFile, editor).then(updateModel);
        }
      });
      $scope.orderSections = function orderSections(section) {
        var index = [
            'root',
            'docs',
            'methods',
            'parameters',
            'responses',
            'security',
            'resources',
            'traits and types'
          ].indexOf(section.name.toLowerCase());
        return index === -1 ? index.length : index;
      };
      $scope.itemClick = function itemClick(suggestion) {
        applySuggestion(editor, suggestion);
      };
      editor.on('cursorActivity', $scope.cursorMoved);
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').constant('NOTIFICATION_TIMEOUT', 3000).controller('notifications', [
    'NOTIFICATION_TIMEOUT',
    '$scope',
    '$timeout',
    function (NOTIFICATION_TIMEOUT, $scope, $timeout) {
      var notifications = [];
      $scope.shouldDisplayNotifications = false;
      function processNotifications() {
        var args;
        if (notifications.length) {
          args = notifications.splice(0, 1)[0];
          $scope.message = args.message;
          $scope.expires = args.expires;
          $scope.level = args.level || 'info';
          // info, error
          $scope.shouldDisplayNotifications = true;
          if (args.expires) {
            $timeout(function () {
              $scope.shouldDisplayNotifications = false;
              processNotifications();
            }, NOTIFICATION_TIMEOUT);
          }
        }
      }
      $scope.$on('event:notification', function (e, args) {
        notifications.push(JSON.parse(JSON.stringify(args)));
        processNotifications();
      });
      $scope.hideNotifications = function () {
        $scope.shouldDisplayNotifications = false;
        processNotifications();
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').controller('mockingServiceController', [
    '$scope',
    'mockingService',
    'codeMirror',
    'getNode',
    function mockingServiceControllerFactory($scope, mockingService, codeMirror, getNode) {
      function addBaseUri() {
        function setLine(lineNumber, line, prefix) {
          codeMirror.setLine($scope.editor, lineNumber, (prefix || '') + $scope.editor.getLine(lineNumber) + '\n' + line);
        }
        var baseUri = 'baseUri: ' + $scope.mock.baseUri;
        var node = getNode($scope.editor, 0);
        // try to find `baseUri` line
        while (node) {
          if (node.getKey() === 'baseUri') {
            if (node.getValue().text !== $scope.mock.baseUri) {
              setLine(node.lineNumber, baseUri, '#');
            }
            return;
          }
          node = node.getNextSibling();
        }
        // try to find `---` line
        for (var i = 0; $scope.editor.getLine(i); i++) {
          if ($scope.editor.getLine(i).trim() === '---') {
            setLine(i, baseUri);
            return;
          }
        }
        // place it right after RAML version tag
        setLine(0, baseUri);
      }
      function removeBaseUri() {
        var baseUriLine = 'baseUri: ' + $scope.mock.baseUri;
        var lineNumber = void 0;
        var line = void 0;
        // trying to find mocked baseUri
        // and remove it
        for (lineNumber = 0; lineNumber < $scope.editor.lineCount(); lineNumber++) {
          line = $scope.editor.getLine(lineNumber).trim();
          if (line === baseUriLine) {
            codeMirror.removeLine($scope.editor, lineNumber);
            break;
          }
        }
        // trying to find previous commented out baseUri
        // and uncomment it
        for (lineNumber = Math.min(lineNumber, $scope.editor.lineCount() - 1); lineNumber >= 0; lineNumber--) {
          line = $scope.editor.getLine(lineNumber).trim();
          if (line.indexOf('#') === 0 && line.slice(1).trim().indexOf('baseUri: ') === 0) {
            codeMirror.setLine($scope.editor, lineNumber, line.slice(1).trim());
            break;
          }
        }
      }
      function loading(promise) {
        $scope.loading = true;
        return promise.finally(function onFinally() {
          $scope.loading = false;
        });
      }
      function setMock(mock) {
        $scope.mock = mock;
        $scope.enabled = !!mock;
      }
      function getMock() {
        loading(mockingService.getMock($scope.fileBrowser.selectedFile).then(setMock).then(function () {
          if ($scope.mock) {
            addBaseUri();
          }
        }));
      }
      function createMock() {
        loading(mockingService.createMock($scope.fileBrowser.selectedFile, $scope.fileBrowser.selectedFile.raml).then(setMock).then(addBaseUri));
      }
      function updateMock() {
        mockingService.updateMock($scope.fileBrowser.selectedFile, $scope.fileBrowser.selectedFile.raml).then(setMock);
        ;
      }
      function deleteMock() {
        loading(mockingService.deleteMock($scope.fileBrowser.selectedFile).then(function () {
          removeBaseUri();
        }).then(setMock));
      }
      $scope.toggleMockingService = function toggleMockingService() {
        if (!$scope.fileBrowser.selectedFile) {
          return;
        }
        if ($scope.enabled) {
          deleteMock();
          return;
        }
        createMock();
      };
      $scope.$watch('fileBrowser.selectedFile', function watch(newValue) {
        if (newValue) {
          getMock();
        } else {
          setMock();
        }
      });
      $scope.$watch('fileBrowser.selectedFile.raml', function watch() {
        if ($scope.enabled) {
          updateMock();
        }
      });
    }
  ]);
  ;
}());
(function () {
  'use strict';
  /**
   * Flex layout splitter
   */
  angular.module('splitter', []).directive('ngSplitter', [
    '$window',
    'config',
    function ($window, config) {
      // Extend angular jqlite with .prev as an opposite to .next
      if (!angular.element.prototype.prev) {
        /**
           * Get the immediately preceding sibling of each element in the set of matched elements.
           */
        angular.element.prototype.prev = function prev() {
          var value;
          if (this.length) {
            value = this[0].previousSibling;
            while (value !== null && value.nodeType !== 1) {
              value = value.previousSibling;
            }
          }
          return angular.isDefined(value) ? angular.element(value) : this;
        };
      }
      function getCollapseTarget(splitter) {
        return splitter.attr('ng-splitter-collapse-target');
      }
      function getMinWidth(splitter) {
        return splitter.attr('ng-splitter-min-width');
      }
      function getCollapseTargetEl(splitter) {
        return splitter[getCollapseTarget(splitter)]();
      }
      function getNonCollapseTargetEl(splitter) {
        return splitter[{
          next: 'prev',
          prev: 'next'
        }[getCollapseTarget(splitter)]]();
      }
      /**
         * Scales the splitter to the requested size, clipping the size based on
         * our constraints and toggling the resize chevron if the size of the
         * next element goes to the minimum value.
         *
         * @param splitter Splitter that was moved
         * @param size Pixels to resize to
         */
      function resizeCollapseTarget(splitter, size) {
        var minWidth = getMinWidth(splitter);
        if (typeof minWidth === 'undefined' || size >= minWidth) {
          getCollapseTargetEl(splitter).css('min-width', Math.max(0, size) + 'px');
        }
        return Math.max(0, size);
      }
      /**
         * @param splitter Splitter that was moved
         * @param sizeAttr 'width' or 'height'
         * @param delta Pixels to resize by
         * @returns New collapse target size after it has been resized
         */
      function performResizeCollapseTarget(splitter, sizeAttr, delta) {
        var collapseTargetEl = getCollapseTargetEl(splitter);
        var collapseTargetElSize = getOffsetSize(collapseTargetEl, sizeAttr);
        var nonCollapseTargetEl = getNonCollapseTargetEl(splitter);
        var nonCollapseTargetElSize = getOffsetSize(nonCollapseTargetEl, sizeAttr);
        var sign = {
            next: 1,
            prev: -1
          }[getCollapseTarget(splitter)];
        // Force delta to be as small as possible to make
        // sure collapse target doesn't over grow if there is
        // no space left
        if (nonCollapseTargetElSize + delta * sign < 0) {
          delta = nonCollapseTargetElSize * sign * -1;
        }
        if (delta) {
          collapseTargetElSize = resizeCollapseTarget(splitter, collapseTargetElSize - delta * sign);
        }
        return collapseTargetElSize;
      }
      /**
         * @param element Element whose offset size we want
         * @param sizeAttr 'width' or 'height'
         * @returns {Number} offset size
         */
      function getOffsetSize(element, sizeAttr) {
        var offsetSizeProperty = 'offset' + sizeAttr[0].toUpperCase() + sizeAttr.slice(1);
        return element[0][offsetSizeProperty];
      }
      //region Splitter config
      /**
         * Loads the splitter size and optionally applies it to the next element
         * after the splitter
         * @param splitter The splitter element. Should have a unique id.
         * @param sizeAttr 'width' or 'height'
         * @returns {Number} The splitter size
         */
      function loadSize(splitter, sizeAttr) {
        //If no size was saved, use the current size;
        return config.get('splitterSize_' + splitter.attr('id')) || saveSize(splitter, sizeAttr);
      }
      /**
         * Saves the splitter size
         * @param splitter The splitter element. Should have a unique id.
         * @param sizeAttr 'width' or 'height'
         * @returns {Number} The size of the splitter
         */
      function saveSize(splitter, sizeAttr) {
        var size = getOffsetSize(getCollapseTargetEl(splitter), sizeAttr);
        config.set('splitterSize_' + splitter.attr('id'), size);
        return size;
      }
      /**
         * Loads whether the splitter was collapsed by the user
         * @param splitter The splitter element. Should have a unique id.
         * @returns {boolean} Whether the splitter was collapsed by the user
         */
      function loadIsCollapsed(splitter) {
        return config.get('splitterCollapsed_' + splitter.attr('id')) === 'true';
      }
      /**
         * Saves whether the splitter is collapsed
         * @param splitter The splitter element. Should have a unique id.
         * @param collapsed Whether the splitter is collapsed
         */
      function saveIsCollapsed(splitter, collapsed) {
        config.set('splitterCollapsed_' + splitter.attr('id'), collapsed);
      }
      /**
         * Toggles the collapse target visibility
         * @param splitter The splitter that owns the chevron
         * @param collapse False means expand collapse target, true
         * means collapse target is shown
         */
      function toggleCollapseTarget(splitter, collapse) {
        splitter.toggleClass('collapsed', collapse);
        getCollapseTargetEl(splitter).toggleClass('hide-display', collapse);
        saveIsCollapsed(splitter, collapse);
      }
      //endregion
      return {
        restrict: 'A',
        link: function (scope, splitter, attrs) {
          var isActive = false;
          var userIsDragging = true;
          var vertical = attrs.ngSplitter === 'vertical';
          var sizeAttr = vertical ? 'width' : 'height';
          var posAttr = vertical ? 'clientX' : 'clientY';
          var lastPos;
          var lastSize = loadSize(splitter, sizeAttr);
          var lastCollapsed = loadIsCollapsed(splitter);
          var parent = splitter.parent();
          // Restore collapse target state (size and collapsed)
          // from last session
          resizeCollapseTarget(splitter, lastSize);
          toggleCollapseTarget(splitter, lastCollapsed);
          scope['splitterCollapsed_' + splitter.attr('id')] = lastCollapsed;
          // Configure UI events
          splitter.on('mousedown', function onMouseDown(event) {
            // Only respond to left mouse button
            if (event.button !== 0) {
              return;
            }
            lastPos = event[posAttr];
            lastSize = loadSize(splitter, sizeAttr);
            lastCollapsed = loadIsCollapsed(splitter);
            isActive = true;
            parent.addClass('noselect');
          });
          ;
          angular.element($window).on('mousemove', function onMouseMove(event) {
            if (isActive) {
              userIsDragging = true;
              // Scale the collapse target
              var collapsed = performResizeCollapseTarget(splitter, sizeAttr, event[posAttr] - lastPos) === 0;
              // Collapse the target if its size has reached zero
              //
              // We don't want to toggle the state every 1px and for
              // that reason we compare current state with last one
              if (collapsed !== lastCollapsed) {
                toggleCollapseTarget(splitter, collapsed);
                scope.$apply(function toogleCollapseState() {
                  scope['splitterCollapsed_' + splitter.attr('id')] = collapsed;
                });
              }
              lastPos = event[posAttr];
              lastCollapsed = collapsed;
            }
          }).on('mouseup', function onMouseUp() {
            if (isActive) {
              if (lastCollapsed) {
                // Preserve collapse target's size if it
                // has reached collapsed state during drag & drop operation
                //
                // We do it to make sure collapsed target expands to proper size
                // when users try to expand it in current or next session
                toggleCollapseTarget(splitter, true);
                resizeCollapseTarget(splitter, lastSize);
                scope.$apply(function toogleCollapseState() {
                  scope['splitterCollapsed_' + splitter.attr('id')] = true;
                });
              } else {
                saveSize(splitter, sizeAttr);
              }
              isActive = false;
              parent.removeClass('noselect');
            }
          });
          ;
          // Wire up the tiny button that handles collapse and expand operations
          splitter.children('.split').on('mousedown', function onClick() {
            userIsDragging = false;
          });
          splitter.children('.split').on('mouseup', function onClick() {
            // Need to make sure that the user is clicking, not dragging:
            if (!userIsDragging) {
              var collapsed = !loadIsCollapsed(splitter);
              toggleCollapseTarget(splitter, collapsed);
              scope.$apply(function toogleCollapseState() {
                scope['splitterCollapsed_' + splitter.attr('id')] = collapsed;
              });
              userIsDragging = true;
              isActive = false;
            }
          });
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('validate', []).directive('ngValidate', [
    '$parse',
    function ($parse) {
      return {
        require: 'ngModel',
        link: function (scope, element, attrs, ngModelController) {
          var fn = $parse(attrs.ngValidate);
          scope.$watch(attrs.ngModel, function (value) {
            var validity = fn(scope, { $value: value });
            ngModelController.$setValidity('validate', validity);
          });
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('autoFocus', []).directive('ngAutoFocus', [
    '$timeout',
    function ($timeout) {
      return {
        link: function (scope, element, attrs) {
          scope.$watch(attrs.ngAutoFocus, function (value) {
            if (!value) {
              return;
            }
            $timeout(function () {
              element[0].focus();
            }, 100);
          });
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('rightClick', []).directive('ngRightClick', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngRightClick);
        element.on('contextmenu', function (e) {
          scope.$apply(function () {
            e.preventDefault();
            fn(scope, { $event: e });
          });
        });
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditor', function () {
    return {
      restrict: 'E',
      scope: {
        mockingServiceDisabled: '=',
        mockingServiceBaseUri: '='
      },
      templateUrl: 'views/raml-editor-main.tmpl.html',
      controller: 'ramlEditorMain'
    };
  });
  ;
}());
(function () {
  'use strict';
  angular.module('dragAndDrop', []).directive('ngDragEnter', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngDragEnter);
        var entered = 0;
        element.on('dragleave', function () {
          entered--;
        });
        element.on('dragenter', function (e) {
          entered++;
          if (entered !== 1) {
            return;
          }
          scope.$apply(function () {
            e.preventDefault();
            fn(scope, { $event: e });
          });
        });
      };
    }
  ]).directive('ngDragLeave', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngDragLeave);
        var entered = 0;
        element.on('dragenter', function () {
          entered++;
        });
        element.on('dragleave', function (e) {
          entered--;
          if (entered !== 0) {
            return;
          }
          scope.$apply(function () {
            e.preventDefault();
            fn(scope, { $event: e });
          });
        });
      };
    }
  ]).directive('ngDrop', [
    '$parse',
    function ($parse) {
      return function (scope, element, attrs) {
        var fn = $parse(attrs.ngDrop);
        element.on('dragover', function (e) {
          e.preventDefault();
        });
        element.on('drop', function (e) {
          scope.$apply(function () {
            e.preventDefault();
            e.stopPropagation();
            fn(scope, { $event: e.originalEvent });
          });
        });
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorContextMenu', [
    '$injector',
    '$window',
    'confirmModal',
    'newNameModal',
    'ramlRepository',
    'newFileService',
    'newFolderService',
    'subMenuService',
    'scroll',
    function ramlEditorContextMenu($injector, $window, confirmModal, newNameModal, ramlRepository, newFileService, newFolderService, subMenuService, scroll) {
      function createActions(target) {
        var saveAction = {
            label: 'Save',
            execute: function execute() {
              return ramlRepository.saveFile(target);
            }
          };
        var newFileAction = {
            label: 'New File',
            fragments: newFileService.files['1.0'],
            execute: function execute(fragmentLabel) {
              if (fragmentLabel) {
                return newFileService.prompt(target, '1.0', fragmentLabel);
              }
            },
            newFile: function newFile() {
              return newFileService.prompt(target, '0.8');
            }
          };
        var newFolderAction = {
            label: 'New Folder',
            execute: function execute() {
              return newFolderService.prompt(target);
            }
          };
        var renameAction = {
            label: 'Rename',
            execute: function execute() {
              var parent = ramlRepository.getParent(target);
              var message = target.isDirectory ? 'Enter a new name for this folder:' : 'Enter a new name for this file:';
              var title = target.isDirectory ? 'Rename a folder' : 'Rename a file';
              var validations = [{
                    message: 'This name is already taken.',
                    validate: function validate(input) {
                      var path = ramlRepository.join(parent.path, input);
                      return !ramlRepository.getByPath(path);
                    }
                  }];
              return newNameModal.open(message, target.name, validations, title).then(function (name) {
                ramlRepository.rename(target, name);
              });
              ;
            }
          };
        var deleteAction = {
            label: 'Delete',
            execute: function execute() {
              var message;
              var title;
              if (target.isDirectory) {
                message = 'Are you sure you want to delete "' + target.name + '" and all its contents?';
                title = 'Delete folder';
              } else {
                message = 'Are you sure you want to delete "' + target.name + '"?';
                title = 'Delete file';
              }
              return confirmModal.open(message, title, {
                closeButtonLabel: 'Delete',
                closeButtonCssClass: 'btn-danger'
              }).then(function () {
                return ramlRepository.remove(target);
              });
              ;
            }
          };
        if (target.isDirectory) {
          return [
            newFileAction,
            newFolderAction,
            renameAction,
            deleteAction
          ];
        }
        return [
          saveAction,
          renameAction,
          deleteAction
        ];
      }
      function outOfWindow(el) {
        var rect = el.getBoundingClientRect();
        return !(rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth));
      }
      return {
        restrict: 'E',
        templateUrl: 'views/raml-editor-context-menu.tmpl.html',
        link: function link(scope, element) {
          scope.openFileMenu = function (action) {
            if (action.label === 'New File') {
              subMenuService.openSubMenu(scope, 'showFileMenu');
            }
          };
          scope.closeFileMenu = function () {
            scope.showFileMenu = false;
          };
          function positionMenu(element, event) {
            var top = event.pageY;
            var left = event.pageX;
            var menuContainer = angular.element(element[0].children[0]);
            menuContainer.css('top', top + 'px');
            menuContainer.css('left', left + 'px');
            setTimeout(function () {
              if (outOfWindow(menuContainer[0])) {
                menuContainer.css('top', top - menuContainer[0].offsetHeight + 'px');
              }
            }, 0);
          }
          function close(e) {
            if (e && e.target.firstChild.nodeValue && e.target.firstChild.nodeValue.match('New File')) {
              return;
            }
            scroll.enable();
            scope.$apply(function () {
              delete contextMenuController.target;
              scope.opened = false;
              $window.removeEventListener('click', close);
              $window.removeEventListener('keydown', closeOnEscape);
            });
          }
          function closeOnEscape(e) {
            if (e.which === 27) {
              e.preventDefault();
              close();
            }
          }
          var contextMenuController = {
              open: function open(event, target) {
                scroll.disable();
                this.target = target;
                scope.target = target;
                scope.actions = createActions(target);
                event.stopPropagation();
                positionMenu(element, event);
                $window.addEventListener('click', close);
                $window.addEventListener('keydown', closeOnEscape);
                scope.opened = true;
              }
            };
          scope.registerContextMenu(contextMenuController);
        },
        scope: true
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorFileBrowser', [
    '$q',
    '$window',
    '$rootScope',
    '$timeout',
    'config',
    'ramlRepository',
    'newNameModal',
    'importService',
    function ($q, $window, $rootScope, $timeout, config, ramlRepository, newNameModal, importService) {
      function Controller($scope) {
        var fileBrowser = this;
        var unwatchSelectedFile = angular.noop;
        var contextMenu = void 0;
        $scope.toggleFolderCollapse = function (node) {
          node.collapsed = !node.collapsed;
        };
        $scope.fileTreeOptions = function () {
          var duplicateName = false;
          return {
            accept: function (sourceNodeScope, destNodesScope, destIndex) {
              var accept;
              var source = sourceNodeScope.$modelValue;
              var dest = destIndex < 0 ? $scope.homeDirectory : destNodesScope.$modelValue[destIndex];
              // if the destination is a file, select its parent directory as destination
              if (!dest.isDirectory) {
                dest = destNodesScope.$nodeScope ? destNodesScope.$nodeScope.$modelValue : $scope.homeDirectory;
              }
              // Check if the destination is a child of the source
              var destIsChild = ramlRepository.getParent(source).path === dest.path || dest.path.slice(0, source.path.length) === source.path;
              duplicateName = dest.children.filter(function (c) {
                return c.name === source.name;
              }).length > 0;
              accept = !duplicateName && !destIsChild;
              if (accept) {
                fileBrowser.cursorState = 'ok';
              } else {
                fileBrowser.cursorState = 'no';
              }
              return accept;
            },
            dropped: function (event) {
              var source = event.source.nodeScope.$modelValue;
              var dest = event.dest.nodesScope.$nodeScope ? event.dest.nodesScope.$nodeScope.$modelValue : $scope.homeDirectory;
              // do the actual moving
              ramlRepository.move(source, dest).then(function () {
                return fileBrowser.select(source);
              });
            },
            dragStop: function (event) {
              // when drag is stopped or canceled, reset the cursor
              fileBrowser.cursorState = '';
              if (!event.canceled && duplicateName) {
                $rootScope.$broadcast('event:notification', {
                  message: 'Failed: duplicate file name found in the destination folder.',
                  expires: true,
                  level: 'error'
                });
              }
            }
          };
        }();
        fileBrowser.select = function select(target) {
          if (target.isDirectory) {
            return fileBrowser.selectDirectory(target);
          }
          return fileBrowser.selectFile(target);
        };
        $scope.$on('event:raml-editor-file-select', function (event, filePath) {
          var file = ramlRepository.getByPath(filePath);
          fileBrowser.selectFile(file);
        });
        fileBrowser.selectFile = function selectFile(file) {
          // If we select a file that is already active, just modify 'currentTarget', no load needed
          if (fileBrowser.selectedFile && fileBrowser.selectedFile.$$hashKey === file.$$hashKey) {
            fileBrowser.currentTarget = file;
            return;
          }
          unwatchSelectedFile();
          var isLoaded = file.loaded || !file.persisted;
          var afterLoading = isLoaded ? $q.when(file) : ramlRepository.loadFile(file);
          afterLoading.then(function (file) {
            fileBrowser.selectedFile = fileBrowser.currentTarget = file;
            $scope.$emit('event:raml-editor-file-selected', file);
            unwatchSelectedFile = $scope.$watch('fileBrowser.selectedFile.contents', function (newContents, oldContents) {
              if (newContents !== oldContents) {
                file.dirty = true;
              }
            });
          });
        };
        fileBrowser.selectDirectory = function selectDirectory(directory) {
          $scope.$emit('event:raml-editor-directory-selected', directory);
        };
        /**
         * This function is used for expanding all the ancestors of a target
         * node in the file tree.
         *
         * @param target {RamlDirectory/RamlFile}
         */
        function expandAncestors(target) {
          // stop at the top-level directory
          if (target.path === '/') {
            return;
          }
          var parent = ramlRepository.getParent(target);
          parent.collapsed = false;
          expandAncestors(parent);
        }
        fileBrowser.saveFile = function saveFile(file) {
          ramlRepository.saveFile(file).then(function () {
            return $rootScope.$broadcast('event:notification', {
              message: 'File saved.',
              expires: true
            });
          });
          ;
        };
        fileBrowser.dropFile = function dropFile(event, directory) {
          return importService.importFromEvent(directory, event).then(function () {
            directory.collapsed = false;
          }).catch(function (err) {
            $rootScope.$broadcast('event:notification', {
              message: err.message,
              expires: true,
              level: 'error'
            });
          });
        };
        fileBrowser.showContextMenu = function showContextMenu(event, target) {
          contextMenu.open(event, target);
        };
        fileBrowser.contextMenuOpenedFor = function contextMenuOpenedFor(target) {
          return contextMenu && contextMenu.target === target;
        };
        function saveListener(e) {
          if (e.which === 83 && (e.metaKey || e.ctrlKey) && !(e.shiftKey || e.altKey)) {
            e.preventDefault();
            $scope.$apply(function () {
              fileBrowser.saveFile(fileBrowser.selectedFile);
            });
          }
        }
        $window.addEventListener('keydown', saveListener);
        $scope.fileBrowser = fileBrowser;
        $scope.registerContextMenu = function registerContextMenu(cm) {
          contextMenu = cm;
        };
        $scope.$on('event:raml-editor-file-generated', function (event, file) {
          fileBrowser.selectFile(file);
        });
        $scope.$on('event:raml-editor-directory-created', function (event, dir) {
          fileBrowser.selectDirectory(dir);
        });
        $scope.$on('event:raml-editor-file-selected', function (event, file) {
          expandAncestors(file);
        });
        $scope.$on('event:raml-editor-directory-selected', function (event, dir) {
          expandAncestors(dir);
        });
        $scope.$on('event:raml-editor-filetree-modified', function (event, target) {
          ramlRepository.getParent(target).sortChildren();
        });
        $scope.$on('event:raml-editor-file-removed', function (event, file) {
          $timeout(function () {
            var files = $scope.homeDirectory.getFiles();
            if (files.length === 0) {
              promptWhenFileListIsEmpty();
            } else if (file === fileBrowser.selectedFile) {
              fileBrowser.selectFile(files[0]);
            }
          });
        });
        $scope.$on('$destroy', function () {
          $window.removeEventListener('keydown', saveListener);
        });
        // watch for selected file path changes, update config if needed
        $scope.$watch('fileBrowser.selectedFile.path', function (newPath, oldPath) {
          if (newPath !== oldPath) {
            config.set('currentFile', JSON.stringify({
              path: newPath,
              name: newPath.slice(newPath.lastIndexOf('/') + 1)
            }));
          }
        });
        function promptWhenFileListIsEmpty() {
          var defaultName = 'Untitled-1.raml';
          var message = 'File system has no files, please input a name for the new file:';
          var validation = [];
          var title = 'Add a new file';
          newNameModal.open(message, defaultName, validation, title).then(function (result) {
            return ramlRepository.generateFile($scope.homeDirectory, result);
          }, function () {
            return ramlRepository.generateFile($scope.homeDirectory, defaultName);
          });
        }
        /**
         * Finds a root file which should have `root` property set to `true`
         * starting at root directory and going down through hierarchy using DFS
         * and current position pointer instead of `shift` operation which is
         * expensive. If there are multiple root files, which should not happen,
         * it returns the very first one and stops the search.
         *
         * @param rootDirectory {RamlDirectory} A root directory to start search at
         *
         * @returns {RamlFile} A root file which is a file with `root` property set to `true`
         */
        function findRootFile(rootDirectory) {
          var queue = [rootDirectory];
          var pos = 0;
          while (pos < queue.length) {
            var directory = queue[pos];
            var files = directory.children;
            var entity = void 0;
            for (var i = 0; i < files.length; i++) {
              entity = files[i];
              if (entity.type === 'file' && entity.root) {
                return entity;
              }
              if (entity.type === 'directory') {
                queue.push(entity);
              }
            }
            pos += 1;
          }
        }
        ramlRepository.loadDirectory().then(function (directory) {
          $scope.homeDirectory = directory;
          fileBrowser.rootFile = findRootFile(directory);
          var files = [];
          $scope.homeDirectory.forEachChildDo(function (child) {
            if (!child.isDirectory) {
              files.push(child);
            }
          });
          if (!files.length) {
            promptWhenFileListIsEmpty();
            return;
          }
          // select a file in the following order:
          //   - previously selected file
          //   - root file
          //   - first file
          var currentFile = JSON.parse(config.get('currentFile', '{}'));
          var fileToOpen = ramlRepository.getByPath(currentFile.path) || fileBrowser.rootFile || files[0];
          fileBrowser.selectFile(fileToOpen);
        });
        ;
      }
      return {
        restrict: 'E',
        templateUrl: 'views/raml-editor-file-browser.tmpl.html',
        controller: Controller
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorProjectButton', [
    '$timeout',
    '$window',
    'subMenuService',
    function ramlEditorProjectButton($timeout, $window, subMenuService) {
      return {
        restrict: 'E',
        templateUrl: 'views/menu/project-menu.tmpl.html',
        link: function (scope) {
          scope.openProjectMenu = function () {
            subMenuService.open(scope, 'showProjectMenu');
          };
          scope.openFileMenu = function () {
            subMenuService.openSubMenu(scope, 'showFileMenu');
          };
          scope.closeFileMenu = function () {
            scope.showFileMenu = false;
          };
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorSaveFileButton', [
    '$rootScope',
    'ramlRepository',
    function ramlEditorSaveFileButton($rootScope, ramlRepository) {
      return {
        restrict: 'E',
        replace: true,
        template: '<li role="save-button" ng-click="saveFile()">' + '<a><i class="fa fa-save"></i>&nbsp;Save</a>' + '</li>',
        link: function (scope) {
          scope.saveFile = function saveFile() {
            var file = scope.fileBrowser.selectedFile;
            return ramlRepository.saveFile(file).then(function success() {
              $rootScope.$broadcast('event:notification', {
                message: 'File saved.',
                expires: true
              });
            });
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorSaveAllButton', [
    '$rootScope',
    'ramlRepository',
    '$q',
    function ramlEditorSaveAllButton($rootScope, ramlRepository, $q) {
      return {
        restrict: 'E',
        replace: true,
        template: '<li role="save-all-button" ng-click="saveAllFiles()">' + '<a><i class="fa fa-save"></i>&nbsp;Save All</a>' + '</li>',
        link: function (scope) {
          scope.saveAllFiles = function saveAllFiles() {
            var promises = [];
            scope.homeDirectory.forEachChildDo(function (file) {
              if (file.isDirectory) {
                return;
              }
              if (file.dirty) {
                return promises.push(ramlRepository.saveFile(file));
              }
            });
            return $q.all(promises).then(function success() {
              $rootScope.$broadcast('event:notification', {
                message: 'All files saved.',
                expires: true
              });
            });
          };
          $rootScope.$on('event:save-all', function () {
            scope.saveAllFiles();
          });
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorNewFolderButton', [
    'newFolderService',
    function ramlEditorNewFolderButton(newFolderService) {
      return {
        restrict: 'E',
        replace: true,
        template: '<li ng-show="supportsFolders" role="new-folder-button" ng-click="newFolder()">' + '<a><i class="fa fa-folder-open"></i>&nbsp;New Folder</a>' + '</li>',
        link: function (scope) {
          scope.newFolder = function newFolder() {
            return newFolderService.prompt(scope.homeDirectory);
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorNewFileMenu', [
    'newFileService',
    'subMenuService',
    function ramlEditorNewFileMenu(newFileService, subMenuService) {
      return {
        restrict: 'E',
        replace: true,
        scope: {
          target: '=',
          showFileMenu: '=',
          showFragmentMenu: '=',
          openFileMenuCondition: '@',
          menuRole: '@'
        },
        templateUrl: 'views/menu/new-file-menu.tmpl.html',
        link: function (scope) {
          scope.closeFragmentMenu = function () {
            scope.showFragmentMenu = false;
          };
          scope.openFragmentMenu = function () {
            subMenuService.openSubMenu(scope, 'showFragmentMenu');
            scope.fragments = newFileService.files['1.0'];
          };
          scope.newFragmentFile = function newFragmentFile(fragmentType) {
            return newFileService.newFragmentFile(scope.target || scope.$parent.homeDirectory, fragmentType);
          };
          scope.newFile = function newFile(version) {
            return newFileService.newFile(scope.target || scope.$parent.homeDirectory, version);
          };
          scope.notSorted = function (fragments) {
            if (!fragments) {
              return [];
            }
            return Object.keys(fragments).map(function (f) {
              return fragments[f];
            });
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorExportMenu', [
    'ramlRepository',
    'subMenuService',
    'ramlToSwagger',
    '$window',
    '$location',
    '$rootScope',
    function ramlEditorExportMenu(ramlRepository, subMenuService, ramlToSwagger, $window, $location, $rootScope) {
      return {
        restrict: 'E',
        templateUrl: 'views/menu/export-menu.tmpl.html',
        link: function (scope) {
          scope.xOasExport = scope.xOasExport || $location.search().xOasExport === 'true';
          function saveFile(yaml, name) {
            var blob = new Blob([yaml], { type: 'application/json;charset=utf-8' });
            $window.saveAs(blob, name);
          }
          function broadcastError(msg) {
            return $rootScope.$broadcast('event:notification', {
              message: msg,
              expires: true,
              level: 'error'
            });
          }
          function replaceExtension(path, ext) {
            var dot = path.lastIndexOf('.');
            if (dot > -1) {
              path = path.substr(0, dot);
            }
            var slash = path.lastIndexOf('/');
            if (slash > -1) {
              path = path.substr(slash + 1);
            }
            return path + '.' + ext;
          }
          scope.openExportMenu = function () {
            subMenuService.openSubMenu(scope, 'showExportMenu');
          };
          scope.closeExportMenu = function () {
            scope.showExportMenu = false;
          };
          scope.exportZipFiles = function exportZipFiles() {
            ramlRepository.exportFiles();
          };
          scope.exportJsonFiles = function exportJsonFiles() {
            var selectedFile = scope.fileBrowser.selectedFile;
            ramlToSwagger.json(selectedFile).then(function (convert) {
              var lines = JSON.stringify(convert.contents, null, 2);
              saveFile(lines, replaceExtension(convert.name || convert.path, 'json'));
            }).catch(function (error) {
              broadcastError(error);
            });
          };
          scope.exportYamlFiles = function exportYamlFiles() {
            var selectedFile = scope.fileBrowser.selectedFile;
            ramlToSwagger.yaml(selectedFile).then(function (convert) {
              saveFile(convert.contents, replaceExtension(convert.name || convert.path, 'yaml'));
            }).catch(function (error) {
              broadcastError(error);
            });
          };
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorImportButton', [
    '$injector',
    'importModal',
    function ramlEditorImportButton($injector, importModal) {
      return {
        restrict: 'E',
        replace: true,
        template: '<li role="import-button" ng-click="importFile()">' + '<a><i class="fa fa-cloud-download"></i>&nbsp;Import</a>' + '</li>',
        link: function (scope) {
          scope.importFile = function importFile() {
            return importModal.open();
          };
        }
      };
    }
  ]);
  ;
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorViewButton', [
    '$timeout',
    '$window',
    'subMenuService',
    '$rootScope',
    function ramlEditorViewButton($timeout, $window, subMenuService, $rootScope) {
      return {
        restrict: 'E',
        templateUrl: 'views/menu/view-menu.tmpl.html',
        link: function (scope) {
          scope.openViewMenu = function () {
            subMenuService.open(scope, 'showViewMenu');
          };
          scope.toogleBackgroundColor = function () {
            $rootScope.$broadcast('event:toggle-theme');
          };
        }
      };
    }
  ]);
}());
(function () {
  'use strict';
  angular.module('ramlEditorApp').directive('ramlEditorHelpButton', [
    '$modal',
    '$timeout',
    '$window',
    'subMenuService',
    function ramlEditorHelpButton($modal, $timeout, $window, subMenuService) {
      return {
        restrict: 'E',
        templateUrl: 'views/menu/help-menu.tmpl.html',
        link: function (scope) {
          scope.openHelpContextMenu = function () {
            subMenuService.open(scope, 'menuContextHelpOpen');
          };
          scope.openHelpModal = function openHelpModal() {
            $modal.open({ templateUrl: 'views/modal/help.html' });
          };
        }
      };
    }
  ]);
}());
/**
 * This file overwrites the ui-tree-node directive from the angular-ui-tree
 * module to modify the behaviour of tree drag-and-drop to better suit the use case
 * of file trees
 */
(function () {
  'use strict';
  angular.module('ui.tree').directive('uiTreeNode', [
    'treeConfig',
    '$uiTreeHelper',
    '$window',
    '$document',
    '$timeout',
    'ramlRepository',
    'config',
    function (treeConfig, $uiTreeHelper, $window, $document, $timeout, ramlRepository, config) {
      return {
        require: [
          '^uiTreeNodes',
          '^uiTree',
          '?uiTreeNode'
        ],
        link: function (scope, element, attrs, controllersArr) {
          var currentConfig = {};
          angular.extend(currentConfig, treeConfig);
          if (currentConfig.nodeClass) {
            element.addClass(currentConfig.nodeClass);
          }
          scope.init(controllersArr);
          scope.collapsed = !!$uiTreeHelper.getNodeAttribute(scope, 'collapsed');
          scope.$watch(attrs.collapsed, function (val) {
            if (typeof val === 'boolean') {
              scope.collapsed = val;
            }
          });
          scope.$watch('collapsed', function (val) {
            $uiTreeHelper.setNodeAttribute(scope, 'collapsed', val);
            attrs.$set('collapsed', val);
          });
          var elements;
          // As a parameter for callbacks
          var firstMoving, dragInfo, pos, dropAccpeted;
          var dragElm, hiddenPlaceElm;
          var hasTouch = 'ontouchstart' in window;
          var dragDelaying = true;
          var dragStarted = false;
          var dragTimer = null;
          var dragCanceled = false;
          var expandTimer = null;
          var expandDelay = 1000;
          // ms
          var body = document.body, html = document.documentElement, documentHeight, documentWidth;
          var dragStart = function (e) {
            if (!hasTouch && (e.button === 2 || e.which === 3)) {
              // disable right click
              return;
            }
            if (e.uiTreeDragging || e.originalEvent && e.originalEvent.uiTreeDragging) {
              // event has already fired in other scope.
              return;
            }
            // the element which is clicked
            var eventElm = angular.element(e.target);
            var eventScope = eventElm.scope();
            if (!eventScope || !eventScope.$type) {
              return;
            }
            if (eventScope.$type !== 'uiTreeNode' && eventScope.$type !== 'uiTreeHandle') {
              // Check if it is a node or a handle
              return;
            }
            if (eventScope.$type === 'uiTreeNode' && eventScope.$handleScope) {
              // If the node has a handle, then it should be clicked by the handle
              return;
            }
            var eventElmTagName = eventElm.prop('tagName').toLowerCase();
            if (eventElmTagName === 'input' || eventElmTagName === 'textarea' || eventElmTagName === 'button' || eventElmTagName === 'select') {
              // if it's a input or button, ignore it
              return;
            }
            // check if it or it's parents has a 'data-nodrag' attribute
            while (eventElm && eventElm[0] && eventElm[0] !== element) {
              if ($uiTreeHelper.nodrag(eventElm)) {
                // if the node mark as `nodrag`, DONOT drag it.
                return;
              }
              eventElm = eventElm.parent();
            }
            if (!scope.beforeDrag(scope)) {
              return;
            }
            e.uiTreeDragging = true;
            // stop event bubbling
            if (e.originalEvent) {
              e.originalEvent.uiTreeDragging = true;
            }
            e.preventDefault();
            var eventObj = $uiTreeHelper.eventObj(e);
            firstMoving = true;
            dragInfo = $uiTreeHelper.dragInfo(scope);
            var tagName = scope.$element.prop('tagName');
            hiddenPlaceElm = angular.element($window.document.createElement(tagName));
            if (currentConfig.hiddenClass) {
              hiddenPlaceElm.addClass(currentConfig.hiddenClass);
            }
            pos = $uiTreeHelper.positionStarted(eventObj, scope.$element);
            dragElm = angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop('tagName'))).addClass(scope.$parentNodesScope.$element.attr('class')).addClass(currentConfig.dragClass).addClass(config.get('theme') === 'light' ? 'drag-light' : '');
            dragElm.css('z-index', 9999);
            scope.$element.after(hiddenPlaceElm);
            dragElm.append(scope.$element.clone().html(scope.$element.children()[0].innerHTML));
            var fileBrowserElement = $document.find('raml-editor-file-browser');
            fileBrowserElement.append(dragElm);
            var left = eventObj.pageX - pos.offsetX - fileBrowserElement.offset().left;
            var top = eventObj.pageY - pos.offsetY - fileBrowserElement.offset().top;
            dragElm.css({
              'left': left + 'px',
              'top': top + 'px'
            });
            elements = { dragging: dragElm };
            scope.$element.addClass('drag-elm');
            // get the node that is being dragged collasp it
            var dragNode = angular.element(dragElm[0].lastChild).scope();
            dragNode.collapsed = true;
            angular.element($document).bind('touchend', dragEndEvent);
            angular.element($document).bind('touchcancel', dragEndEvent);
            angular.element($document).bind('touchmove', dragMoveEvent);
            angular.element($document).bind('mouseup', dragEndEvent);
            angular.element($document).bind('mousemove', dragMoveEvent);
            angular.element($document).bind('mouseleave', dragCancelEvent);
            documentHeight = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
            documentWidth = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
            scope.$treeScope.isDragging = true;
          };
          var dragMove = function (e) {
            if (!dragStarted) {
              if (!dragDelaying) {
                dragStarted = true;
                scope.$apply(function () {
                  scope.$callbacks.dragStart(dragInfo.eventArgs(elements, pos));
                });
              }
              return;
            }
            var eventObj = $uiTreeHelper.eventObj(e);
            var leftElmPos, topElmPos, boundingRect;
            if (dragElm) {
              e.preventDefault();
              if ($window.getSelection) {
                $window.getSelection().removeAllRanges();
              } else if ($window.document.selection) {
                $window.document.selection.empty();
              }
              var fileBrowserElement = $document.find('raml-editor-file-browser');
              leftElmPos = eventObj.pageX - pos.offsetX - fileBrowserElement.offset().left;
              topElmPos = eventObj.pageY - pos.offsetY - fileBrowserElement.offset().top;
              boundingRect = {
                left: leftElmPos,
                right: leftElmPos + dragElm[0].scrollWidth + 5,
                top: topElmPos,
                bottom: topElmPos + dragElm[0].scrollHeight
              };
              // check horizontal boundaries
              if (boundingRect.left < 0) {
                leftElmPos = 0;
              } else if (boundingRect.right > documentWidth) {
                leftElmPos = documentWidth - dragElm[0].scrollWidth - 5;
              }
              // check vertical boundaries
              if (boundingRect.top < 0) {
                topElmPos = 0;
              } else if (boundingRect.bottom > documentHeight) {
                topElmPos = documentHeight - dragElm[0].scrollHeight;
              }
              dragElm.css({
                'left': leftElmPos + 'px',
                'top': topElmPos + 'px'
              });
              var topScroll = window.pageYOffset || $window.document.documentElement.scrollTop;
              var bottomScroll = topScroll + (window.innerHeight || $window.document.clientHeight || $window.document.clientHeight);
              // to scroll down if cursor y-position is greater than the bottom position the vertical scroll
              if (bottomScroll < eventObj.pageY && bottomScroll <= documentHeight) {
                window.scrollBy(0, 10);
              }
              // to scroll top if cursor y-position is less than the top position the vertical scroll
              if (topScroll > eventObj.pageY) {
                window.scrollBy(0, -10);
              }
              $uiTreeHelper.positionMoved(e, pos, firstMoving);
              if (firstMoving) {
                firstMoving = false;
                return;
              }
              // Select the drag target. Because IE does not support CSS 'pointer-events: none', it will always
              // pick the drag element itself as the target. To prevent this, we hide the drag element while
              // selecting the target.
              var displayElm;
              if (angular.isFunction(dragElm.hide)) {
                dragElm.hide();
              } else {
                displayElm = dragElm[0].style.display;
                dragElm[0].style.display = 'none';
              }
              var targetX = eventObj.pageX - $window.document.body.scrollLeft;
              var targetY = eventObj.pageY - (window.pageYOffset || $window.document.documentElement.scrollTop);
              // when using elementFromPoint() inside an iframe, you have to call
              // elementFromPoint() twice to make sure IE8 returns the correct value
              $window.document.elementFromPoint(targetX, targetY);
              var targetElm = angular.element($window.document.elementFromPoint(targetX, targetY));
              if (angular.isFunction(dragElm.show)) {
                dragElm.show();
              } else {
                dragElm[0].style.display = displayElm;
              }
              var targetNode = targetElm.scope();
              if (!pos.dirAx && targetNode !== scope.prevHoverNode) {
                var isEmpty = false;
                scope.prevHoverNode = targetNode;
                if (!targetNode) {
                  return;
                }
                if (targetNode.$type === 'uiTree' && targetNode.dragEnabled) {
                  isEmpty = targetNode.isEmpty();  // Check if it's empty tree
                }
                if (targetNode.$type === 'uiTreeHandle') {
                  targetNode = targetNode.$nodeScope;
                }
                if (targetNode.$type === 'uiTreeDummyNode') {
                  // Check if it is dropped at the tree root
                  dropAccpeted = targetNode.$parentNodesScope.accept(scope, -1);
                  if (dropAccpeted) {
                    dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.$parentNodesScope.childNodes(), findInsertIndex(scope.$modelValue, targetNode.$parentNodesScope.$modelValue));
                  }
                  $('.dragover').removeClass('dragover');
                  targetElm.addClass('dragover');
                  if (expandTimer) {
                    $timeout.cancel(expandTimer);
                    expandTimer = null;
                  }
                  return;
                }
                if (targetNode.$type !== 'uiTreeNode' && !isEmpty) {
                  // Check if it is a uiTreeNode or it's an empty tree
                  return;
                }
                $timeout.cancel(expandTimer);
                $('.dragover').removeClass('dragover');
                if (targetNode.$childNodesScope) {
                  // It's a folder
                  angular.element(targetNode.$element.children()[0]).addClass('dragover');
                  // Expand the folder automatically if it was originally collapsed
                  if (targetNode.collapsed) {
                    expandTimer = $timeout(function () {
                      targetNode.collapsed = false;
                      scope.nodeToExpand = null;
                    }, expandDelay);
                  }
                  scope.nodeToExpand = targetNode;
                } else if (targetNode.$parentNodeScope) {
                  // It's a file, we modify its parent
                  targetElm.addClass('dragover');
                  angular.element(targetNode.$parentNodeScope.$element.children()[0]).addClass('dragover');
                  scope.nodeToExpand = targetNode.$parentNodeScope;
                } else {
                  // file at root
                  targetElm.addClass('dragover');
                }
                if (isEmpty) {
                  // it's an empty tree
                  if (targetNode.$nodesScope.accept(scope, 0)) {
                    dragInfo.moveTo(targetNode.$nodesScope, targetNode.$nodesScope.childNodes(), 0);
                  }
                } else if (targetNode.dragEnabled()) {
                  // drag enabled
                  targetElm = targetNode.$element;
                  // Get the element of ui-tree-node
                  dropAccpeted = targetNode.$parentNodesScope.accept(scope, targetNode.index());
                  if (dropAccpeted) {
                    if (targetNode.$childNodesScope) {
                      dragInfo.moveTo(targetNode.$childNodesScope, targetNode.childNodes(), findInsertIndex(scope.$modelValue, targetNode.$childNodesScope.$modelValue));
                    } else {
                      dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.$parentNodesScope.childNodes(), findInsertIndex(scope.$modelValue, targetNode.$parentNodesScope.$modelValue));
                    }
                  }
                }
              }
              scope.$apply(function () {
                scope.$callbacks.dragMove(dragInfo.eventArgs(elements, pos));
              });
            }
          };
          var dragEnd = function (e) {
            e.preventDefault();
            if (dragElm) {
              scope.$treeScope.$apply(function () {
                scope.$callbacks.beforeDrop(dragInfo.eventArgs(elements, pos));
              });
              // roll back elements changed
              hiddenPlaceElm.replaceWith(scope.$element);
              dragElm.remove();
              dragElm = null;
              if (scope.$$apply) {
                dragInfo.apply();
                scope.$treeScope.$apply(function () {
                  scope.$callbacks.dropped(dragInfo.eventArgs(elements, pos));
                });
              } else {
                bindDrag();
              }
              scope.$treeScope.$apply(function () {
                var eventArgs = dragInfo.eventArgs(elements, pos);
                eventArgs.canceled = dragCanceled;
                scope.$callbacks.dragStop(eventArgs);
              });
              scope.$$apply = false;
              dragInfo = null;
            }
            angular.element($document).unbind('touchend', dragEndEvent);
            // Mobile
            angular.element($document).unbind('touchcancel', dragEndEvent);
            // Mobile
            angular.element($document).unbind('touchmove', dragMoveEvent);
            // Mobile
            angular.element($document).unbind('mouseup', dragEndEvent);
            angular.element($document).unbind('mousemove', dragMoveEvent);
            angular.element($window.document.body).unbind('mouseleave', dragCancelEvent);
            // reset variables
            $('.dragover').removeClass('dragover');
            scope.$element.removeClass('drag-elm');
            scope.$treeScope.isDragging = false;
            scope.prevHoverNode = null;
            dragCanceled = false;
          };
          // find the index to insert a element into a sorted array
          var findInsertIndex = function (source, dest) {
            var low = 0, high = dest.length - 1, mid;
            while (high >= low) {
              mid = Math.floor((low + high) / 2);
              if (ramlRepository.sortingFunction.call(null, dest[mid], source) > 0) {
                high = mid - 1;
              } else {
                low = mid + 1;
              }
            }
            return low;
          };
          var dragStartEvent = function (e) {
            if (scope.dragEnabled()) {
              dragStart(e);
            }
          };
          var dragMoveEvent = function (e) {
            dragMove(e);
          };
          var dragEndEvent = function (e) {
            scope.$$apply = dropAccpeted;
            dragEnd(e);
          };
          var dragCancelEvent = function (e) {
            scope.$$apply = false;
            dragCanceled = true;
            dragEnd(e);
          };
          var bindDrag = function () {
            $timeout(function () {
              element.unbind();
              element.bind('touchstart mousedown', function (e) {
                dragDelaying = true;
                dragStarted = false;
                dragTimer = $timeout(function () {
                  dragDelaying = false;
                  dragStartEvent(e);
                }, scope.dragDelay);
              });
              element.bind('touchend touchcancel mouseup', function () {
                $timeout.cancel(dragTimer);
              });
            });
          };
          bindDrag();
          angular.element($window.document.body).bind('keydown', function (e) {
            if (e.keyCode === 27) {
              dragCancelEvent(e);
            }
          });
        }
      };
    }
  ]).directive('uiTreeDummyNode', [
    'treeConfig',
    function (treeConfig) {
      return {
        require: [
          '^uiTreeNodes',
          '^uiTree'
        ],
        template: '<div class="file-item dummy" ng-class="{\'no-drop\': fileBrowser.cursorState === \'no\', copy: fileBrowser.cursorState === \'ok\'}"></div>',
        restrict: 'E',
        replace: true,
        controller: function ($scope, $element) {
          this.scope = $scope;
          $scope.$element = $element;
          $scope.$parentNodeScope = null;
          // uiTreeNode Scope of parent node;
          $scope.$childNodesScope = null;
          // uiTreeNodes Scope of child nodes.
          $scope.$parentNodesScope = null;
          // uiTreeNodes Scope of parent nodes.
          $scope.$treeScope = null;
          // uiTree scope
          $scope.$$apply = false;
          $scope.$type = 'uiTreeDummyNode';
          $scope.init = function (controllersArr) {
            var treeNodesCtrl = controllersArr[0];
            $scope.$treeScope = controllersArr[1] ? controllersArr[1].scope : null;
            // find the scope of it's parent node
            $scope.$parentNodeScope = treeNodesCtrl.scope.$nodeScope;
            $scope.$parentNodesScope = treeNodesCtrl.scope;
          };
        },
        link: function (scope, element, attr, controllersArr) {
          var config = {};
          angular.extend(config, treeConfig);
          if (config.nodeClass) {
            element.addClass(config.nodeClass);
          }
          scope.init(controllersArr);
        }
      };
    }
  ]);
}());
angular.module('ramlEditorApp').run([
  '$templateCache',
  function ($templateCache) {
    'use strict';
    $templateCache.put('views/confirm-modal.html', '<form name="form" novalidate>\n' + '  <div class="modal-header">\n' + '    <h3>{{title}}</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body">\n' + '    <p>{{message}}</p>\n' + '  </div>\n' + '\n' + '  <div class="modal-footer">\n' + '    <button type="button" class="btn btn-default" ng-click="$dismiss()">{{dismissButtonLabel}}</button>\n' + '    <button type="button" class="btn btn-default" ng-if="canDiscard" ng-click="discard()">{{discardButtonLabel}}</button>\n' + '    <button type="button" class="btn" ng-class="closeButtonCssClass" ng-click="$close()" ng-auto-focus="true">{{closeButtonLabel}}</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/import-modal.html', '<form name="form" novalidate ng-submit="import(form)">\n' + '  <div class="modal-header">\n' + '    <h3>Import file</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body" ng-class="{\'has-error\': submittedType === mode.type && form.$invalid}">\n' + '    <div style="text-align: center; font-size: 2em; margin-bottom: 1em;" ng-show="importing">\n' + '      <i class="fa fa-spin fa-spinner"></i>\n' + '    </div>\n' + '\n' + '    <div class="form-group" style="margin-bottom: 10px;">\n' + '      <div style="float: left; width: 130px;">\n' + '        <select class="form-control" ng-model="mode" ng-options="option.name for option in options"></select>\n' + '      </div>\n' + '\n' + '      <div style="margin-left: 145px;" ng-switch="mode.type">\n' + '        <input id="swagger" name="swagger" type="url" ng-model="mode.value" class="form-control" required ng-switch-when="url" placeholder="http://petstore.swagger.io/v2/swagger.json">\n' + '\n' + '        <input id="file" name="file" type="file" ng-model="mode.value" class="form-control" required ng-switch-when="file" onchange="angular.element(this).scope().handleFileSelect(this)">\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div ng-if="submittedType === \'url\'">\n' + '      <p class="help-block" ng-show="form.swagger.$error.required || form.swagger.$error.url">Please provide a valid URL.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="submittedType === \'file\'">\n' + '      <p class="help-block" ng-show="form.file.$error.required">Please select a file to import.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="mode.type === \'file\'">\n' + '      <p>If you want to upload multiple files, you can .zip them and import them in a single step.</p>\n' + '    </div>\n' + '\n' + '    <div ng-if="mode.spec === \'OAS\'">\n' + '      <p>Note: Currently supports OAS (Swagger) v2.0</p>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="modal-footer" style="margin-top: 0;">\n' + '    <button type="button" class="btn btn-default" ng-click="$dismiss()">Close</button>\n' + '    <button type="submit" class="btn btn-primary">Import</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/import-service-conflict-modal.html', '<form name="form" novalidate>\n' + '  <div class="modal-header">\n' + '    <h3>Path already exists</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body">\n' + '    The path (<strong>{{path}}</strong>) already exists.\n' + '  </div>\n' + '\n' + '  <div class="modal-footer">\n' + '    <button type="button" class="btn btn-default pull-left" ng-click="skip()">Skip</button>\n' + '    <button type="submit" class="btn btn-primary" ng-click="keep()">Keep Both</button>\n' + '    <button type="submit" class="btn btn-primary" ng-click="replace()">Replace</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/menu/export-menu.tmpl.html', '<li ng-if="!xOasExport" role="export-zip" ng-click="exportZipFiles()">\n' + '  <a><i class="fa fa-download"></i>&nbsp;Export files</a>\n' + '</li>\n' + '\n' + '<a ng-if="xOasExport">\n' + '  <i class="fa fa-plus"></i>&nbsp;Export\n' + '  <i class="submenu-icon fa fa-caret-right"></i>\n' + '</a>\n' + '\n' + '<ul ng-if="xOasExport" role="menu-dropdown" class="submenu-item menu-item-context" ng-show="showExportMenu">\n' + '  <li role="export-zip" ng-click="exportZipFiles()"><a>&nbsp;Project Zip</a></li>\n' + '  <li role="export-json" ng-click="exportJsonFiles()"><a>&nbsp;OAS 2.0 JSON</a></li>\n' + '  <li role="export-yaml" ng-click="exportYamlFiles()"><a>&nbsp;OAS 2.0 YAML</a></li>\n' + '</ul>\n');
    $templateCache.put('views/menu/help-menu.tmpl.html', '<span role="help-button" class="menu-item-toggle" ng-click="openHelpContextMenu($event)">\n' + '  <i class="fa fa-question-circle"></i>&nbsp;Help\n' + '  <i class="menu-icon fa fa-caret-down"></i>\n' + '</span>\n' + '<ul role="menu-dropdown" class="menu-item-context" ng-show="menuContextHelpOpen">\n' + '  <li role="context-menu-item"><a role="raml-specification" href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md" target="_blank">RAML Specification</a></li>\n' + '  <li rile="context-menu-item"><a role="raml-website" href="http://raml.org" target="_blank">raml.org Website</a></li>\n' + '  <li role="context-menu-item"><a role="report-raml-bug" href="https://github.com/mulesoft/api-designer/issues" target="_blank">Report a Bug</a></li>\n' + '  <li role="context-menu-item"><a role="raml-guide" href="http://raml.org/docs.html" target="_blank">Getting Started Guide</a></li>\n' + '  <li role="context-menu-item" ng-click="openHelpModal()"><a role="raml-about">About</a></li>\n' + '</ul>\n');
    $templateCache.put('views/menu/new-file-menu.tmpl.html', '<ul role="{{menuRole}}" class="submenu-item menu-item-context" ng-show="showFileMenu">\n' + '  <li role="context-menu-item" ng-mouseenter="openFragmentMenu()" ng-mouseleave="closeFragmentMenu()">\n' + '    <a>\n' + '        &nbsp;Raml 1.0\n' + '        <i class="submenu-icon fa fa-caret-right"></i>\n' + '    </a>\n' + '\n' + '    <ul role="{{menuRole}}" class="submenu-item menu-item-context" ng-show="{{ openFileMenuCondition }}">\n' + '      <li role="new-raml-{{fragment.name}}" ng-repeat="fragment in notSorted(fragments)" ng-click="newFragmentFile(fragment.label)">\n' + '        <a>&nbsp;{{ fragment.name }}</a>\n' + '      </li>\n' + '    </ul>\n' + '  </li>\n' + '\n' + '  <li role="new-raml-0.8" ng-click="newFile(\'0.8\')">\n' + '    <a>&nbsp;Raml 0.8 API Spec</a>\n' + '  </li>\n' + '</ul>\n');
    $templateCache.put('views/menu/project-menu.tmpl.html', '<span class="menu-item-toggle" role="project-button" ng-click="openProjectMenu($event)">\n' + '  <i class="fa fa-cogs"></i>&nbsp;Project\n' + '  <i class="menu-icon fa fa-caret-down"></i>\n' + '</span>\n' + '<ul role="menu-dropdown" class="menu-item-context" ng-show="showProjectMenu">\n' + '  <li role="new-file" ng-mouseenter="openFileMenu()" ng-mouseleave="closeFileMenu()">\n' + '    <a>\n' + '      <i class="fa fa-plus"></i>&nbsp;New File\n' + '      <i class="submenu-icon fa fa-caret-right"></i>\n' + '    </a>\n' + '    <raml-editor-new-file-menu show-file-menu="showFileMenu" show-fragment-menu="showFragmentMenu" open-file-menu-condition="showFragmentMenu" menu-role="menu-dropdown"></raml-editor-new-file-menu>\n' + '  </li>\n' + '\n' + '  <raml-editor-new-folder-button></raml-editor-new-folder-button>\n' + '\n' + '  <raml-editor-save-file-button></raml-editor-save-file-button>\n' + '\n' + '  <raml-editor-save-all-button></raml-editor-save-all-button>\n' + '\n' + '  <raml-editor-import-button></raml-editor-import-button>\n' + '\n' + '  <raml-editor-export-menu ng-if="!xOasExport"></raml-editor-export-menu>\n' + '\n' + '  <li role="context-menu-item" class="submenu" ng-mouseenter="openExportMenu()" ng-mouseleave="closeExportMenu()" ng-show="xOasExport && canExportFiles()">\n' + '    <raml-editor-export-menu></raml-editor-export-menu>\n' + '  </li>\n' + '</ul>\n');
    $templateCache.put('views/menu/view-menu.tmpl.html', '<span class="menu-item-toggle" ng-click="openViewMenu($event)">\n' + '  <i class="fa fa-edit"></i>&nbsp;View\n' + '  <i class="menu-icon fa fa-caret-down"></i>\n' + '</span>\n' + '<ul role="menu-dropdown" class="menu-item-context" ng-show="showViewMenu">\n' + '  <li role="toogle-background" ng-click="toogleBackgroundColor()">\n' + '      <a>&nbsp;Toggle Background Color</a>\n' + '  </li>\n' + '</ul>\n' + '\n');
    $templateCache.put('views/modal/help.html', '<div class="modal-header">\n' + '    <h3>About</h3>\n' + '</div>\n' + '\n' + '<div class="modal-body">\n' + '    <p>\n' + '        The API Designer for RAML is built by MuleSoft, and is a web-based editor designed to help you author RAML specifications for your APIs.\n' + '        <br />\n' + '        <br />\n' + '        RAML is a human-and-machine readable modeling language for REST APIs, backed by a workgroup of industry leaders.\n' + '    </p>\n' + '\n' + '    <p>\n' + '        To learn more about the RAML specification and other tools which support RAML, please visit <a href="http://www.raml.org" target="_blank">http://www.raml.org</a>.\n' + '        <br />\n' + '        <br />\n' + '        For specific questions, or to get help from the community, head to the community forum at <a href="http://forums.raml.org" target="_blank">http://forums.raml.org</a>.\n' + '    </p>\n' + '</div>\n');
    $templateCache.put('views/new-name-modal.html', '<form name="form" novalidate ng-submit="submit(form)">\n' + '  <div class="modal-header">\n' + '    <h3>{{input.title}}</h3>\n' + '  </div>\n' + '\n' + '  <div class="modal-body">\n' + '    <!-- name -->\n' + '    <div class="form-group" ng-class="{\'has-error\': form.$submitted && form.name.$invalid}">\n' + '      <p>\n' + '        {{input.message}}\n' + '      </p>\n' + '      <p ng-if="input.link">\n' + '        Learn more\n' + '        <a target="_blank" href="{{input.link}}">\n' + '          <i class="fa fa-external-link"></i>\n' + '        </a>\n' + '      </p>\n' + '      <!-- label -->\n' + '      <label for="name" class="control-label required-field-label">Name</label>\n' + '\n' + '      <!-- input -->\n' + '      <input id="name" name="name" type="text"\n' + '             ng-model="input.newName" class="form-control"\n' + '             ng-validate="isValid($value)"\n' + '             ng-maxlength="64" ng-auto-focus="true" value="{{input.suggestedName}}" required>\n' + '\n' + '      <!-- error -->\n' + '      <p class="help-block" ng-show="form.$submitted && form.name.$error.required">Please provide a name.</p>\n' + '      <p class="help-block" ng-show="form.$submitted && form.name.$error.maxlength">Name must be shorter than 64 characters.</p>\n' + '      <p class="help-block" ng-show="form.$submitted && form.name.$error.validate">{{validationErrorMessage}}</p>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="modal-footer">\n' + '    <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n' + '    <button type="submit" class="btn btn-primary">OK</button>\n' + '  </div>\n' + '</form>\n');
    $templateCache.put('views/raml-editor-context-menu.tmpl.html', '<ul role="context-menu" ng-show="opened">\n' + '  <li role="context-menu-item" ng-mouseenter="openFileMenu(action)" ng-mouseleave="closeFileMenu()" ng-repeat="action in actions" ng-click="action.execute()">\n' + '    {{ action.label }}\n' + '    <i class="submenu-icon fa fa-caret-right" ng-if="action.fragments !== undefined"></i>\n' + '    <raml-editor-new-file-menu ng-if="action.fragments !== undefined" target="target" show-file-menu="showFileMenu" show-fragment-menu="showFragmentMenu" open-file-menu-condition="showFragmentMenu" menu-role="context-menu"></raml-editor-new-file-menu>\n' + '  </li>\n' + '</ul>\n');
    $templateCache.put('views/raml-editor-file-browser.tmpl.html', '<raml-editor-context-menu></raml-editor-context-menu>\n' + '\n' + '<script type="text/ng-template" id="file-item.html">\n' + '  <div ui-tree-handle class="file-item" ng-right-click="fileBrowser.showContextMenu($event, node)" ng-click="fileBrowser.select(node)"\n' + '    ng-class="{currentfile: fileBrowser.currentTarget.path === node.path && !isDragging,\n' + '      dirty: node.dirty,\n' + '      geared: fileBrowser.contextMenuOpenedFor(node),\n' + '      directory: node.isDirectory,\n' + '      \'no-drop\': fileBrowser.cursorState === \'no\',\n' + '      copy: fileBrowser.cursorState === \'ok\'}"\n' + '    ng-drop="node.isDirectory && fileBrowser.dropFile($event, node)">\n' + '    <span class="file-name" ng-click="toggleFolderCollapse(node)">\n' + '      <i class="fa icon fa-caret-right fa-fw" ng-if="node.isDirectory" ng-class="{\'fa-rotate-90\': !collapsed}"></i>\n' + '      <i class="fa icon fa-fw" ng-class="{\'fa-folder-o\': node.isDirectory, \'fa-file-text-o\': !node.isDirectory}"></i>\n' + '      &nbsp;{{node.name}}\n' + '    </span>\n' + '    <i class="fa fa-cog" ng-click="fileBrowser.showContextMenu($event, node)" ng-class="{hidden: isDragging}" data-nodrag></i>\n' + '  </div>\n' + '\n' + '  <ul ui-tree-nodes ng-if="node.isDirectory" ng-class="{hidden: collapsed}" ng-model="node.children">\n' + '    <li ui-tree-node ng-repeat="node in node.children" ng-include="\'file-item.html\'" data-collapsed="node.collapsed" data-path="{{node.path}}">\n' + '    </li>\n' + '  </ul>\n' + '</script>\n' + '\n' + '<div ui-tree="fileTreeOptions" ng-model="homeDirectory" class="file-list" data-drag-delay="300" data-empty-place-holder-enabled="false" ng-drop="fileBrowser.dropFile($event, homeDirectory)" ng-right-click="fileBrowser.showContextMenu($event, homeDirectory)">\n' + '  <ul ui-tree-nodes ng-model="homeDirectory.children" id="tree-root">\n' + '    <ui-tree-dummy-node class="top"></ui-tree-dummy-node>\n' + '    <li ui-tree-node ng-repeat="node in homeDirectory.children" ng-include="\'file-item.html\'" data-collapsed="node.collapsed"\n' + '     data-path="{{node.path}}"\n' + '     ng-drag-enter="node.collapsed = false"\n' + '     ng-drag-leave="node.collapsed = true"></li>\n' + '    <ui-tree-dummy-node class="bottom" ng-click="fileBrowser.select(homeDirectory)"></ui-tree-dummy-node>\n' + '  </ul>\n' + '</div>\n');
    $templateCache.put('views/raml-editor-main.tmpl.html', '<div role="raml-editor" class="{{theme}}">\n' + '  <div role="notifications" ng-controller="notifications" class="hidden" ng-class="{hidden: !shouldDisplayNotifications, error: level === \'error\'}">\n' + '    {{message}}\n' + '    <i class="fa" ng-class="{\'fa-check\': level === \'info\', \'fa-warning\': level === \'error\'}" ng-click="hideNotifications()"></i>\n' + '  </div>\n' + '\n' + '  <header>\n' + '    <h1>\n' + '      <strong>API</strong> Designer\n' + '    </h1>\n' + '\n' + '    <a role="logo" target="_blank" href="http://mulesoft.com"></a>\n' + '  </header>\n' + '\n' + '  <ul class="menubar">\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-project-button></raml-editor-project-button>\n' + '    </li>\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-view-button></raml-editor-view-button>\n' + '    </li>\n' + '    <li class="menu-item menu-item-ll">\n' + '      <raml-editor-help-button></raml-editor-help-button>\n' + '    </li>\n' + '    <li class="spacer file-absolute-path">{{getSelectedFileAbsolutePath()}}</li>\n' + '    <li class="menu-item menu-item-fr menu-item-mocking-service" ng-show="getIsMockingServiceVisible()" ng-controller="mockingServiceController" ng-click="toggleMockingService()">\n' + '      <div class="title">Mocking Service</div>\n' + '      <div class="field-wrapper" ng-class="{loading: loading}">\n' + '        <i class="fa fa-spin fa-spinner" ng-if="loading"></i>\n' + '        <div class="field" ng-if="!loading">\n' + '          <input type="checkbox" value="None" id="mockingServiceEnabled" ng-checked="enabled" ng-click="$event.preventDefault()" />\n' + '          <label for="mockingServiceEnabled"></label>\n' + '        </div>\n' + '      </div>\n' + '    </li>\n' + '  </ul>\n' + '\n' + '  <div role="flexColumns">\n' + '    <raml-editor-file-browser role="browser"></raml-editor-file-browser>\n' + '\n' + '    <div id="browserAndEditor" ng-splitter="vertical" ng-splitter-collapse-target="prev"><div class="split split-left">&nbsp;</div></div>\n' + '\n' + '    <div role="editor" ng-class="{error: currentError}">\n' + '      <div id="code" role="code"></div>\n' + '\n' + '      <div role="shelf" ng-show="getIsShelfVisible()" ng-class="{expanded: !shelf.collapsed}">\n' + '        <div role="shelf-tab" ng-click="toggleShelf()">\n' + '          <i class="fa fa-inbox fa-lg"></i><i class="fa" ng-class="shelf.collapsed ? \'fa-caret-up\' : \'fa-caret-down\'"></i>\n' + '        </div>\n' + '\n' + '        <div role="shelf-container" ng-show="!shelf.collapsed" ng-include src="\'views/raml-editor-shelf.tmpl.html\'"></div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div id="consoleAndEditor" ng-show="getIsConsoleVisible()" ng-splitter="vertical" ng-splitter-collapse-target="next" ng-splitter-min-width="470"><div class="split split-right">&nbsp;</div></div>\n' + '\n' + '    <div ng-show="getIsConsoleVisible()" role="preview-wrapper" class="raml-console-embedded">\n' + '      <div ng-if="!splitterCollapsed_consoleAndEditor && getIsConsoleVisible()">\n' + '        <raml-console raml="raml" errors="ramlError" disable-description="true"\n' + '            options="{ singleView: true, disableThemeSwitcher: true, disableRamlClientGenerator: true, disableTitle: true}"\n' + '            style="padding: 0; margin-top: 0;"></raml-console>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('views/raml-editor-shelf.tmpl.html', '<ul role="sections" ng-controller="ramlEditorShelf">\n' + '  <li role="section" ng-repeat="category in model.categories | orderBy:orderSections" class="{{category.name | dasherize}}">\n' + '    {{category.name}}&nbsp;({{category.items.length}})\n' + '    <ul role="items">\n' + '      <li ng-repeat="item in category.items" ng-click="itemClick(item)"><i class="fa fa-reply"></i><span>{{item.title}}</span></li>\n' + '    </ul>\n' + '  </li>\n' + '</ul>\n');
  }
]);